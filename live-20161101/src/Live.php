<?php

// This file is auto-generated, don't edit it. Thanks.

namespace AlibabaCloud\SDK\Live\V20161101;

use AlibabaCloud\Endpoint\Endpoint;
use AlibabaCloud\OpenApiUtil\OpenApiUtilClient;
use AlibabaCloud\SDK\Live\V20161101\Models\AddCasterComponentRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddCasterComponentResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddCasterEpisodeGroupContentRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddCasterEpisodeGroupContentResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddCasterEpisodeGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddCasterEpisodeGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddCasterEpisodeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddCasterEpisodeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddCasterLayoutRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddCasterLayoutResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddCasterProgramRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddCasterProgramResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddCasterVideoResourceRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddCasterVideoResourceResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddCustomLiveStreamTranscodeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddCustomLiveStreamTranscodeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveAIProduceRulesRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveAIProduceRulesResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveAISubtitleRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveAISubtitleResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveAISubtitleShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveAppRecordConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveAppRecordConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveAppSnapshotConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveAppSnapshotConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveAudioAuditConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveAudioAuditConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveAudioAuditNotifyConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveAudioAuditNotifyConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveCenterTransferRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveCenterTransferResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveDetectNotifyConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveDetectNotifyConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveDomainMappingRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveDomainMappingResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveDomainPlayMappingRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveDomainPlayMappingResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveDomainRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveDomainResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveMessageGroupBandRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveMessageGroupBandResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveMessageGroupBandShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLivePackageConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLivePackageConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLivePullStreamInfoConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLivePullStreamInfoConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveRecordNotifyConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveRecordNotifyConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveRecordVodConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveRecordVodConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveSnapshotDetectPornConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveSnapshotDetectPornConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveSnapshotNotifyConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveSnapshotNotifyConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveStreamMergeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveStreamMergeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveStreamTranscodeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveStreamTranscodeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveStreamWatermarkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveStreamWatermarkResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveStreamWatermarkRuleRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveStreamWatermarkRuleResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddPlaylistItemsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddPlaylistItemsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddRtsLiveStreamTranscodeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddRtsLiveStreamTranscodeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddShowIntoShowListRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddShowIntoShowListResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddStudioLayoutRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddStudioLayoutResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddTrancodeSEIRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddTrancodeSEIResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\BanLiveMessageGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\BanLiveMessageGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\BanLiveMessageGroupShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\BatchDeleteLiveDomainConfigsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\BatchDeleteLiveDomainConfigsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\BatchGetOnlineUsersRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\BatchGetOnlineUsersResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\BatchSetLiveDomainConfigsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\BatchSetLiveDomainConfigsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CancelMuteAllGroupUserRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CancelMuteAllGroupUserResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CancelMuteGroupUserRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CancelMuteGroupUserResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CancelMuteGroupUserShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ChangeLiveDomainResourceGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ChangeLiveDomainResourceGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CheckLiveMessageUsersInGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CheckLiveMessageUsersInGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CheckLiveMessageUsersInGroupShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CheckLiveMessageUsersOnlineRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CheckLiveMessageUsersOnlineResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CheckLiveMessageUsersOnlineShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CloseLiveShiftRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CloseLiveShiftResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CopyCasterRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CopyCasterResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CopyCasterSceneConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CopyCasterSceneConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateCasterRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateCasterResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateCustomTemplateRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateCustomTemplateResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateEdgeTranscodeJobRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateEdgeTranscodeJobResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateEventSubRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateEventSubResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLiveAIStudioRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLiveAIStudioResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLiveAIStudioShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLiveDelayConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLiveDelayConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLiveMessageAppRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLiveMessageAppResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLiveMessageGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLiveMessageGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLiveMessageGroupShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLivePrivateLineRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLivePrivateLineResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLivePullToPushRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLivePullToPushResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLivePullToPushShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLiveRealTimeLogDeliveryRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLiveRealTimeLogDeliveryResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLiveStreamMonitorRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLiveStreamMonitorResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLiveStreamRecordIndexFilesRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLiveStreamRecordIndexFilesResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateMessageAppRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateMessageAppResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateMessageAppShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateMessageGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateMessageGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateMessageGroupShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateMixStreamRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateMixStreamResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateRoomRealTimeStreamAddressRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateRoomRealTimeStreamAddressResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateRtcAsrTaskRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateRtcAsrTaskResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateRtcMPUEventSubRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateRtcMPUEventSubResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateRTCWhipStreamAddressRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateRTCWhipStreamAddressResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCasterComponentRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCasterComponentResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCasterEpisodeGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCasterEpisodeGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCasterEpisodeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCasterEpisodeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCasterLayoutRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCasterLayoutResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCasterProgramRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCasterProgramResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCasterRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCasterResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCasterSceneConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCasterSceneConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCasterVideoResourceRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCasterVideoResourceResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteChannelRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteChannelResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCustomTemplateRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCustomTemplateResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteEdgeTranscodeJobRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteEdgeTranscodeJobResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteEventSubRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteEventSubResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveAIProduceRulesRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveAIProduceRulesResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveAIStudioRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveAIStudioResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveAISubtitleRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveAISubtitleResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveAppRecordConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveAppRecordConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveAppSnapshotConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveAppSnapshotConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveAudioAuditConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveAudioAuditConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveAudioAuditNotifyConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveAudioAuditNotifyConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveCenterTransferRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveCenterTransferResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveDelayConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveDelayConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveDetectNotifyConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveDetectNotifyConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveDomainMappingRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveDomainMappingResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveDomainPlayMappingRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveDomainPlayMappingResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveDomainRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveDomainResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveEdgeTransferRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveEdgeTransferResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveLazyPullStreamInfoConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveLazyPullStreamInfoConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveMessageGroupMessageRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveMessageGroupMessageResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveMessageGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveMessageGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveMessageUserMessageRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveMessageUserMessageResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLivePackageConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLivePackageConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLivePrivateLineRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLivePrivateLineResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLivePullStreamInfoConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLivePullStreamInfoConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLivePullToPushRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLivePullToPushResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveRealtimeLogDeliveryRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveRealtimeLogDeliveryResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveRealTimeLogLogstoreRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveRealTimeLogLogstoreResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveRecordNotifyConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveRecordNotifyConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveRecordVodConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveRecordVodConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveSnapshotDetectPornConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveSnapshotDetectPornConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveSnapshotNotifyConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveSnapshotNotifyConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveSpecificStagingConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveSpecificStagingConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveStreamBlockRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveStreamBlockResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveStreamMergeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveStreamMergeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveStreamMonitorRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveStreamMonitorResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveStreamRecordIndexFilesRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveStreamRecordIndexFilesResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveStreamsNotifyUrlConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveStreamsNotifyUrlConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveStreamTranscodeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveStreamTranscodeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveStreamWatermarkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveStreamWatermarkResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveStreamWatermarkRuleRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveStreamWatermarkRuleResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteMessageAppRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteMessageAppResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteMixStreamRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteMixStreamResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeletePlaylistItemsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeletePlaylistItemsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeletePlaylistRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeletePlaylistResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteRtcAsrTaskRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteRtcAsrTaskResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteRtcMPUEventSubRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteRtcMPUEventSubResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteSnapshotCallbackAuthRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteSnapshotCallbackAuthResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteSnapshotFilesRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteSnapshotFilesResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteStudioLayoutRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteStudioLayoutResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeAutoShowListTasksRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeAutoShowListTasksResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterChannelsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterChannelsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterComponentsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterComponentsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterLayoutsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterLayoutsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterProgramRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterProgramResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterSceneAudioRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterSceneAudioResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterScenesRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterScenesResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCastersRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCastersResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterStreamUrlRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterStreamUrlResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterVideoResourcesRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterVideoResourcesResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeChannelParticipantsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeChannelParticipantsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeChannelUsersRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeChannelUsersResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeDomainUsageDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeDomainUsageDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeDomainWithIntegrityRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeDomainWithIntegrityResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeHlsLiveStreamRealTimeBpsDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeHlsLiveStreamRealTimeBpsDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveAIProduceRulesRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveAIProduceRulesResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveAIStudioRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveAIStudioResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveAISubtitleRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveAISubtitleResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveAudioAuditConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveAudioAuditConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveAudioAuditNotifyConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveAudioAuditNotifyConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveCdnDiagnoseInfoRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveCdnDiagnoseInfoResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveCenterStreamRateDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveCenterStreamRateDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveCenterTransferRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveCenterTransferResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveCertificateDetailRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveCertificateDetailResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveCertificateListRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveCertificateListResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDelayConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDelayConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDelayedStreamingUsageRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDelayedStreamingUsageResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDetectNotifyConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDetectNotifyConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDetectPornDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDetectPornDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainBpsDataByLayerRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainBpsDataByLayerResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainBpsDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainBpsDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainByCertificateRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainByCertificateResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainCertificateInfoRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainCertificateInfoResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainConfigsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainConfigsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainDetailRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainDetailResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainEdgeLogRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainEdgeLogResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainFrameRateAndBitRateDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainFrameRateAndBitRateDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainLimitRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainLimitResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainLogExTtlRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainLogExTtlResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainLogRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainLogResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainMappingRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainMappingResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainMonitoringUsageDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainMonitoringUsageDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainMultiStreamConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainMultiStreamConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainOnlineUserNumRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainOnlineUserNumResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainPublishErrorCodeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainPublishErrorCodeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainPushBpsDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainPushBpsDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainPushTrafficDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainPushTrafficDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainPvUvDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainPvUvDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainRealTimeBpsDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainRealTimeBpsDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainRealTimeHttpCodeDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainRealTimeHttpCodeDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainRealtimeLogDeliveryRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainRealtimeLogDeliveryResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainRealTimeTrafficDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainRealTimeTrafficDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainRecordUsageDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainRecordUsageDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainSnapshotDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainSnapshotDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainStagingConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainStagingConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainStreamTranscodeDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainStreamTranscodeDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainTimeShiftDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainTimeShiftDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainTrafficDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainTrafficDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainTranscodeParamsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainTranscodeParamsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDrmUsageDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDrmUsageDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveEdgeTransferRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveEdgeTransferResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveGrtnDurationRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveGrtnDurationResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveHttpsDomainListRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveHttpsDomainListResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveInteractionMetricDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveInteractionMetricDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveIpInfoRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveIpInfoResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveLazyPullStreamConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveLazyPullStreamConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveMessageAppRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveMessageAppResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveMessageGroupBandRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveMessageGroupBandResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveMessageGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveMessageGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLivePackageConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLivePackageConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLivePrivateLineAreasRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLivePrivateLineAreasResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLivePrivateLineAvailGARequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLivePrivateLineAvailGAResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveProducerUsageDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveProducerUsageDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLivePullStreamConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLivePullStreamConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLivePullToPushListRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLivePullToPushListResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLivePullToPushRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLivePullToPushResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLivePushProxyLogRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLivePushProxyLogResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLivePushProxyUsageDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLivePushProxyUsageDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveRealtimeDeliveryAccRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveRealtimeDeliveryAccResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveRealtimeLogAuthorizedRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveRealtimeLogAuthorizedResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveRecordConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveRecordConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveRecordNotifyConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveRecordNotifyConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveRecordNotifyRecordsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveRecordNotifyRecordsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveRecordVodConfigsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveRecordVodConfigsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveShiftConfigsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveShiftConfigsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveSnapshotConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveSnapshotConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveSnapshotDetectPornConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveSnapshotDetectPornConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveSnapshotNotifyConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveSnapshotNotifyConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamAuthCheckingRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamAuthCheckingResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamBitRateDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamBitRateDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamCountRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamCountResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamDelayConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamDelayConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamDetailFrameRateAndBitRateDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamDetailFrameRateAndBitRateDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamHistoryUserNumRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamHistoryUserNumResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamMergeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamMergeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamMetricDetailDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamMetricDetailDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamMonitorListRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamMonitorListResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamPreloadTasksRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamPreloadTasksResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamPushMetricDetailDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamPushMetricDetailDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamRecordContentRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamRecordContentResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamRecordIndexFileRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamRecordIndexFileResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamRecordIndexFilesRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamRecordIndexFilesResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamsBlockListRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamsBlockListResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamsControlHistoryRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamsControlHistoryResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamSnapshotInfoRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamSnapshotInfoResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamsNotifyRecordsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamsNotifyRecordsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamsNotifyUrlConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamsNotifyUrlConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamsOnlineListRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamsOnlineListResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamsPublishListRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamsPublishListResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamStateRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamStateResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamsTotalCountRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamsTotalCountResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamTranscodeInfoRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamTranscodeInfoResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamTranscodeMetricDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamTranscodeMetricDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamTranscodeStreamNumRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamTranscodeStreamNumResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamWatermarkRulesRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamWatermarkRulesResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamWatermarksRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamWatermarksResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveTopDomainsByFlowRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveTopDomainsByFlowResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveTrafficDomainLogRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveTrafficDomainLogResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveUpVideoAudioInfoRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveUpVideoAudioInfoResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveUserBillPredictionRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveUserBillPredictionResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveUserDomainsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveUserDomainsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveUserStreamMetricDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveUserStreamMetricDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveUserTagsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveUserTagsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveUserTrafficLogRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveUserTrafficLogResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveVerifyContentRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveVerifyContentResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeMeterLiveBypassDurationRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeMeterLiveBypassDurationResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeMixStreamListRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeMixStreamListResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRtcCloudRecordingFilesRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRtcCloudRecordingFilesResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRtcMPUEventSubRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRtcMPUEventSubResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRTSNativeSDKFirstFrameCostRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRTSNativeSDKFirstFrameCostResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRTSNativeSDKFirstFrameCostShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRTSNativeSDKFirstFrameDelayRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRTSNativeSDKFirstFrameDelayResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRTSNativeSDKFirstFrameDelayShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRTSNativeSDKPlayFailStatusRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRTSNativeSDKPlayFailStatusResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRTSNativeSDKPlayFailStatusShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRTSNativeSDKPlayTimeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRTSNativeSDKPlayTimeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRTSNativeSDKPlayTimeShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRTSNativeSDKVvDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRTSNativeSDKVvDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRTSNativeSDKVvDataShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeShowListRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeShowListResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeStreamLocationBlockRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeStreamLocationBlockResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeStudioLayoutsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeStudioLayoutsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeToutiaoLivePlayRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeToutiaoLivePlayResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeToutiaoLivePublishRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeToutiaoLivePublishResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeUidOnlineStreamsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeUidOnlineStreamsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeUpBpsPeakDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeUpBpsPeakDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeUpBpsPeakOfLineRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeUpBpsPeakOfLineResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeUpPeakPublishStreamDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeUpPeakPublishStreamDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DisableLiveRealtimeLogDeliveryRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DisableLiveRealtimeLogDeliveryResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DynamicUpdateWaterMarkStreamRuleRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DynamicUpdateWaterMarkStreamRuleResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\EditPlaylistRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\EditPlaylistResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\EditShowAndReplaceRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\EditShowAndReplaceResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\EffectCasterUrgentRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\EffectCasterUrgentResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\EffectCasterVideoResourceRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\EffectCasterVideoResourceResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\EnableLiveRealtimeLogDeliveryRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\EnableLiveRealtimeLogDeliveryResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ForbidLiveStreamRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ForbidLiveStreamResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\GetAllCustomTemplatesRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\GetAllCustomTemplatesResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\GetCustomTemplateRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\GetCustomTemplateResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\GetEdgeTranscodeJobRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\GetEdgeTranscodeJobResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\GetEdgeTranscodeTemplateRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\GetEdgeTranscodeTemplateResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\GetEditingJobInfoRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\GetEditingJobInfoResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\GetMessageAppRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\GetMessageAppResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\GetMessageGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\GetMessageGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\GetMessageTokenRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\GetMessageTokenResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\GetTranscodeTaskStatusRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\GetTranscodeTaskStatusResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\HotLiveRtcStreamRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\HotLiveRtcStreamResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\InitializeAutoShowListTaskRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\InitializeAutoShowListTaskResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\JoinMessageGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\JoinMessageGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\KickLiveMessageGroupUserRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\KickLiveMessageGroupUserResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\LeaveMessageGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\LeaveMessageGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListEdgeTranscodeJobRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListEdgeTranscodeJobResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListEdgeTranscodeTemplateRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListEdgeTranscodeTemplateResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListEventSubEventRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListEventSubEventResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListEventSubRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListEventSubResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveDelayConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveDelayConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveMessageAppsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveMessageAppsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveMessageGroupByPageRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveMessageGroupByPageResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveMessageGroupMessagesRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveMessageGroupMessagesResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveMessageGroupsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveMessageGroupsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveMessageGroupUsersRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveMessageGroupUsersResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveRealtimeLogDeliveryDomainsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveRealtimeLogDeliveryDomainsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveRealtimeLogDeliveryInfosRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveRealtimeLogDeliveryInfosResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveRealtimeLogDeliveryRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveRealtimeLogDeliveryResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListMessageAppRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListMessageAppResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListMessageGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListMessageGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListMessageGroupUserByIdRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListMessageGroupUserByIdResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListMessageGroupUserByIdShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListMessageGroupUserRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListMessageGroupUserResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListMessageRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListMessageResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListMuteGroupUserRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListMuteGroupUserResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListPlaylistItemsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListPlaylistItemsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListPlaylistRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListPlaylistResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListRtcMPUEventSubRecordRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListRtcMPUEventSubRecordResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListRtcMPUTaskDetailRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListRtcMPUTaskDetailResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\LiveUpstreamQosDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\LiveUpstreamQosDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\LiveUpstreamQosDataShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\MiguLivePullToPushStartRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\MiguLivePullToPushStartResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\MiguLivePullToPushStatusRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\MiguLivePullToPushStatusResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyCasterComponentRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyCasterComponentResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyCasterEpisodeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyCasterEpisodeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyCasterLayoutRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyCasterLayoutResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyCasterProgramRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyCasterProgramResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyCasterVideoResourceRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyCasterVideoResourceResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveAIStudioRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveAIStudioResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveAIStudioShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveDomainSchdmByPropertyRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveDomainSchdmByPropertyResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveMessageAppAuditRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveMessageAppAuditResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveMessageAppCallbackRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveMessageAppCallbackResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveMessageAppDisableRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveMessageAppDisableResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveMessageGroupBandRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveMessageGroupBandResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveMessageGroupBandShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveMessageGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveMessageGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveMessageGroupShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveMessageUserInfoRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveMessageUserInfoResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveRealtimeLogDeliveryRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveRealtimeLogDeliveryResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyShowListRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyShowListResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyStudioLayoutRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyStudioLayoutResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\MuteAllGroupUserRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\MuteAllGroupUserResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\MuteGroupUserRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\MuteGroupUserResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\MuteGroupUserShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\OpenLiveShiftRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\OpenLiveShiftResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\PlayChoosenShowRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\PlayChoosenShowResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\PublishLiveStagingConfigToProductionRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\PublishLiveStagingConfigToProductionResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\QueryLiveDomainMultiStreamListRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\QueryLiveDomainMultiStreamListResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\QueryMessageAppRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\QueryMessageAppResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\QueryRtcAsrTasksRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\QueryRtcAsrTasksResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\QuerySnapshotCallbackAuthRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\QuerySnapshotCallbackAuthResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\RealTimeRecordCommandRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\RealTimeRecordCommandResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\RecoverLiveMessageDeletedGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\RecoverLiveMessageDeletedGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\RemoveLiveMessageGroupBandRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\RemoveLiveMessageGroupBandResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\RemoveLiveMessageGroupBandShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\RemoveShowFromShowListRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\RemoveShowFromShowListResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\RemoveTerminalsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\RemoveTerminalsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\RestartCasterRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\RestartCasterResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\RestartLivePullToPushRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\RestartLivePullToPushResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\RestartTranscodeTaskRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\RestartTranscodeTaskResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ResumeLiveStreamRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ResumeLiveStreamResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\RollbackLiveStagingConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\RollbackLiveStagingConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SendLikeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SendLikeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SendLiveMessageGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SendLiveMessageGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SendLiveMessageUserRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SendLiveMessageUserResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SendMessageToGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SendMessageToGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SendMessageToGroupUsersRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SendMessageToGroupUsersResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SendMessageToGroupUsersShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetCasterChannelRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetCasterChannelResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SetCasterConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetCasterConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SetCasterSceneConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetCasterSceneConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveDomainCertificateRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveDomainCertificateResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveDomainMultiStreamConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveDomainMultiStreamConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveDomainMultiStreamMasterRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveDomainMultiStreamMasterResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveDomainMultiStreamOptimalModeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveDomainMultiStreamOptimalModeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveDomainStagingConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveDomainStagingConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveEdgeTransferRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveEdgeTransferResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveLazyPullStreamInfoConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveLazyPullStreamInfoConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveMpuTaskSeiRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveMpuTaskSeiResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveStreamBlockRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveStreamBlockResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveStreamDelayConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveStreamDelayConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveStreamPreloadTasksRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveStreamPreloadTasksResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveStreamsNotifyUrlConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveStreamsNotifyUrlConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SetShowListBackgroundRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetShowListBackgroundResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SetSnapshotCallbackAuthRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetSnapshotCallbackAuthResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StartCasterRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StartCasterResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StartCasterSceneRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StartCasterSceneResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StartEdgeTranscodeJobRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StartEdgeTranscodeJobResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StartLiveDomainRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StartLiveDomainResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StartLiveMPUTaskRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StartLiveMPUTaskResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StartLiveMPUTaskShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StartLiveStreamMonitorRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StartLiveStreamMonitorResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StartPlaylistRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StartPlaylistResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StartRtcCloudRecordingRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StartRtcCloudRecordingResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StartRtcCloudRecordingShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StopCasterRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StopCasterResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StopCasterSceneRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StopCasterSceneResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StopEdgeTranscodeJobRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StopEdgeTranscodeJobResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StopLiveDomainRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StopLiveDomainResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StopLiveMPUTaskRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StopLiveMPUTaskResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StopLivePullToPushRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StopLivePullToPushResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StopLiveStreamMonitorRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StopLiveStreamMonitorResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StopPlaylistRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StopPlaylistResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StopRtcAsrTaskRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StopRtcAsrTaskResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StopRtcCloudRecordingRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StopRtcCloudRecordingResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\TagLiveResourcesRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\TagLiveResourcesResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UnbanLiveMessageGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UnbanLiveMessageGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UnTagLiveResourcesRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UnTagLiveResourcesResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateCasterResourceGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateCasterResourceGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateCasterSceneAudioRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateCasterSceneAudioResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateCasterSceneConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateCasterSceneConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateCustomLiveStreamTranscodeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateCustomLiveStreamTranscodeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateEdgeTranscodeJobRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateEdgeTranscodeJobResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateEventSubRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateEventSubResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveAIProduceRulesRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveAIProduceRulesResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveAISubtitleRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveAISubtitleResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveAISubtitleShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveAppRecordConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveAppRecordConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveAppSnapshotConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveAppSnapshotConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveAudioAuditConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveAudioAuditConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveAudioAuditNotifyConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveAudioAuditNotifyConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveCenterTransferRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveCenterTransferResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveDelayConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveDelayConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveDetectNotifyConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveDetectNotifyConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveMPUTaskRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveMPUTaskResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveMPUTaskShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLivePackageConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLivePackageConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLivePullStreamInfoConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLivePullStreamInfoConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLivePullToPushRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLivePullToPushResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLivePullToPushShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveRecordNotifyConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveRecordNotifyConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveRecordVodConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveRecordVodConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveSnapshotDetectPornConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveSnapshotDetectPornConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveSnapshotNotifyConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveSnapshotNotifyConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveStreamMonitorRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveStreamMonitorResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveStreamTranscodeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveStreamTranscodeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveStreamWatermarkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveStreamWatermarkResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveStreamWatermarkRuleRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveStreamWatermarkRuleResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateMessageAppRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateMessageAppResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateMessageAppShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateMessageGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateMessageGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateMessageGroupShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateMixStreamRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateMixStreamResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateRtcCloudRecordingRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateRtcCloudRecordingResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateRtcCloudRecordingShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateRtcMPUEventSubRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateRtcMPUEventSubResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateRtsLiveStreamTranscodeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateRtsLiveStreamTranscodeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\VerifyLiveDomainOwnerRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\VerifyLiveDomainOwnerResponse;
use AlibabaCloud\Tea\Utils\Utils;
use AlibabaCloud\Tea\Utils\Utils\RuntimeOptions;
use Darabonba\OpenApi\Models\OpenApiRequest;
use Darabonba\OpenApi\Models\Params;
use Darabonba\OpenApi\OpenApiClient;

class Live extends OpenApiClient
{
    public function __construct($config)
    {
        parent::__construct($config);
        $this->_endpointRule = 'regional';
        $this->_endpointMap = [
            'cn-qingdao' => 'live.aliyuncs.com',
            'cn-beijing' => 'live.aliyuncs.com',
            'cn-hangzhou' => 'live.aliyuncs.com',
            'cn-shanghai' => 'live.aliyuncs.com',
            'cn-shenzhen' => 'live.aliyuncs.com',
            'ap-southeast-1' => 'live.aliyuncs.com',
            'ap-southeast-5' => 'live.aliyuncs.com',
            'ap-northeast-1' => 'live.aliyuncs.com',
            'eu-central-1' => 'live.aliyuncs.com',
            'ap-south-1' => 'live.aliyuncs.com',
            'ap-northeast-2-pop' => 'live.aliyuncs.com',
            'ap-southeast-2' => 'live.aliyuncs.com',
            'ap-southeast-3' => 'live.aliyuncs.com',
            'cn-beijing-finance-1' => 'live.aliyuncs.com',
            'cn-beijing-finance-pop' => 'live.aliyuncs.com',
            'cn-beijing-gov-1' => 'live.aliyuncs.com',
            'cn-beijing-nu16-b01' => 'live.aliyuncs.com',
            'cn-chengdu' => 'live.aliyuncs.com',
            'cn-edge-1' => 'live.aliyuncs.com',
            'cn-fujian' => 'live.aliyuncs.com',
            'cn-haidian-cm12-c01' => 'live.aliyuncs.com',
            'cn-hangzhou-bj-b01' => 'live.aliyuncs.com',
            'cn-hangzhou-finance' => 'live.aliyuncs.com',
            'cn-hangzhou-internal-prod-1' => 'live.aliyuncs.com',
            'cn-hangzhou-internal-test-1' => 'live.aliyuncs.com',
            'cn-hangzhou-internal-test-2' => 'live.aliyuncs.com',
            'cn-hangzhou-internal-test-3' => 'live.aliyuncs.com',
            'cn-hangzhou-test-306' => 'live.aliyuncs.com',
            'cn-hongkong' => 'live.aliyuncs.com',
            'cn-hongkong-finance-pop' => 'live.aliyuncs.com',
            'cn-huhehaote' => 'live.aliyuncs.com',
            'cn-huhehaote-nebula-1' => 'live.aliyuncs.com',
            'cn-north-2-gov-1' => 'live.aliyuncs.com',
            'cn-qingdao-nebula' => 'live.aliyuncs.com',
            'cn-shanghai-et15-b01' => 'live.aliyuncs.com',
            'cn-shanghai-et2-b01' => 'live.aliyuncs.com',
            'cn-shanghai-finance-1' => 'live.aliyuncs.com',
            'cn-shanghai-inner' => 'live.aliyuncs.com',
            'cn-shanghai-internal-test-1' => 'live.aliyuncs.com',
            'cn-shenzhen-finance-1' => 'live.aliyuncs.com',
            'cn-shenzhen-inner' => 'live.aliyuncs.com',
            'cn-shenzhen-st4-d01' => 'live.aliyuncs.com',
            'cn-shenzhen-su18-b01' => 'live.aliyuncs.com',
            'cn-wuhan' => 'live.aliyuncs.com',
            'cn-wulanchabu' => 'live.aliyuncs.com',
            'cn-yushanfang' => 'live.aliyuncs.com',
            'cn-zhangbei' => 'live.aliyuncs.com',
            'cn-zhangbei-na61-b01' => 'live.aliyuncs.com',
            'cn-zhangjiakou' => 'live.aliyuncs.com',
            'cn-zhangjiakou-na62-a01' => 'live.aliyuncs.com',
            'cn-zhengzhou-nebula-1' => 'live.aliyuncs.com',
            'eu-west-1' => 'live.aliyuncs.com',
            'eu-west-1-oxs' => 'live.aliyuncs.com',
            'me-east-1' => 'live.aliyuncs.com',
            'rus-west-1-pop' => 'live.aliyuncs.com',
            'us-east-1' => 'live.aliyuncs.com',
            'us-west-1' => 'live.aliyuncs.com',
        ];
        $this->checkConfig($config);
        $this->_endpoint = $this->getEndpoint('live', $this->_regionId, $this->_endpointRule, $this->_network, $this->_suffix, $this->_endpointMap, $this->_endpoint);
    }

    /**
     * @param string   $productId
     * @param string   $regionId
     * @param string   $endpointRule
     * @param string   $network
     * @param string   $suffix
     * @param string[] $endpointMap
     * @param string   $endpoint
     *
     * @return string
     */
    public function getEndpoint($productId, $regionId, $endpointRule, $network, $suffix, $endpointMap, $endpoint)
    {
        if (!Utils::empty_($endpoint)) {
            return $endpoint;
        }
        if (!Utils::isUnset($endpointMap) && !Utils::empty_(@$endpointMap[$regionId])) {
            return @$endpointMap[$regionId];
        }

        return Endpoint::getEndpointRules($productId, $regionId, $endpointRule, $network, $suffix);
    }

    /**
     * @summary Adds a component to a production studio.
     *  *
     * @description Before you call this operation to add a component to a production studio, you must first create the production studio and learn about the production studio layouts. You can call this operation to add three types of components: image, text, and subtitle. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddCasterComponentRequest $request AddCasterComponentRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return AddCasterComponentResponse AddCasterComponentResponse
     */
    public function addCasterComponentWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->captionLayerContent)) {
            $query['CaptionLayerContent'] = $request->captionLayerContent;
        }
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->componentLayer)) {
            $query['ComponentLayer'] = $request->componentLayer;
        }
        if (!Utils::isUnset($request->componentName)) {
            $query['ComponentName'] = $request->componentName;
        }
        if (!Utils::isUnset($request->componentType)) {
            $query['ComponentType'] = $request->componentType;
        }
        if (!Utils::isUnset($request->effect)) {
            $query['Effect'] = $request->effect;
        }
        if (!Utils::isUnset($request->htmlLayerContent)) {
            $query['HtmlLayerContent'] = $request->htmlLayerContent;
        }
        if (!Utils::isUnset($request->imageLayerContent)) {
            $query['ImageLayerContent'] = $request->imageLayerContent;
        }
        if (!Utils::isUnset($request->layerOrder)) {
            $query['LayerOrder'] = $request->layerOrder;
        }
        if (!Utils::isUnset($request->locationId)) {
            $query['LocationId'] = $request->locationId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->textLayerContent)) {
            $query['TextLayerContent'] = $request->textLayerContent;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddCasterComponent',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddCasterComponentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a component to a production studio.
     *  *
     * @description Before you call this operation to add a component to a production studio, you must first create the production studio and learn about the production studio layouts. You can call this operation to add three types of components: image, text, and subtitle. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddCasterComponentRequest $request AddCasterComponentRequest
     *
     * @return AddCasterComponentResponse AddCasterComponentResponse
     */
    public function addCasterComponent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addCasterComponentWithOptions($request, $runtime);
    }

    /**
     * @summary Adds an episode to a production studio.
     *  *
     * @description To call this operation, you must obtain the production studio ID in advance. The production studio ID is generated after the production studio is created.
     * *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
     * *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
     * >  You can find the ID of the production studio in the Instance ID/Name column.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddCasterEpisodeRequest $request AddCasterEpisodeRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return AddCasterEpisodeResponse AddCasterEpisodeResponse
     */
    public function addCasterEpisodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->componentId)) {
            $query['ComponentId'] = $request->componentId;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->episodeName)) {
            $query['EpisodeName'] = $request->episodeName;
        }
        if (!Utils::isUnset($request->episodeType)) {
            $query['EpisodeType'] = $request->episodeType;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceId)) {
            $query['ResourceId'] = $request->resourceId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->switchType)) {
            $query['SwitchType'] = $request->switchType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddCasterEpisode',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddCasterEpisodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds an episode to a production studio.
     *  *
     * @description To call this operation, you must obtain the production studio ID in advance. The production studio ID is generated after the production studio is created.
     * *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
     * *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
     * >  You can find the ID of the production studio in the Instance ID/Name column.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddCasterEpisodeRequest $request AddCasterEpisodeRequest
     *
     * @return AddCasterEpisodeResponse AddCasterEpisodeResponse
     */
    public function addCasterEpisode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addCasterEpisodeWithOptions($request, $runtime);
    }

    /**
     * @summary Adds an episode list to a production studio.
     *  *
     * @description You need to create a production studio and obtain the production studio configurations before you call this operation to create an episode list in the production studio. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddCasterEpisodeGroupRequest $request AddCasterEpisodeGroupRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return AddCasterEpisodeGroupResponse AddCasterEpisodeGroupResponse
     */
    public function addCasterEpisodeGroupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->callbackUrl)) {
            $query['CallbackUrl'] = $request->callbackUrl;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->item)) {
            $query['Item'] = $request->item;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->repeatNum)) {
            $query['RepeatNum'] = $request->repeatNum;
        }
        if (!Utils::isUnset($request->sideOutputUrl)) {
            $query['SideOutputUrl'] = $request->sideOutputUrl;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddCasterEpisodeGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddCasterEpisodeGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds an episode list to a production studio.
     *  *
     * @description You need to create a production studio and obtain the production studio configurations before you call this operation to create an episode list in the production studio. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddCasterEpisodeGroupRequest $request AddCasterEpisodeGroupRequest
     *
     * @return AddCasterEpisodeGroupResponse AddCasterEpisodeGroupResponse
     */
    public function addCasterEpisodeGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addCasterEpisodeGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Adds information about an episode list in a production studio.
     *  *
     * @description You need to create a production studio and add an episode list to the production studio before you call this operation to add information about the episode list in the production studio. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddCasterEpisodeGroupContentRequest $request AddCasterEpisodeGroupContentRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return AddCasterEpisodeGroupContentResponse AddCasterEpisodeGroupContentResponse
     */
    public function addCasterEpisodeGroupContentWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->content)) {
            $query['Content'] = $request->content;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddCasterEpisodeGroupContent',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddCasterEpisodeGroupContentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds information about an episode list in a production studio.
     *  *
     * @description You need to create a production studio and add an episode list to the production studio before you call this operation to add information about the episode list in the production studio. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddCasterEpisodeGroupContentRequest $request AddCasterEpisodeGroupContentRequest
     *
     * @return AddCasterEpisodeGroupContentResponse AddCasterEpisodeGroupContentResponse
     */
    public function addCasterEpisodeGroupContent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addCasterEpisodeGroupContentWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a layout for a production studio.
     *  *
     * @description First, create a director desk and add video resources to the director desk, then call this interface to add the director desk layout. To create a director desk using the API, refer to [Create Director Desk](https://help.aliyun.com/document_detail/69338.html).
     * ## QPS Limitation
     * The per-user QPS limit for this interface is 10 times/second. Exceeding this limit will result in API calls being throttled, which may impact your business operations. Please use the API reasonably. For more information, see [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param AddCasterLayoutRequest $request AddCasterLayoutRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return AddCasterLayoutResponse AddCasterLayoutResponse
     */
    public function addCasterLayoutWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->audioLayer)) {
            $query['AudioLayer'] = $request->audioLayer;
        }
        if (!Utils::isUnset($request->blendList)) {
            $query['BlendList'] = $request->blendList;
        }
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->mixList)) {
            $query['MixList'] = $request->mixList;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->videoLayer)) {
            $query['VideoLayer'] = $request->videoLayer;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddCasterLayout',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddCasterLayoutResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a layout for a production studio.
     *  *
     * @description First, create a director desk and add video resources to the director desk, then call this interface to add the director desk layout. To create a director desk using the API, refer to [Create Director Desk](https://help.aliyun.com/document_detail/69338.html).
     * ## QPS Limitation
     * The per-user QPS limit for this interface is 10 times/second. Exceeding this limit will result in API calls being throttled, which may impact your business operations. Please use the API reasonably. For more information, see [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param AddCasterLayoutRequest $request AddCasterLayoutRequest
     *
     * @return AddCasterLayoutResponse AddCasterLayoutResponse
     */
    public function addCasterLayout($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addCasterLayoutWithOptions($request, $runtime);
    }

    /**
     * @summary Adds the episode list for carousel playback in a production studio.
     *  *
     * @description Create a production studio, add input sources to the production studio, and then call this operation to add the episode list for carousel playback in the production studio. This operation supports videos and components as episodes. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddCasterProgramRequest $request AddCasterProgramRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return AddCasterProgramResponse AddCasterProgramResponse
     */
    public function addCasterProgramWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->episode)) {
            $query['Episode'] = $request->episode;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddCasterProgram',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddCasterProgramResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds the episode list for carousel playback in a production studio.
     *  *
     * @description Create a production studio, add input sources to the production studio, and then call this operation to add the episode list for carousel playback in the production studio. This operation supports videos and components as episodes. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddCasterProgramRequest $request AddCasterProgramRequest
     *
     * @return AddCasterProgramResponse AddCasterProgramResponse
     */
    public function addCasterProgram($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addCasterProgramWithOptions($request, $runtime);
    }

    /**
     * @summary Adds an input source to a production studio. The number of input sources is limited by the number of input channels of the production studio.
     *  *
     * @description ##
     * Create a production studio, and then call this operation to add a video source to the production studio. The number of video sources is limited by the number of input channels of the production studio. For information about how to create a production studio by calling an API operation, see [CreateCaster](https://help.aliyun.com/document_detail/69338.html).
     * ## QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param AddCasterVideoResourceRequest $request AddCasterVideoResourceRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return AddCasterVideoResourceResponse AddCasterVideoResourceResponse
     */
    public function addCasterVideoResourceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->beginOffset)) {
            $query['BeginOffset'] = $request->beginOffset;
        }
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->endOffset)) {
            $query['EndOffset'] = $request->endOffset;
        }
        if (!Utils::isUnset($request->fixedDelayDuration)) {
            $query['FixedDelayDuration'] = $request->fixedDelayDuration;
        }
        if (!Utils::isUnset($request->imageId)) {
            $query['ImageId'] = $request->imageId;
        }
        if (!Utils::isUnset($request->imageUrl)) {
            $query['ImageUrl'] = $request->imageUrl;
        }
        if (!Utils::isUnset($request->liveStreamUrl)) {
            $query['LiveStreamUrl'] = $request->liveStreamUrl;
        }
        if (!Utils::isUnset($request->locationId)) {
            $query['LocationId'] = $request->locationId;
        }
        if (!Utils::isUnset($request->materialId)) {
            $query['MaterialId'] = $request->materialId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->ptsCallbackInterval)) {
            $query['PtsCallbackInterval'] = $request->ptsCallbackInterval;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->repeatNum)) {
            $query['RepeatNum'] = $request->repeatNum;
        }
        if (!Utils::isUnset($request->resourceName)) {
            $query['ResourceName'] = $request->resourceName;
        }
        if (!Utils::isUnset($request->vodUrl)) {
            $query['VodUrl'] = $request->vodUrl;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddCasterVideoResource',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddCasterVideoResourceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds an input source to a production studio. The number of input sources is limited by the number of input channels of the production studio.
     *  *
     * @description ##
     * Create a production studio, and then call this operation to add a video source to the production studio. The number of video sources is limited by the number of input channels of the production studio. For information about how to create a production studio by calling an API operation, see [CreateCaster](https://help.aliyun.com/document_detail/69338.html).
     * ## QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param AddCasterVideoResourceRequest $request AddCasterVideoResourceRequest
     *
     * @return AddCasterVideoResourceResponse AddCasterVideoResourceResponse
     */
    public function addCasterVideoResource($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addCasterVideoResourceWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a custom transcoding configuration for a streaming domain.
     *  *
     * @description This operation supports the following types of custom transcoding templates:
     * *   h264: H.264
     * *   h264-nbhd: H.264 Narrowband HD™
     * *   h265: H.265
     * *   h265-nbhd: H.265 Narrowband HD™
     * *   audio: audio-only
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param AddCustomLiveStreamTranscodeRequest $request AddCustomLiveStreamTranscodeRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return AddCustomLiveStreamTranscodeResponse AddCustomLiveStreamTranscodeResponse
     */
    public function addCustomLiveStreamTranscodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->app)) {
            $query['App'] = $request->app;
        }
        if (!Utils::isUnset($request->audioBitrate)) {
            $query['AudioBitrate'] = $request->audioBitrate;
        }
        if (!Utils::isUnset($request->audioChannelNum)) {
            $query['AudioChannelNum'] = $request->audioChannelNum;
        }
        if (!Utils::isUnset($request->audioCodec)) {
            $query['AudioCodec'] = $request->audioCodec;
        }
        if (!Utils::isUnset($request->audioProfile)) {
            $query['AudioProfile'] = $request->audioProfile;
        }
        if (!Utils::isUnset($request->audioRate)) {
            $query['AudioRate'] = $request->audioRate;
        }
        if (!Utils::isUnset($request->bitrateWithSource)) {
            $query['BitrateWithSource'] = $request->bitrateWithSource;
        }
        if (!Utils::isUnset($request->domain)) {
            $query['Domain'] = $request->domain;
        }
        if (!Utils::isUnset($request->encryptParameters)) {
            $query['EncryptParameters'] = $request->encryptParameters;
        }
        if (!Utils::isUnset($request->extWithSource)) {
            $query['ExtWithSource'] = $request->extWithSource;
        }
        if (!Utils::isUnset($request->FPS)) {
            $query['FPS'] = $request->FPS;
        }
        if (!Utils::isUnset($request->fpsWithSource)) {
            $query['FpsWithSource'] = $request->fpsWithSource;
        }
        if (!Utils::isUnset($request->gop)) {
            $query['Gop'] = $request->gop;
        }
        if (!Utils::isUnset($request->height)) {
            $query['Height'] = $request->height;
        }
        if (!Utils::isUnset($request->kmsKeyExpireInterval)) {
            $query['KmsKeyExpireInterval'] = $request->kmsKeyExpireInterval;
        }
        if (!Utils::isUnset($request->kmsKeyID)) {
            $query['KmsKeyID'] = $request->kmsKeyID;
        }
        if (!Utils::isUnset($request->kmsUID)) {
            $query['KmsUID'] = $request->kmsUID;
        }
        if (!Utils::isUnset($request->lazy)) {
            $query['Lazy'] = $request->lazy;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->profile)) {
            $query['Profile'] = $request->profile;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resWithSource)) {
            $query['ResWithSource'] = $request->resWithSource;
        }
        if (!Utils::isUnset($request->template)) {
            $query['Template'] = $request->template;
        }
        if (!Utils::isUnset($request->templateType)) {
            $query['TemplateType'] = $request->templateType;
        }
        if (!Utils::isUnset($request->videoBitrate)) {
            $query['VideoBitrate'] = $request->videoBitrate;
        }
        if (!Utils::isUnset($request->width)) {
            $query['Width'] = $request->width;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddCustomLiveStreamTranscode',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddCustomLiveStreamTranscodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a custom transcoding configuration for a streaming domain.
     *  *
     * @description This operation supports the following types of custom transcoding templates:
     * *   h264: H.264
     * *   h264-nbhd: H.264 Narrowband HD™
     * *   h265: H.265
     * *   h265-nbhd: H.265 Narrowband HD™
     * *   audio: audio-only
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param AddCustomLiveStreamTranscodeRequest $request AddCustomLiveStreamTranscodeRequest
     *
     * @return AddCustomLiveStreamTranscodeResponse AddCustomLiveStreamTranscodeResponse
     */
    public function addCustomLiveStreamTranscode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addCustomLiveStreamTranscodeWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a subtitle rule.
     *  *
     * @description *   After you call the [AddLiveAISubtitle](https://help.aliyun.com/document_detail/2848222.html) operation to add a subtitle template, you can call this operation to create a subtitle rule for the template.
     * *   You must add "_Subtitle template name" after the stream name in the streaming URL to play the subtitle stream.
     *     *   RTMP: rtmp://example.aliyundoc.com/app/stream_{Subtitle template name}?auth_key={Access token}
     *     *   FLV: http://example.aliyundoc.com/app/stream_{Subtitle template name}.flv?auth_key={Access token}
     *     *   M3U8: http://example.aliyundoc.com/app/stream_{Subtitle template name}.m3u8?auth_key={Access token}
     * >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddLiveAIProduceRulesRequest $request AddLiveAIProduceRulesRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return AddLiveAIProduceRulesResponse AddLiveAIProduceRulesResponse
     */
    public function addLiveAIProduceRulesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->app)) {
            $query['App'] = $request->app;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->domain)) {
            $query['Domain'] = $request->domain;
        }
        if (!Utils::isUnset($request->isLazy)) {
            $query['IsLazy'] = $request->isLazy;
        }
        if (!Utils::isUnset($request->liveTemplate)) {
            $query['LiveTemplate'] = $request->liveTemplate;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->studioName)) {
            $query['StudioName'] = $request->studioName;
        }
        if (!Utils::isUnset($request->subtitleName)) {
            $query['SubtitleName'] = $request->subtitleName;
        }
        if (!Utils::isUnset($request->suffix)) {
            $query['Suffix'] = $request->suffix;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveAIProduceRules',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveAIProduceRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a subtitle rule.
     *  *
     * @description *   After you call the [AddLiveAISubtitle](https://help.aliyun.com/document_detail/2848222.html) operation to add a subtitle template, you can call this operation to create a subtitle rule for the template.
     * *   You must add "_Subtitle template name" after the stream name in the streaming URL to play the subtitle stream.
     *     *   RTMP: rtmp://example.aliyundoc.com/app/stream_{Subtitle template name}?auth_key={Access token}
     *     *   FLV: http://example.aliyundoc.com/app/stream_{Subtitle template name}.flv?auth_key={Access token}
     *     *   M3U8: http://example.aliyundoc.com/app/stream_{Subtitle template name}.m3u8?auth_key={Access token}
     * >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddLiveAIProduceRulesRequest $request AddLiveAIProduceRulesRequest
     *
     * @return AddLiveAIProduceRulesResponse AddLiveAIProduceRulesResponse
     */
    public function addLiveAIProduceRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveAIProduceRulesWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a subtitle template.
     *  *
     * @description ## Instructions
     * - This interface supports adding live caption template configurations, with templates configurable to describe caption content, layout, and more.
     * - After adding caption templates, you also need to call the [AddLiveAIProduceRules](https://help.aliyun.com/document_detail/2799676.html) interface to add caption rules. Restarting the stream will then enable captions in the broadcast.
     * - Real-time captions are currently supported in Beijing, Shanghai, Singapore, Indonesia, and Saudi regions.
     * >Notice: The real-time caption feature is currently in beta testing. Each user can add up to 300 caption templates.
     * ## QPS Limit
     * The QPS limit for this interface per user is 60 requests/second. Exceeding this limit will result in API throttling, which may impact your services. Please use judiciously. For more information, refer to [QPS Limitations](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param AddLiveAISubtitleRequest $tmpReq  AddLiveAISubtitleRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return AddLiveAISubtitleResponse AddLiveAISubtitleResponse
     */
    public function addLiveAISubtitleWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new AddLiveAISubtitleShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->positionNormalized)) {
            $request->positionNormalizedShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->positionNormalized, 'PositionNormalized', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->bgColor)) {
            $query['BgColor'] = $request->bgColor;
        }
        if (!Utils::isUnset($request->bgWidthNormalized)) {
            $query['BgWidthNormalized'] = $request->bgWidthNormalized;
        }
        if (!Utils::isUnset($request->borderWidthNormalized)) {
            $query['BorderWidthNormalized'] = $request->borderWidthNormalized;
        }
        if (!Utils::isUnset($request->copyFrom)) {
            $query['CopyFrom'] = $request->copyFrom;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->dstLanguage)) {
            $query['DstLanguage'] = $request->dstLanguage;
        }
        if (!Utils::isUnset($request->fontColor)) {
            $query['FontColor'] = $request->fontColor;
        }
        if (!Utils::isUnset($request->fontName)) {
            $query['FontName'] = $request->fontName;
        }
        if (!Utils::isUnset($request->fontSizeNormalized)) {
            $query['FontSizeNormalized'] = $request->fontSizeNormalized;
        }
        if (!Utils::isUnset($request->height)) {
            $query['Height'] = $request->height;
        }
        if (!Utils::isUnset($request->maxLines)) {
            $query['MaxLines'] = $request->maxLines;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->positionNormalizedShrink)) {
            $query['PositionNormalized'] = $request->positionNormalizedShrink;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->showSourceLan)) {
            $query['ShowSourceLan'] = $request->showSourceLan;
        }
        if (!Utils::isUnset($request->srcLanguage)) {
            $query['SrcLanguage'] = $request->srcLanguage;
        }
        if (!Utils::isUnset($request->subtitleName)) {
            $query['SubtitleName'] = $request->subtitleName;
        }
        if (!Utils::isUnset($request->width)) {
            $query['Width'] = $request->width;
        }
        if (!Utils::isUnset($request->wordPerLine)) {
            $query['WordPerLine'] = $request->wordPerLine;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveAISubtitle',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveAISubtitleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a subtitle template.
     *  *
     * @description ## Instructions
     * - This interface supports adding live caption template configurations, with templates configurable to describe caption content, layout, and more.
     * - After adding caption templates, you also need to call the [AddLiveAIProduceRules](https://help.aliyun.com/document_detail/2799676.html) interface to add caption rules. Restarting the stream will then enable captions in the broadcast.
     * - Real-time captions are currently supported in Beijing, Shanghai, Singapore, Indonesia, and Saudi regions.
     * >Notice: The real-time caption feature is currently in beta testing. Each user can add up to 300 caption templates.
     * ## QPS Limit
     * The QPS limit for this interface per user is 60 requests/second. Exceeding this limit will result in API throttling, which may impact your services. Please use judiciously. For more information, refer to [QPS Limitations](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param AddLiveAISubtitleRequest $request AddLiveAISubtitleRequest
     *
     * @return AddLiveAISubtitleResponse AddLiveAISubtitleResponse
     */
    public function addLiveAISubtitle($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveAISubtitleWithOptions($request, $runtime);
    }

    /**
     * @summary Configure APP recording, with output saved to OSS.
     *  *
     * @description The live stream recording feature allows you to record a live stream and stores the recordings in a specified location. You can view the recordings whenever you want to. Recordings that are stored in OSS support multiple formats, such as Transport Stream (TS), MP4, Flash Video (FLV), and Common Media Application Format (CMAF). You can use different recording policies, including automatic recording, on-demand recording, and manual recording. By calling this operation, you can configure the recording template. For more information about live stream recording, see [Live stream recording](https://help.aliyun.com/document_detail/199357.html).
     * A configuration is identified by the DomainName, AppName, and StreamName parameters all together. If you try to call this operation to add a configuration that has the same DomainName, AppName, and StreamName parameters as an existing configuration, an error indicating that the configuration already exists is returned.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddLiveAppRecordConfigRequest $request AddLiveAppRecordConfigRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return AddLiveAppRecordConfigResponse AddLiveAppRecordConfigResponse
     */
    public function addLiveAppRecordConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->delayTime)) {
            $query['DelayTime'] = $request->delayTime;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->onDemand)) {
            $query['OnDemand'] = $request->onDemand;
        }
        if (!Utils::isUnset($request->ossBucket)) {
            $query['OssBucket'] = $request->ossBucket;
        }
        if (!Utils::isUnset($request->ossEndpoint)) {
            $query['OssEndpoint'] = $request->ossEndpoint;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->recordFormat)) {
            $query['RecordFormat'] = $request->recordFormat;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        if (!Utils::isUnset($request->transcodeRecordFormat)) {
            $query['TranscodeRecordFormat'] = $request->transcodeRecordFormat;
        }
        if (!Utils::isUnset($request->transcodeTemplates)) {
            $query['TranscodeTemplates'] = $request->transcodeTemplates;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveAppRecordConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveAppRecordConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configure APP recording, with output saved to OSS.
     *  *
     * @description The live stream recording feature allows you to record a live stream and stores the recordings in a specified location. You can view the recordings whenever you want to. Recordings that are stored in OSS support multiple formats, such as Transport Stream (TS), MP4, Flash Video (FLV), and Common Media Application Format (CMAF). You can use different recording policies, including automatic recording, on-demand recording, and manual recording. By calling this operation, you can configure the recording template. For more information about live stream recording, see [Live stream recording](https://help.aliyun.com/document_detail/199357.html).
     * A configuration is identified by the DomainName, AppName, and StreamName parameters all together. If you try to call this operation to add a configuration that has the same DomainName, AppName, and StreamName parameters as an existing configuration, an error indicating that the configuration already exists is returned.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddLiveAppRecordConfigRequest $request AddLiveAppRecordConfigRequest
     *
     * @return AddLiveAppRecordConfigResponse AddLiveAppRecordConfigResponse
     */
    public function addLiveAppRecordConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveAppRecordConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Configures the snapshot feature for a streaming domain. The captured snapshots are stored in Object Storage Service (OSS). The configuration takes effect after you restart stream ingest.
     *  *
     * @description *   Before you call this operation, make sure that you fully understand the billing method and pricing of live stream snapshots in ApsaraVideo Live. For more information, see [Billing of live stream snapshots](https://help.aliyun.com/document_detail/195286.html).
     * *   Make sure that Object Storage Service (OSS) is activated and a specific bucket is created. This way, ApsaraVideo Live can store live stream snapshots in the bucket. For more information, see [Configure OSS](https://help.aliyun.com/document_detail/84932.html).
     * *   If you store snapshots in OSS, storage fees are generated. For more information, see [Storage fees](https://help.aliyun.com/document_detail/173534.html).
     * *   The OSS bucket must reside in the same region as the live center of the streaming domain. Cross-region snapshot capture is not supported.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddLiveAppSnapshotConfigRequest $request AddLiveAppSnapshotConfigRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return AddLiveAppSnapshotConfigResponse AddLiveAppSnapshotConfigResponse
     */
    public function addLiveAppSnapshotConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->callback)) {
            $query['Callback'] = $request->callback;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ossBucket)) {
            $query['OssBucket'] = $request->ossBucket;
        }
        if (!Utils::isUnset($request->ossEndpoint)) {
            $query['OssEndpoint'] = $request->ossEndpoint;
        }
        if (!Utils::isUnset($request->overwriteOssObject)) {
            $query['OverwriteOssObject'] = $request->overwriteOssObject;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        if (!Utils::isUnset($request->sequenceOssObject)) {
            $query['SequenceOssObject'] = $request->sequenceOssObject;
        }
        if (!Utils::isUnset($request->timeInterval)) {
            $query['TimeInterval'] = $request->timeInterval;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveAppSnapshotConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveAppSnapshotConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures the snapshot feature for a streaming domain. The captured snapshots are stored in Object Storage Service (OSS). The configuration takes effect after you restart stream ingest.
     *  *
     * @description *   Before you call this operation, make sure that you fully understand the billing method and pricing of live stream snapshots in ApsaraVideo Live. For more information, see [Billing of live stream snapshots](https://help.aliyun.com/document_detail/195286.html).
     * *   Make sure that Object Storage Service (OSS) is activated and a specific bucket is created. This way, ApsaraVideo Live can store live stream snapshots in the bucket. For more information, see [Configure OSS](https://help.aliyun.com/document_detail/84932.html).
     * *   If you store snapshots in OSS, storage fees are generated. For more information, see [Storage fees](https://help.aliyun.com/document_detail/173534.html).
     * *   The OSS bucket must reside in the same region as the live center of the streaming domain. Cross-region snapshot capture is not supported.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddLiveAppSnapshotConfigRequest $request AddLiveAppSnapshotConfigRequest
     *
     * @return AddLiveAppSnapshotConfigResponse AddLiveAppSnapshotConfigResponse
     */
    public function addLiveAppSnapshotConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveAppSnapshotConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Adds an audio moderation configuration.
     *  *
     * @description *   The content moderation feature detects undesirable sensitive content in the audio from live streams and returns callbacks to notify you of the violations. Then, you can manually review the content and take actions accordingly.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddLiveAudioAuditConfigRequest $request AddLiveAudioAuditConfigRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return AddLiveAudioAuditConfigResponse AddLiveAudioAuditConfigResponse
     */
    public function addLiveAudioAuditConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->bizType)) {
            $query['BizType'] = $request->bizType;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ossBucket)) {
            $query['OssBucket'] = $request->ossBucket;
        }
        if (!Utils::isUnset($request->ossEndpoint)) {
            $query['OssEndpoint'] = $request->ossEndpoint;
        }
        if (!Utils::isUnset($request->ossObject)) {
            $query['OssObject'] = $request->ossObject;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveAudioAuditConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveAudioAuditConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds an audio moderation configuration.
     *  *
     * @description *   The content moderation feature detects undesirable sensitive content in the audio from live streams and returns callbacks to notify you of the violations. Then, you can manually review the content and take actions accordingly.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddLiveAudioAuditConfigRequest $request AddLiveAudioAuditConfigRequest
     *
     * @return AddLiveAudioAuditConfigResponse AddLiveAudioAuditConfigResponse
     */
    public function addLiveAudioAuditConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveAudioAuditConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Configures callbacks for audio moderation results.
     *  *
     * @description *   The content moderation feature returns the audio moderation results based on the configured callback template.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddLiveAudioAuditNotifyConfigRequest $request AddLiveAudioAuditNotifyConfigRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return AddLiveAudioAuditNotifyConfigResponse AddLiveAudioAuditNotifyConfigResponse
     */
    public function addLiveAudioAuditNotifyConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->callback)) {
            $query['Callback'] = $request->callback;
        }
        if (!Utils::isUnset($request->callbackTemplate)) {
            $query['CallbackTemplate'] = $request->callbackTemplate;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveAudioAuditNotifyConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveAudioAuditNotifyConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures callbacks for audio moderation results.
     *  *
     * @description *   The content moderation feature returns the audio moderation results based on the configured callback template.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddLiveAudioAuditNotifyConfigRequest $request AddLiveAudioAuditNotifyConfigRequest
     *
     * @return AddLiveAudioAuditNotifyConfigResponse AddLiveAudioAuditNotifyConfigResponse
     */
    public function addLiveAudioAuditNotifyConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveAudioAuditNotifyConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a configuration of live center stream relay.
     *  *
     * @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddLiveCenterTransferRequest $request AddLiveCenterTransferRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return AddLiveCenterTransferResponse AddLiveCenterTransferResponse
     */
    public function addLiveCenterTransferWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->dstUrl)) {
            $query['DstUrl'] = $request->dstUrl;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        if (!Utils::isUnset($request->transferArgs)) {
            $query['TransferArgs'] = $request->transferArgs;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveCenterTransfer',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveCenterTransferResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a configuration of live center stream relay.
     *  *
     * @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddLiveCenterTransferRequest $request AddLiveCenterTransferRequest
     *
     * @return AddLiveCenterTransferResponse AddLiveCenterTransferResponse
     */
    public function addLiveCenterTransfer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveCenterTransferWithOptions($request, $runtime);
    }

    /**
     * @summary Configures callbacks for video moderation results. As a result, a callback URL that is used to receive the callback notifications is added.
     *  *
     * @description *   The automated review feature sends notifications about violations to the callback URL in real time. Then, you can manually review the content and take actions accordingly.
     * *   Only some live centers support the automated review feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
     *  *
     * @param AddLiveDetectNotifyConfigRequest $request AddLiveDetectNotifyConfigRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return AddLiveDetectNotifyConfigResponse AddLiveDetectNotifyConfigResponse
     */
    public function addLiveDetectNotifyConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->notifyUrl)) {
            $query['NotifyUrl'] = $request->notifyUrl;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveDetectNotifyConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveDetectNotifyConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures callbacks for video moderation results. As a result, a callback URL that is used to receive the callback notifications is added.
     *  *
     * @description *   The automated review feature sends notifications about violations to the callback URL in real time. Then, you can manually review the content and take actions accordingly.
     * *   Only some live centers support the automated review feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
     *  *
     * @param AddLiveDetectNotifyConfigRequest $request AddLiveDetectNotifyConfigRequest
     *
     * @return AddLiveDetectNotifyConfigResponse AddLiveDetectNotifyConfigResponse
     */
    public function addLiveDetectNotifyConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveDetectNotifyConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a domain name to ApsaraVideo Live. This operation allows you to add only one domain name at a time.
     *  *
     * @description *   You must activate ApsaraVideo Live before you add a domain name. For more information, see [Activate ApsaraVideo Live](https://help.aliyun.com/document_detail/195292.html).
     * *   ApsaraVideo Live verifies the ownership of a new domain name that you add. After the verification is passed, the domain name is added to ApsaraVideo Live. ApsaraVideo Live allows you to use a Domain Name System (DNS) record or a verification file to verify the ownership of a domain name. For more information, see [Verify the ownership of a domain name](https://help.aliyun.com/document_detail/184466.html).
     * *   To use ApsaraVideo Live to ingest and play streams, you must add an ingest domain and a streaming domain. You can add only one domain name at a time.
     * *   After you add a domain name, you must configure a CNAME record for the domain name. For more information, see [Add a CNAME record](https://help.aliyun.com/document_detail/84929.html).
     * *   After you add an ingest domain and a streaming domain, you must associate the streaming domain with the ingest domain. For more information, see [Associate a streaming domain with an ingest domain](https://help.aliyun.com/document_detail/199338.html).
     * >  From February 19, 2019, domain names that are added by calling the AddLiveDomain operation do not support live center ingest. Domain names that are added by using Alibaba Cloud CDN also do not support live center ingest. When you call the AddLiveDomain operation, you can set the LiveDomainType parameter to liveEdge to add an ingest domain that uses edge ingest or set the LiveDomainType parameter to liveVideo to add a streaming domain. You can associate a streaming domain with an ingest domain by calling the AddLiveDomainMapping operation. Domain names added before February 19, 2019, for which live center ingest was configured, are not affected.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddLiveDomainRequest $request AddLiveDomainRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return AddLiveDomainResponse AddLiveDomainResponse
     */
    public function addLiveDomainWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkUrl)) {
            $query['CheckUrl'] = $request->checkUrl;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->liveDomainType)) {
            $query['LiveDomainType'] = $request->liveDomainType;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->region)) {
            $query['Region'] = $request->region;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->scope)) {
            $query['Scope'] = $request->scope;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->topLevelDomain)) {
            $query['TopLevelDomain'] = $request->topLevelDomain;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveDomain',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveDomainResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a domain name to ApsaraVideo Live. This operation allows you to add only one domain name at a time.
     *  *
     * @description *   You must activate ApsaraVideo Live before you add a domain name. For more information, see [Activate ApsaraVideo Live](https://help.aliyun.com/document_detail/195292.html).
     * *   ApsaraVideo Live verifies the ownership of a new domain name that you add. After the verification is passed, the domain name is added to ApsaraVideo Live. ApsaraVideo Live allows you to use a Domain Name System (DNS) record or a verification file to verify the ownership of a domain name. For more information, see [Verify the ownership of a domain name](https://help.aliyun.com/document_detail/184466.html).
     * *   To use ApsaraVideo Live to ingest and play streams, you must add an ingest domain and a streaming domain. You can add only one domain name at a time.
     * *   After you add a domain name, you must configure a CNAME record for the domain name. For more information, see [Add a CNAME record](https://help.aliyun.com/document_detail/84929.html).
     * *   After you add an ingest domain and a streaming domain, you must associate the streaming domain with the ingest domain. For more information, see [Associate a streaming domain with an ingest domain](https://help.aliyun.com/document_detail/199338.html).
     * >  From February 19, 2019, domain names that are added by calling the AddLiveDomain operation do not support live center ingest. Domain names that are added by using Alibaba Cloud CDN also do not support live center ingest. When you call the AddLiveDomain operation, you can set the LiveDomainType parameter to liveEdge to add an ingest domain that uses edge ingest or set the LiveDomainType parameter to liveVideo to add a streaming domain. You can associate a streaming domain with an ingest domain by calling the AddLiveDomainMapping operation. Domain names added before February 19, 2019, for which live center ingest was configured, are not affected.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddLiveDomainRequest $request AddLiveDomainRequest
     *
     * @return AddLiveDomainResponse AddLiveDomainResponse
     */
    public function addLiveDomain($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveDomainWithOptions($request, $runtime);
    }

    /**
     * @summary Creates the mapping between a streaming domain and an ingest domain.
     *  *
     * @description Call the [AddLiveDomain](https://help.aliyun.com/document_detail/88327.html) operation to add a streaming domain and an ingest domain, and then call this operation to create the mapping between the two domain names.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param AddLiveDomainMappingRequest $request AddLiveDomainMappingRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return AddLiveDomainMappingResponse AddLiveDomainMappingResponse
     */
    public function addLiveDomainMappingWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pullDomain)) {
            $query['PullDomain'] = $request->pullDomain;
        }
        if (!Utils::isUnset($request->pushDomain)) {
            $query['PushDomain'] = $request->pushDomain;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveDomainMapping',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveDomainMappingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates the mapping between a streaming domain and an ingest domain.
     *  *
     * @description Call the [AddLiveDomain](https://help.aliyun.com/document_detail/88327.html) operation to add a streaming domain and an ingest domain, and then call this operation to create the mapping between the two domain names.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param AddLiveDomainMappingRequest $request AddLiveDomainMappingRequest
     *
     * @return AddLiveDomainMappingResponse AddLiveDomainMappingResponse
     */
    public function addLiveDomainMapping($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveDomainMappingWithOptions($request, $runtime);
    }

    /**
     * @summary Maps a sub-streaming domain to a main streaming domain.
     *  *
     * @description You can call the [AddLiveDomain](https://help.aliyun.com/document_detail/88327.html) operation to add a main streaming domain and a sub-streaming domain and then call this operation to map the sub-streaming domain to the main streaming domain.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddLiveDomainPlayMappingRequest $request AddLiveDomainPlayMappingRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return AddLiveDomainPlayMappingResponse AddLiveDomainPlayMappingResponse
     */
    public function addLiveDomainPlayMappingWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->playDomain)) {
            $query['PlayDomain'] = $request->playDomain;
        }
        if (!Utils::isUnset($request->pullDomain)) {
            $query['PullDomain'] = $request->pullDomain;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveDomainPlayMapping',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveDomainPlayMappingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Maps a sub-streaming domain to a main streaming domain.
     *  *
     * @description You can call the [AddLiveDomain](https://help.aliyun.com/document_detail/88327.html) operation to add a main streaming domain and a sub-streaming domain and then call this operation to map the sub-streaming domain to the main streaming domain.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddLiveDomainPlayMappingRequest $request AddLiveDomainPlayMappingRequest
     *
     * @return AddLiveDomainPlayMappingResponse AddLiveDomainPlayMappingResponse
     */
    public function addLiveDomainPlayMapping($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveDomainPlayMappingWithOptions($request, $runtime);
    }

    /**
     * @summary Mutes one or more users.
     *  *
     * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddLiveMessageGroupBandRequest $tmpReq  AddLiveMessageGroupBandRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return AddLiveMessageGroupBandResponse AddLiveMessageGroupBandResponse
     */
    public function addLiveMessageGroupBandWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new AddLiveMessageGroupBandShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->bannedUsers)) {
            $request->bannedUsersShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->bannedUsers, 'BannedUsers', 'simple');
        }
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->bannedUsersShrink)) {
            $query['BannedUsers'] = $request->bannedUsersShrink;
        }
        if (!Utils::isUnset($request->dataCenter)) {
            $query['DataCenter'] = $request->dataCenter;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveMessageGroupBand',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveMessageGroupBandResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Mutes one or more users.
     *  *
     * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddLiveMessageGroupBandRequest $request AddLiveMessageGroupBandRequest
     *
     * @return AddLiveMessageGroupBandResponse AddLiveMessageGroupBandResponse
     */
    public function addLiveMessageGroupBand($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveMessageGroupBandWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a live stream encapsulation configuration.
     *  *
     * @description *   The first time you configure encapsulation for a domain name, domain acceleration is automatically configured and takes effect in 3 to 5 minutes.
     * *   If the streaming domain resides in a region outside China, including Singapore, Germany (Frankfurt), Japan (Tokyo), and Indonesia (Jakarta), you may encounter high latency issues. We recommend that you test and verify whether the settings meet expectations.
     * *   You can call this operation to add a live stream encapsulation configuration. The configuration takes effect only after you re-ingest the stream.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddLivePackageConfigRequest $request AddLivePackageConfigRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return AddLivePackageConfigResponse AddLivePackageConfigResponse
     */
    public function addLivePackageConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ignoreTranscode)) {
            $query['IgnoreTranscode'] = $request->ignoreTranscode;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->partDuration)) {
            $query['PartDuration'] = $request->partDuration;
        }
        if (!Utils::isUnset($request->protocol)) {
            $query['Protocol'] = $request->protocol;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->segmentDuration)) {
            $query['SegmentDuration'] = $request->segmentDuration;
        }
        if (!Utils::isUnset($request->segmentNum)) {
            $query['SegmentNum'] = $request->segmentNum;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLivePackageConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLivePackageConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a live stream encapsulation configuration.
     *  *
     * @description *   The first time you configure encapsulation for a domain name, domain acceleration is automatically configured and takes effect in 3 to 5 minutes.
     * *   If the streaming domain resides in a region outside China, including Singapore, Germany (Frankfurt), Japan (Tokyo), and Indonesia (Jakarta), you may encounter high latency issues. We recommend that you test and verify whether the settings meet expectations.
     * *   You can call this operation to add a live stream encapsulation configuration. The configuration takes effect only after you re-ingest the stream.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddLivePackageConfigRequest $request AddLivePackageConfigRequest
     *
     * @return AddLivePackageConfigResponse AddLivePackageConfigResponse
     */
    public function addLivePackageConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLivePackageConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a stream pulling configuration for a live stream, which includes parameters such as the origin URL, start time, and end time.
     *  *
     * @description *   Before you call this operation, make sure that you fully understand the billing method and pricing of stream pulling in ApsaraVideo Live. For more information, see [Billing of standard streaming](https://help.aliyun.com/document_detail/195284.html).
     * *   Stream pulling refers to the process of pulling live streams from third-party streaming URLs to a live center of ApsaraVideo Live for CDN acceleration.
     * *   You can call this operation only for regular stream pulling. That is, you can specify the start time and end time to pull live streams.
     * *   Regular stream pulling and triggered stream pulling are supported in the ApsaraVideo Live console. For more information, see [Configure stream pulling](https://help.aliyun.com/document_detail/199452.html).
     * *   You can specify custom values for the AppName and StreamName parameters. Streaming URLs that are generated vary based on different values of the AppName and StreamName parameters. You can use the [URL generator](https://help.aliyun.com/document_detail/197400.html) to generate a streaming URL.
     * *   A configuration is identified by the DomainName, AppName, and StreamName parameters all together. If you try to call this operation to add a configuration that has the same DomainName, AppName, and StreamName parameters as an existing configuration, an error indicating that the configuration already exists is returned.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddLivePullStreamInfoConfigRequest $request AddLivePullStreamInfoConfigRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return AddLivePullStreamInfoConfigResponse AddLivePullStreamInfoConfigResponse
     */
    public function addLivePullStreamInfoConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->sourceUrl)) {
            $query['SourceUrl'] = $request->sourceUrl;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLivePullStreamInfoConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLivePullStreamInfoConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a stream pulling configuration for a live stream, which includes parameters such as the origin URL, start time, and end time.
     *  *
     * @description *   Before you call this operation, make sure that you fully understand the billing method and pricing of stream pulling in ApsaraVideo Live. For more information, see [Billing of standard streaming](https://help.aliyun.com/document_detail/195284.html).
     * *   Stream pulling refers to the process of pulling live streams from third-party streaming URLs to a live center of ApsaraVideo Live for CDN acceleration.
     * *   You can call this operation only for regular stream pulling. That is, you can specify the start time and end time to pull live streams.
     * *   Regular stream pulling and triggered stream pulling are supported in the ApsaraVideo Live console. For more information, see [Configure stream pulling](https://help.aliyun.com/document_detail/199452.html).
     * *   You can specify custom values for the AppName and StreamName parameters. Streaming URLs that are generated vary based on different values of the AppName and StreamName parameters. You can use the [URL generator](https://help.aliyun.com/document_detail/197400.html) to generate a streaming URL.
     * *   A configuration is identified by the DomainName, AppName, and StreamName parameters all together. If you try to call this operation to add a configuration that has the same DomainName, AppName, and StreamName parameters as an existing configuration, an error indicating that the configuration already exists is returned.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddLivePullStreamInfoConfigRequest $request AddLivePullStreamInfoConfigRequest
     *
     * @return AddLivePullStreamInfoConfigResponse AddLivePullStreamInfoConfigResponse
     */
    public function addLivePullStreamInfoConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLivePullStreamInfoConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Configures recording callbacks for a domain name.
     *  *
     * @description Before you call this operation to configure recording callbacks for a domain name, you can query whether the domain name already has recording callbacks configured. For more information, see [DescribeLiveRecordNotifyConfig](https://help.aliyun.com/document_detail/2847893.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddLiveRecordNotifyConfigRequest $request AddLiveRecordNotifyConfigRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return AddLiveRecordNotifyConfigResponse AddLiveRecordNotifyConfigResponse
     */
    public function addLiveRecordNotifyConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->needStatusNotify)) {
            $query['NeedStatusNotify'] = $request->needStatusNotify;
        }
        if (!Utils::isUnset($request->notifyUrl)) {
            $query['NotifyUrl'] = $request->notifyUrl;
        }
        if (!Utils::isUnset($request->onDemandUrl)) {
            $query['OnDemandUrl'] = $request->onDemandUrl;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveRecordNotifyConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveRecordNotifyConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures recording callbacks for a domain name.
     *  *
     * @description Before you call this operation to configure recording callbacks for a domain name, you can query whether the domain name already has recording callbacks configured. For more information, see [DescribeLiveRecordNotifyConfig](https://help.aliyun.com/document_detail/2847893.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddLiveRecordNotifyConfigRequest $request AddLiveRecordNotifyConfigRequest
     *
     * @return AddLiveRecordNotifyConfigResponse AddLiveRecordNotifyConfigResponse
     */
    public function addLiveRecordNotifyConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveRecordNotifyConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a Live-to-VOD configuration to store recordings in the media library of ApsaraVideo VOD.
     *  *
     * @description You can call this operation to configure the Live-to-VOD feature to store recordings in the media library of ApsaraVideo VOD.
     * >  You cannot configure the Live-to-VOD feature by using a Finance Cloud account.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddLiveRecordVodConfigRequest $request AddLiveRecordVodConfigRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return AddLiveRecordVodConfigResponse AddLiveRecordVodConfigResponse
     */
    public function addLiveRecordVodConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->autoCompose)) {
            $query['AutoCompose'] = $request->autoCompose;
        }
        if (!Utils::isUnset($request->composeVodTranscodeGroupId)) {
            $query['ComposeVodTranscodeGroupId'] = $request->composeVodTranscodeGroupId;
        }
        if (!Utils::isUnset($request->cycleDuration)) {
            $query['CycleDuration'] = $request->cycleDuration;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->onDemand)) {
            $query['OnDemand'] = $request->onDemand;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->storageLocation)) {
            $query['StorageLocation'] = $request->storageLocation;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        if (!Utils::isUnset($request->vodTranscodeGroupId)) {
            $query['VodTranscodeGroupId'] = $request->vodTranscodeGroupId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveRecordVodConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveRecordVodConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a Live-to-VOD configuration to store recordings in the media library of ApsaraVideo VOD.
     *  *
     * @description You can call this operation to configure the Live-to-VOD feature to store recordings in the media library of ApsaraVideo VOD.
     * >  You cannot configure the Live-to-VOD feature by using a Finance Cloud account.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddLiveRecordVodConfigRequest $request AddLiveRecordVodConfigRequest
     *
     * @return AddLiveRecordVodConfigResponse AddLiveRecordVodConfigResponse
     */
    public function addLiveRecordVodConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveRecordVodConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a video moderation configuration for live streams in an application under a domain name.
     *  *
     * @description - The live streaming audit function identifies and reviews违规sensitive content at the domain and App level, and promptly notifies users of such violations via callbacks. Users can then review the content and take appropriate actions.
     * - Currently, only some live streaming centers support intelligent auditing. For a list of live streaming centers that support this feature, please refer to [Service Regions](https://help.aliyun.com/document_detail/193730.html).
     * ## QPS Limitation
     * The QPS limit for this API per user is 30 requests/second. Exceeding this limit will result in API throttling, which may impact your services. Please use the API judiciously. For more information, see [QPS Limitations](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param AddLiveSnapshotDetectPornConfigRequest $request AddLiveSnapshotDetectPornConfigRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return AddLiveSnapshotDetectPornConfigResponse AddLiveSnapshotDetectPornConfigResponse
     */
    public function addLiveSnapshotDetectPornConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->interval)) {
            $query['Interval'] = $request->interval;
        }
        if (!Utils::isUnset($request->ossBucket)) {
            $query['OssBucket'] = $request->ossBucket;
        }
        if (!Utils::isUnset($request->ossEndpoint)) {
            $query['OssEndpoint'] = $request->ossEndpoint;
        }
        if (!Utils::isUnset($request->ossObject)) {
            $query['OssObject'] = $request->ossObject;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->scene)) {
            $query['Scene'] = $request->scene;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveSnapshotDetectPornConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveSnapshotDetectPornConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a video moderation configuration for live streams in an application under a domain name.
     *  *
     * @description - The live streaming audit function identifies and reviews违规sensitive content at the domain and App level, and promptly notifies users of such violations via callbacks. Users can then review the content and take appropriate actions.
     * - Currently, only some live streaming centers support intelligent auditing. For a list of live streaming centers that support this feature, please refer to [Service Regions](https://help.aliyun.com/document_detail/193730.html).
     * ## QPS Limitation
     * The QPS limit for this API per user is 30 requests/second. Exceeding this limit will result in API throttling, which may impact your services. Please use the API judiciously. For more information, see [QPS Limitations](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param AddLiveSnapshotDetectPornConfigRequest $request AddLiveSnapshotDetectPornConfigRequest
     *
     * @return AddLiveSnapshotDetectPornConfigResponse AddLiveSnapshotDetectPornConfigResponse
     */
    public function addLiveSnapshotDetectPornConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveSnapshotDetectPornConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Configures snapshot callbacks.
     *  *
     * @description ### QPS Limit
     * The QPS limit for this API per user is 30 times/second. Exceeding this limit will result in API calls being throttled, which may impact your business operations. Please use the API reasonably. For more information, please refer to [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param AddLiveSnapshotNotifyConfigRequest $request AddLiveSnapshotNotifyConfigRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return AddLiveSnapshotNotifyConfigResponse AddLiveSnapshotNotifyConfigResponse
     */
    public function addLiveSnapshotNotifyConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->notifyAuthKey)) {
            $query['NotifyAuthKey'] = $request->notifyAuthKey;
        }
        if (!Utils::isUnset($request->notifyReqAuth)) {
            $query['NotifyReqAuth'] = $request->notifyReqAuth;
        }
        if (!Utils::isUnset($request->notifyUrl)) {
            $query['NotifyUrl'] = $request->notifyUrl;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveSnapshotNotifyConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveSnapshotNotifyConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures snapshot callbacks.
     *  *
     * @description ### QPS Limit
     * The QPS limit for this API per user is 30 times/second. Exceeding this limit will result in API calls being throttled, which may impact your business operations. Please use the API reasonably. For more information, please refer to [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param AddLiveSnapshotNotifyConfigRequest $request AddLiveSnapshotNotifyConfigRequest
     *
     * @return AddLiveSnapshotNotifyConfigResponse AddLiveSnapshotNotifyConfigResponse
     */
    public function addLiveSnapshotNotifyConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveSnapshotNotifyConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Invoke AddLiveStreamMerge to add primary and backup stream merging configuration.
     *  *
     * @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddLiveStreamMergeRequest $request AddLiveStreamMergeRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return AddLiveStreamMergeResponse AddLiveStreamMergeResponse
     */
    public function addLiveStreamMergeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->inAppName1)) {
            $query['InAppName1'] = $request->inAppName1;
        }
        if (!Utils::isUnset($request->inAppName2)) {
            $query['InAppName2'] = $request->inAppName2;
        }
        if (!Utils::isUnset($request->inStreamName1)) {
            $query['InStreamName1'] = $request->inStreamName1;
        }
        if (!Utils::isUnset($request->inStreamName2)) {
            $query['InStreamName2'] = $request->inStreamName2;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->protocol)) {
            $query['Protocol'] = $request->protocol;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveStreamMerge',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveStreamMergeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Invoke AddLiveStreamMerge to add primary and backup stream merging configuration.
     *  *
     * @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddLiveStreamMergeRequest $request AddLiveStreamMergeRequest
     *
     * @return AddLiveStreamMergeResponse AddLiveStreamMergeResponse
     */
    public function addLiveStreamMerge($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveStreamMergeWithOptions($request, $runtime);
    }

    /**
     * @summary Adds transcoding configurations for a streaming domain.
     *  *
     * @description You must obtain the customer master key (CMK) in Key Management Service (KMS) before you call this operation to add transcoding configurations. Only standard transcoding templates and Narrowband HD™ transcoding templates are supported for this operation.
     * ## QPS limits
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
     *  *
     * @param AddLiveStreamTranscodeRequest $request AddLiveStreamTranscodeRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return AddLiveStreamTranscodeResponse AddLiveStreamTranscodeResponse
     */
    public function addLiveStreamTranscodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->app)) {
            $query['App'] = $request->app;
        }
        if (!Utils::isUnset($request->domain)) {
            $query['Domain'] = $request->domain;
        }
        if (!Utils::isUnset($request->encryptParameters)) {
            $query['EncryptParameters'] = $request->encryptParameters;
        }
        if (!Utils::isUnset($request->lazy)) {
            $query['Lazy'] = $request->lazy;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->template)) {
            $query['Template'] = $request->template;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveStreamTranscode',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveStreamTranscodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds transcoding configurations for a streaming domain.
     *  *
     * @description You must obtain the customer master key (CMK) in Key Management Service (KMS) before you call this operation to add transcoding configurations. Only standard transcoding templates and Narrowband HD™ transcoding templates are supported for this operation.
     * ## QPS limits
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
     *  *
     * @param AddLiveStreamTranscodeRequest $request AddLiveStreamTranscodeRequest
     *
     * @return AddLiveStreamTranscodeResponse AddLiveStreamTranscodeResponse
     */
    public function addLiveStreamTranscode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveStreamTranscodeWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a watermark template.
     *  *
     * @description *   You can call this operation to create a watermark template and configure information such as the watermark content and layout in the template.
     * *   After you create a watermark template, you must also call the [AddLiveStreamWatermarkRule](https://help.aliyun.com/document_detail/2848100.html) operation to add a watermark rule. A live stream in progress can contain the watermark only after the stream is re-ingested.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddLiveStreamWatermarkRequest $request AddLiveStreamWatermarkRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return AddLiveStreamWatermarkResponse AddLiveStreamWatermarkResponse
     */
    public function addLiveStreamWatermarkWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->domain)) {
            $query['Domain'] = $request->domain;
        }
        if (!Utils::isUnset($request->height)) {
            $query['Height'] = $request->height;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->offsetCorner)) {
            $query['OffsetCorner'] = $request->offsetCorner;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pictureUrl)) {
            $query['PictureUrl'] = $request->pictureUrl;
        }
        if (!Utils::isUnset($request->refHeight)) {
            $query['RefHeight'] = $request->refHeight;
        }
        if (!Utils::isUnset($request->refWidth)) {
            $query['RefWidth'] = $request->refWidth;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->transparency)) {
            $query['Transparency'] = $request->transparency;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->XOffset)) {
            $query['XOffset'] = $request->XOffset;
        }
        if (!Utils::isUnset($request->YOffset)) {
            $query['YOffset'] = $request->YOffset;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveStreamWatermark',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveStreamWatermarkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a watermark template.
     *  *
     * @description *   You can call this operation to create a watermark template and configure information such as the watermark content and layout in the template.
     * *   After you create a watermark template, you must also call the [AddLiveStreamWatermarkRule](https://help.aliyun.com/document_detail/2848100.html) operation to add a watermark rule. A live stream in progress can contain the watermark only after the stream is re-ingested.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddLiveStreamWatermarkRequest $request AddLiveStreamWatermarkRequest
     *
     * @return AddLiveStreamWatermarkResponse AddLiveStreamWatermarkResponse
     */
    public function addLiveStreamWatermark($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveStreamWatermarkWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a watermark rule.
     *  *
     * @description After calling the [AddLiveStreamWatermark](https://help.aliyun.com/document_detail/469416.html) API to add a watermark template, you can use this interface to add watermark rules.
     * ## QPS Limit
     *  The QPS limit for this interface per user is 60 times/second. Exceeding the limit will result in API calls being throttled, which may impact your business. Please use it reasonably. For more information, see [QPS Limit](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param AddLiveStreamWatermarkRuleRequest $request AddLiveStreamWatermarkRuleRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return AddLiveStreamWatermarkRuleResponse AddLiveStreamWatermarkRuleResponse
     */
    public function addLiveStreamWatermarkRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->app)) {
            $query['App'] = $request->app;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->domain)) {
            $query['Domain'] = $request->domain;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->stream)) {
            $query['Stream'] = $request->stream;
        }
        if (!Utils::isUnset($request->templateId)) {
            $query['TemplateId'] = $request->templateId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveStreamWatermarkRule',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveStreamWatermarkRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a watermark rule.
     *  *
     * @description After calling the [AddLiveStreamWatermark](https://help.aliyun.com/document_detail/469416.html) API to add a watermark template, you can use this interface to add watermark rules.
     * ## QPS Limit
     *  The QPS limit for this interface per user is 60 times/second. Exceeding the limit will result in API calls being throttled, which may impact your business. Please use it reasonably. For more information, see [QPS Limit](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param AddLiveStreamWatermarkRuleRequest $request AddLiveStreamWatermarkRuleRequest
     *
     * @return AddLiveStreamWatermarkRuleResponse AddLiveStreamWatermarkRuleResponse
     */
    public function addLiveStreamWatermarkRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveStreamWatermarkRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Adds episodes to an episode list.
     *  *
     * @description Create a production studio, add a layout and components to the production studio, and then call this operation to add episodes. If no episode list exists in the production studio, this operation creates an episode list for the production studio. For more information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddPlaylistItemsRequest $request AddPlaylistItemsRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return AddPlaylistItemsResponse AddPlaylistItemsResponse
     */
    public function addPlaylistItemsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->programConfig)) {
            $query['ProgramConfig'] = $request->programConfig;
        }
        if (!Utils::isUnset($request->programId)) {
            $query['ProgramId'] = $request->programId;
        }
        if (!Utils::isUnset($request->programItems)) {
            $query['ProgramItems'] = $request->programItems;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddPlaylistItems',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddPlaylistItemsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds episodes to an episode list.
     *  *
     * @description Create a production studio, add a layout and components to the production studio, and then call this operation to add episodes. If no episode list exists in the production studio, this operation creates an episode list for the production studio. For more information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddPlaylistItemsRequest $request AddPlaylistItemsRequest
     *
     * @return AddPlaylistItemsResponse AddPlaylistItemsResponse
     */
    public function addPlaylistItems($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addPlaylistItemsWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a Real-Time Streaming (RTS) transcoding configuration for a streaming domain.
     *  *
     * @description You can call this operation to add an RTS transcoding configuration. This operation supports four template types: h264, h264-nbhd, h264-origin, and audio.
     * ## QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param AddRtsLiveStreamTranscodeRequest $request AddRtsLiveStreamTranscodeRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return AddRtsLiveStreamTranscodeResponse AddRtsLiveStreamTranscodeResponse
     */
    public function addRtsLiveStreamTranscodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->app)) {
            $query['App'] = $request->app;
        }
        if (!Utils::isUnset($request->audioBitrate)) {
            $query['AudioBitrate'] = $request->audioBitrate;
        }
        if (!Utils::isUnset($request->audioChannelNum)) {
            $query['AudioChannelNum'] = $request->audioChannelNum;
        }
        if (!Utils::isUnset($request->audioCodec)) {
            $query['AudioCodec'] = $request->audioCodec;
        }
        if (!Utils::isUnset($request->audioProfile)) {
            $query['AudioProfile'] = $request->audioProfile;
        }
        if (!Utils::isUnset($request->audioRate)) {
            $query['AudioRate'] = $request->audioRate;
        }
        if (!Utils::isUnset($request->deleteBframes)) {
            $query['DeleteBframes'] = $request->deleteBframes;
        }
        if (!Utils::isUnset($request->domain)) {
            $query['Domain'] = $request->domain;
        }
        if (!Utils::isUnset($request->FPS)) {
            $query['FPS'] = $request->FPS;
        }
        if (!Utils::isUnset($request->gop)) {
            $query['Gop'] = $request->gop;
        }
        if (!Utils::isUnset($request->height)) {
            $query['Height'] = $request->height;
        }
        if (!Utils::isUnset($request->lazy)) {
            $query['Lazy'] = $request->lazy;
        }
        if (!Utils::isUnset($request->opus)) {
            $query['Opus'] = $request->opus;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->profile)) {
            $query['Profile'] = $request->profile;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->template)) {
            $query['Template'] = $request->template;
        }
        if (!Utils::isUnset($request->templateType)) {
            $query['TemplateType'] = $request->templateType;
        }
        if (!Utils::isUnset($request->videoBitrate)) {
            $query['VideoBitrate'] = $request->videoBitrate;
        }
        if (!Utils::isUnset($request->width)) {
            $query['Width'] = $request->width;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddRtsLiveStreamTranscode',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddRtsLiveStreamTranscodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a Real-Time Streaming (RTS) transcoding configuration for a streaming domain.
     *  *
     * @description You can call this operation to add an RTS transcoding configuration. This operation supports four template types: h264, h264-nbhd, h264-origin, and audio.
     * ## QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param AddRtsLiveStreamTranscodeRequest $request AddRtsLiveStreamTranscodeRequest
     *
     * @return AddRtsLiveStreamTranscodeResponse AddRtsLiveStreamTranscodeResponse
     */
    public function addRtsLiveStreamTranscode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addRtsLiveStreamTranscodeWithOptions($request, $runtime);
    }

    /**
     * @summary Adds an episode to an episode list.
     *  *
     * @description You must create a production studio in the new playlist mode and add media resources to the production studio before you can call this operation. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
     * You can add up to 1,000 episodes to an episode list.
     * >
     * *   When you select media resources from ApsaraVideo VOD, we recommend that you select resources that are stored in hosted OSS buckets. Resources stored in non-hosted OSS buckets have a validity period. Pay attention to the validity if you select resources that are stored in non-hosted OSS buckets.
     * *   When you add media resources to a production studio, we recommend that you select resources from ApsaraVideo Live and ApsaraVideo VOD. If you add a third-party stream by specifying a streaming URL, there is a possibility that the stream fails to be played. You must pay attention to the quality and validity of the third-party stream.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddShowIntoShowListRequest $request AddShowIntoShowListRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return AddShowIntoShowListResponse AddShowIntoShowListResponse
     */
    public function addShowIntoShowListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->duration)) {
            $query['Duration'] = $request->duration;
        }
        if (!Utils::isUnset($request->liveInputType)) {
            $query['LiveInputType'] = $request->liveInputType;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->repeatTimes)) {
            $query['RepeatTimes'] = $request->repeatTimes;
        }
        if (!Utils::isUnset($request->resourceId)) {
            $query['ResourceId'] = $request->resourceId;
        }
        if (!Utils::isUnset($request->resourceType)) {
            $query['ResourceType'] = $request->resourceType;
        }
        if (!Utils::isUnset($request->resourceUrl)) {
            $query['ResourceUrl'] = $request->resourceUrl;
        }
        if (!Utils::isUnset($request->showName)) {
            $query['ShowName'] = $request->showName;
        }
        if (!Utils::isUnset($request->spot)) {
            $query['Spot'] = $request->spot;
        }
        if (!Utils::isUnset($request->isBatchMode)) {
            $query['isBatchMode'] = $request->isBatchMode;
        }
        if (!Utils::isUnset($request->showList)) {
            $query['showList'] = $request->showList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddShowIntoShowList',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddShowIntoShowListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds an episode to an episode list.
     *  *
     * @description You must create a production studio in the new playlist mode and add media resources to the production studio before you can call this operation. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
     * You can add up to 1,000 episodes to an episode list.
     * >
     * *   When you select media resources from ApsaraVideo VOD, we recommend that you select resources that are stored in hosted OSS buckets. Resources stored in non-hosted OSS buckets have a validity period. Pay attention to the validity if you select resources that are stored in non-hosted OSS buckets.
     * *   When you add media resources to a production studio, we recommend that you select resources from ApsaraVideo Live and ApsaraVideo VOD. If you add a third-party stream by specifying a streaming URL, there is a possibility that the stream fails to be played. You must pay attention to the quality and validity of the third-party stream.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddShowIntoShowListRequest $request AddShowIntoShowListRequest
     *
     * @return AddShowIntoShowListResponse AddShowIntoShowListResponse
     */
    public function addShowIntoShowList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addShowIntoShowListWithOptions($request, $runtime);
    }

    /**
     * @summary Configures a layout for a virtual studio.
     *  *
     * @description You can call this operation to configure a common layout or a studio layout for a virtual studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddStudioLayoutRequest $request AddStudioLayoutRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return AddStudioLayoutResponse AddStudioLayoutResponse
     */
    public function addStudioLayoutWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bgImageConfig)) {
            $query['BgImageConfig'] = $request->bgImageConfig;
        }
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->commonConfig)) {
            $query['CommonConfig'] = $request->commonConfig;
        }
        if (!Utils::isUnset($request->layerOrderConfigList)) {
            $query['LayerOrderConfigList'] = $request->layerOrderConfigList;
        }
        if (!Utils::isUnset($request->layoutName)) {
            $query['LayoutName'] = $request->layoutName;
        }
        if (!Utils::isUnset($request->layoutType)) {
            $query['LayoutType'] = $request->layoutType;
        }
        if (!Utils::isUnset($request->mediaInputConfigList)) {
            $query['MediaInputConfigList'] = $request->mediaInputConfigList;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->screenInputConfigList)) {
            $query['ScreenInputConfigList'] = $request->screenInputConfigList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddStudioLayout',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddStudioLayoutResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures a layout for a virtual studio.
     *  *
     * @description You can call this operation to configure a common layout or a studio layout for a virtual studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddStudioLayoutRequest $request AddStudioLayoutRequest
     *
     * @return AddStudioLayoutResponse AddStudioLayoutResponse
     */
    public function addStudioLayout($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addStudioLayoutWithOptions($request, $runtime);
    }

    /**
     * @summary Inserts supplemental enhancement information (SEI) to transcoded streams.
     *  *
     * @description Obtain the streaming domain, and then call this operation to insert SEI to the transcoded streams. Make sure that the stream name is the name of the source stream. This way, the SEI is inserted to all the transcoded streams.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddTrancodeSEIRequest $request AddTrancodeSEIRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return AddTrancodeSEIResponse AddTrancodeSEIResponse
     */
    public function addTrancodeSEIWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->delay)) {
            $query['Delay'] = $request->delay;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pattern)) {
            $query['Pattern'] = $request->pattern;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->repeat)) {
            $query['Repeat'] = $request->repeat;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        if (!Utils::isUnset($request->text)) {
            $query['Text'] = $request->text;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'AddTrancodeSEI',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddTrancodeSEIResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Inserts supplemental enhancement information (SEI) to transcoded streams.
     *  *
     * @description Obtain the streaming domain, and then call this operation to insert SEI to the transcoded streams. Make sure that the stream name is the name of the source stream. This way, the SEI is inserted to all the transcoded streams.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param AddTrancodeSEIRequest $request AddTrancodeSEIRequest
     *
     * @return AddTrancodeSEIResponse AddTrancodeSEIResponse
     */
    public function addTrancodeSEI($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addTrancodeSEIWithOptions($request, $runtime);
    }

    /**
     * @summary Mutes a group.
     *  *
     * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param BanLiveMessageGroupRequest $tmpReq  BanLiveMessageGroupRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return BanLiveMessageGroupResponse BanLiveMessageGroupResponse
     */
    public function banLiveMessageGroupWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new BanLiveMessageGroupShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->exceptUsers)) {
            $request->exceptUsersShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->exceptUsers, 'ExceptUsers', 'simple');
        }
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->dataCenter)) {
            $query['DataCenter'] = $request->dataCenter;
        }
        if (!Utils::isUnset($request->exceptUsersShrink)) {
            $query['ExceptUsers'] = $request->exceptUsersShrink;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'BanLiveMessageGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return BanLiveMessageGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Mutes a group.
     *  *
     * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param BanLiveMessageGroupRequest $request BanLiveMessageGroupRequest
     *
     * @return BanLiveMessageGroupResponse BanLiveMessageGroupResponse
     */
    public function banLiveMessageGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->banLiveMessageGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes the configurations of multiple domain names at a time.
     *  *
     * @description Obtain the domain names for which you want to delete the configurations, and then call this operation to delete the configurations of these domain domains at a time.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param BatchDeleteLiveDomainConfigsRequest $request BatchDeleteLiveDomainConfigsRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return BatchDeleteLiveDomainConfigsResponse BatchDeleteLiveDomainConfigsResponse
     */
    public function batchDeleteLiveDomainConfigsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainNames)) {
            $query['DomainNames'] = $request->domainNames;
        }
        if (!Utils::isUnset($request->functionNames)) {
            $query['FunctionNames'] = $request->functionNames;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'BatchDeleteLiveDomainConfigs',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return BatchDeleteLiveDomainConfigsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes the configurations of multiple domain names at a time.
     *  *
     * @description Obtain the domain names for which you want to delete the configurations, and then call this operation to delete the configurations of these domain domains at a time.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param BatchDeleteLiveDomainConfigsRequest $request BatchDeleteLiveDomainConfigsRequest
     *
     * @return BatchDeleteLiveDomainConfigsResponse BatchDeleteLiveDomainConfigsResponse
     */
    public function batchDeleteLiveDomainConfigs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->batchDeleteLiveDomainConfigsWithOptions($request, $runtime);
    }

    /**
     * @summary 根据一个或多个用户uid查询用户是否在线
     *  *
     * @description ## Usage notes
     * You can query whether up to 20 users are online at a time.
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param BatchGetOnlineUsersRequest $request BatchGetOnlineUsersRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return BatchGetOnlineUsersResponse BatchGetOnlineUsersResponse
     */
    public function batchGetOnlineUsersWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->appId)) {
            $body['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->groupId)) {
            $body['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->userIds)) {
            $body['UserIds'] = $request->userIds;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'BatchGetOnlineUsers',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return BatchGetOnlineUsersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 根据一个或多个用户uid查询用户是否在线
     *  *
     * @description ## Usage notes
     * You can query whether up to 20 users are online at a time.
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param BatchGetOnlineUsersRequest $request BatchGetOnlineUsersRequest
     *
     * @return BatchGetOnlineUsersResponse BatchGetOnlineUsersResponse
     */
    public function batchGetOnlineUsers($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->batchGetOnlineUsersWithOptions($request, $runtime);
    }

    /**
     * @summary Configures multiple domain names at a time.
     *  *
     * @description Obtain the domain names that you want to configure, and then call this operation to configure the domain names in batches.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param BatchSetLiveDomainConfigsRequest $request BatchSetLiveDomainConfigsRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return BatchSetLiveDomainConfigsResponse BatchSetLiveDomainConfigsResponse
     */
    public function batchSetLiveDomainConfigsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainNames)) {
            $query['DomainNames'] = $request->domainNames;
        }
        if (!Utils::isUnset($request->functions)) {
            $query['Functions'] = $request->functions;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'BatchSetLiveDomainConfigs',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return BatchSetLiveDomainConfigsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures multiple domain names at a time.
     *  *
     * @description Obtain the domain names that you want to configure, and then call this operation to configure the domain names in batches.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param BatchSetLiveDomainConfigsRequest $request BatchSetLiveDomainConfigsRequest
     *
     * @return BatchSetLiveDomainConfigsResponse BatchSetLiveDomainConfigsResponse
     */
    public function batchSetLiveDomainConfigs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->batchSetLiveDomainConfigsWithOptions($request, $runtime);
    }

    /**
     * @summary Unmutes a message group.
     *  *
     * @description ## QPS限制
     * 本接口的单用户QPS限制为100次/秒。超过限制，API调用会被限流，这可能会影响您的业务，请合理调用。更多信息，请参见[QPS限制](https://help.aliyun.com/document_detail/343507.html)。
     *  *
     * @param CancelMuteAllGroupUserRequest $request CancelMuteAllGroupUserRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return CancelMuteAllGroupUserResponse CancelMuteAllGroupUserResponse
     */
    public function cancelMuteAllGroupUserWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->appId)) {
            $body['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->broadCastType)) {
            $body['BroadCastType'] = $request->broadCastType;
        }
        if (!Utils::isUnset($request->groupId)) {
            $body['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->operatorUserId)) {
            $body['OperatorUserId'] = $request->operatorUserId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CancelMuteAllGroupUser',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CancelMuteAllGroupUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Unmutes a message group.
     *  *
     * @description ## QPS限制
     * 本接口的单用户QPS限制为100次/秒。超过限制，API调用会被限流，这可能会影响您的业务，请合理调用。更多信息，请参见[QPS限制](https://help.aliyun.com/document_detail/343507.html)。
     *  *
     * @param CancelMuteAllGroupUserRequest $request CancelMuteAllGroupUserRequest
     *
     * @return CancelMuteAllGroupUserResponse CancelMuteAllGroupUserResponse
     */
    public function cancelMuteAllGroupUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->cancelMuteAllGroupUserWithOptions($request, $runtime);
    }

    /**
     * @summary Unmutes members in a message group.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param CancelMuteGroupUserRequest $tmpReq  CancelMuteGroupUserRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return CancelMuteGroupUserResponse CancelMuteGroupUserResponse
     */
    public function cancelMuteGroupUserWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new CancelMuteGroupUserShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->cancelMuteUserList)) {
            $request->cancelMuteUserListShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->cancelMuteUserList, 'CancelMuteUserList', 'simple');
        }
        $body = [];
        if (!Utils::isUnset($request->appId)) {
            $body['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->broadCastType)) {
            $body['BroadCastType'] = $request->broadCastType;
        }
        if (!Utils::isUnset($request->cancelMuteUserListShrink)) {
            $body['CancelMuteUserList'] = $request->cancelMuteUserListShrink;
        }
        if (!Utils::isUnset($request->groupId)) {
            $body['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->operatorUserId)) {
            $body['OperatorUserId'] = $request->operatorUserId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CancelMuteGroupUser',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CancelMuteGroupUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Unmutes members in a message group.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param CancelMuteGroupUserRequest $request CancelMuteGroupUserRequest
     *
     * @return CancelMuteGroupUserResponse CancelMuteGroupUserResponse
     */
    public function cancelMuteGroupUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->cancelMuteGroupUserWithOptions($request, $runtime);
    }

    /**
     * @summary Changes the resource group to which a domain name belongs. In this case, you move the domain name from the original resource group to another resource group.
     *  *
     * @description You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ChangeLiveDomainResourceGroupRequest $request ChangeLiveDomainResourceGroupRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return ChangeLiveDomainResourceGroupResponse ChangeLiveDomainResourceGroupResponse
     */
    public function changeLiveDomainResourceGroupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->newResourceGroupId)) {
            $query['NewResourceGroupId'] = $request->newResourceGroupId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ChangeLiveDomainResourceGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ChangeLiveDomainResourceGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Changes the resource group to which a domain name belongs. In this case, you move the domain name from the original resource group to another resource group.
     *  *
     * @description You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ChangeLiveDomainResourceGroupRequest $request ChangeLiveDomainResourceGroupRequest
     *
     * @return ChangeLiveDomainResourceGroupResponse ChangeLiveDomainResourceGroupResponse
     */
    public function changeLiveDomainResourceGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->changeLiveDomainResourceGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Queries whether a user is in an interactive messaging group.
     *  *
     * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CheckLiveMessageUsersInGroupRequest $tmpReq  CheckLiveMessageUsersInGroupRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return CheckLiveMessageUsersInGroupResponse CheckLiveMessageUsersInGroupResponse
     */
    public function checkLiveMessageUsersInGroupWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new CheckLiveMessageUsersInGroupShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->userIds)) {
            $request->userIdsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->userIds, 'UserIds', 'simple');
        }
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->dataCenter)) {
            $query['DataCenter'] = $request->dataCenter;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->userIdsShrink)) {
            $query['UserIds'] = $request->userIdsShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'CheckLiveMessageUsersInGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CheckLiveMessageUsersInGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries whether a user is in an interactive messaging group.
     *  *
     * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CheckLiveMessageUsersInGroupRequest $request CheckLiveMessageUsersInGroupRequest
     *
     * @return CheckLiveMessageUsersInGroupResponse CheckLiveMessageUsersInGroupResponse
     */
    public function checkLiveMessageUsersInGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkLiveMessageUsersInGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Queries whether one or more specified users are online.
     *  *
     * @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CheckLiveMessageUsersOnlineRequest $tmpReq  CheckLiveMessageUsersOnlineRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return CheckLiveMessageUsersOnlineResponse CheckLiveMessageUsersOnlineResponse
     */
    public function checkLiveMessageUsersOnlineWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new CheckLiveMessageUsersOnlineShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->userIds)) {
            $request->userIdsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->userIds, 'UserIds', 'simple');
        }
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->dataCenter)) {
            $query['DataCenter'] = $request->dataCenter;
        }
        if (!Utils::isUnset($request->userIdsShrink)) {
            $query['UserIds'] = $request->userIdsShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'CheckLiveMessageUsersOnline',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CheckLiveMessageUsersOnlineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries whether one or more specified users are online.
     *  *
     * @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CheckLiveMessageUsersOnlineRequest $request CheckLiveMessageUsersOnlineRequest
     *
     * @return CheckLiveMessageUsersOnlineResponse CheckLiveMessageUsersOnlineResponse
     */
    public function checkLiveMessageUsersOnline($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkLiveMessageUsersOnlineWithOptions($request, $runtime);
    }

    /**
     * @summary Disables time shifting for a domain name, or an application or a live stream under the domain name.
     *  *
     * @description Obtain the streaming domain, and then call this operation to disable time shifting for the streaming domain or an application or a live stream under the streaming domain.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CloseLiveShiftRequest $request CloseLiveShiftRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return CloseLiveShiftResponse CloseLiveShiftResponse
     */
    public function closeLiveShiftWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'CloseLiveShift',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CloseLiveShiftResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Disables time shifting for a domain name, or an application or a live stream under the domain name.
     *  *
     * @description Obtain the streaming domain, and then call this operation to disable time shifting for the streaming domain or an application or a live stream under the streaming domain.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CloseLiveShiftRequest $request CloseLiveShiftRequest
     *
     * @return CloseLiveShiftResponse CloseLiveShiftResponse
     */
    public function closeLiveShift($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->closeLiveShiftWithOptions($request, $runtime);
    }

    /**
     * @summary Duplicates a production studio.
     *  *
     * @description You can call this operation to duplicate a production studio. This way, a new, identical production studio is created.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CopyCasterRequest $request CopyCasterRequest
     * @param RuntimeOptions    $runtime runtime options for this request RuntimeOptions
     *
     * @return CopyCasterResponse CopyCasterResponse
     */
    public function copyCasterWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterName)) {
            $query['CasterName'] = $request->casterName;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->srcCasterId)) {
            $query['SrcCasterId'] = $request->srcCasterId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'CopyCaster',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CopyCasterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Duplicates a production studio.
     *  *
     * @description You can call this operation to duplicate a production studio. This way, a new, identical production studio is created.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CopyCasterRequest $request CopyCasterRequest
     *
     * @return CopyCasterResponse CopyCasterResponse
     */
    public function copyCaster($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->copyCasterWithOptions($request, $runtime);
    }

    /**
     * @summary Applies the configuration of a PVW scene to a PGM scene.
     *  *
     * @description *   Streaming fees and transcoding fees are calculated based on the corresponding output resolutions and durations. For more information, see [Billing of production studios](https://help.aliyun.com/document_detail/64531.html).
     * *   You can call this operation to apply the configuration of a source scene to a destination scene. This operation takes effect only if the source scene is a PVW scene and the destination scene is a PGM scene. A PVW scene is a preview scene, and a PGM scene is a program scene.
     * *   The PVW scene and PGM scene must be in the same production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CopyCasterSceneConfigRequest $request CopyCasterSceneConfigRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return CopyCasterSceneConfigResponse CopyCasterSceneConfigResponse
     */
    public function copyCasterSceneConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->fromSceneId)) {
            $query['FromSceneId'] = $request->fromSceneId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->toSceneId)) {
            $query['ToSceneId'] = $request->toSceneId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'CopyCasterSceneConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CopyCasterSceneConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Applies the configuration of a PVW scene to a PGM scene.
     *  *
     * @description *   Streaming fees and transcoding fees are calculated based on the corresponding output resolutions and durations. For more information, see [Billing of production studios](https://help.aliyun.com/document_detail/64531.html).
     * *   You can call this operation to apply the configuration of a source scene to a destination scene. This operation takes effect only if the source scene is a PVW scene and the destination scene is a PGM scene. A PVW scene is a preview scene, and a PGM scene is a program scene.
     * *   The PVW scene and PGM scene must be in the same production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CopyCasterSceneConfigRequest $request CopyCasterSceneConfigRequest
     *
     * @return CopyCasterSceneConfigResponse CopyCasterSceneConfigResponse
     */
    public function copyCasterSceneConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->copyCasterSceneConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a production studio.
     *  *
     * @description You must enable the production studio feature before you can call this operation to create a production studio. For more information, see [Enable the production studio feature](https://help.aliyun.com/document_detail/60361.html).
     * You can call this operation to create production studios in general mode or playlist mode. Production studios in playlist mode can be used for carousel playback.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CreateCasterRequest $request CreateCasterRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateCasterResponse CreateCasterResponse
     */
    public function createCasterWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterName)) {
            $query['CasterName'] = $request->casterName;
        }
        if (!Utils::isUnset($request->casterTemplate)) {
            $query['CasterTemplate'] = $request->casterTemplate;
        }
        if (!Utils::isUnset($request->chargeType)) {
            $query['ChargeType'] = $request->chargeType;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->expireTime)) {
            $query['ExpireTime'] = $request->expireTime;
        }
        if (!Utils::isUnset($request->normType)) {
            $query['NormType'] = $request->normType;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->purchaseTime)) {
            $query['PurchaseTime'] = $request->purchaseTime;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateCaster',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateCasterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a production studio.
     *  *
     * @description You must enable the production studio feature before you can call this operation to create a production studio. For more information, see [Enable the production studio feature](https://help.aliyun.com/document_detail/60361.html).
     * You can call this operation to create production studios in general mode or playlist mode. Production studios in playlist mode can be used for carousel playback.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CreateCasterRequest $request CreateCasterRequest
     *
     * @return CreateCasterResponse CreateCasterResponse
     */
    public function createCaster($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createCasterWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a custom stream mixing template.
     *  *
     * @description After you call this operation to create a custom template, record the template name. When you call the [CreateMixStream](https://help.aliyun.com/document_detail/2848087.html) operation to create a stream mixing task, you can set the MixStreamTemplate parameter to the name of the custom template. This way, you can use the custom template for stream mixing.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CreateCustomTemplateRequest $request CreateCustomTemplateRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateCustomTemplateResponse CreateCustomTemplateResponse
     */
    public function createCustomTemplateWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->customTemplate)) {
            $query['CustomTemplate'] = $request->customTemplate;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->template)) {
            $query['Template'] = $request->template;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateCustomTemplate',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateCustomTemplateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a custom stream mixing template.
     *  *
     * @description After you call this operation to create a custom template, record the template name. When you call the [CreateMixStream](https://help.aliyun.com/document_detail/2848087.html) operation to create a stream mixing task, you can set the MixStreamTemplate parameter to the name of the custom template. This way, you can use the custom template for stream mixing.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CreateCustomTemplateRequest $request CreateCustomTemplateRequest
     *
     * @return CreateCustomTemplateResponse CreateCustomTemplateResponse
     */
    public function createCustomTemplate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createCustomTemplateWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an edge transcoding task.
     *  *
     * @description *   You can call this operation to create an edge transcoding task.
     * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CreateEdgeTranscodeJobRequest $request CreateEdgeTranscodeJobRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateEdgeTranscodeJobResponse CreateEdgeTranscodeJobResponse
     */
    public function createEdgeTranscodeJobWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->streamInput)) {
            $query['StreamInput'] = $request->streamInput;
        }
        if (!Utils::isUnset($request->streamOutput)) {
            $query['StreamOutput'] = $request->streamOutput;
        }
        if (!Utils::isUnset($request->templateId)) {
            $query['TemplateId'] = $request->templateId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateEdgeTranscodeJob',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateEdgeTranscodeJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an edge transcoding task.
     *  *
     * @description *   You can call this operation to create an edge transcoding task.
     * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CreateEdgeTranscodeJobRequest $request CreateEdgeTranscodeJobRequest
     *
     * @return CreateEdgeTranscodeJobResponse CreateEdgeTranscodeJobResponse
     */
    public function createEdgeTranscodeJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createEdgeTranscodeJobWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a callback to subscribe to channel or user events.
     *  *
     * @description You can call this operation to create a callback to subscribe to channel or user events. When you create a callback, you can configure parameters such as the callback URL and event type.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CreateEventSubRequest $request CreateEventSubRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateEventSubResponse CreateEventSubResponse
     */
    public function createEventSubWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->callbackUrl)) {
            $query['CallbackUrl'] = $request->callbackUrl;
        }
        if (!Utils::isUnset($request->channelId)) {
            $query['ChannelId'] = $request->channelId;
        }
        if (!Utils::isUnset($request->events)) {
            $query['Events'] = $request->events;
        }
        if (!Utils::isUnset($request->users)) {
            $query['Users'] = $request->users;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateEventSub',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateEventSubResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a callback to subscribe to channel or user events.
     *  *
     * @description You can call this operation to create a callback to subscribe to channel or user events. When you create a callback, you can configure parameters such as the callback URL and event type.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CreateEventSubRequest $request CreateEventSubRequest
     *
     * @return CreateEventSubResponse CreateEventSubResponse
     */
    public function createEventSub($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createEventSubWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a lightweight virtual studio template.
     *  *
     * @description >  The lightweight virtual studio feature is in invitational preview. You can add up to 300 virtual studio templates.
     *  *
     * @param CreateLiveAIStudioRequest $tmpReq  CreateLiveAIStudioRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateLiveAIStudioResponse CreateLiveAIStudioResponse
     */
    public function createLiveAIStudioWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new CreateLiveAIStudioShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->mattingLayout)) {
            $request->mattingLayoutShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->mattingLayout, 'MattingLayout', 'json');
        }
        if (!Utils::isUnset($tmpReq->mediaLayout)) {
            $request->mediaLayoutShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->mediaLayout, 'MediaLayout', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->backgroundResourceId)) {
            $query['BackgroundResourceId'] = $request->backgroundResourceId;
        }
        if (!Utils::isUnset($request->backgroundResourceUrl)) {
            $query['BackgroundResourceUrl'] = $request->backgroundResourceUrl;
        }
        if (!Utils::isUnset($request->backgroundType)) {
            $query['BackgroundType'] = $request->backgroundType;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->height)) {
            $query['Height'] = $request->height;
        }
        if (!Utils::isUnset($request->mattingLayoutShrink)) {
            $query['MattingLayout'] = $request->mattingLayoutShrink;
        }
        if (!Utils::isUnset($request->mattingType)) {
            $query['MattingType'] = $request->mattingType;
        }
        if (!Utils::isUnset($request->mediaLayoutShrink)) {
            $query['MediaLayout'] = $request->mediaLayoutShrink;
        }
        if (!Utils::isUnset($request->mediaResourceId)) {
            $query['MediaResourceId'] = $request->mediaResourceId;
        }
        if (!Utils::isUnset($request->mediaResourceUrl)) {
            $query['MediaResourceUrl'] = $request->mediaResourceUrl;
        }
        if (!Utils::isUnset($request->mediaType)) {
            $query['MediaType'] = $request->mediaType;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->studioName)) {
            $query['StudioName'] = $request->studioName;
        }
        if (!Utils::isUnset($request->width)) {
            $query['Width'] = $request->width;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateLiveAIStudio',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateLiveAIStudioResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a lightweight virtual studio template.
     *  *
     * @description >  The lightweight virtual studio feature is in invitational preview. You can add up to 300 virtual studio templates.
     *  *
     * @param CreateLiveAIStudioRequest $request CreateLiveAIStudioRequest
     *
     * @return CreateLiveAIStudioResponse CreateLiveAIStudioResponse
     */
    public function createLiveAIStudio($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createLiveAIStudioWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a stream delay configuration.
     *  *
     * @description Stream delay is different from latency caused by streaming protocols. Stream delay is a feature that allows you to delay the playback of a live stream that is processed in the cloud.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CreateLiveDelayConfigRequest $request CreateLiveDelayConfigRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateLiveDelayConfigResponse CreateLiveDelayConfigResponse
     */
    public function createLiveDelayConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->app)) {
            $query['App'] = $request->app;
        }
        if (!Utils::isUnset($request->delayTime)) {
            $query['DelayTime'] = $request->delayTime;
        }
        if (!Utils::isUnset($request->domain)) {
            $query['Domain'] = $request->domain;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->stream)) {
            $query['Stream'] = $request->stream;
        }
        if (!Utils::isUnset($request->taskTriggerMode)) {
            $query['TaskTriggerMode'] = $request->taskTriggerMode;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateLiveDelayConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateLiveDelayConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a stream delay configuration.
     *  *
     * @description Stream delay is different from latency caused by streaming protocols. Stream delay is a feature that allows you to delay the playback of a live stream that is processed in the cloud.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CreateLiveDelayConfigRequest $request CreateLiveDelayConfigRequest
     *
     * @return CreateLiveDelayConfigResponse CreateLiveDelayConfigResponse
     */
    public function createLiveDelayConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createLiveDelayConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an interactive messaging application.
     *  *
     * @description *   When you call other operations to manage the interactive messaging application, you must specify the same data center in which the application is created.
     * *   You can create up to 300 interactive messaging applications in an Alibaba Cloud account.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CreateLiveMessageAppRequest $request CreateLiveMessageAppRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateLiveMessageAppResponse CreateLiveMessageAppResponse
     */
    public function createLiveMessageAppWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->auditType)) {
            $query['AuditType'] = $request->auditType;
        }
        if (!Utils::isUnset($request->auditUrl)) {
            $query['AuditUrl'] = $request->auditUrl;
        }
        if (!Utils::isUnset($request->dataCenter)) {
            $query['DataCenter'] = $request->dataCenter;
        }
        if (!Utils::isUnset($request->eventCallbackUrl)) {
            $query['EventCallbackUrl'] = $request->eventCallbackUrl;
        }
        if (!Utils::isUnset($request->msgLifeCycle)) {
            $query['MsgLifeCycle'] = $request->msgLifeCycle;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateLiveMessageApp',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateLiveMessageAppResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an interactive messaging application.
     *  *
     * @description *   When you call other operations to manage the interactive messaging application, you must specify the same data center in which the application is created.
     * *   You can create up to 300 interactive messaging applications in an Alibaba Cloud account.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CreateLiveMessageAppRequest $request CreateLiveMessageAppRequest
     *
     * @return CreateLiveMessageAppResponse CreateLiveMessageAppResponse
     */
    public function createLiveMessageApp($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createLiveMessageAppWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an interactive messaging group.
     *  *
     * @description *   Before you call this operation, make sure that you have called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create an interactive messaging application.
     * *   You can create up to 5,000 interactive messaging groups in an interactive messaging application.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CreateLiveMessageGroupRequest $tmpReq  CreateLiveMessageGroupRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateLiveMessageGroupResponse CreateLiveMessageGroupResponse
     */
    public function createLiveMessageGroupWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new CreateLiveMessageGroupShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->administrators)) {
            $request->administratorsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->administrators, 'Administrators', 'simple');
        }
        $query = [];
        if (!Utils::isUnset($request->administratorsShrink)) {
            $query['Administrators'] = $request->administratorsShrink;
        }
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->creatorId)) {
            $query['CreatorId'] = $request->creatorId;
        }
        if (!Utils::isUnset($request->dataCenter)) {
            $query['DataCenter'] = $request->dataCenter;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->groupInfo)) {
            $query['GroupInfo'] = $request->groupInfo;
        }
        if (!Utils::isUnset($request->groupName)) {
            $query['GroupName'] = $request->groupName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateLiveMessageGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateLiveMessageGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an interactive messaging group.
     *  *
     * @description *   Before you call this operation, make sure that you have called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create an interactive messaging application.
     * *   You can create up to 5,000 interactive messaging groups in an interactive messaging application.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CreateLiveMessageGroupRequest $request CreateLiveMessageGroupRequest
     *
     * @return CreateLiveMessageGroupResponse CreateLiveMessageGroupResponse
     */
    public function createLiveMessageGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createLiveMessageGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a Global Accelerator (GA) instance and binds it to an acceleration circuit.
     *  *
     * @description *   You can call this operation to create a GA instance and bind it to an acceleration circuit. The granularity is at the stream level. You need to specify the access points where the acceleration circuit starts and ends.
     * *   The settings take effect only if the value of AppName and the value of StreamName are the same as the application name and stream name that are specified in the streaming URL.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CreateLivePrivateLineRequest $request CreateLivePrivateLineRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateLivePrivateLineResponse CreateLivePrivateLineResponse
     */
    public function createLivePrivateLineWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->accelerationArea)) {
            $query['AccelerationArea'] = $request->accelerationArea;
        }
        if (!Utils::isUnset($request->accelerationType)) {
            $query['AccelerationType'] = $request->accelerationType;
        }
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->maxBandwidth)) {
            $query['MaxBandwidth'] = $request->maxBandwidth;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->reuse)) {
            $query['Reuse'] = $request->reuse;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        if (!Utils::isUnset($request->videoCenter)) {
            $query['VideoCenter'] = $request->videoCenter;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateLivePrivateLine',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateLivePrivateLineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a Global Accelerator (GA) instance and binds it to an acceleration circuit.
     *  *
     * @description *   You can call this operation to create a GA instance and bind it to an acceleration circuit. The granularity is at the stream level. You need to specify the access points where the acceleration circuit starts and ends.
     * *   The settings take effect only if the value of AppName and the value of StreamName are the same as the application name and stream name that are specified in the streaming URL.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CreateLivePrivateLineRequest $request CreateLivePrivateLineRequest
     *
     * @return CreateLivePrivateLineResponse CreateLivePrivateLineResponse
     */
    public function createLivePrivateLine($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createLivePrivateLineWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a pulled-stream relay task.
     *  *
     * @description >  The pulled-stream relay feature is in public preview. You can use it free of charge. After the public preview ends, fees will be charged. The specific end time will be announced.
     * *   You can call this operation to create a pulled-stream relay task.
     * *   The pulled source can be a live stream or video-on-demand (VOD) resources.
     * *   After a task is created, it starts at the specified start time and ends at the specified end time. A task that ends is automatically deleted.
     * *   Make sure that the destination URL specified in the task is not used by another task. Otherwise, conflicts occur and stream ingest fails.
     * *   The events for pulled-stream relay callbacks include state changes of a pulled-stream relay task and exit of a pulled-stream relay task. For more information, see [Pulled-stream relay callbacks](https://help.aliyun.com/document_detail/2846768.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CreateLivePullToPushRequest $tmpReq  CreateLivePullToPushRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateLivePullToPushResponse CreateLivePullToPushResponse
     */
    public function createLivePullToPushWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new CreateLivePullToPushShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->sourceUrls)) {
            $request->sourceUrlsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->sourceUrls, 'SourceUrls', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->callbackUrl)) {
            $query['CallbackUrl'] = $request->callbackUrl;
        }
        if (!Utils::isUnset($request->dstUrl)) {
            $query['DstUrl'] = $request->dstUrl;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->fileIndex)) {
            $query['FileIndex'] = $request->fileIndex;
        }
        if (!Utils::isUnset($request->offset)) {
            $query['Offset'] = $request->offset;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->region)) {
            $query['Region'] = $request->region;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->repeatNumber)) {
            $query['RepeatNumber'] = $request->repeatNumber;
        }
        if (!Utils::isUnset($request->retryCount)) {
            $query['RetryCount'] = $request->retryCount;
        }
        if (!Utils::isUnset($request->retryInterval)) {
            $query['RetryInterval'] = $request->retryInterval;
        }
        if (!Utils::isUnset($request->sourceProtocol)) {
            $query['SourceProtocol'] = $request->sourceProtocol;
        }
        if (!Utils::isUnset($request->sourceType)) {
            $query['SourceType'] = $request->sourceType;
        }
        if (!Utils::isUnset($request->sourceUrlsShrink)) {
            $query['SourceUrls'] = $request->sourceUrlsShrink;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->taskName)) {
            $query['TaskName'] = $request->taskName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateLivePullToPush',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateLivePullToPushResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a pulled-stream relay task.
     *  *
     * @description >  The pulled-stream relay feature is in public preview. You can use it free of charge. After the public preview ends, fees will be charged. The specific end time will be announced.
     * *   You can call this operation to create a pulled-stream relay task.
     * *   The pulled source can be a live stream or video-on-demand (VOD) resources.
     * *   After a task is created, it starts at the specified start time and ends at the specified end time. A task that ends is automatically deleted.
     * *   Make sure that the destination URL specified in the task is not used by another task. Otherwise, conflicts occur and stream ingest fails.
     * *   The events for pulled-stream relay callbacks include state changes of a pulled-stream relay task and exit of a pulled-stream relay task. For more information, see [Pulled-stream relay callbacks](https://help.aliyun.com/document_detail/2846768.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CreateLivePullToPushRequest $request CreateLivePullToPushRequest
     *
     * @return CreateLivePullToPushResponse CreateLivePullToPushResponse
     */
    public function createLivePullToPush($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createLivePullToPushWithOptions($request, $runtime);
    }

    /**
     * @summary Configures real-time log delivery for a domain name.
     *  *
     * @description ##
     * Obtain the streaming domain, and then call this operation to configure real-time log delivery for the streaming domain.
     * This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
     * ## QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param CreateLiveRealTimeLogDeliveryRequest $request CreateLiveRealTimeLogDeliveryRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateLiveRealTimeLogDeliveryResponse CreateLiveRealTimeLogDeliveryResponse
     */
    public function createLiveRealTimeLogDeliveryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateLiveRealTimeLogDelivery',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateLiveRealTimeLogDeliveryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures real-time log delivery for a domain name.
     *  *
     * @description ##
     * Obtain the streaming domain, and then call this operation to configure real-time log delivery for the streaming domain.
     * This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
     * ## QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param CreateLiveRealTimeLogDeliveryRequest $request CreateLiveRealTimeLogDeliveryRequest
     *
     * @return CreateLiveRealTimeLogDeliveryResponse CreateLiveRealTimeLogDeliveryResponse
     */
    public function createLiveRealTimeLogDelivery($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createLiveRealTimeLogDeliveryWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a monitoring session.
     *  *
     * @description You can call this operation to create a monitoring session. Make sure that the parameter settings meet the requirements.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CreateLiveStreamMonitorRequest $request CreateLiveStreamMonitorRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateLiveStreamMonitorResponse CreateLiveStreamMonitorResponse
     */
    public function createLiveStreamMonitorWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->app)) {
            $query['App'] = $request->app;
        }
        if (!Utils::isUnset($request->callbackUrl)) {
            $query['CallbackUrl'] = $request->callbackUrl;
        }
        if (!Utils::isUnset($request->dingTalkWebHookUrl)) {
            $query['DingTalkWebHookUrl'] = $request->dingTalkWebHookUrl;
        }
        if (!Utils::isUnset($request->domain)) {
            $query['Domain'] = $request->domain;
        }
        if (!Utils::isUnset($request->inputList)) {
            $query['InputList'] = $request->inputList;
        }
        if (!Utils::isUnset($request->monitorConfig)) {
            $query['MonitorConfig'] = $request->monitorConfig;
        }
        if (!Utils::isUnset($request->monitorName)) {
            $query['MonitorName'] = $request->monitorName;
        }
        if (!Utils::isUnset($request->outputTemplate)) {
            $query['OutputTemplate'] = $request->outputTemplate;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->stream)) {
            $query['Stream'] = $request->stream;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateLiveStreamMonitor',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateLiveStreamMonitorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a monitoring session.
     *  *
     * @description You can call this operation to create a monitoring session. Make sure that the parameter settings meet the requirements.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CreateLiveStreamMonitorRequest $request CreateLiveStreamMonitorRequest
     *
     * @return CreateLiveStreamMonitorResponse CreateLiveStreamMonitorResponse
     */
    public function createLiveStreamMonitor($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createLiveStreamMonitorWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an M3U8 index file for a recording in a specified time period.
     *  *
     * @description You must have configured Object Storage Service (OSS) before you call this operation. For more information, see [Configure OSS](https://help.aliyun.com/document_detail/84932.html). ApsaraVideo Live allows you to record a live stream in the M3U8 format and store the M3U8 file in OSS. You can edit the TS segments that are included in the stored M3U8 file in real time.
     * >
     * *   You can create an index file only after a live stream is ingested. If no live stream is available within the specified time range or the name of the specified live stream is invalid, the index file fails to be created.
     * *   The time range that is specified by the StartTime and EndTime parameters must be the duration of at least one TS segment. The default duration of a TS segment is 30 seconds.
     * *   ApsaraVideo Live stores the information about TS segments for only three months. You can create M3U8 index files only for the recordings of the last three months.
     * *   OSS stores TS segments for a time period that is specified by the storage configuration in OSS. For more information, see [Configure lifecycle rules](https://help.aliyun.com/document_detail/31904.html).
     * *   ApsaraVideo Live stores the information about M3U8 index files for six months. You can query the information about only the M3U8 index files that were created in the last six months.
     * *   OSS stores M3U8 index files for a time period that is specified by the storage configuration in OSS.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 45 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CreateLiveStreamRecordIndexFilesRequest $request CreateLiveStreamRecordIndexFilesRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateLiveStreamRecordIndexFilesResponse CreateLiveStreamRecordIndexFilesResponse
     */
    public function createLiveStreamRecordIndexFilesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->endTimeIncluded)) {
            $query['EndTimeIncluded'] = $request->endTimeIncluded;
        }
        if (!Utils::isUnset($request->ossBucket)) {
            $query['OssBucket'] = $request->ossBucket;
        }
        if (!Utils::isUnset($request->ossEndpoint)) {
            $query['OssEndpoint'] = $request->ossEndpoint;
        }
        if (!Utils::isUnset($request->ossObject)) {
            $query['OssObject'] = $request->ossObject;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateLiveStreamRecordIndexFiles',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateLiveStreamRecordIndexFilesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an M3U8 index file for a recording in a specified time period.
     *  *
     * @description You must have configured Object Storage Service (OSS) before you call this operation. For more information, see [Configure OSS](https://help.aliyun.com/document_detail/84932.html). ApsaraVideo Live allows you to record a live stream in the M3U8 format and store the M3U8 file in OSS. You can edit the TS segments that are included in the stored M3U8 file in real time.
     * >
     * *   You can create an index file only after a live stream is ingested. If no live stream is available within the specified time range or the name of the specified live stream is invalid, the index file fails to be created.
     * *   The time range that is specified by the StartTime and EndTime parameters must be the duration of at least one TS segment. The default duration of a TS segment is 30 seconds.
     * *   ApsaraVideo Live stores the information about TS segments for only three months. You can create M3U8 index files only for the recordings of the last three months.
     * *   OSS stores TS segments for a time period that is specified by the storage configuration in OSS. For more information, see [Configure lifecycle rules](https://help.aliyun.com/document_detail/31904.html).
     * *   ApsaraVideo Live stores the information about M3U8 index files for six months. You can query the information about only the M3U8 index files that were created in the last six months.
     * *   OSS stores M3U8 index files for a time period that is specified by the storage configuration in OSS.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 45 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CreateLiveStreamRecordIndexFilesRequest $request CreateLiveStreamRecordIndexFilesRequest
     *
     * @return CreateLiveStreamRecordIndexFilesResponse CreateLiveStreamRecordIndexFilesResponse
     */
    public function createLiveStreamRecordIndexFiles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createLiveStreamRecordIndexFilesWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an interactive messaging application.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param CreateMessageAppRequest $tmpReq  CreateMessageAppRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateMessageAppResponse CreateMessageAppResponse
     */
    public function createMessageAppWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new CreateMessageAppShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->appConfig)) {
            $request->appConfigShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->appConfig, 'AppConfig', 'json');
        }
        if (!Utils::isUnset($tmpReq->extension)) {
            $request->extensionShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->extension, 'Extension', 'json');
        }
        $body = [];
        if (!Utils::isUnset($request->appConfigShrink)) {
            $body['AppConfig'] = $request->appConfigShrink;
        }
        if (!Utils::isUnset($request->appName)) {
            $body['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->extensionShrink)) {
            $body['Extension'] = $request->extensionShrink;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateMessageApp',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateMessageAppResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an interactive messaging application.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param CreateMessageAppRequest $request CreateMessageAppRequest
     *
     * @return CreateMessageAppResponse CreateMessageAppResponse
     */
    public function createMessageApp($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createMessageAppWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a message group.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param CreateMessageGroupRequest $tmpReq  CreateMessageGroupRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateMessageGroupResponse CreateMessageGroupResponse
     */
    public function createMessageGroupWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new CreateMessageGroupShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->extension)) {
            $request->extensionShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->extension, 'Extension', 'json');
        }
        $body = [];
        if (!Utils::isUnset($request->appId)) {
            $body['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->creatorId)) {
            $body['CreatorId'] = $request->creatorId;
        }
        if (!Utils::isUnset($request->extensionShrink)) {
            $body['Extension'] = $request->extensionShrink;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateMessageGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateMessageGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a message group.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param CreateMessageGroupRequest $request CreateMessageGroupRequest
     *
     * @return CreateMessageGroupResponse CreateMessageGroupResponse
     */
    public function createMessageGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createMessageGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a stream mixing task.
     *  *
     * @description You can call this operation to create a stream mixing task. This operation supports preset layouts and custom layouts.
     * If you have any questions or suggestions about the use of the stream mixing feature, you are welcome to search the group ID 34935990 in DingTalk to join the developer group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CreateMixStreamRequest $request CreateMixStreamRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateMixStreamResponse CreateMixStreamResponse
     */
    public function createMixStreamWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->callbackConfig)) {
            $query['CallbackConfig'] = $request->callbackConfig;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->inputStreamList)) {
            $query['InputStreamList'] = $request->inputStreamList;
        }
        if (!Utils::isUnset($request->layoutId)) {
            $query['LayoutId'] = $request->layoutId;
        }
        if (!Utils::isUnset($request->outputConfig)) {
            $query['OutputConfig'] = $request->outputConfig;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateMixStream',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateMixStreamResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a stream mixing task.
     *  *
     * @description You can call this operation to create a stream mixing task. This operation supports preset layouts and custom layouts.
     * If you have any questions or suggestions about the use of the stream mixing feature, you are welcome to search the group ID 34935990 in DingTalk to join the developer group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CreateMixStreamRequest $request CreateMixStreamRequest
     *
     * @return CreateMixStreamResponse CreateMixStreamResponse
     */
    public function createMixStream($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createMixStreamWithOptions($request, $runtime);
    }

    /**
     * @summary 创建房间whip协议推流地址
     *  *
     * @param CreateRTCWhipStreamAddressRequest $request CreateRTCWhipStreamAddressRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateRTCWhipStreamAddressResponse CreateRTCWhipStreamAddressResponse
     */
    public function createRTCWhipStreamAddressWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->channelId)) {
            $query['ChannelId'] = $request->channelId;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->displayName)) {
            $query['DisplayName'] = $request->displayName;
        }
        if (!Utils::isUnset($request->expireTime)) {
            $query['ExpireTime'] = $request->expireTime;
        }
        if (!Utils::isUnset($request->userId)) {
            $query['UserId'] = $request->userId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateRTCWhipStreamAddress',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateRTCWhipStreamAddressResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 创建房间whip协议推流地址
     *  *
     * @param CreateRTCWhipStreamAddressRequest $request CreateRTCWhipStreamAddressRequest
     *
     * @return CreateRTCWhipStreamAddressResponse CreateRTCWhipStreamAddressResponse
     */
    public function createRTCWhipStreamAddress($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createRTCWhipStreamAddressWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a Real-Time Messaging Protocol (RTMP) ingest URL for a channel.
     *  *
     * @description ### [](#)Usage notes
     * To use the interactive streaming feature, you must use ApsaraVideo Real-time Communication (ARTC) SDK to join a channel and ingest streams over Real-Time Communication (RTC). In specific scenarios, you can ingest streams over Real-Time Messaging Protocol (RTMP) by using tools such as Open Broadcaster Software (OBS). Then, ApsaraVideo Live automatically converts the RTMP streams to RTC streams and distributes the RTC streams to viewers. You can call this operation to generate an ingest URL in the RTMP format. After you ingest RTMP streams, ApsaraVideo Live automatically converts the streams to RTC streams. Do not call this operation if you require only regular live streaming. To quickly ingest RTMP streams and start live streaming, see [Get started with ApsaraVideo Live](https://help.aliyun.com/document_detail/198676.html).
     * ## [](#)Procedure
     * 1.  Call this operation to generate an ingest URL in the RTMP format.
     * 2.  Ingest a stream by using the ingest URL. Other users in the channel can watch the stream.
     * 3.  Stop ingesting the stream. Other users in the channel see that the user who ingested the stream leaves the channel.
     * >
     * *   You can repeat Steps 2 and 3 within the validity period of the ingest URL.
     * *   We recommend that you call the [DescribeChannelParticipants](https://help.aliyun.com/document_detail/610801.html) operation to query online users in the channel at regular intervals. This way, you can check whether the user who ingests the stream is still in the channel. If the user who ingests the stream is not in the channel, the stream may be interrupted. In this case, we recommend that you stop ingesting the stream and perform Step 2.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param CreateRoomRealTimeStreamAddressRequest $request CreateRoomRealTimeStreamAddressRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateRoomRealTimeStreamAddressResponse CreateRoomRealTimeStreamAddressResponse
     */
    public function createRoomRealTimeStreamAddressWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateRoomRealTimeStreamAddress',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateRoomRealTimeStreamAddressResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a Real-Time Messaging Protocol (RTMP) ingest URL for a channel.
     *  *
     * @description ### [](#)Usage notes
     * To use the interactive streaming feature, you must use ApsaraVideo Real-time Communication (ARTC) SDK to join a channel and ingest streams over Real-Time Communication (RTC). In specific scenarios, you can ingest streams over Real-Time Messaging Protocol (RTMP) by using tools such as Open Broadcaster Software (OBS). Then, ApsaraVideo Live automatically converts the RTMP streams to RTC streams and distributes the RTC streams to viewers. You can call this operation to generate an ingest URL in the RTMP format. After you ingest RTMP streams, ApsaraVideo Live automatically converts the streams to RTC streams. Do not call this operation if you require only regular live streaming. To quickly ingest RTMP streams and start live streaming, see [Get started with ApsaraVideo Live](https://help.aliyun.com/document_detail/198676.html).
     * ## [](#)Procedure
     * 1.  Call this operation to generate an ingest URL in the RTMP format.
     * 2.  Ingest a stream by using the ingest URL. Other users in the channel can watch the stream.
     * 3.  Stop ingesting the stream. Other users in the channel see that the user who ingested the stream leaves the channel.
     * >
     * *   You can repeat Steps 2 and 3 within the validity period of the ingest URL.
     * *   We recommend that you call the [DescribeChannelParticipants](https://help.aliyun.com/document_detail/610801.html) operation to query online users in the channel at regular intervals. This way, you can check whether the user who ingests the stream is still in the channel. If the user who ingests the stream is not in the channel, the stream may be interrupted. In this case, we recommend that you stop ingesting the stream and perform Step 2.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param CreateRoomRealTimeStreamAddressRequest $request CreateRoomRealTimeStreamAddressRequest
     *
     * @return CreateRoomRealTimeStreamAddressResponse CreateRoomRealTimeStreamAddressResponse
     */
    public function createRoomRealTimeStreamAddress($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createRoomRealTimeStreamAddressWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a live subtitle task to transcribe an audio stream to text in real time.
     *  *
     * @description You can call this operation to create a live subtitle task that transcribes audio in a live stream to text in real time.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CreateRtcAsrTaskRequest $request CreateRtcAsrTaskRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateRtcAsrTaskResponse CreateRtcAsrTaskResponse
     */
    public function createRtcAsrTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->authKey)) {
            $query['AuthKey'] = $request->authKey;
        }
        if (!Utils::isUnset($request->autoTerminateDelay)) {
            $query['AutoTerminateDelay'] = $request->autoTerminateDelay;
        }
        if (!Utils::isUnset($request->autoTerminateEnabled)) {
            $query['AutoTerminateEnabled'] = $request->autoTerminateEnabled;
        }
        if (!Utils::isUnset($request->callbackURL)) {
            $query['CallbackURL'] = $request->callbackURL;
        }
        if (!Utils::isUnset($request->channelID)) {
            $query['ChannelID'] = $request->channelID;
        }
        if (!Utils::isUnset($request->language)) {
            $query['Language'] = $request->language;
        }
        if (!Utils::isUnset($request->mode)) {
            $query['Mode'] = $request->mode;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->reportInterval)) {
            $query['ReportInterval'] = $request->reportInterval;
        }
        if (!Utils::isUnset($request->rtcUserId)) {
            $query['RtcUserId'] = $request->rtcUserId;
        }
        if (!Utils::isUnset($request->SDKAppID)) {
            $query['SDKAppID'] = $request->SDKAppID;
        }
        if (!Utils::isUnset($request->streamURL)) {
            $query['StreamURL'] = $request->streamURL;
        }
        if (!Utils::isUnset($request->targetLanguages)) {
            $query['TargetLanguages'] = $request->targetLanguages;
        }
        if (!Utils::isUnset($request->translateEnabled)) {
            $query['TranslateEnabled'] = $request->translateEnabled;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateRtcAsrTask',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateRtcAsrTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a live subtitle task to transcribe an audio stream to text in real time.
     *  *
     * @description You can call this operation to create a live subtitle task that transcribes audio in a live stream to text in real time.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CreateRtcAsrTaskRequest $request CreateRtcAsrTaskRequest
     *
     * @return CreateRtcAsrTaskResponse CreateRtcAsrTaskResponse
     */
    public function createRtcAsrTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createRtcAsrTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a subscription to mixed-stream relay events.
     *  *
     * @description You can call this operation to create a subscription to mixed-stream relay events. You can configure parameters such as the callback URL, application to which you want to subscribe, and channel information when you create a subscription.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CreateRtcMPUEventSubRequest $request CreateRtcMPUEventSubRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateRtcMPUEventSubResponse CreateRtcMPUEventSubResponse
     */
    public function createRtcMPUEventSubWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->callbackUrl)) {
            $query['CallbackUrl'] = $request->callbackUrl;
        }
        if (!Utils::isUnset($request->channelIds)) {
            $query['ChannelIds'] = $request->channelIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateRtcMPUEventSub',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateRtcMPUEventSubResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a subscription to mixed-stream relay events.
     *  *
     * @description You can call this operation to create a subscription to mixed-stream relay events. You can configure parameters such as the callback URL, application to which you want to subscribe, and channel information when you create a subscription.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param CreateRtcMPUEventSubRequest $request CreateRtcMPUEventSubRequest
     *
     * @return CreateRtcMPUEventSubResponse CreateRtcMPUEventSubResponse
     */
    public function createRtcMPUEventSub($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createRtcMPUEventSubWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a production studio.
     *  *
     * @description *   You can delete only production studios that are closed.
     * *   When a production studio is deleted, the scenes, components, and layouts of the production studio are also deleted.
     * *   You cannot recover a deleted production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteCasterRequest $request DeleteCasterRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteCasterResponse DeleteCasterResponse
     */
    public function deleteCasterWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteCaster',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteCasterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a production studio.
     *  *
     * @description *   You can delete only production studios that are closed.
     * *   When a production studio is deleted, the scenes, components, and layouts of the production studio are also deleted.
     * *   You cannot recover a deleted production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteCasterRequest $request DeleteCasterRequest
     *
     * @return DeleteCasterResponse DeleteCasterResponse
     */
    public function deleteCaster($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCasterWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a component in a production studio.
     *  *
     * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to delete a component in the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteCasterComponentRequest $request DeleteCasterComponentRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteCasterComponentResponse DeleteCasterComponentResponse
     */
    public function deleteCasterComponentWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->componentId)) {
            $query['ComponentId'] = $request->componentId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteCasterComponent',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteCasterComponentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a component in a production studio.
     *  *
     * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to delete a component in the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteCasterComponentRequest $request DeleteCasterComponentRequest
     *
     * @return DeleteCasterComponentResponse DeleteCasterComponentResponse
     */
    public function deleteCasterComponent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCasterComponentWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an episode in a production studio.
     *  *
     * @description Before you call this operation to delete an episode in a production studio, you must obtain the ID of the production studio and the ID of the episode.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteCasterEpisodeRequest $request DeleteCasterEpisodeRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteCasterEpisodeResponse DeleteCasterEpisodeResponse
     */
    public function deleteCasterEpisodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->episodeId)) {
            $query['EpisodeId'] = $request->episodeId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteCasterEpisode',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteCasterEpisodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an episode in a production studio.
     *  *
     * @description Before you call this operation to delete an episode in a production studio, you must obtain the ID of the production studio and the ID of the episode.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteCasterEpisodeRequest $request DeleteCasterEpisodeRequest
     *
     * @return DeleteCasterEpisodeResponse DeleteCasterEpisodeResponse
     */
    public function deleteCasterEpisode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCasterEpisodeWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an episode list in a production studio.
     *  *
     * @description Before you call this operation to delete an episode list in a production studio, make sure that you have called the [AddCasterEpisodeGroup](https://help.aliyun.com/document_detail/2848071.html) operation to add the episode list in the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteCasterEpisodeGroupRequest $request DeleteCasterEpisodeGroupRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteCasterEpisodeGroupResponse DeleteCasterEpisodeGroupResponse
     */
    public function deleteCasterEpisodeGroupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->programId)) {
            $query['ProgramId'] = $request->programId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteCasterEpisodeGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteCasterEpisodeGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an episode list in a production studio.
     *  *
     * @description Before you call this operation to delete an episode list in a production studio, make sure that you have called the [AddCasterEpisodeGroup](https://help.aliyun.com/document_detail/2848071.html) operation to add the episode list in the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteCasterEpisodeGroupRequest $request DeleteCasterEpisodeGroupRequest
     *
     * @return DeleteCasterEpisodeGroupResponse DeleteCasterEpisodeGroupResponse
     */
    public function deleteCasterEpisodeGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCasterEpisodeGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a layout in a production studio.
     *  *
     * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio and then call this operation to delete a layout in the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DeleteCasterLayoutRequest $request DeleteCasterLayoutRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteCasterLayoutResponse DeleteCasterLayoutResponse
     */
    public function deleteCasterLayoutWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->layoutId)) {
            $query['LayoutId'] = $request->layoutId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteCasterLayout',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteCasterLayoutResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a layout in a production studio.
     *  *
     * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio and then call this operation to delete a layout in the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DeleteCasterLayoutRequest $request DeleteCasterLayoutRequest
     *
     * @return DeleteCasterLayoutResponse DeleteCasterLayoutResponse
     */
    public function deleteCasterLayout($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCasterLayoutWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes the episode list for carousel playback in a production studio.
     *  *
     * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to delete the episode list for carousel playback in the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteCasterProgramRequest $request DeleteCasterProgramRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteCasterProgramResponse DeleteCasterProgramResponse
     */
    public function deleteCasterProgramWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteCasterProgram',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteCasterProgramResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes the episode list for carousel playback in a production studio.
     *  *
     * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to delete the episode list for carousel playback in the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteCasterProgramRequest $request DeleteCasterProgramRequest
     *
     * @return DeleteCasterProgramResponse DeleteCasterProgramResponse
     */
    public function deleteCasterProgram($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCasterProgramWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes the settings of a scene.
     *  *
     * @description You can call this operation to delete the settings of a scene, such as the component setting, layout setting, or both of them.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DeleteCasterSceneConfigRequest $request DeleteCasterSceneConfigRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteCasterSceneConfigResponse DeleteCasterSceneConfigResponse
     */
    public function deleteCasterSceneConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->sceneId)) {
            $query['SceneId'] = $request->sceneId;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteCasterSceneConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteCasterSceneConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes the settings of a scene.
     *  *
     * @description You can call this operation to delete the settings of a scene, such as the component setting, layout setting, or both of them.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DeleteCasterSceneConfigRequest $request DeleteCasterSceneConfigRequest
     *
     * @return DeleteCasterSceneConfigResponse DeleteCasterSceneConfigResponse
     */
    public function deleteCasterSceneConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCasterSceneConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Removes an input source from a production studio.
     *  *
     * @description Before you call this operation to remove an input source from a production studio, make sure that you have called the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DeleteCasterVideoResourceRequest $request DeleteCasterVideoResourceRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteCasterVideoResourceResponse DeleteCasterVideoResourceResponse
     */
    public function deleteCasterVideoResourceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceId)) {
            $query['ResourceId'] = $request->resourceId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteCasterVideoResource',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteCasterVideoResourceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Removes an input source from a production studio.
     *  *
     * @description Before you call this operation to remove an input source from a production studio, make sure that you have called the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DeleteCasterVideoResourceRequest $request DeleteCasterVideoResourceRequest
     *
     * @return DeleteCasterVideoResourceResponse DeleteCasterVideoResourceResponse
     */
    public function deleteCasterVideoResource($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCasterVideoResourceWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a channel.
     *  *
     * @description ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteChannelRequest $request DeleteChannelRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteChannelResponse DeleteChannelResponse
     */
    public function deleteChannelWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->channelId)) {
            $query['ChannelId'] = $request->channelId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteChannel',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteChannelResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a channel.
     *  *
     * @description ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteChannelRequest $request DeleteChannelRequest
     *
     * @return DeleteChannelResponse DeleteChannelResponse
     */
    public function deleteChannel($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteChannelWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a custom stream mixing template.
     *  *
     * @description Obtain the name of the custom stream mixing template that you want to delete, and then call this operation to delete the template.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteCustomTemplateRequest $request DeleteCustomTemplateRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteCustomTemplateResponse DeleteCustomTemplateResponse
     */
    public function deleteCustomTemplateWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->template)) {
            $query['Template'] = $request->template;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteCustomTemplate',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteCustomTemplateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a custom stream mixing template.
     *  *
     * @description Obtain the name of the custom stream mixing template that you want to delete, and then call this operation to delete the template.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteCustomTemplateRequest $request DeleteCustomTemplateRequest
     *
     * @return DeleteCustomTemplateResponse DeleteCustomTemplateResponse
     */
    public function deleteCustomTemplate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCustomTemplateWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an edge transcoding task.
     *  *
     * @description *   You can call this operation to delete an edge transcoding task.
     * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteEdgeTranscodeJobRequest $request DeleteEdgeTranscodeJobRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteEdgeTranscodeJobResponse DeleteEdgeTranscodeJobResponse
     */
    public function deleteEdgeTranscodeJobWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->jobId)) {
            $query['JobId'] = $request->jobId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteEdgeTranscodeJob',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteEdgeTranscodeJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an edge transcoding task.
     *  *
     * @description *   You can call this operation to delete an edge transcoding task.
     * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteEdgeTranscodeJobRequest $request DeleteEdgeTranscodeJobRequest
     *
     * @return DeleteEdgeTranscodeJobResponse DeleteEdgeTranscodeJobResponse
     */
    public function deleteEdgeTranscodeJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteEdgeTranscodeJobWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a callback that is used to subscribe to channel or user events.
     *  *
     * @description Before you call this operation, make sure that you have called the [CreateEventSubscribe](https://help.aliyun.com/document_detail/2848209.html) operation to create a callback that is used to subscribe to channel or user events.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteEventSubRequest $request DeleteEventSubRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteEventSubResponse DeleteEventSubResponse
     */
    public function deleteEventSubWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->subscribeId)) {
            $query['SubscribeId'] = $request->subscribeId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteEventSub',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteEventSubResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a callback that is used to subscribe to channel or user events.
     *  *
     * @description Before you call this operation, make sure that you have called the [CreateEventSubscribe](https://help.aliyun.com/document_detail/2848209.html) operation to create a callback that is used to subscribe to channel or user events.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteEventSubRequest $request DeleteEventSubRequest
     *
     * @return DeleteEventSubResponse DeleteEventSubResponse
     */
    public function deleteEventSub($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteEventSubWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a subtitle rule.
     *  *
     * @description You can call this operation to delete a specified subtitle rule.
     * >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveAIProduceRulesRequest $request DeleteLiveAIProduceRulesRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLiveAIProduceRulesResponse DeleteLiveAIProduceRulesResponse
     */
    public function deleteLiveAIProduceRulesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->app)) {
            $query['App'] = $request->app;
        }
        if (!Utils::isUnset($request->domain)) {
            $query['Domain'] = $request->domain;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->rulesId)) {
            $query['RulesId'] = $request->rulesId;
        }
        if (!Utils::isUnset($request->suffixName)) {
            $query['SuffixName'] = $request->suffixName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveAIProduceRules',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveAIProduceRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a subtitle rule.
     *  *
     * @description You can call this operation to delete a specified subtitle rule.
     * >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveAIProduceRulesRequest $request DeleteLiveAIProduceRulesRequest
     *
     * @return DeleteLiveAIProduceRulesResponse DeleteLiveAIProduceRulesResponse
     */
    public function deleteLiveAIProduceRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveAIProduceRulesWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a virtual studio template.
     *  *
     * @description To delete a virtual studio template, you must first unbind the rules. Otherwise, an error occurs.
     * >  The lightweight virtual studio feature is in invitational preview. You can add up to 300 virtual studio templates.
     *  *
     * @param DeleteLiveAIStudioRequest $request DeleteLiveAIStudioRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLiveAIStudioResponse DeleteLiveAIStudioResponse
     */
    public function deleteLiveAIStudioWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->studioId)) {
            $query['StudioId'] = $request->studioId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveAIStudio',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveAIStudioResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a virtual studio template.
     *  *
     * @description To delete a virtual studio template, you must first unbind the rules. Otherwise, an error occurs.
     * >  The lightweight virtual studio feature is in invitational preview. You can add up to 300 virtual studio templates.
     *  *
     * @param DeleteLiveAIStudioRequest $request DeleteLiveAIStudioRequest
     *
     * @return DeleteLiveAIStudioResponse DeleteLiveAIStudioResponse
     */
    public function deleteLiveAIStudio($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveAIStudioWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a specified subtitle template.
     *  *
     * @description You can call this operation to delete a specified subtitle template for live streaming.
     * >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DeleteLiveAISubtitleRequest $request DeleteLiveAISubtitleRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLiveAISubtitleResponse DeleteLiveAISubtitleResponse
     */
    public function deleteLiveAISubtitleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->subtitleId)) {
            $query['SubtitleId'] = $request->subtitleId;
        }
        if (!Utils::isUnset($request->subtitleName)) {
            $query['SubtitleName'] = $request->subtitleName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveAISubtitle',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveAISubtitleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a specified subtitle template.
     *  *
     * @description You can call this operation to delete a specified subtitle template for live streaming.
     * >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DeleteLiveAISubtitleRequest $request DeleteLiveAISubtitleRequest
     *
     * @return DeleteLiveAISubtitleResponse DeleteLiveAISubtitleResponse
     */
    public function deleteLiveAISubtitle($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveAISubtitleWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a recording configuration at the application level.
     *  *
     * @description Obtain the main streaming domain, and then call this operation to delete a recording configuration at the application level.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveAppRecordConfigRequest $request DeleteLiveAppRecordConfigRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLiveAppRecordConfigResponse DeleteLiveAppRecordConfigResponse
     */
    public function deleteLiveAppRecordConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveAppRecordConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveAppRecordConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a recording configuration at the application level.
     *  *
     * @description Obtain the main streaming domain, and then call this operation to delete a recording configuration at the application level.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveAppRecordConfigRequest $request DeleteLiveAppRecordConfigRequest
     *
     * @return DeleteLiveAppRecordConfigResponse DeleteLiveAppRecordConfigResponse
     */
    public function deleteLiveAppRecordConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveAppRecordConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes the snapshot configuration for live streams in an application. The deletion takes effect after you restart stream ingest.
     *  *
     * @description You can call this operation to delete the snapshot configuration for live streams in an application. The deletion takes effect after you restart stream ingest.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveAppSnapshotConfigRequest $request DeleteLiveAppSnapshotConfigRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLiveAppSnapshotConfigResponse DeleteLiveAppSnapshotConfigResponse
     */
    public function deleteLiveAppSnapshotConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveAppSnapshotConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveAppSnapshotConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes the snapshot configuration for live streams in an application. The deletion takes effect after you restart stream ingest.
     *  *
     * @description You can call this operation to delete the snapshot configuration for live streams in an application. The deletion takes effect after you restart stream ingest.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveAppSnapshotConfigRequest $request DeleteLiveAppSnapshotConfigRequest
     *
     * @return DeleteLiveAppSnapshotConfigResponse DeleteLiveAppSnapshotConfigResponse
     */
    public function deleteLiveAppSnapshotConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveAppSnapshotConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an audio moderation configuration.
     *  *
     * @description *   Obtain the main streaming domain, and then call this operation to delete an audio moderation configuration.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DeleteLiveAudioAuditConfigRequest $request DeleteLiveAudioAuditConfigRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLiveAudioAuditConfigResponse DeleteLiveAudioAuditConfigResponse
     */
    public function deleteLiveAudioAuditConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveAudioAuditConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveAudioAuditConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an audio moderation configuration.
     *  *
     * @description *   Obtain the main streaming domain, and then call this operation to delete an audio moderation configuration.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DeleteLiveAudioAuditConfigRequest $request DeleteLiveAudioAuditConfigRequest
     *
     * @return DeleteLiveAudioAuditConfigResponse DeleteLiveAudioAuditConfigResponse
     */
    public function deleteLiveAudioAuditConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveAudioAuditConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes the configuration of callbacks for audio moderation results.
     *  *
     * @description *   Obtain the main streaming domain, and then call this operation to delete the configuration of callbacks for audio moderation results.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveAudioAuditNotifyConfigRequest $request DeleteLiveAudioAuditNotifyConfigRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLiveAudioAuditNotifyConfigResponse DeleteLiveAudioAuditNotifyConfigResponse
     */
    public function deleteLiveAudioAuditNotifyConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveAudioAuditNotifyConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveAudioAuditNotifyConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes the configuration of callbacks for audio moderation results.
     *  *
     * @description *   Obtain the main streaming domain, and then call this operation to delete the configuration of callbacks for audio moderation results.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveAudioAuditNotifyConfigRequest $request DeleteLiveAudioAuditNotifyConfigRequest
     *
     * @return DeleteLiveAudioAuditNotifyConfigResponse DeleteLiveAudioAuditNotifyConfigResponse
     */
    public function deleteLiveAudioAuditNotifyConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveAudioAuditNotifyConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a configuration of live center stream relay.
     *  *
     * @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveCenterTransferRequest $request DeleteLiveCenterTransferRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLiveCenterTransferResponse DeleteLiveCenterTransferResponse
     */
    public function deleteLiveCenterTransferWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->dstUrl)) {
            $query['DstUrl'] = $request->dstUrl;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveCenterTransfer',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveCenterTransferResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a configuration of live center stream relay.
     *  *
     * @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveCenterTransferRequest $request DeleteLiveCenterTransferRequest
     *
     * @return DeleteLiveCenterTransferResponse DeleteLiveCenterTransferResponse
     */
    public function deleteLiveCenterTransfer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveCenterTransferWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a stream delay configuration.
     *  *
     * @description You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveDelayConfigRequest $request DeleteLiveDelayConfigRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLiveDelayConfigResponse DeleteLiveDelayConfigResponse
     */
    public function deleteLiveDelayConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->app)) {
            $query['App'] = $request->app;
        }
        if (!Utils::isUnset($request->domain)) {
            $query['Domain'] = $request->domain;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->stream)) {
            $query['Stream'] = $request->stream;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveDelayConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveDelayConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a stream delay configuration.
     *  *
     * @description You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveDelayConfigRequest $request DeleteLiveDelayConfigRequest
     *
     * @return DeleteLiveDelayConfigResponse DeleteLiveDelayConfigResponse
     */
    public function deleteLiveDelayConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveDelayConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes the configuration of callbacks for video moderation results.
     *  *
     * @description ## [](#)Usage notes
     * *   Obtain the main streaming domain, and then call this operation to delete the configuration of callbacks for video moderation results.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveDetectNotifyConfigRequest $request DeleteLiveDetectNotifyConfigRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLiveDetectNotifyConfigResponse DeleteLiveDetectNotifyConfigResponse
     */
    public function deleteLiveDetectNotifyConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveDetectNotifyConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveDetectNotifyConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes the configuration of callbacks for video moderation results.
     *  *
     * @description ## [](#)Usage notes
     * *   Obtain the main streaming domain, and then call this operation to delete the configuration of callbacks for video moderation results.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveDetectNotifyConfigRequest $request DeleteLiveDetectNotifyConfigRequest
     *
     * @return DeleteLiveDetectNotifyConfigResponse DeleteLiveDetectNotifyConfigResponse
     */
    public function deleteLiveDetectNotifyConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveDetectNotifyConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Removes a domain name from ApsaraVideo Live.
     *  *
     * @description *   After you successfully call the DeleteLiveDomain operation, all records of the specified domain name are deleted. Exercise caution when you perform this operation.
     * *   We recommend that you restore to an A record for the domain name at the DNS provider before you remove the domain name. Otherwise, the domain name may become inaccessible. If your domain name is registered with Alibaba Cloud, log on to the [Alibaba Cloud DNS console](https://account.aliyun.com/login/login.htm?oauth_callback=https%3A%2F%2Fdns.console.aliyun.com%2F%3Fspm%3Da2c4g.11186623.0.0.3cda841fcvk7Qs\\&lang=zh) and navigate to the **Domain Name Resolution** page. Find the domain name and then click **DNS Settings** in the Actions column. On the page that appears, change the CNAME record to an A record. If your domain name is registered with another DNS provider, configure similar settings on the platform of that DNS provider.
     * *   If you want to only suspend the use of the domain name, we recommend that you call the [StopLiveDomain](https://help.aliyun.com/document_detail/88329.html) operation.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DeleteLiveDomainRequest $request DeleteLiveDomainRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLiveDomainResponse DeleteLiveDomainResponse
     */
    public function deleteLiveDomainWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveDomain',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveDomainResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Removes a domain name from ApsaraVideo Live.
     *  *
     * @description *   After you successfully call the DeleteLiveDomain operation, all records of the specified domain name are deleted. Exercise caution when you perform this operation.
     * *   We recommend that you restore to an A record for the domain name at the DNS provider before you remove the domain name. Otherwise, the domain name may become inaccessible. If your domain name is registered with Alibaba Cloud, log on to the [Alibaba Cloud DNS console](https://account.aliyun.com/login/login.htm?oauth_callback=https%3A%2F%2Fdns.console.aliyun.com%2F%3Fspm%3Da2c4g.11186623.0.0.3cda841fcvk7Qs\\&lang=zh) and navigate to the **Domain Name Resolution** page. Find the domain name and then click **DNS Settings** in the Actions column. On the page that appears, change the CNAME record to an A record. If your domain name is registered with another DNS provider, configure similar settings on the platform of that DNS provider.
     * *   If you want to only suspend the use of the domain name, we recommend that you call the [StopLiveDomain](https://help.aliyun.com/document_detail/88329.html) operation.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DeleteLiveDomainRequest $request DeleteLiveDomainRequest
     *
     * @return DeleteLiveDomainResponse DeleteLiveDomainResponse
     */
    public function deleteLiveDomain($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveDomainWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes the mapping between a streaming domain and an ingest domain.
     *  *
     * @description Make sure that the streaming domain has been mapped to the ingest domain before you call this operation to delete the mapping. For more information about how to map a streaming domain to an ingest domain, see [AddLiveDomainMapping](https://help.aliyun.com/document_detail/88782.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DeleteLiveDomainMappingRequest $request DeleteLiveDomainMappingRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLiveDomainMappingResponse DeleteLiveDomainMappingResponse
     */
    public function deleteLiveDomainMappingWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pullDomain)) {
            $query['PullDomain'] = $request->pullDomain;
        }
        if (!Utils::isUnset($request->pushDomain)) {
            $query['PushDomain'] = $request->pushDomain;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveDomainMapping',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveDomainMappingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes the mapping between a streaming domain and an ingest domain.
     *  *
     * @description Make sure that the streaming domain has been mapped to the ingest domain before you call this operation to delete the mapping. For more information about how to map a streaming domain to an ingest domain, see [AddLiveDomainMapping](https://help.aliyun.com/document_detail/88782.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DeleteLiveDomainMappingRequest $request DeleteLiveDomainMappingRequest
     *
     * @return DeleteLiveDomainMappingResponse DeleteLiveDomainMappingResponse
     */
    public function deleteLiveDomainMapping($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveDomainMappingWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes the mapping between a main streaming domain and a sub-streaming domain.
     *  *
     * @description Before you call this operation, make sure that the mapping between the main streaming domain and the sub-streaming domain is created. For more information about how to call an operation to create the mapping between a main streaming domain and a sub-streaming domain, see [AddLiveDomainPlayMapping](https://help.aliyun.com/document_detail/173091.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveDomainPlayMappingRequest $request DeleteLiveDomainPlayMappingRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLiveDomainPlayMappingResponse DeleteLiveDomainPlayMappingResponse
     */
    public function deleteLiveDomainPlayMappingWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->playDomain)) {
            $query['PlayDomain'] = $request->playDomain;
        }
        if (!Utils::isUnset($request->pullDomain)) {
            $query['PullDomain'] = $request->pullDomain;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveDomainPlayMapping',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveDomainPlayMappingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes the mapping between a main streaming domain and a sub-streaming domain.
     *  *
     * @description Before you call this operation, make sure that the mapping between the main streaming domain and the sub-streaming domain is created. For more information about how to call an operation to create the mapping between a main streaming domain and a sub-streaming domain, see [AddLiveDomainPlayMapping](https://help.aliyun.com/document_detail/173091.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveDomainPlayMappingRequest $request DeleteLiveDomainPlayMappingRequest
     *
     * @return DeleteLiveDomainPlayMappingResponse DeleteLiveDomainPlayMappingResponse
     */
    public function deleteLiveDomainPlayMapping($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveDomainPlayMappingWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes the configuration of edge stream relay.
     *  *
     * @description You can call the DeleteLiveEdgeTransfer operation to delete the configuration of edge stream relay for a specific domain name. Ingested streams that are already relayed based on the configuration are not affected. The following table describes the scenarios in which edge stream relay takes effect or not.
     * |Scenario|Analysis|Result|
     * |---|---|---|
     * |1\\. You ingest a stream after you call the SetLiveEdgeTransfer operation to configure edge stream relay. Then, you call the DeleteLiveEdgeTransfer operation to delete the configuration.|The configuration of edge stream relay is available when you ingest the stream.|The ingested stream is not affected, and stream relay is not interrupted.|
     * |2\\. You call the DeleteLiveEdgeTransfer operation to delete the configuration of edge stream relay after you ingest a stream. Then, you disconnect and resume the ingested stream.|The configuration of edge stream relay is not available after you resume the ingested stream.|Edge stream relay does not take effect.|
     * |3\\. You call the DeleteLiveEdgeTransfer operation before you ingest a stream.|The configuration of edge stream relay is not available.|Edge stream relay does not take effect.|
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveEdgeTransferRequest $request DeleteLiveEdgeTransferRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLiveEdgeTransferResponse DeleteLiveEdgeTransferResponse
     */
    public function deleteLiveEdgeTransferWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveEdgeTransfer',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveEdgeTransferResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes the configuration of edge stream relay.
     *  *
     * @description You can call the DeleteLiveEdgeTransfer operation to delete the configuration of edge stream relay for a specific domain name. Ingested streams that are already relayed based on the configuration are not affected. The following table describes the scenarios in which edge stream relay takes effect or not.
     * |Scenario|Analysis|Result|
     * |---|---|---|
     * |1\\. You ingest a stream after you call the SetLiveEdgeTransfer operation to configure edge stream relay. Then, you call the DeleteLiveEdgeTransfer operation to delete the configuration.|The configuration of edge stream relay is available when you ingest the stream.|The ingested stream is not affected, and stream relay is not interrupted.|
     * |2\\. You call the DeleteLiveEdgeTransfer operation to delete the configuration of edge stream relay after you ingest a stream. Then, you disconnect and resume the ingested stream.|The configuration of edge stream relay is not available after you resume the ingested stream.|Edge stream relay does not take effect.|
     * |3\\. You call the DeleteLiveEdgeTransfer operation before you ingest a stream.|The configuration of edge stream relay is not available.|Edge stream relay does not take effect.|
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveEdgeTransferRequest $request DeleteLiveEdgeTransferRequest
     *
     * @return DeleteLiveEdgeTransferResponse DeleteLiveEdgeTransferResponse
     */
    public function deleteLiveEdgeTransfer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveEdgeTransferWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a configuration of triggered stream pulling.
     *  *
     * @description This operation is application to triggered stream pulling. You can call this operation to delete a configuration of triggered stream pulling. If you set the AppName parameter to ali_all_app, configurations of triggered stream pulling for all applications under the domain name are deleted.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveLazyPullStreamInfoConfigRequest $request DeleteLiveLazyPullStreamInfoConfigRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLiveLazyPullStreamInfoConfigResponse DeleteLiveLazyPullStreamInfoConfigResponse
     */
    public function deleteLiveLazyPullStreamInfoConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveLazyPullStreamInfoConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveLazyPullStreamInfoConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a configuration of triggered stream pulling.
     *  *
     * @description This operation is application to triggered stream pulling. You can call this operation to delete a configuration of triggered stream pulling. If you set the AppName parameter to ali_all_app, configurations of triggered stream pulling for all applications under the domain name are deleted.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveLazyPullStreamInfoConfigRequest $request DeleteLiveLazyPullStreamInfoConfigRequest
     *
     * @return DeleteLiveLazyPullStreamInfoConfigResponse DeleteLiveLazyPullStreamInfoConfigResponse
     */
    public function deleteLiveLazyPullStreamInfoConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveLazyPullStreamInfoConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an interactive messaging group.
     *  *
     * @description *   Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * *   After you delete an interactive messaging group, it is no longer available. Every user in the group is notified that the group is closed.
     * *   After you delete an interactive messaging group, messages in the group are retained for 30 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveMessageGroupRequest $request DeleteLiveMessageGroupRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLiveMessageGroupResponse DeleteLiveMessageGroupResponse
     */
    public function deleteLiveMessageGroupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->dataCenter)) {
            $query['DataCenter'] = $request->dataCenter;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->operatorId)) {
            $query['OperatorId'] = $request->operatorId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveMessageGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveMessageGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an interactive messaging group.
     *  *
     * @description *   Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * *   After you delete an interactive messaging group, it is no longer available. Every user in the group is notified that the group is closed.
     * *   After you delete an interactive messaging group, messages in the group are retained for 30 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveMessageGroupRequest $request DeleteLiveMessageGroupRequest
     *
     * @return DeleteLiveMessageGroupResponse DeleteLiveMessageGroupResponse
     */
    public function deleteLiveMessageGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveMessageGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a message that was sent to an interactive messaging group.
     *  *
     * @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveMessageGroupMessageRequest $request DeleteLiveMessageGroupMessageRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLiveMessageGroupMessageResponse DeleteLiveMessageGroupMessageResponse
     */
    public function deleteLiveMessageGroupMessageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->dataCenter)) {
            $query['DataCenter'] = $request->dataCenter;
        }
        if (!Utils::isUnset($request->deleterId)) {
            $query['DeleterId'] = $request->deleterId;
        }
        if (!Utils::isUnset($request->deleterInfo)) {
            $query['DeleterInfo'] = $request->deleterInfo;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->messageId)) {
            $query['MessageId'] = $request->messageId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveMessageGroupMessage',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveMessageGroupMessageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a message that was sent to an interactive messaging group.
     *  *
     * @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveMessageGroupMessageRequest $request DeleteLiveMessageGroupMessageRequest
     *
     * @return DeleteLiveMessageGroupMessageResponse DeleteLiveMessageGroupMessageResponse
     */
    public function deleteLiveMessageGroupMessage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveMessageGroupMessageWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a message that is sent to a user.
     *  *
     * @description ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DeleteLiveMessageUserMessageRequest $request DeleteLiveMessageUserMessageRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLiveMessageUserMessageResponse DeleteLiveMessageUserMessageResponse
     */
    public function deleteLiveMessageUserMessageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->dataCenter)) {
            $query['DataCenter'] = $request->dataCenter;
        }
        if (!Utils::isUnset($request->deleterId)) {
            $query['DeleterId'] = $request->deleterId;
        }
        if (!Utils::isUnset($request->deleterInfo)) {
            $query['DeleterInfo'] = $request->deleterInfo;
        }
        if (!Utils::isUnset($request->messageId)) {
            $query['MessageId'] = $request->messageId;
        }
        if (!Utils::isUnset($request->receiverId)) {
            $query['ReceiverId'] = $request->receiverId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveMessageUserMessage',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveMessageUserMessageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a message that is sent to a user.
     *  *
     * @description ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DeleteLiveMessageUserMessageRequest $request DeleteLiveMessageUserMessageRequest
     *
     * @return DeleteLiveMessageUserMessageResponse DeleteLiveMessageUserMessageResponse
     */
    public function deleteLiveMessageUserMessage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveMessageUserMessageWithOptions($request, $runtime);
    }

    /**
     * @description You can call this operation to delete a live stream encapsulation configuration. The deletion takes effect after you re-ingest the stream.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLivePackageConfigRequest $request DeleteLivePackageConfigRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLivePackageConfigResponse DeleteLivePackageConfigResponse
     */
    public function deleteLivePackageConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLivePackageConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLivePackageConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @description You can call this operation to delete a live stream encapsulation configuration. The deletion takes effect after you re-ingest the stream.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLivePackageConfigRequest $request DeleteLivePackageConfigRequest
     *
     * @return DeleteLivePackageConfigResponse DeleteLivePackageConfigResponse
     */
    public function deleteLivePackageConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLivePackageConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Unbinds a Global Accelerator (GA) instance from an acceleration circuit.
     *  *
     * @description After you unbind a GA instance from an acceleration circuit, your stream ingest and streaming are no longer accelerated by the GA instance. The GA instance still exists. If you want to release the GA instance, delete it in the GA console.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLivePrivateLineRequest $request DeleteLivePrivateLineRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLivePrivateLineResponse DeleteLivePrivateLineResponse
     */
    public function deleteLivePrivateLineWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->accelerationType)) {
            $query['AccelerationType'] = $request->accelerationType;
        }
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLivePrivateLine',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLivePrivateLineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Unbinds a Global Accelerator (GA) instance from an acceleration circuit.
     *  *
     * @description After you unbind a GA instance from an acceleration circuit, your stream ingest and streaming are no longer accelerated by the GA instance. The GA instance still exists. If you want to release the GA instance, delete it in the GA console.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLivePrivateLineRequest $request DeleteLivePrivateLineRequest
     *
     * @return DeleteLivePrivateLineResponse DeleteLivePrivateLineResponse
     */
    public function deleteLivePrivateLine($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLivePrivateLineWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a stream pulling configuration.
     *  *
     * @description This operation is applicable to regular stream pulling. You can call this operation to delete a configuration of regular stream pulling.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLivePullStreamInfoConfigRequest $request DeleteLivePullStreamInfoConfigRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLivePullStreamInfoConfigResponse DeleteLivePullStreamInfoConfigResponse
     */
    public function deleteLivePullStreamInfoConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLivePullStreamInfoConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLivePullStreamInfoConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a stream pulling configuration.
     *  *
     * @description This operation is applicable to regular stream pulling. You can call this operation to delete a configuration of regular stream pulling.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLivePullStreamInfoConfigRequest $request DeleteLivePullStreamInfoConfigRequest
     *
     * @return DeleteLivePullStreamInfoConfigResponse DeleteLivePullStreamInfoConfigResponse
     */
    public function deleteLivePullStreamInfoConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLivePullStreamInfoConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a pulled-stream relay task.
     *  *
     * @description *   You can call this operation to delete a pulled-stream relay task.
     * *   If you delete a running task, the task is immediately stopped and cannot be restarted.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLivePullToPushRequest $request DeleteLivePullToPushRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLivePullToPushResponse DeleteLivePullToPushResponse
     */
    public function deleteLivePullToPushWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLivePullToPush',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLivePullToPushResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a pulled-stream relay task.
     *  *
     * @description *   You can call this operation to delete a pulled-stream relay task.
     * *   If you delete a running task, the task is immediately stopped and cannot be restarted.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLivePullToPushRequest $request DeleteLivePullToPushRequest
     *
     * @return DeleteLivePullToPushResponse DeleteLivePullToPushResponse
     */
    public function deleteLivePullToPush($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLivePullToPushWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes the Logstore that is specified by a configuration of real-time log delivery.
     *  *
     * @description *   You can call this operation to delete the Logstore that is specified by a configuration of real-time log delivery. Make sure that all parameters meet the requirements when you call this operation.
     * *   You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) operation to query the Project, Logstore, and Region parameters.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveRealTimeLogLogstoreRequest $request DeleteLiveRealTimeLogLogstoreRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLiveRealTimeLogLogstoreResponse DeleteLiveRealTimeLogLogstoreResponse
     */
    public function deleteLiveRealTimeLogLogstoreWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveRealTimeLogLogstore',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveRealTimeLogLogstoreResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes the Logstore that is specified by a configuration of real-time log delivery.
     *  *
     * @description *   You can call this operation to delete the Logstore that is specified by a configuration of real-time log delivery. Make sure that all parameters meet the requirements when you call this operation.
     * *   You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) operation to query the Project, Logstore, and Region parameters.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveRealTimeLogLogstoreRequest $request DeleteLiveRealTimeLogLogstoreRequest
     *
     * @return DeleteLiveRealTimeLogLogstoreResponse DeleteLiveRealTimeLogLogstoreResponse
     */
    public function deleteLiveRealTimeLogLogstore($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveRealTimeLogLogstoreWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes the configurations of real-time log delivery for one or more domain names.
     *  *
     * @description *
     * *   This operation is applicable to only streaming domains. If you want to configure real-tome log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
     * *   You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) to query the Project, Logstore, and Region parameters.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveRealtimeLogDeliveryRequest $request DeleteLiveRealtimeLogDeliveryRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLiveRealtimeLogDeliveryResponse DeleteLiveRealtimeLogDeliveryResponse
     */
    public function deleteLiveRealtimeLogDeliveryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveRealtimeLogDelivery',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveRealtimeLogDeliveryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes the configurations of real-time log delivery for one or more domain names.
     *  *
     * @description *
     * *   This operation is applicable to only streaming domains. If you want to configure real-tome log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
     * *   You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) to query the Project, Logstore, and Region parameters.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveRealtimeLogDeliveryRequest $request DeleteLiveRealtimeLogDeliveryRequest
     *
     * @return DeleteLiveRealtimeLogDeliveryResponse DeleteLiveRealtimeLogDeliveryResponse
     */
    public function deleteLiveRealtimeLogDelivery($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveRealtimeLogDeliveryWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes the configuration of callbacks for live stream recording under a domain name.
     *  *
     * @description Obtain the main streaming domain, and then call this operation to delete the configuration of callbacks for live stream recording under the main streaming domain.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveRecordNotifyConfigRequest $request DeleteLiveRecordNotifyConfigRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLiveRecordNotifyConfigResponse DeleteLiveRecordNotifyConfigResponse
     */
    public function deleteLiveRecordNotifyConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveRecordNotifyConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveRecordNotifyConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes the configuration of callbacks for live stream recording under a domain name.
     *  *
     * @description Obtain the main streaming domain, and then call this operation to delete the configuration of callbacks for live stream recording under the main streaming domain.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveRecordNotifyConfigRequest $request DeleteLiveRecordNotifyConfigRequest
     *
     * @return DeleteLiveRecordNotifyConfigResponse DeleteLiveRecordNotifyConfigResponse
     */
    public function deleteLiveRecordNotifyConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveRecordNotifyConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a Live-to-VOD configuration.
     *  *
     * @description Obtain the main streaming domain, and then call this operation to delete a Live-to-VOD configuration.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveRecordVodConfigRequest $request DeleteLiveRecordVodConfigRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLiveRecordVodConfigResponse DeleteLiveRecordVodConfigResponse
     */
    public function deleteLiveRecordVodConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveRecordVodConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveRecordVodConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a Live-to-VOD configuration.
     *  *
     * @description Obtain the main streaming domain, and then call this operation to delete a Live-to-VOD configuration.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveRecordVodConfigRequest $request DeleteLiveRecordVodConfigRequest
     *
     * @return DeleteLiveRecordVodConfigResponse DeleteLiveRecordVodConfigResponse
     */
    public function deleteLiveRecordVodConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveRecordVodConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a video moderation configuration.
     *  *
     * @description *   Obtain the main streaming domain, and then call this operation to delete a video moderation configuration.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveSnapshotDetectPornConfigRequest $request DeleteLiveSnapshotDetectPornConfigRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLiveSnapshotDetectPornConfigResponse DeleteLiveSnapshotDetectPornConfigResponse
     */
    public function deleteLiveSnapshotDetectPornConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveSnapshotDetectPornConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveSnapshotDetectPornConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a video moderation configuration.
     *  *
     * @description *   Obtain the main streaming domain, and then call this operation to delete a video moderation configuration.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveSnapshotDetectPornConfigRequest $request DeleteLiveSnapshotDetectPornConfigRequest
     *
     * @return DeleteLiveSnapshotDetectPornConfigResponse DeleteLiveSnapshotDetectPornConfigResponse
     */
    public function deleteLiveSnapshotDetectPornConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveSnapshotDetectPornConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes the configuration of snapshot callbacks.
     *  *
     * @description You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveSnapshotNotifyConfigRequest $request DeleteLiveSnapshotNotifyConfigRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLiveSnapshotNotifyConfigResponse DeleteLiveSnapshotNotifyConfigResponse
     */
    public function deleteLiveSnapshotNotifyConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveSnapshotNotifyConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveSnapshotNotifyConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes the configuration of snapshot callbacks.
     *  *
     * @description You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveSnapshotNotifyConfigRequest $request DeleteLiveSnapshotNotifyConfigRequest
     *
     * @return DeleteLiveSnapshotNotifyConfigResponse DeleteLiveSnapshotNotifyConfigResponse
     */
    public function deleteLiveSnapshotNotifyConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveSnapshotNotifyConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes domain configurations in the canary release environment.
     *  *
     * @description ## [](#)Usage notes
     * Before you call this operation to delete a domain configuration in the canary release environment, you can call the [DescribeLiveDomainStagingConfig](https://help.aliyun.com/document_detail/297374.html) operation to obtain the configuration ID.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DeleteLiveSpecificStagingConfigRequest $request DeleteLiveSpecificStagingConfigRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLiveSpecificStagingConfigResponse DeleteLiveSpecificStagingConfigResponse
     */
    public function deleteLiveSpecificStagingConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->configId)) {
            $query['ConfigId'] = $request->configId;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveSpecificStagingConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveSpecificStagingConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes domain configurations in the canary release environment.
     *  *
     * @description ## [](#)Usage notes
     * Before you call this operation to delete a domain configuration in the canary release environment, you can call the [DescribeLiveDomainStagingConfig](https://help.aliyun.com/document_detail/297374.html) operation to obtain the configuration ID.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DeleteLiveSpecificStagingConfigRequest $request DeleteLiveSpecificStagingConfigRequest
     *
     * @return DeleteLiveSpecificStagingConfigResponse DeleteLiveSpecificStagingConfigResponse
     */
    public function deleteLiveSpecificStagingConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveSpecificStagingConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a configuration of stream-level region blocking.
     *  *
     * @description You can call this operation to delete a configuration of stream-level region blocking.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveStreamBlockRequest $request DeleteLiveStreamBlockRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLiveStreamBlockResponse DeleteLiveStreamBlockResponse
     */
    public function deleteLiveStreamBlockWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveStreamBlock',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveStreamBlockResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a configuration of stream-level region blocking.
     *  *
     * @description You can call this operation to delete a configuration of stream-level region blocking.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveStreamBlockRequest $request DeleteLiveStreamBlockRequest
     *
     * @return DeleteLiveStreamBlockResponse DeleteLiveStreamBlockResponse
     */
    public function deleteLiveStreamBlock($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveStreamBlockWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an active mixed stream.
     *  *
     * @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveStreamMergeRequest $request DeleteLiveStreamMergeRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLiveStreamMergeResponse DeleteLiveStreamMergeResponse
     */
    public function deleteLiveStreamMergeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveStreamMerge',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveStreamMergeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an active mixed stream.
     *  *
     * @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveStreamMergeRequest $request DeleteLiveStreamMergeRequest
     *
     * @return DeleteLiveStreamMergeResponse DeleteLiveStreamMergeResponse
     */
    public function deleteLiveStreamMerge($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveStreamMergeWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a monitoring session.
     *  *
     * @description Before you call this operation, obtain the monitoring session ID from the response parameter **MonitorId** of the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation.
     * >  You cannot delete a monitoring session that is in the started state. If you try to delete it, a 400 error is reported.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveStreamMonitorRequest $request DeleteLiveStreamMonitorRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLiveStreamMonitorResponse DeleteLiveStreamMonitorResponse
     */
    public function deleteLiveStreamMonitorWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->monitorId)) {
            $query['MonitorId'] = $request->monitorId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveStreamMonitor',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveStreamMonitorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a monitoring session.
     *  *
     * @description Before you call this operation, obtain the monitoring session ID from the response parameter **MonitorId** of the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation.
     * >  You cannot delete a monitoring session that is in the started state. If you try to delete it, a 400 error is reported.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveStreamMonitorRequest $request DeleteLiveStreamMonitorRequest
     *
     * @return DeleteLiveStreamMonitorResponse DeleteLiveStreamMonitorResponse
     */
    public function deleteLiveStreamMonitor($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveStreamMonitorWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes live stream recordings.
     *  *
     * @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveStreamRecordIndexFilesRequest $request DeleteLiveStreamRecordIndexFilesRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLiveStreamRecordIndexFilesResponse DeleteLiveStreamRecordIndexFilesResponse
     */
    public function deleteLiveStreamRecordIndexFilesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->recordId)) {
            $query['RecordId'] = $request->recordId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->removeFile)) {
            $query['RemoveFile'] = $request->removeFile;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveStreamRecordIndexFiles',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveStreamRecordIndexFilesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes live stream recordings.
     *  *
     * @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveStreamRecordIndexFilesRequest $request DeleteLiveStreamRecordIndexFilesRequest
     *
     * @return DeleteLiveStreamRecordIndexFilesResponse DeleteLiveStreamRecordIndexFilesResponse
     */
    public function deleteLiveStreamRecordIndexFiles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveStreamRecordIndexFilesWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a transcoding configuration.
     *  *
     * @description Standard transcoding templates, Narrowband HD™ transcoding templates, and custom transcoding templates are supported for this operation.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveStreamTranscodeRequest $request DeleteLiveStreamTranscodeRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLiveStreamTranscodeResponse DeleteLiveStreamTranscodeResponse
     */
    public function deleteLiveStreamTranscodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->app)) {
            $query['App'] = $request->app;
        }
        if (!Utils::isUnset($request->domain)) {
            $query['Domain'] = $request->domain;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        if (!Utils::isUnset($request->template)) {
            $query['Template'] = $request->template;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveStreamTranscode',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveStreamTranscodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a transcoding configuration.
     *  *
     * @description Standard transcoding templates, Narrowband HD™ transcoding templates, and custom transcoding templates are supported for this operation.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveStreamTranscodeRequest $request DeleteLiveStreamTranscodeRequest
     *
     * @return DeleteLiveStreamTranscodeResponse DeleteLiveStreamTranscodeResponse
     */
    public function deleteLiveStreamTranscode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveStreamTranscodeWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a specified watermark template.
     *  *
     * @description This interface supports deleting the watermark template with the specified TemplateId for live streaming.
     * ## QPS Limitation
     *  The per-user QPS limit for this interface is 60 times/second. Exceeding this limit will result in API throttling, which may impact your business operations. Please use it reasonably. For more information, please refer to [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DeleteLiveStreamWatermarkRequest $request DeleteLiveStreamWatermarkRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLiveStreamWatermarkResponse DeleteLiveStreamWatermarkResponse
     */
    public function deleteLiveStreamWatermarkWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->templateId)) {
            $query['TemplateId'] = $request->templateId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveStreamWatermark',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveStreamWatermarkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a specified watermark template.
     *  *
     * @description This interface supports deleting the watermark template with the specified TemplateId for live streaming.
     * ## QPS Limitation
     *  The per-user QPS limit for this interface is 60 times/second. Exceeding this limit will result in API throttling, which may impact your business operations. Please use it reasonably. For more information, please refer to [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DeleteLiveStreamWatermarkRequest $request DeleteLiveStreamWatermarkRequest
     *
     * @return DeleteLiveStreamWatermarkResponse DeleteLiveStreamWatermarkResponse
     */
    public function deleteLiveStreamWatermark($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveStreamWatermarkWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a watermark rule.
     *  *
     * @description You can call this operation to delete a watermark rule with a specified ID.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveStreamWatermarkRuleRequest $request DeleteLiveStreamWatermarkRuleRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLiveStreamWatermarkRuleResponse DeleteLiveStreamWatermarkRuleResponse
     */
    public function deleteLiveStreamWatermarkRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->app)) {
            $query['App'] = $request->app;
        }
        if (!Utils::isUnset($request->domain)) {
            $query['Domain'] = $request->domain;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->ruleId)) {
            $query['RuleId'] = $request->ruleId;
        }
        if (!Utils::isUnset($request->stream)) {
            $query['Stream'] = $request->stream;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveStreamWatermarkRule',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveStreamWatermarkRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a watermark rule.
     *  *
     * @description You can call this operation to delete a watermark rule with a specified ID.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveStreamWatermarkRuleRequest $request DeleteLiveStreamWatermarkRuleRequest
     *
     * @return DeleteLiveStreamWatermarkRuleResponse DeleteLiveStreamWatermarkRuleResponse
     */
    public function deleteLiveStreamWatermarkRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveStreamWatermarkRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes the callback configuration for stream ingest under an ingest domain.
     *  *
     * @description Obtain the ingest domain, and then call this operation to delete the callback configuration for stream ingest under the ingest domain.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveStreamsNotifyUrlConfigRequest $request DeleteLiveStreamsNotifyUrlConfigRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLiveStreamsNotifyUrlConfigResponse DeleteLiveStreamsNotifyUrlConfigResponse
     */
    public function deleteLiveStreamsNotifyUrlConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveStreamsNotifyUrlConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveStreamsNotifyUrlConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes the callback configuration for stream ingest under an ingest domain.
     *  *
     * @description Obtain the ingest domain, and then call this operation to delete the callback configuration for stream ingest under the ingest domain.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteLiveStreamsNotifyUrlConfigRequest $request DeleteLiveStreamsNotifyUrlConfigRequest
     *
     * @return DeleteLiveStreamsNotifyUrlConfigResponse DeleteLiveStreamsNotifyUrlConfigResponse
     */
    public function deleteLiveStreamsNotifyUrlConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveStreamsNotifyUrlConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an interactive messaging application.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DeleteMessageAppRequest $request DeleteMessageAppRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteMessageAppResponse DeleteMessageAppResponse
     */
    public function deleteMessageAppWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->appId)) {
            $body['AppId'] = $request->appId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'DeleteMessageApp',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteMessageAppResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an interactive messaging application.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DeleteMessageAppRequest $request DeleteMessageAppRequest
     *
     * @return DeleteMessageAppResponse DeleteMessageAppResponse
     */
    public function deleteMessageApp($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteMessageAppWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a stream mixing task.
     *  *
     * @description You can call the [CreateMixStream](https://help.aliyun.com/document_detail/2848087.html) operation to create a stream mixing task and then call this operation to delete the stream mixing task. If you no longer need a mixed stream, be sure to delete it. Mixed streams that are not deleted are continuously ingested.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteMixStreamRequest $request DeleteMixStreamRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteMixStreamResponse DeleteMixStreamResponse
     */
    public function deleteMixStreamWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->mixStreamId)) {
            $query['MixStreamId'] = $request->mixStreamId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteMixStream',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteMixStreamResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a stream mixing task.
     *  *
     * @description You can call the [CreateMixStream](https://help.aliyun.com/document_detail/2848087.html) operation to create a stream mixing task and then call this operation to delete the stream mixing task. If you no longer need a mixed stream, be sure to delete it. Mixed streams that are not deleted are continuously ingested.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteMixStreamRequest $request DeleteMixStreamRequest
     *
     * @return DeleteMixStreamResponse DeleteMixStreamResponse
     */
    public function deleteMixStream($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteMixStreamWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an episode list.
     *  *
     * @description Before you call this operation to delete an episode list, make sure that you have called the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to create the episode list.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeletePlaylistRequest $request DeletePlaylistRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return DeletePlaylistResponse DeletePlaylistResponse
     */
    public function deletePlaylistWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->programId)) {
            $query['ProgramId'] = $request->programId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeletePlaylist',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeletePlaylistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an episode list.
     *  *
     * @description Before you call this operation to delete an episode list, make sure that you have called the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to create the episode list.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeletePlaylistRequest $request DeletePlaylistRequest
     *
     * @return DeletePlaylistResponse DeletePlaylistResponse
     */
    public function deletePlaylist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deletePlaylistWithOptions($request, $runtime);
    }

    /**
     * @summary Removes episodes from an episode list.
     *  *
     * @description Before you call this operation to remove an episode, make sure that you have called the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add the episode.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeletePlaylistItemsRequest $request DeletePlaylistItemsRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DeletePlaylistItemsResponse DeletePlaylistItemsResponse
     */
    public function deletePlaylistItemsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->programId)) {
            $query['ProgramId'] = $request->programId;
        }
        if (!Utils::isUnset($request->programItemIds)) {
            $query['ProgramItemIds'] = $request->programItemIds;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeletePlaylistItems',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeletePlaylistItemsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Removes episodes from an episode list.
     *  *
     * @description Before you call this operation to remove an episode, make sure that you have called the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add the episode.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeletePlaylistItemsRequest $request DeletePlaylistItemsRequest
     *
     * @return DeletePlaylistItemsResponse DeletePlaylistItemsResponse
     */
    public function deletePlaylistItems($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deletePlaylistItemsWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a live subtitle task.
     *  *
     * @description You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteRtcAsrTaskRequest $request DeleteRtcAsrTaskRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteRtcAsrTaskResponse DeleteRtcAsrTaskResponse
     */
    public function deleteRtcAsrTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteRtcAsrTask',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteRtcAsrTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a live subtitle task.
     *  *
     * @description You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteRtcAsrTaskRequest $request DeleteRtcAsrTaskRequest
     *
     * @return DeleteRtcAsrTaskResponse DeleteRtcAsrTaskResponse
     */
    public function deleteRtcAsrTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteRtcAsrTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a subscription to mixed-stream relay events.
     *  *
     * @description *   You can call this operation to delete a subscription to mixed-stream relay events.
     * *   Before you call this operation, make sure that you have called the CreateRtcMPUEventSub operation to create the subscription.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DeleteRtcMPUEventSubRequest $request DeleteRtcMPUEventSubRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteRtcMPUEventSubResponse DeleteRtcMPUEventSubResponse
     */
    public function deleteRtcMPUEventSubWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteRtcMPUEventSub',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteRtcMPUEventSubResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a subscription to mixed-stream relay events.
     *  *
     * @description *   You can call this operation to delete a subscription to mixed-stream relay events.
     * *   Before you call this operation, make sure that you have called the CreateRtcMPUEventSub operation to create the subscription.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DeleteRtcMPUEventSubRequest $request DeleteRtcMPUEventSubRequest
     *
     * @return DeleteRtcMPUEventSubResponse DeleteRtcMPUEventSubResponse
     */
    public function deleteRtcMPUEventSub($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteRtcMPUEventSubWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes the configuration of authentication for snapshot callbacks.
     *  *
     * @description You can call this operation to delete the configuration of authentication for snapshot callbacks for a main streaming domain. For an ongoing live stream, the deletion takes effect after you re-ingest the stream. Snapshot callbacks for the stream are no longer authenticated.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteSnapshotCallbackAuthRequest $request DeleteSnapshotCallbackAuthRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteSnapshotCallbackAuthResponse DeleteSnapshotCallbackAuthResponse
     */
    public function deleteSnapshotCallbackAuthWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteSnapshotCallbackAuth',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteSnapshotCallbackAuthResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes the configuration of authentication for snapshot callbacks.
     *  *
     * @description You can call this operation to delete the configuration of authentication for snapshot callbacks for a main streaming domain. For an ongoing live stream, the deletion takes effect after you re-ingest the stream. Snapshot callbacks for the stream are no longer authenticated.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteSnapshotCallbackAuthRequest $request DeleteSnapshotCallbackAuthRequest
     *
     * @return DeleteSnapshotCallbackAuthResponse DeleteSnapshotCallbackAuthResponse
     */
    public function deleteSnapshotCallbackAuth($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteSnapshotCallbackAuthWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes snapshots.
     *  *
     * @description You can delete only snapshots that were captured in the last year.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteSnapshotFilesRequest $request DeleteSnapshotFilesRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteSnapshotFilesResponse DeleteSnapshotFilesResponse
     */
    public function deleteSnapshotFilesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->createTimestampList)) {
            $query['CreateTimestampList'] = $request->createTimestampList;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->removeFile)) {
            $query['RemoveFile'] = $request->removeFile;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteSnapshotFiles',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteSnapshotFilesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes snapshots.
     *  *
     * @description You can delete only snapshots that were captured in the last year.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteSnapshotFilesRequest $request DeleteSnapshotFilesRequest
     *
     * @return DeleteSnapshotFilesResponse DeleteSnapshotFilesResponse
     */
    public function deleteSnapshotFiles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteSnapshotFilesWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a layout in a virtual studio.
     *  *
     * @description You can call this operation to delete a layout in a virtual studio. You can delete only one layout in a call.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteStudioLayoutRequest $request DeleteStudioLayoutRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteStudioLayoutResponse DeleteStudioLayoutResponse
     */
    public function deleteStudioLayoutWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->layoutId)) {
            $query['LayoutId'] = $request->layoutId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteStudioLayout',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteStudioLayoutResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a layout in a virtual studio.
     *  *
     * @description You can call this operation to delete a layout in a virtual studio. You can delete only one layout in a call.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DeleteStudioLayoutRequest $request DeleteStudioLayoutRequest
     *
     * @return DeleteStudioLayoutResponse DeleteStudioLayoutResponse
     */
    public function deleteStudioLayout($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteStudioLayoutWithOptions($request, $runtime);
    }

    /**
     * @summary Queries scheduled tasks that are used to start and stop playing an episode list at specified points in time.
     *  *
     * @description You can call this operation to query scheduled tasks that are used to start and stop playing an episode list at specified points in time. Make sure that the parameter settings meet the requirements.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeAutoShowListTasksRequest $request DescribeAutoShowListTasksRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAutoShowListTasksResponse DescribeAutoShowListTasksResponse
     */
    public function describeAutoShowListTasksWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeAutoShowListTasks',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAutoShowListTasksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries scheduled tasks that are used to start and stop playing an episode list at specified points in time.
     *  *
     * @description You can call this operation to query scheduled tasks that are used to start and stop playing an episode list at specified points in time. Make sure that the parameter settings meet the requirements.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeAutoShowListTasksRequest $request DescribeAutoShowListTasksRequest
     *
     * @return DescribeAutoShowListTasksResponse DescribeAutoShowListTasksResponse
     */
    public function describeAutoShowListTasks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAutoShowListTasksWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the channels of a production studio.
     *  *
     * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to query the channels of the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeCasterChannelsRequest $request DescribeCasterChannelsRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCasterChannelsResponse DescribeCasterChannelsResponse
     */
    public function describeCasterChannelsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCasterChannels',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCasterChannelsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the channels of a production studio.
     *  *
     * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to query the channels of the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeCasterChannelsRequest $request DescribeCasterChannelsRequest
     *
     * @return DescribeCasterChannelsResponse DescribeCasterChannelsResponse
     */
    public function describeCasterChannels($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCasterChannelsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the components of a production studio.
     *  *
     * @description You can call the [AddCasterComponent](https://help.aliyun.com/document_detail/2848030.html) operation to add components to a production studio and then call this operation to query the components of the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeCasterComponentsRequest $request DescribeCasterComponentsRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCasterComponentsResponse DescribeCasterComponentsResponse
     */
    public function describeCasterComponentsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->componentId)) {
            $query['ComponentId'] = $request->componentId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCasterComponents',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCasterComponentsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the components of a production studio.
     *  *
     * @description You can call the [AddCasterComponent](https://help.aliyun.com/document_detail/2848030.html) operation to add components to a production studio and then call this operation to query the components of the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeCasterComponentsRequest $request DescribeCasterComponentsRequest
     *
     * @return DescribeCasterComponentsResponse DescribeCasterComponentsResponse
     */
    public function describeCasterComponents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCasterComponentsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of a production studio.
     *  *
     * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to query the configurations of the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeCasterConfigRequest $request DescribeCasterConfigRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCasterConfigResponse DescribeCasterConfigResponse
     */
    public function describeCasterConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCasterConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCasterConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of a production studio.
     *  *
     * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to query the configurations of the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeCasterConfigRequest $request DescribeCasterConfigRequest
     *
     * @return DescribeCasterConfigResponse DescribeCasterConfigResponse
     */
    public function describeCasterConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCasterConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a specified layout or all layouts of a production studio.
     *  *
     * @description You can call this operation to query layouts of a production studio. If no layout ID is specified, the operation returns all layouts of the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeCasterLayoutsRequest $request DescribeCasterLayoutsRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCasterLayoutsResponse DescribeCasterLayoutsResponse
     */
    public function describeCasterLayoutsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->layoutId)) {
            $query['LayoutId'] = $request->layoutId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCasterLayouts',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCasterLayoutsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a specified layout or all layouts of a production studio.
     *  *
     * @description You can call this operation to query layouts of a production studio. If no layout ID is specified, the operation returns all layouts of the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeCasterLayoutsRequest $request DescribeCasterLayoutsRequest
     *
     * @return DescribeCasterLayoutsResponse DescribeCasterLayoutsResponse
     */
    public function describeCasterLayouts($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCasterLayoutsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about the episode list for carousel playback in a production studio.
     *  *
     * @description You can call this operation to query episodes in the episode list for carousel playback. The supported types of episodes include video resource and component.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeCasterProgramRequest $request DescribeCasterProgramRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCasterProgramResponse DescribeCasterProgramResponse
     */
    public function describeCasterProgramWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->episodeId)) {
            $query['EpisodeId'] = $request->episodeId;
        }
        if (!Utils::isUnset($request->episodeType)) {
            $query['EpisodeType'] = $request->episodeType;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNum)) {
            $query['PageNum'] = $request->pageNum;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCasterProgram',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCasterProgramResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about the episode list for carousel playback in a production studio.
     *  *
     * @description You can call this operation to query episodes in the episode list for carousel playback. The supported types of episodes include video resource and component.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeCasterProgramRequest $request DescribeCasterProgramRequest
     *
     * @return DescribeCasterProgramResponse DescribeCasterProgramResponse
     */
    public function describeCasterProgram($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCasterProgramWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the audio configurations of a scene.
     *  *
     * @description ## [](#)Usage notes
     * You can call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio and then call this operation to query the audio configurations of a scene in the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeCasterSceneAudioRequest $request DescribeCasterSceneAudioRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCasterSceneAudioResponse DescribeCasterSceneAudioResponse
     */
    public function describeCasterSceneAudioWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->sceneId)) {
            $query['SceneId'] = $request->sceneId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCasterSceneAudio',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCasterSceneAudioResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the audio configurations of a scene.
     *  *
     * @description ## [](#)Usage notes
     * You can call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio and then call this operation to query the audio configurations of a scene in the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeCasterSceneAudioRequest $request DescribeCasterSceneAudioRequest
     *
     * @return DescribeCasterSceneAudioResponse DescribeCasterSceneAudioResponse
     */
    public function describeCasterSceneAudio($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCasterSceneAudioWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the scenes of a production studio.
     *  *
     * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio and then call this operation to query the scenes of the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeCasterScenesRequest $request DescribeCasterScenesRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCasterScenesResponse DescribeCasterScenesResponse
     */
    public function describeCasterScenesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->sceneId)) {
            $query['SceneId'] = $request->sceneId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCasterScenes',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCasterScenesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the scenes of a production studio.
     *  *
     * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio and then call this operation to query the scenes of the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeCasterScenesRequest $request DescribeCasterScenesRequest
     *
     * @return DescribeCasterScenesResponse DescribeCasterScenesResponse
     */
    public function describeCasterScenes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCasterScenesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the streaming URLs of a production studio.
     *  *
     * @description You must create a production studio before calling this operation to query the information.
     * ## QPS limit
     * A single user can perform a maximum of 15 queries per second (QPS). Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
     *  *
     * @param DescribeCasterStreamUrlRequest $request DescribeCasterStreamUrlRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCasterStreamUrlResponse DescribeCasterStreamUrlResponse
     */
    public function describeCasterStreamUrlWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCasterStreamUrl',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCasterStreamUrlResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the streaming URLs of a production studio.
     *  *
     * @description You must create a production studio before calling this operation to query the information.
     * ## QPS limit
     * A single user can perform a maximum of 15 queries per second (QPS). Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
     *  *
     * @param DescribeCasterStreamUrlRequest $request DescribeCasterStreamUrlRequest
     *
     * @return DescribeCasterStreamUrlResponse DescribeCasterStreamUrlResponse
     */
    public function describeCasterStreamUrl($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCasterStreamUrlWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the input sources of a production studio.
     *  *
     * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to query the input sources of the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeCasterVideoResourcesRequest $request DescribeCasterVideoResourcesRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCasterVideoResourcesResponse DescribeCasterVideoResourcesResponse
     */
    public function describeCasterVideoResourcesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCasterVideoResources',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCasterVideoResourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the input sources of a production studio.
     *  *
     * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to query the input sources of the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeCasterVideoResourcesRequest $request DescribeCasterVideoResourcesRequest
     *
     * @return DescribeCasterVideoResourcesResponse DescribeCasterVideoResourcesResponse
     */
    public function describeCasterVideoResources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCasterVideoResourcesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the list of production studios.
     *  *
     * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848012.html) operation to create a production studio and then call this operation to query the production studio list. The status of a production studio can be idle or streaming.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeCastersRequest $request DescribeCastersRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCastersResponse DescribeCastersResponse
     */
    public function describeCastersWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->casterName)) {
            $query['CasterName'] = $request->casterName;
        }
        if (!Utils::isUnset($request->chargeType)) {
            $query['ChargeType'] = $request->chargeType;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->normType)) {
            $query['NormType'] = $request->normType;
        }
        if (!Utils::isUnset($request->orderByModifyAsc)) {
            $query['OrderByModifyAsc'] = $request->orderByModifyAsc;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNum)) {
            $query['PageNum'] = $request->pageNum;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCasters',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCastersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the list of production studios.
     *  *
     * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848012.html) operation to create a production studio and then call this operation to query the production studio list. The status of a production studio can be idle or streaming.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeCastersRequest $request DescribeCastersRequest
     *
     * @return DescribeCastersResponse DescribeCastersResponse
     */
    public function describeCasters($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCastersWithOptions($request, $runtime);
    }

    /**
     * @summary Queries online users in a channel.
     *  *
     * @description You can call this operation to query online users in a channel. The returned result does not include details about the users.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeChannelParticipantsRequest $request DescribeChannelParticipantsRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeChannelParticipantsResponse DescribeChannelParticipantsResponse
     */
    public function describeChannelParticipantsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->channelId)) {
            $query['ChannelId'] = $request->channelId;
        }
        if (!Utils::isUnset($request->order)) {
            $query['Order'] = $request->order;
        }
        if (!Utils::isUnset($request->pageNum)) {
            $query['PageNum'] = $request->pageNum;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeChannelParticipants',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeChannelParticipantsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries online users in a channel.
     *  *
     * @description You can call this operation to query online users in a channel. The returned result does not include details about the users.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeChannelParticipantsRequest $request DescribeChannelParticipantsRequest
     *
     * @return DescribeChannelParticipantsResponse DescribeChannelParticipantsResponse
     */
    public function describeChannelParticipants($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeChannelParticipantsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of online users in a channel.
     *  *
     * @description You can call this operation to query information about online users in a channel, such as the total number of users during live streaming.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeChannelUsersRequest $request DescribeChannelUsersRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeChannelUsersResponse DescribeChannelUsersResponse
     */
    public function describeChannelUsersWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->channelId)) {
            $query['ChannelId'] = $request->channelId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeChannelUsers',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeChannelUsersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of online users in a channel.
     *  *
     * @description You can call this operation to query information about online users in a channel, such as the total number of users during live streaming.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeChannelUsersRequest $request DescribeChannelUsersRequest
     *
     * @return DescribeChannelUsersResponse DescribeChannelUsersResponse
     */
    public function describeChannelUsers($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeChannelUsersWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the resource usage data of specific domain names in a specified billable region.
     *  *
     * @description * You can query the resource usage data of up to 100 domain names at a time. Separate multiple domain names with commas (,). If you do not specify the DomainName parameter, the resource usage data of all domain names within your Alibaba Cloud account is returned.
     * * The resource usage data includes network traffic that is measured in bytes, bandwidth that is measured in bit/s, and the number of requests.
     * * If you do not specify the Interval parameter, you can query the resource usage data in the last 12 months that spans a period of up to 31 days per call. If you specify a time range of 1 to 3 days in a call, the time interval between the entries that are returned is 1 hour. If you specify a time range of more than 3 days in a call, the time interval between the entries that are returned is 1 day.
     * * The following table describes the maximum time range per query, the time period within which historical data is available, and the data delay if you specify the Interval parameter.
     * |Time granularity|Maximum time range per query|Historical data available|Data delay|
     * |---|---|---|---|
     * |5 minutes|3 days|93 days|15 minutes|
     * |1 hour|31 days|186 days|4 hours|
     * |1 day|90 days|366 days|04:00 on the next day|
     * ## QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeDomainUsageDataRequest $request DescribeDomainUsageDataRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeDomainUsageDataResponse DescribeDomainUsageDataResponse
     */
    public function describeDomainUsageDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->area)) {
            $query['Area'] = $request->area;
        }
        if (!Utils::isUnset($request->dataProtocol)) {
            $query['DataProtocol'] = $request->dataProtocol;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->field)) {
            $query['Field'] = $request->field;
        }
        if (!Utils::isUnset($request->interval)) {
            $query['Interval'] = $request->interval;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDomainUsageData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDomainUsageDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the resource usage data of specific domain names in a specified billable region.
     *  *
     * @description * You can query the resource usage data of up to 100 domain names at a time. Separate multiple domain names with commas (,). If you do not specify the DomainName parameter, the resource usage data of all domain names within your Alibaba Cloud account is returned.
     * * The resource usage data includes network traffic that is measured in bytes, bandwidth that is measured in bit/s, and the number of requests.
     * * If you do not specify the Interval parameter, you can query the resource usage data in the last 12 months that spans a period of up to 31 days per call. If you specify a time range of 1 to 3 days in a call, the time interval between the entries that are returned is 1 hour. If you specify a time range of more than 3 days in a call, the time interval between the entries that are returned is 1 day.
     * * The following table describes the maximum time range per query, the time period within which historical data is available, and the data delay if you specify the Interval parameter.
     * |Time granularity|Maximum time range per query|Historical data available|Data delay|
     * |---|---|---|---|
     * |5 minutes|3 days|93 days|15 minutes|
     * |1 hour|31 days|186 days|4 hours|
     * |1 day|90 days|366 days|04:00 on the next day|
     * ## QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeDomainUsageDataRequest $request DescribeDomainUsageDataRequest
     *
     * @return DescribeDomainUsageDataResponse DescribeDomainUsageDataResponse
     */
    public function describeDomainUsageData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDomainUsageDataWithOptions($request, $runtime);
    }

    /**
     * @summary Obtains domain integrity.
     *  *
     * @description You can call this operation to obtain domain integrity.
     * ## [](#qps-)QPS limits
     * You can call this API operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeDomainWithIntegrityRequest $request DescribeDomainWithIntegrityRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeDomainWithIntegrityResponse DescribeDomainWithIntegrityResponse
     */
    public function describeDomainWithIntegrityWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDomainWithIntegrity',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDomainWithIntegrityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Obtains domain integrity.
     *  *
     * @description You can call this operation to obtain domain integrity.
     * ## [](#qps-)QPS limits
     * You can call this API operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeDomainWithIntegrityRequest $request DescribeDomainWithIntegrityRequest
     *
     * @return DescribeDomainWithIntegrityResponse DescribeDomainWithIntegrityResponse
     */
    public function describeDomainWithIntegrity($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDomainWithIntegrityWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about HTTP Live Streaming (HLS) streams, such as the number of online users and bandwidth.
     *  *
     * @description You can call this operation to query the information about HTTP Live Streaming (HLS) streams, such as the number of online users and bandwidth.
     * *   The number of online users for an HLS stream is counted based on the universally unique identifiers (UUIDs) of users that are placed after the M3U8 URL.
     * *   You can query the data of up to 100 domain names in a single request. If the DomainName parameter is left empty, the data of all domain names under the account is queried.
     *  *
     * @param DescribeHlsLiveStreamRealTimeBpsDataRequest $request DescribeHlsLiveStreamRealTimeBpsDataRequest
     * @param RuntimeOptions                              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeHlsLiveStreamRealTimeBpsDataResponse DescribeHlsLiveStreamRealTimeBpsDataResponse
     */
    public function describeHlsLiveStreamRealTimeBpsDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeHlsLiveStreamRealTimeBpsData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeHlsLiveStreamRealTimeBpsDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about HTTP Live Streaming (HLS) streams, such as the number of online users and bandwidth.
     *  *
     * @description You can call this operation to query the information about HTTP Live Streaming (HLS) streams, such as the number of online users and bandwidth.
     * *   The number of online users for an HLS stream is counted based on the universally unique identifiers (UUIDs) of users that are placed after the M3U8 URL.
     * *   You can query the data of up to 100 domain names in a single request. If the DomainName parameter is left empty, the data of all domain names under the account is queried.
     *  *
     * @param DescribeHlsLiveStreamRealTimeBpsDataRequest $request DescribeHlsLiveStreamRealTimeBpsDataRequest
     *
     * @return DescribeHlsLiveStreamRealTimeBpsDataResponse DescribeHlsLiveStreamRealTimeBpsDataResponse
     */
    public function describeHlsLiveStreamRealTimeBpsData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeHlsLiveStreamRealTimeBpsDataWithOptions($request, $runtime);
    }

    /**
     * @summary Queries subtitle rules.
     *  *
     * @description You can call this operation to query subtitle rules. Make sure that the parameter settings meet the requirements.
     * >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveAIProduceRulesRequest $request DescribeLiveAIProduceRulesRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveAIProduceRulesResponse DescribeLiveAIProduceRulesResponse
     */
    public function describeLiveAIProduceRulesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->app)) {
            $query['App'] = $request->app;
        }
        if (!Utils::isUnset($request->domain)) {
            $query['Domain'] = $request->domain;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->rulesId)) {
            $query['RulesId'] = $request->rulesId;
        }
        if (!Utils::isUnset($request->suffixName)) {
            $query['SuffixName'] = $request->suffixName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveAIProduceRules',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveAIProduceRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries subtitle rules.
     *  *
     * @description You can call this operation to query subtitle rules. Make sure that the parameter settings meet the requirements.
     * >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveAIProduceRulesRequest $request DescribeLiveAIProduceRulesRequest
     *
     * @return DescribeLiveAIProduceRulesResponse DescribeLiveAIProduceRulesResponse
     */
    public function describeLiveAIProduceRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveAIProduceRulesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the virtual studio templates within your Alibaba Cloud account.
     *  *
     * @param DescribeLiveAIStudioRequest $request DescribeLiveAIStudioRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveAIStudioResponse DescribeLiveAIStudioResponse
     */
    public function describeLiveAIStudioWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->studioId)) {
            $query['StudioId'] = $request->studioId;
        }
        if (!Utils::isUnset($request->studioName)) {
            $query['StudioName'] = $request->studioName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveAIStudio',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveAIStudioResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the virtual studio templates within your Alibaba Cloud account.
     *  *
     * @param DescribeLiveAIStudioRequest $request DescribeLiveAIStudioRequest
     *
     * @return DescribeLiveAIStudioResponse DescribeLiveAIStudioResponse
     */
    public function describeLiveAIStudio($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveAIStudioWithOptions($request, $runtime);
    }

    /**
     * @summary Queries subtitle templates.
     *  *
     * @description This interface supports querying the list of subtitle template information with specified pagination parameters. Ensure that the parameter settings meet the requirements when calling.
     * >Notice: The real-time subtitle function is currently in the beta testing phase, and each user can add up to 300 subtitle templates.
     * ## QPS Limit
     * The QPS limit for this interface per user is 60 times/second. Exceeding this limit will result in API calls being throttled, which may impact your business operations. Please use it reasonably. For more information, refer to [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveAISubtitleRequest $request DescribeLiveAISubtitleRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveAISubtitleResponse DescribeLiveAISubtitleResponse
     */
    public function describeLiveAISubtitleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->isDefault)) {
            $query['IsDefault'] = $request->isDefault;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->subtitleId)) {
            $query['SubtitleId'] = $request->subtitleId;
        }
        if (!Utils::isUnset($request->subtitleName)) {
            $query['SubtitleName'] = $request->subtitleName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveAISubtitle',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveAISubtitleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries subtitle templates.
     *  *
     * @description This interface supports querying the list of subtitle template information with specified pagination parameters. Ensure that the parameter settings meet the requirements when calling.
     * >Notice: The real-time subtitle function is currently in the beta testing phase, and each user can add up to 300 subtitle templates.
     * ## QPS Limit
     * The QPS limit for this interface per user is 60 times/second. Exceeding this limit will result in API calls being throttled, which may impact your business operations. Please use it reasonably. For more information, refer to [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveAISubtitleRequest $request DescribeLiveAISubtitleRequest
     *
     * @return DescribeLiveAISubtitleResponse DescribeLiveAISubtitleResponse
     */
    public function describeLiveAISubtitle($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveAISubtitleWithOptions($request, $runtime);
    }

    /**
     * @summary Queries audio moderation configurations.
     *  *
     * @description *   Obtain the main streaming domain, and then call this operation to query audio moderation configurations.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveAudioAuditConfigRequest $request DescribeLiveAudioAuditConfigRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveAudioAuditConfigResponse DescribeLiveAudioAuditConfigResponse
     */
    public function describeLiveAudioAuditConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveAudioAuditConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveAudioAuditConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries audio moderation configurations.
     *  *
     * @description *   Obtain the main streaming domain, and then call this operation to query audio moderation configurations.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveAudioAuditConfigRequest $request DescribeLiveAudioAuditConfigRequest
     *
     * @return DescribeLiveAudioAuditConfigResponse DescribeLiveAudioAuditConfigResponse
     */
    public function describeLiveAudioAuditConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveAudioAuditConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configuration of callbacks for audio moderation results.
     *  *
     * @description *   Obtain the main streaming domain, and then call this operation to query the configuration of callbacks for audio moderation results.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveAudioAuditNotifyConfigRequest $request DescribeLiveAudioAuditNotifyConfigRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveAudioAuditNotifyConfigResponse DescribeLiveAudioAuditNotifyConfigResponse
     */
    public function describeLiveAudioAuditNotifyConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveAudioAuditNotifyConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveAudioAuditNotifyConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configuration of callbacks for audio moderation results.
     *  *
     * @description *   Obtain the main streaming domain, and then call this operation to query the configuration of callbacks for audio moderation results.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveAudioAuditNotifyConfigRequest $request DescribeLiveAudioAuditNotifyConfigRequest
     *
     * @return DescribeLiveAudioAuditNotifyConfigResponse DescribeLiveAudioAuditNotifyConfigResponse
     */
    public function describeLiveAudioAuditNotifyConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveAudioAuditNotifyConfigWithOptions($request, $runtime);
    }

    /**
     * @param DescribeLiveCdnDiagnoseInfoRequest $request DescribeLiveCdnDiagnoseInfoRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveCdnDiagnoseInfoResponse DescribeLiveCdnDiagnoseInfoResponse
     */
    public function describeLiveCdnDiagnoseInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        if (!Utils::isUnset($request->app)) {
            $query['app'] = $request->app;
        }
        if (!Utils::isUnset($request->domain)) {
            $query['domain'] = $request->domain;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['endTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->intervalType)) {
            $query['intervalType'] = $request->intervalType;
        }
        if (!Utils::isUnset($request->phase)) {
            $query['phase'] = $request->phase;
        }
        if (!Utils::isUnset($request->requestType)) {
            $query['requestType'] = $request->requestType;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['startTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['streamName'] = $request->streamName;
        }
        if (!Utils::isUnset($request->streamSuffix)) {
            $query['streamSuffix'] = $request->streamSuffix;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveCdnDiagnoseInfo',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveCdnDiagnoseInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param DescribeLiveCdnDiagnoseInfoRequest $request DescribeLiveCdnDiagnoseInfoRequest
     *
     * @return DescribeLiveCdnDiagnoseInfoResponse DescribeLiveCdnDiagnoseInfoResponse
     */
    public function describeLiveCdnDiagnoseInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveCdnDiagnoseInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the audio and video frame rates and bitrates of a stream in a live center.
     *  *
     * @description The time granularity for the returned data is 5 seconds. The maximum time range to query is 3 hours. You can query data in the last 30 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveCenterStreamRateDataRequest $request DescribeLiveCenterStreamRateDataRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveCenterStreamRateDataResponse DescribeLiveCenterStreamRateDataResponse
     */
    public function describeLiveCenterStreamRateDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveCenterStreamRateData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveCenterStreamRateDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the audio and video frame rates and bitrates of a stream in a live center.
     *  *
     * @description The time granularity for the returned data is 5 seconds. The maximum time range to query is 3 hours. You can query data in the last 30 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveCenterStreamRateDataRequest $request DescribeLiveCenterStreamRateDataRequest
     *
     * @return DescribeLiveCenterStreamRateDataResponse DescribeLiveCenterStreamRateDataResponse
     */
    public function describeLiveCenterStreamRateData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveCenterStreamRateDataWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a configuration of live center stream relay.
     *  *
     * @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveCenterTransferRequest $request DescribeLiveCenterTransferRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveCenterTransferResponse DescribeLiveCenterTransferResponse
     */
    public function describeLiveCenterTransferWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->dstUrl)) {
            $query['DstUrl'] = $request->dstUrl;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveCenterTransfer',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveCenterTransferResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a configuration of live center stream relay.
     *  *
     * @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveCenterTransferRequest $request DescribeLiveCenterTransferRequest
     *
     * @return DescribeLiveCenterTransferResponse DescribeLiveCenterTransferResponse
     */
    public function describeLiveCenterTransfer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveCenterTransferWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of a certificate.
     *  *
     * @description You can obtain the certificate name on the [Certificates](https://help.aliyun.com/document_detail/2584962.html) page of the ApsaraVideo Live console and then call this operation to query the certificate details.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveCertificateDetailRequest $request DescribeLiveCertificateDetailRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveCertificateDetailResponse DescribeLiveCertificateDetailResponse
     */
    public function describeLiveCertificateDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->certName)) {
            $query['CertName'] = $request->certName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveCertificateDetail',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveCertificateDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of a certificate.
     *  *
     * @description You can obtain the certificate name on the [Certificates](https://help.aliyun.com/document_detail/2584962.html) page of the ApsaraVideo Live console and then call this operation to query the certificate details.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveCertificateDetailRequest $request DescribeLiveCertificateDetailRequest
     *
     * @return DescribeLiveCertificateDetailResponse DescribeLiveCertificateDetailResponse
     */
    public function describeLiveCertificateDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveCertificateDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the certificates of one or more specified domain names or all certificates within your Alibaba Cloud account.
     *  *
     * @description If you specify one or more domain names in the request, the certificates of the domain names are returned. If you do not specify a domain name in the request, all certificates within your Alibaba Cloud account are returned.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveCertificateListRequest $request DescribeLiveCertificateListRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveCertificateListResponse DescribeLiveCertificateListResponse
     */
    public function describeLiveCertificateListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveCertificateList',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveCertificateListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the certificates of one or more specified domain names or all certificates within your Alibaba Cloud account.
     *  *
     * @description If you specify one or more domain names in the request, the certificates of the domain names are returned. If you do not specify a domain name in the request, all certificates within your Alibaba Cloud account are returned.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveCertificateListRequest $request DescribeLiveCertificateListRequest
     *
     * @return DescribeLiveCertificateListResponse DescribeLiveCertificateListResponse
     */
    public function describeLiveCertificateList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveCertificateListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a stream delay configuration.
     *  *
     * @description ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveDelayConfigRequest $request DescribeLiveDelayConfigRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDelayConfigResponse DescribeLiveDelayConfigResponse
     */
    public function describeLiveDelayConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->app)) {
            $query['App'] = $request->app;
        }
        if (!Utils::isUnset($request->domain)) {
            $query['Domain'] = $request->domain;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->stream)) {
            $query['Stream'] = $request->stream;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDelayConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDelayConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a stream delay configuration.
     *  *
     * @description ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveDelayConfigRequest $request DescribeLiveDelayConfigRequest
     *
     * @return DescribeLiveDelayConfigResponse DescribeLiveDelayConfigResponse
     */
    public function describeLiveDelayConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDelayConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the stream delay usage data.
     *  *
     * @description *   You can call this operation to query your stream delay usage data. The default time granularity is 1 hour.
     * *   The maximum time range for a query is 31 days.
     * *   The minimum time granularity for a query is 1 hour.
     * *   You can query the data in the last 31 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDelayedStreamingUsageRequest $request DescribeLiveDelayedStreamingUsageRequest
     * @param RuntimeOptions                           $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDelayedStreamingUsageResponse DescribeLiveDelayedStreamingUsageResponse
     */
    public function describeLiveDelayedStreamingUsageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->interval)) {
            $query['Interval'] = $request->interval;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->region)) {
            $query['Region'] = $request->region;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->splitBy)) {
            $query['SplitBy'] = $request->splitBy;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDelayedStreamingUsage',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDelayedStreamingUsageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the stream delay usage data.
     *  *
     * @description *   You can call this operation to query your stream delay usage data. The default time granularity is 1 hour.
     * *   The maximum time range for a query is 31 days.
     * *   The minimum time granularity for a query is 1 hour.
     * *   You can query the data in the last 31 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDelayedStreamingUsageRequest $request DescribeLiveDelayedStreamingUsageRequest
     *
     * @return DescribeLiveDelayedStreamingUsageResponse DescribeLiveDelayedStreamingUsageResponse
     */
    public function describeLiveDelayedStreamingUsage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDelayedStreamingUsageWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configuration of callbacks for video moderation results.
     *  *
     * @description *   Obtain the main streaming domain, and then call this operation to query the configuration of callbacks for video moderation results.
     * *   Only some live centers support the automated review feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
     *  *
     * @param DescribeLiveDetectNotifyConfigRequest $request DescribeLiveDetectNotifyConfigRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDetectNotifyConfigResponse DescribeLiveDetectNotifyConfigResponse
     */
    public function describeLiveDetectNotifyConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDetectNotifyConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDetectNotifyConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configuration of callbacks for video moderation results.
     *  *
     * @description *   Obtain the main streaming domain, and then call this operation to query the configuration of callbacks for video moderation results.
     * *   Only some live centers support the automated review feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
     *  *
     * @param DescribeLiveDetectNotifyConfigRequest $request DescribeLiveDetectNotifyConfigRequest
     *
     * @return DescribeLiveDetectNotifyConfigResponse DescribeLiveDetectNotifyConfigResponse
     */
    public function describeLiveDetectNotifyConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDetectNotifyConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the usage data of content moderation.
     *  *
     * @description *   The minimum data granularity is 5 minutes. If you do not specify the `StartTime` parameter, data in the last 24 hours is queried.
     * *   You can query data in the last 90 days.
     * *   You can call this operation to query the bandwidth at each interval.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDetectPornDataRequest $request DescribeLiveDetectPornDataRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDetectPornDataResponse DescribeLiveDetectPornDataResponse
     */
    public function describeLiveDetectPornDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->app)) {
            $query['App'] = $request->app;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->fee)) {
            $query['Fee'] = $request->fee;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->region)) {
            $query['Region'] = $request->region;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->scene)) {
            $query['Scene'] = $request->scene;
        }
        if (!Utils::isUnset($request->splitBy)) {
            $query['SplitBy'] = $request->splitBy;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->stream)) {
            $query['Stream'] = $request->stream;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDetectPornData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDetectPornDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the usage data of content moderation.
     *  *
     * @description *   The minimum data granularity is 5 minutes. If you do not specify the `StartTime` parameter, data in the last 24 hours is queried.
     * *   You can query data in the last 90 days.
     * *   You can call this operation to query the bandwidth at each interval.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDetectPornDataRequest $request DescribeLiveDetectPornDataRequest
     *
     * @return DescribeLiveDetectPornDataResponse DescribeLiveDetectPornDataResponse
     */
    public function describeLiveDetectPornData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDetectPornDataWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the bandwidth data for one or more streaming domains.
     *  *
     * @description *   You can specify both the StartTime and EndTime parameters to query the data in the specified period of time. If you do not specify the StartTime and EndTime parameters, the data of the last hour is queried by default.
     * *   If you specify only the StartTime parameter but not the EndTime parameter, the data of the hour following the specified start time is queried.
     * *   If you specify only the EndTime parameter but not the StartTime parameter, the data of the hour preceding the specified end time is queried.
     * *   You can query the data in the last 90 days.
     * *   This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainBpsDataRequest $request DescribeLiveDomainBpsDataRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDomainBpsDataResponse DescribeLiveDomainBpsDataResponse
     */
    public function describeLiveDomainBpsDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->interval)) {
            $query['Interval'] = $request->interval;
        }
        if (!Utils::isUnset($request->ispNameEn)) {
            $query['IspNameEn'] = $request->ispNameEn;
        }
        if (!Utils::isUnset($request->locationNameEn)) {
            $query['LocationNameEn'] = $request->locationNameEn;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainBpsData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainBpsDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the bandwidth data for one or more streaming domains.
     *  *
     * @description *   You can specify both the StartTime and EndTime parameters to query the data in the specified period of time. If you do not specify the StartTime and EndTime parameters, the data of the last hour is queried by default.
     * *   If you specify only the StartTime parameter but not the EndTime parameter, the data of the hour following the specified start time is queried.
     * *   If you specify only the EndTime parameter but not the StartTime parameter, the data of the hour preceding the specified end time is queried.
     * *   You can query the data in the last 90 days.
     * *   This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainBpsDataRequest $request DescribeLiveDomainBpsDataRequest
     *
     * @return DescribeLiveDomainBpsDataResponse DescribeLiveDomainBpsDataResponse
     */
    public function describeLiveDomainBpsData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainBpsDataWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the bandwidth and traffic data by protocol for one or more domain names.
     *  *
     * @description You can query data in the last 90 days. You can specify up to 500 domain names. Separate multiple domain names with commas (,). The data of multiple domain names is aggregated and returned. The following section describes the time granularities of the data entries returned depending on the time range specified by the **StartTime** and **EndTime** parameters:
     * *   If the time range is smaller than or equal to 3 days, the time granularity is 5 minutes.
     * *   If the time range is larger than 3 days but smaller than or equal to 31 days, the time granularity is 1 hour.
     * *   If the time range is larger than 31 days, the time granularity is 1 day.
     * >  If neither the **StartTime** nor the **EndTime** parameter is specified, the data of the last 24 hours is returned.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainBpsDataByLayerRequest $request DescribeLiveDomainBpsDataByLayerRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDomainBpsDataByLayerResponse DescribeLiveDomainBpsDataByLayerResponse
     */
    public function describeLiveDomainBpsDataByLayerWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->interval)) {
            $query['Interval'] = $request->interval;
        }
        if (!Utils::isUnset($request->ispNameEn)) {
            $query['IspNameEn'] = $request->ispNameEn;
        }
        if (!Utils::isUnset($request->layer)) {
            $query['Layer'] = $request->layer;
        }
        if (!Utils::isUnset($request->locationNameEn)) {
            $query['LocationNameEn'] = $request->locationNameEn;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainBpsDataByLayer',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainBpsDataByLayerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the bandwidth and traffic data by protocol for one or more domain names.
     *  *
     * @description You can query data in the last 90 days. You can specify up to 500 domain names. Separate multiple domain names with commas (,). The data of multiple domain names is aggregated and returned. The following section describes the time granularities of the data entries returned depending on the time range specified by the **StartTime** and **EndTime** parameters:
     * *   If the time range is smaller than or equal to 3 days, the time granularity is 5 minutes.
     * *   If the time range is larger than 3 days but smaller than or equal to 31 days, the time granularity is 1 hour.
     * *   If the time range is larger than 31 days, the time granularity is 1 day.
     * >  If neither the **StartTime** nor the **EndTime** parameter is specified, the data of the last 24 hours is returned.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainBpsDataByLayerRequest $request DescribeLiveDomainBpsDataByLayerRequest
     *
     * @return DescribeLiveDomainBpsDataByLayerResponse DescribeLiveDomainBpsDataByLayerResponse
     */
    public function describeLiveDomainBpsDataByLayer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainBpsDataByLayerWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the accelerated domain names that match a certificate.
     *  *
     * @description You can call this operation to query the accelerated domain names that match a certificate.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainByCertificateRequest $request DescribeLiveDomainByCertificateRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDomainByCertificateResponse DescribeLiveDomainByCertificateResponse
     */
    public function describeLiveDomainByCertificateWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->SSLPub)) {
            $query['SSLPub'] = $request->SSLPub;
        }
        if (!Utils::isUnset($request->SSLStatus)) {
            $query['SSLStatus'] = $request->SSLStatus;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainByCertificate',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainByCertificateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the accelerated domain names that match a certificate.
     *  *
     * @description You can call this operation to query the accelerated domain names that match a certificate.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainByCertificateRequest $request DescribeLiveDomainByCertificateRequest
     *
     * @return DescribeLiveDomainByCertificateResponse DescribeLiveDomainByCertificateResponse
     */
    public function describeLiveDomainByCertificate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainByCertificateWithOptions($request, $runtime);
    }

    /**
     * @summary Queries certificate information about a domain name.
     *  *
     * @description Obtain a domain name, and then call this operation to query certificate information about the domain name.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainCertificateInfoRequest $request DescribeLiveDomainCertificateInfoRequest
     * @param RuntimeOptions                           $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDomainCertificateInfoResponse DescribeLiveDomainCertificateInfoResponse
     */
    public function describeLiveDomainCertificateInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainCertificateInfo',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainCertificateInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries certificate information about a domain name.
     *  *
     * @description Obtain a domain name, and then call this operation to query certificate information about the domain name.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainCertificateInfoRequest $request DescribeLiveDomainCertificateInfoRequest
     *
     * @return DescribeLiveDomainCertificateInfoResponse DescribeLiveDomainCertificateInfoResponse
     */
    public function describeLiveDomainCertificateInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainCertificateInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries one or more configurations of a domain name.
     *  *
     * @description You can call this operation to query multiple configurations at a time.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainConfigsRequest $request DescribeLiveDomainConfigsRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDomainConfigsResponse DescribeLiveDomainConfigsResponse
     */
    public function describeLiveDomainConfigsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->functionNames)) {
            $query['FunctionNames'] = $request->functionNames;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainConfigs',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainConfigsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries one or more configurations of a domain name.
     *  *
     * @description You can call this operation to query multiple configurations at a time.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainConfigsRequest $request DescribeLiveDomainConfigsRequest
     *
     * @return DescribeLiveDomainConfigsResponse DescribeLiveDomainConfigsResponse
     */
    public function describeLiveDomainConfigs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainConfigsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the basic information about a domain name.
     *  *
     * @description ## [](#)Usage notes
     * You can call this operation to query the basic information about an ingest domain or a streaming domain. If you want to query a newly added domain name, wait a few minutes until the configuration of the domain name is completed in ApsaraVideo Live.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveDomainDetailRequest $request DescribeLiveDomainDetailRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDomainDetailResponse DescribeLiveDomainDetailResponse
     */
    public function describeLiveDomainDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainDetail',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the basic information about a domain name.
     *  *
     * @description ## [](#)Usage notes
     * You can call this operation to query the basic information about an ingest domain or a streaming domain. If you want to query a newly added domain name, wait a few minutes until the configuration of the domain name is completed in ApsaraVideo Live.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveDomainDetailRequest $request DescribeLiveDomainDetailRequest
     *
     * @return DescribeLiveDomainDetailResponse DescribeLiveDomainDetailResponse
     */
    public function describeLiveDomainDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainDetailWithOptions($request, $runtime);
    }

    /**
     * @summary 直播离线日志查询地址
     *  *
     * @param DescribeLiveDomainEdgeLogRequest $request DescribeLiveDomainEdgeLogRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDomainEdgeLogResponse DescribeLiveDomainEdgeLogResponse
     */
    public function describeLiveDomainEdgeLogWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainEdgeLog',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainEdgeLogResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 直播离线日志查询地址
     *  *
     * @param DescribeLiveDomainEdgeLogRequest $request DescribeLiveDomainEdgeLogRequest
     *
     * @return DescribeLiveDomainEdgeLogResponse DescribeLiveDomainEdgeLogResponse
     */
    public function describeLiveDomainEdgeLog($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainEdgeLogWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the frame rates and bitrates of all live streams under an ingest domain.
     *  *
     * @description You can call this operation to query the real-time bitrates and frame rates of live streams, which helps you evaluate the stream ingest quality. A delay exists in data collection and statistics. We recommend that you query the data of more than 5 minutes ago.
     * >  Use this operation to replace the deprecated DescribeLiveStreamsFrameRateAndBitRateData operation.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainFrameRateAndBitRateDataRequest $request DescribeLiveDomainFrameRateAndBitRateDataRequest
     * @param RuntimeOptions                                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDomainFrameRateAndBitRateDataResponse DescribeLiveDomainFrameRateAndBitRateDataResponse
     */
    public function describeLiveDomainFrameRateAndBitRateDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->queryTime)) {
            $query['QueryTime'] = $request->queryTime;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainFrameRateAndBitRateData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainFrameRateAndBitRateDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the frame rates and bitrates of all live streams under an ingest domain.
     *  *
     * @description You can call this operation to query the real-time bitrates and frame rates of live streams, which helps you evaluate the stream ingest quality. A delay exists in data collection and statistics. We recommend that you query the data of more than 5 minutes ago.
     * >  Use this operation to replace the deprecated DescribeLiveStreamsFrameRateAndBitRateData operation.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainFrameRateAndBitRateDataRequest $request DescribeLiveDomainFrameRateAndBitRateDataRequest
     *
     * @return DescribeLiveDomainFrameRateAndBitRateDataResponse DescribeLiveDomainFrameRateAndBitRateDataResponse
     */
    public function describeLiveDomainFrameRateAndBitRateData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainFrameRateAndBitRateDataWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the maximum numbers of ingested and transcoded streams for a streaming domain.
     *  *
     * @description This operation applies only to main streaming domains.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveDomainLimitRequest $request DescribeLiveDomainLimitRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDomainLimitResponse DescribeLiveDomainLimitResponse
     */
    public function describeLiveDomainLimitWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainLimit',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainLimitResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the maximum numbers of ingested and transcoded streams for a streaming domain.
     *  *
     * @description This operation applies only to main streaming domains.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveDomainLimitRequest $request DescribeLiveDomainLimitRequest
     *
     * @return DescribeLiveDomainLimitResponse DescribeLiveDomainLimitResponse
     */
    public function describeLiveDomainLimit($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainLimitWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the address from which you can download the raw access logs of a domain name.
     *  *
     * @description *   You can call this operation to query the offline logs of a single domain name.
     * *   The StartTime and EndTime parameters are optional. You can specify both the parameters to query logs that are generated within the specified time period.
     * *   If you do not specify the StartTime and EndTime parameters, logs that are generated in the last 24 hours are queried by default.
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveDomainLogRequest $request DescribeLiveDomainLogRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDomainLogResponse DescribeLiveDomainLogResponse
     */
    public function describeLiveDomainLogWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainLog',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainLogResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the address from which you can download the raw access logs of a domain name.
     *  *
     * @description *   You can call this operation to query the offline logs of a single domain name.
     * *   The StartTime and EndTime parameters are optional. You can specify both the parameters to query logs that are generated within the specified time period.
     * *   If you do not specify the StartTime and EndTime parameters, logs that are generated in the last 24 hours are queried by default.
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveDomainLogRequest $request DescribeLiveDomainLogRequest
     *
     * @return DescribeLiveDomainLogResponse DescribeLiveDomainLogResponse
     */
    public function describeLiveDomainLog($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainLogWithOptions($request, $runtime);
    }

    /**
     * @summary 直播离线日志扩展接口(大客定制)
     *  *
     * @param DescribeLiveDomainLogExTtlRequest $request DescribeLiveDomainLogExTtlRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDomainLogExTtlResponse DescribeLiveDomainLogExTtlResponse
     */
    public function describeLiveDomainLogExTtlWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainLogExTtl',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainLogExTtlResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 直播离线日志扩展接口(大客定制)
     *  *
     * @param DescribeLiveDomainLogExTtlRequest $request DescribeLiveDomainLogExTtlRequest
     *
     * @return DescribeLiveDomainLogExTtlResponse DescribeLiveDomainLogExTtlResponse
     */
    public function describeLiveDomainLogExTtl($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainLogExTtlWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the mappings of an ingest domain, a main streaming domain, or a sub-streaming domain.
     *  *
     * @description Obtain the ingest domain, main streaming domain, or sub-streaming domain, and then call this operation to query the mappings of the domain name.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 500 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveDomainMappingRequest $request DescribeLiveDomainMappingRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDomainMappingResponse DescribeLiveDomainMappingResponse
     */
    public function describeLiveDomainMappingWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainMapping',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainMappingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the mappings of an ingest domain, a main streaming domain, or a sub-streaming domain.
     *  *
     * @description Obtain the ingest domain, main streaming domain, or sub-streaming domain, and then call this operation to query the mappings of the domain name.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 500 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveDomainMappingRequest $request DescribeLiveDomainMappingRequest
     *
     * @return DescribeLiveDomainMappingResponse DescribeLiveDomainMappingResponse
     */
    public function describeLiveDomainMapping($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainMappingWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the live monitoring usage data for one or more domain names.
     *  *
     * @description *   You can specify one or more domain names. Separate multiple domain names with commas (,).
     * *   You can query data in the last 90 days.
     * *   The data is queried by hour or day.
     * *   The maximum time range for a query is 31 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainMonitoringUsageDataRequest $request DescribeLiveDomainMonitoringUsageDataRequest
     * @param RuntimeOptions                               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDomainMonitoringUsageDataResponse DescribeLiveDomainMonitoringUsageDataResponse
     */
    public function describeLiveDomainMonitoringUsageDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->interval)) {
            $query['Interval'] = $request->interval;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->region)) {
            $query['Region'] = $request->region;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->splitBy)) {
            $query['SplitBy'] = $request->splitBy;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainMonitoringUsageData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainMonitoringUsageDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the live monitoring usage data for one or more domain names.
     *  *
     * @description *   You can specify one or more domain names. Separate multiple domain names with commas (,).
     * *   You can query data in the last 90 days.
     * *   The data is queried by hour or day.
     * *   The maximum time range for a query is 31 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainMonitoringUsageDataRequest $request DescribeLiveDomainMonitoringUsageDataRequest
     *
     * @return DescribeLiveDomainMonitoringUsageDataResponse DescribeLiveDomainMonitoringUsageDataResponse
     */
    public function describeLiveDomainMonitoringUsageData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainMonitoringUsageDataWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configuration status of dual-stream disaster recovery.
     *  *
     * @param DescribeLiveDomainMultiStreamConfigRequest $request DescribeLiveDomainMultiStreamConfigRequest
     * @param RuntimeOptions                             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDomainMultiStreamConfigResponse DescribeLiveDomainMultiStreamConfigResponse
     */
    public function describeLiveDomainMultiStreamConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainMultiStreamConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainMultiStreamConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configuration status of dual-stream disaster recovery.
     *  *
     * @param DescribeLiveDomainMultiStreamConfigRequest $request DescribeLiveDomainMultiStreamConfigRequest
     *
     * @return DescribeLiveDomainMultiStreamConfigResponse DescribeLiveDomainMultiStreamConfigResponse
     */
    public function describeLiveDomainMultiStreamConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainMultiStreamConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the number of online users at a specified point in time for all live streams under a specified domain name.
     *  *
     * @description You can call this operation to collect statistics on the number of online users for only Flash Video (FLV), Real-Time Streaming (RTS), and Real-Time Messaging Protocol (RTMP) streams, but not HTTP Live Streaming (HLS) streams. A delay exists in data collection and statistics. We recommend that you query the data of more than 5 minutes ago.
     * >  Use this operation to replace the deprecated DescribeLiveStreamOnlineUserNum operation.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 200 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainOnlineUserNumRequest $request DescribeLiveDomainOnlineUserNumRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDomainOnlineUserNumResponse DescribeLiveDomainOnlineUserNumResponse
     */
    public function describeLiveDomainOnlineUserNumWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->queryTime)) {
            $query['QueryTime'] = $request->queryTime;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainOnlineUserNum',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainOnlineUserNumResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the number of online users at a specified point in time for all live streams under a specified domain name.
     *  *
     * @description You can call this operation to collect statistics on the number of online users for only Flash Video (FLV), Real-Time Streaming (RTS), and Real-Time Messaging Protocol (RTMP) streams, but not HTTP Live Streaming (HLS) streams. A delay exists in data collection and statistics. We recommend that you query the data of more than 5 minutes ago.
     * >  Use this operation to replace the deprecated DescribeLiveStreamOnlineUserNum operation.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 200 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainOnlineUserNumRequest $request DescribeLiveDomainOnlineUserNumRequest
     *
     * @return DescribeLiveDomainOnlineUserNumResponse DescribeLiveDomainOnlineUserNumResponse
     */
    public function describeLiveDomainOnlineUserNum($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainOnlineUserNumWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the HTTP status codes that are returned within a specified period of time under an ingest domain.
     *  *
     * @description *   This operation is used to monitor data. The returned data cannot be used as a reference to calculate resource usage for billing.
     * *   You can query data within the previous 90 days.
     * *   The data is delayed for 3 to 5 minutes.
     * ## [](#qps-)QPS limits
     * You can call this API operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainPublishErrorCodeRequest $request DescribeLiveDomainPublishErrorCodeRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDomainPublishErrorCodeResponse DescribeLiveDomainPublishErrorCodeResponse
     */
    public function describeLiveDomainPublishErrorCodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainPublishErrorCode',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainPublishErrorCodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the HTTP status codes that are returned within a specified period of time under an ingest domain.
     *  *
     * @description *   This operation is used to monitor data. The returned data cannot be used as a reference to calculate resource usage for billing.
     * *   You can query data within the previous 90 days.
     * *   The data is delayed for 3 to 5 minutes.
     * ## [](#qps-)QPS limits
     * You can call this API operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainPublishErrorCodeRequest $request DescribeLiveDomainPublishErrorCodeRequest
     *
     * @return DescribeLiveDomainPublishErrorCodeResponse DescribeLiveDomainPublishErrorCodeResponse
     */
    public function describeLiveDomainPublishErrorCode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainPublishErrorCodeWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the bandwidth data for one or more ingest domains.
     *  *
     * @description *   The bandwidth unit is bit/s.
     * *   You can specify multiple domain names by separating them with commas (,).
     * *   If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
     * *   You can query the data in the last 90 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainPushBpsDataRequest $request DescribeLiveDomainPushBpsDataRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDomainPushBpsDataResponse DescribeLiveDomainPushBpsDataResponse
     */
    public function describeLiveDomainPushBpsDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->interval)) {
            $query['Interval'] = $request->interval;
        }
        if (!Utils::isUnset($request->ispNameEn)) {
            $query['IspNameEn'] = $request->ispNameEn;
        }
        if (!Utils::isUnset($request->locationNameEn)) {
            $query['LocationNameEn'] = $request->locationNameEn;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainPushBpsData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainPushBpsDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the bandwidth data for one or more ingest domains.
     *  *
     * @description *   The bandwidth unit is bit/s.
     * *   You can specify multiple domain names by separating them with commas (,).
     * *   If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
     * *   You can query the data in the last 90 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainPushBpsDataRequest $request DescribeLiveDomainPushBpsDataRequest
     *
     * @return DescribeLiveDomainPushBpsDataResponse DescribeLiveDomainPushBpsDataResponse
     */
    public function describeLiveDomainPushBpsData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainPushBpsDataWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the network traffic data for one or more ingest domains.
     *  *
     * @description *   The traffic unit is bytes.
     * *   You can specify multiple domain names by separating them with commas (,).
     * *   If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
     * *   You can query the data in the last 90 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainPushTrafficDataRequest $request DescribeLiveDomainPushTrafficDataRequest
     * @param RuntimeOptions                           $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDomainPushTrafficDataResponse DescribeLiveDomainPushTrafficDataResponse
     */
    public function describeLiveDomainPushTrafficDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->interval)) {
            $query['Interval'] = $request->interval;
        }
        if (!Utils::isUnset($request->ispNameEn)) {
            $query['IspNameEn'] = $request->ispNameEn;
        }
        if (!Utils::isUnset($request->locationNameEn)) {
            $query['LocationNameEn'] = $request->locationNameEn;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainPushTrafficData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainPushTrafficDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the network traffic data for one or more ingest domains.
     *  *
     * @description *   The traffic unit is bytes.
     * *   You can specify multiple domain names by separating them with commas (,).
     * *   If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
     * *   You can query the data in the last 90 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainPushTrafficDataRequest $request DescribeLiveDomainPushTrafficDataRequest
     *
     * @return DescribeLiveDomainPushTrafficDataResponse DescribeLiveDomainPushTrafficDataResponse
     */
    public function describeLiveDomainPushTrafficData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainPushTrafficDataWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the data of page views (PVs) and unique visitors (UVs) of a streaming domain.
     *  *
     * @description *   You can call this operation to query the geographical distribution of viewers, the visitor ranking of a streaming domain, and the number of independent requests from IP addresses under a streaming domain within a specified time period.
     * *   If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
     * *   You can specify only one streaming domain in each request.
     * *   You can query the data in the last 90 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainPvUvDataRequest $request DescribeLiveDomainPvUvDataRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDomainPvUvDataResponse DescribeLiveDomainPvUvDataResponse
     */
    public function describeLiveDomainPvUvDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainPvUvData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainPvUvDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the data of page views (PVs) and unique visitors (UVs) of a streaming domain.
     *  *
     * @description *   You can call this operation to query the geographical distribution of viewers, the visitor ranking of a streaming domain, and the number of independent requests from IP addresses under a streaming domain within a specified time period.
     * *   If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
     * *   You can specify only one streaming domain in each request.
     * *   You can query the data in the last 90 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainPvUvDataRequest $request DescribeLiveDomainPvUvDataRequest
     *
     * @return DescribeLiveDomainPvUvDataResponse DescribeLiveDomainPvUvDataResponse
     */
    public function describeLiveDomainPvUvData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainPvUvDataWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the bandwidth data that is collected every minute for one or more domain names.
     *  *
     * @description *   You can call this operation to query the bandwidth usage of one or more specified domain names.
     * *   You can query data in the last seven days. The time range that is specified by the StartTime and EndTime parameters cannot exceed 24 hours for a query.
     * *   If you specify neither the StartTime parameter nor the EndTime parameter, the data of the last hour is returned.
     * *   This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainRealTimeBpsDataRequest $request DescribeLiveDomainRealTimeBpsDataRequest
     * @param RuntimeOptions                           $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDomainRealTimeBpsDataResponse DescribeLiveDomainRealTimeBpsDataResponse
     */
    public function describeLiveDomainRealTimeBpsDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainRealTimeBpsData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainRealTimeBpsDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the bandwidth data that is collected every minute for one or more domain names.
     *  *
     * @description *   You can call this operation to query the bandwidth usage of one or more specified domain names.
     * *   You can query data in the last seven days. The time range that is specified by the StartTime and EndTime parameters cannot exceed 24 hours for a query.
     * *   If you specify neither the StartTime parameter nor the EndTime parameter, the data of the last hour is returned.
     * *   This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainRealTimeBpsDataRequest $request DescribeLiveDomainRealTimeBpsDataRequest
     *
     * @return DescribeLiveDomainRealTimeBpsDataResponse DescribeLiveDomainRealTimeBpsDataResponse
     */
    public function describeLiveDomainRealTimeBpsData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainRealTimeBpsDataWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the proportions of HTTP status codes returned for one or more domain names. Data is collected every minute.
     *  *
     * @description The following table describes the time granularities supported by this operation.
     * |Time granularity|Maximum time range per query|Historical data available|Data delay|
     * |---|---|---|---|
     * |1 minute|1 hour|7 days|5 minutes|
     * |5 minutes|3 days|93 days|15 minutes|
     * |1 hour|31 days|186 days|Usually 4 hours|
     * |1 day|Unlimited|366 days|After 04:00 on the next day|
     * ## QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainRealTimeHttpCodeDataRequest $request DescribeLiveDomainRealTimeHttpCodeDataRequest
     * @param RuntimeOptions                                $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDomainRealTimeHttpCodeDataResponse DescribeLiveDomainRealTimeHttpCodeDataResponse
     */
    public function describeLiveDomainRealTimeHttpCodeDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->ispNameEn)) {
            $query['IspNameEn'] = $request->ispNameEn;
        }
        if (!Utils::isUnset($request->locationNameEn)) {
            $query['LocationNameEn'] = $request->locationNameEn;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainRealTimeHttpCodeData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainRealTimeHttpCodeDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the proportions of HTTP status codes returned for one or more domain names. Data is collected every minute.
     *  *
     * @description The following table describes the time granularities supported by this operation.
     * |Time granularity|Maximum time range per query|Historical data available|Data delay|
     * |---|---|---|---|
     * |1 minute|1 hour|7 days|5 minutes|
     * |5 minutes|3 days|93 days|15 minutes|
     * |1 hour|31 days|186 days|Usually 4 hours|
     * |1 day|Unlimited|366 days|After 04:00 on the next day|
     * ## QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainRealTimeHttpCodeDataRequest $request DescribeLiveDomainRealTimeHttpCodeDataRequest
     *
     * @return DescribeLiveDomainRealTimeHttpCodeDataResponse DescribeLiveDomainRealTimeHttpCodeDataResponse
     */
    public function describeLiveDomainRealTimeHttpCodeData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainRealTimeHttpCodeDataWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the network traffic data that is collected in real time for one or more domain names.
     *  *
     * @description *   You can call this operation to query the real-time traffic in a region for an Internet service provider (ISP) within a specified period of time under one or more streaming domains.
     * *   If you do not specify the StartTime parameter or the EndTime parameter, the data of the last hour is returned. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
     * *   This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
     * *   You can query the data in the last 90 days.
     * ## [](#qps-)QPS limit
     * This operation does not have a queries per second (QPS) limit on a single user. You can call this operation based on your business requirements.
     *  *
     * @param DescribeLiveDomainRealTimeTrafficDataRequest $request DescribeLiveDomainRealTimeTrafficDataRequest
     * @param RuntimeOptions                               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDomainRealTimeTrafficDataResponse DescribeLiveDomainRealTimeTrafficDataResponse
     */
    public function describeLiveDomainRealTimeTrafficDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->ispNameEn)) {
            $query['IspNameEn'] = $request->ispNameEn;
        }
        if (!Utils::isUnset($request->locationNameEn)) {
            $query['LocationNameEn'] = $request->locationNameEn;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainRealTimeTrafficData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainRealTimeTrafficDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the network traffic data that is collected in real time for one or more domain names.
     *  *
     * @description *   You can call this operation to query the real-time traffic in a region for an Internet service provider (ISP) within a specified period of time under one or more streaming domains.
     * *   If you do not specify the StartTime parameter or the EndTime parameter, the data of the last hour is returned. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
     * *   This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
     * *   You can query the data in the last 90 days.
     * ## [](#qps-)QPS limit
     * This operation does not have a queries per second (QPS) limit on a single user. You can call this operation based on your business requirements.
     *  *
     * @param DescribeLiveDomainRealTimeTrafficDataRequest $request DescribeLiveDomainRealTimeTrafficDataRequest
     *
     * @return DescribeLiveDomainRealTimeTrafficDataResponse DescribeLiveDomainRealTimeTrafficDataResponse
     */
    public function describeLiveDomainRealTimeTrafficData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainRealTimeTrafficDataWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about real-time log delivery for a domain name.
     *  *
     * @description You can call this operation to query the status of real-time log delivery for a domain name. Make sure that the parameter settings meet the requirements.
     * ## QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveDomainRealtimeLogDeliveryRequest $request DescribeLiveDomainRealtimeLogDeliveryRequest
     * @param RuntimeOptions                               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDomainRealtimeLogDeliveryResponse DescribeLiveDomainRealtimeLogDeliveryResponse
     */
    public function describeLiveDomainRealtimeLogDeliveryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainRealtimeLogDelivery',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainRealtimeLogDeliveryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about real-time log delivery for a domain name.
     *  *
     * @description You can call this operation to query the status of real-time log delivery for a domain name. Make sure that the parameter settings meet the requirements.
     * ## QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveDomainRealtimeLogDeliveryRequest $request DescribeLiveDomainRealtimeLogDeliveryRequest
     *
     * @return DescribeLiveDomainRealtimeLogDeliveryResponse DescribeLiveDomainRealtimeLogDeliveryResponse
     */
    public function describeLiveDomainRealtimeLogDelivery($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainRealtimeLogDeliveryWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the numbers of live recording channels and container format conversions.
     *  *
     * @description *   You can call this operation to query the number of concurrent recording channels on each day and event tracking data at different time intervals. This way, you can measure the peak number of concurrent recording channels on each day or month.
     * *   The number of time shifting channels is not included in the number of recording channels.
     * *   You can query data by domain name or query data for multiple domain names at a time. If you specify multiple domain names, separate them with commas (,).
     * *   If you set the data granularity to 1 minute, the maximum time range to query is 24 hours. You can query data in the last 60 days.
     * *   If you set the data granularity to 1 hour, the maximum time range to query is 31 days. You can query data in the last 180 days.
     * *   If you set the data granularity to 1 day, the maximum time range to query is 90 days. You can query data in the last 366 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainRecordUsageDataRequest $request DescribeLiveDomainRecordUsageDataRequest
     * @param RuntimeOptions                           $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDomainRecordUsageDataResponse DescribeLiveDomainRecordUsageDataResponse
     */
    public function describeLiveDomainRecordUsageDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->interval)) {
            $query['Interval'] = $request->interval;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->region)) {
            $query['Region'] = $request->region;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->splitBy)) {
            $query['SplitBy'] = $request->splitBy;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainRecordUsageData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainRecordUsageDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the numbers of live recording channels and container format conversions.
     *  *
     * @description *   You can call this operation to query the number of concurrent recording channels on each day and event tracking data at different time intervals. This way, you can measure the peak number of concurrent recording channels on each day or month.
     * *   The number of time shifting channels is not included in the number of recording channels.
     * *   You can query data by domain name or query data for multiple domain names at a time. If you specify multiple domain names, separate them with commas (,).
     * *   If you set the data granularity to 1 minute, the maximum time range to query is 24 hours. You can query data in the last 60 days.
     * *   If you set the data granularity to 1 hour, the maximum time range to query is 31 days. You can query data in the last 180 days.
     * *   If you set the data granularity to 1 day, the maximum time range to query is 90 days. You can query data in the last 366 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainRecordUsageDataRequest $request DescribeLiveDomainRecordUsageDataRequest
     *
     * @return DescribeLiveDomainRecordUsageDataResponse DescribeLiveDomainRecordUsageDataResponse
     */
    public function describeLiveDomainRecordUsageData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainRecordUsageDataWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the number of snapshots for one or more streaming domains.
     *  *
     * @description *   You can call this operation to collect statistics on the total number of snapshots on a day.
     * *   You can query data in the last 90 days.
     * ## [](#qps-)QPS limit
     * This operation does not have a queries per second (QPS) limit on a single user. You can call this operation based on your business requirements.
     *  *
     * @param DescribeLiveDomainSnapshotDataRequest $request DescribeLiveDomainSnapshotDataRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDomainSnapshotDataResponse DescribeLiveDomainSnapshotDataResponse
     */
    public function describeLiveDomainSnapshotDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainSnapshotData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainSnapshotDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the number of snapshots for one or more streaming domains.
     *  *
     * @description *   You can call this operation to collect statistics on the total number of snapshots on a day.
     * *   You can query data in the last 90 days.
     * ## [](#qps-)QPS limit
     * This operation does not have a queries per second (QPS) limit on a single user. You can call this operation based on your business requirements.
     *  *
     * @param DescribeLiveDomainSnapshotDataRequest $request DescribeLiveDomainSnapshotDataRequest
     *
     * @return DescribeLiveDomainSnapshotDataResponse DescribeLiveDomainSnapshotDataResponse
     */
    public function describeLiveDomainSnapshotData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainSnapshotDataWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the feature configurations of an accelerated domain name in the canary release environment.
     *  *
     * @description ## [](#)Usage notes
     * You can call this operation to query the feature configurations of an accelerated domain name in the canary release environment.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveDomainStagingConfigRequest $request DescribeLiveDomainStagingConfigRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDomainStagingConfigResponse DescribeLiveDomainStagingConfigResponse
     */
    public function describeLiveDomainStagingConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->functionNames)) {
            $query['FunctionNames'] = $request->functionNames;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainStagingConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainStagingConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the feature configurations of an accelerated domain name in the canary release environment.
     *  *
     * @description ## [](#)Usage notes
     * You can call this operation to query the feature configurations of an accelerated domain name in the canary release environment.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveDomainStagingConfigRequest $request DescribeLiveDomainStagingConfigRequest
     *
     * @return DescribeLiveDomainStagingConfigResponse DescribeLiveDomainStagingConfigResponse
     */
    public function describeLiveDomainStagingConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainStagingConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the transcoding length for one or more domain names.
     *  *
     * @description *   You can call this operation to collect the transcoding usage data at each time interval.
     * *   You can specify multiple domain names by separating them with commas (,).
     * *   You can query data in the last 90 days.
     * *   The time granularity of data is 1 hour or 1 day.
     * *   For information about the billing of different transcoding types and transcoding resolutions, see the description about billing of different transcoding specifications in transcoding bills in the [Billing of live stream transcoding](https://help.aliyun.com/document_detail/90424.html) section of the ApsaraVideo Live pricing page.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainStreamTranscodeDataRequest $request DescribeLiveDomainStreamTranscodeDataRequest
     * @param RuntimeOptions                               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDomainStreamTranscodeDataResponse DescribeLiveDomainStreamTranscodeDataResponse
     */
    public function describeLiveDomainStreamTranscodeDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->interval)) {
            $query['Interval'] = $request->interval;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->precision)) {
            $query['Precision'] = $request->precision;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->split)) {
            $query['Split'] = $request->split;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainStreamTranscodeData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainStreamTranscodeDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the transcoding length for one or more domain names.
     *  *
     * @description *   You can call this operation to collect the transcoding usage data at each time interval.
     * *   You can specify multiple domain names by separating them with commas (,).
     * *   You can query data in the last 90 days.
     * *   The time granularity of data is 1 hour or 1 day.
     * *   For information about the billing of different transcoding types and transcoding resolutions, see the description about billing of different transcoding specifications in transcoding bills in the [Billing of live stream transcoding](https://help.aliyun.com/document_detail/90424.html) section of the ApsaraVideo Live pricing page.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainStreamTranscodeDataRequest $request DescribeLiveDomainStreamTranscodeDataRequest
     *
     * @return DescribeLiveDomainStreamTranscodeDataResponse DescribeLiveDomainStreamTranscodeDataResponse
     */
    public function describeLiveDomainStreamTranscodeData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainStreamTranscodeDataWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the resource usage data of time shifting for one or more domain names.
     *  *
     * @description *   You can call this operation to query the time shifting usage data at each time interval.
     * *   You can query data in the last 90 days.
     * *   The time interval is 1 hour.
     * *   The maximum time range for a query is 31 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainTimeShiftDataRequest $request DescribeLiveDomainTimeShiftDataRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDomainTimeShiftDataResponse DescribeLiveDomainTimeShiftDataResponse
     */
    public function describeLiveDomainTimeShiftDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->interval)) {
            $query['Interval'] = $request->interval;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainTimeShiftData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainTimeShiftDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the resource usage data of time shifting for one or more domain names.
     *  *
     * @description *   You can call this operation to query the time shifting usage data at each time interval.
     * *   You can query data in the last 90 days.
     * *   The time interval is 1 hour.
     * *   The maximum time range for a query is 31 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainTimeShiftDataRequest $request DescribeLiveDomainTimeShiftDataRequest
     *
     * @return DescribeLiveDomainTimeShiftDataResponse DescribeLiveDomainTimeShiftDataResponse
     */
    public function describeLiveDomainTimeShiftData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainTimeShiftDataWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the network traffic data for one or more domain names.
     *  *
     * @description *   If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is returned.
     * *   This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainTrafficDataRequest $request DescribeLiveDomainTrafficDataRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDomainTrafficDataResponse DescribeLiveDomainTrafficDataResponse
     */
    public function describeLiveDomainTrafficDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->interval)) {
            $query['Interval'] = $request->interval;
        }
        if (!Utils::isUnset($request->ispNameEn)) {
            $query['IspNameEn'] = $request->ispNameEn;
        }
        if (!Utils::isUnset($request->locationNameEn)) {
            $query['LocationNameEn'] = $request->locationNameEn;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainTrafficData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainTrafficDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the network traffic data for one or more domain names.
     *  *
     * @description *   If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is returned.
     * *   This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveDomainTrafficDataRequest $request DescribeLiveDomainTrafficDataRequest
     *
     * @return DescribeLiveDomainTrafficDataResponse DescribeLiveDomainTrafficDataResponse
     */
    public function describeLiveDomainTrafficData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainTrafficDataWithOptions($request, $runtime);
    }

    /**
     * @param DescribeLiveDomainTranscodeParamsRequest $request DescribeLiveDomainTranscodeParamsRequest
     * @param RuntimeOptions                           $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDomainTranscodeParamsResponse DescribeLiveDomainTranscodeParamsResponse
     */
    public function describeLiveDomainTranscodeParamsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        if (!Utils::isUnset($request->app)) {
            $query['app'] = $request->app;
        }
        if (!Utils::isUnset($request->pushdomain)) {
            $query['pushdomain'] = $request->pushdomain;
        }
        if (!Utils::isUnset($request->templateName)) {
            $query['template_name'] = $request->templateName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainTranscodeParams',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainTranscodeParamsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param DescribeLiveDomainTranscodeParamsRequest $request DescribeLiveDomainTranscodeParamsRequest
     *
     * @return DescribeLiveDomainTranscodeParamsResponse DescribeLiveDomainTranscodeParamsResponse
     */
    public function describeLiveDomainTranscodeParams($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainTranscodeParamsWithOptions($request, $runtime);
    }

    /**
     * @description ### [](#)Usage notes
     * *   You can query data in the previous 90 days.
     * *   The maximum time range to query is 31 days.
     * ### [](#qps-)QPS limit
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveDrmUsageDataRequest $request DescribeLiveDrmUsageDataRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveDrmUsageDataResponse DescribeLiveDrmUsageDataResponse
     */
    public function describeLiveDrmUsageDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->interval)) {
            $query['Interval'] = $request->interval;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->splitBy)) {
            $query['SplitBy'] = $request->splitBy;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDrmUsageData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDrmUsageDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @description ### [](#)Usage notes
     * *   You can query data in the previous 90 days.
     * *   The maximum time range to query is 31 days.
     * ### [](#qps-)QPS limit
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveDrmUsageDataRequest $request DescribeLiveDrmUsageDataRequest
     *
     * @return DescribeLiveDrmUsageDataResponse DescribeLiveDrmUsageDataResponse
     */
    public function describeLiveDrmUsageData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDrmUsageDataWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configuration of edge stream relay.
     *  *
     * @description Obtain the ingest domain, and then call this operation to query the configuration of edge stream relay.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveEdgeTransferRequest $request DescribeLiveEdgeTransferRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveEdgeTransferResponse DescribeLiveEdgeTransferResponse
     */
    public function describeLiveEdgeTransferWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveEdgeTransfer',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveEdgeTransferResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configuration of edge stream relay.
     *  *
     * @description Obtain the ingest domain, and then call this operation to query the configuration of edge stream relay.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveEdgeTransferRequest $request DescribeLiveEdgeTransferRequest
     *
     * @return DescribeLiveEdgeTransferResponse DescribeLiveEdgeTransferResponse
     */
    public function describeLiveEdgeTransfer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveEdgeTransferWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the co-streaming usage data.
     *  *
     * @description *   The maximum time range for a query is 31 days.
     * *   The minimum time granularity for a query is 5 minutes.
     * *   You can query the data in the last 90 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveGrtnDurationRequest $request DescribeLiveGrtnDurationRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveGrtnDurationResponse DescribeLiveGrtnDurationResponse
     */
    public function describeLiveGrtnDurationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->area)) {
            $query['Area'] = $request->area;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->interval)) {
            $query['Interval'] = $request->interval;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveGrtnDuration',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveGrtnDurationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the co-streaming usage data.
     *  *
     * @description *   The maximum time range for a query is 31 days.
     * *   The minimum time granularity for a query is 5 minutes.
     * *   You can query the data in the last 90 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveGrtnDurationRequest $request DescribeLiveGrtnDurationRequest
     *
     * @return DescribeLiveGrtnDurationResponse DescribeLiveGrtnDurationResponse
     */
    public function describeLiveGrtnDuration($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveGrtnDurationWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about all certificates that you have configured.
     *  *
     * @description You can call this operation to query the information about all certificates that you have configured.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveHttpsDomainListRequest $request DescribeLiveHttpsDomainListRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveHttpsDomainListResponse DescribeLiveHttpsDomainListResponse
     */
    public function describeLiveHttpsDomainListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->keyword)) {
            $query['Keyword'] = $request->keyword;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveHttpsDomainList',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveHttpsDomainListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about all certificates that you have configured.
     *  *
     * @description You can call this operation to query the information about all certificates that you have configured.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveHttpsDomainListRequest $request DescribeLiveHttpsDomainListRequest
     *
     * @return DescribeLiveHttpsDomainListResponse DescribeLiveHttpsDomainListResponse
     */
    public function describeLiveHttpsDomainList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveHttpsDomainListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the metric data of ApsaraVideo Real-time Communication (ARTC).
     *  *
     * @description *   You can query data in the last 30 days. The time range for a query cannot exceed 24 hours.
     * *   The time granularity for a query is 5 minutes.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveInteractionMetricDataRequest $request DescribeLiveInteractionMetricDataRequest
     * @param RuntimeOptions                           $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveInteractionMetricDataResponse DescribeLiveInteractionMetricDataResponse
     */
    public function describeLiveInteractionMetricDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->beginTs)) {
            $query['BeginTs'] = $request->beginTs;
        }
        if (!Utils::isUnset($request->endTs)) {
            $query['EndTs'] = $request->endTs;
        }
        if (!Utils::isUnset($request->metricType)) {
            $query['MetricType'] = $request->metricType;
        }
        if (!Utils::isUnset($request->os)) {
            $query['Os'] = $request->os;
        }
        if (!Utils::isUnset($request->terminalType)) {
            $query['TerminalType'] = $request->terminalType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveInteractionMetricData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveInteractionMetricDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the metric data of ApsaraVideo Real-time Communication (ARTC).
     *  *
     * @description *   You can query data in the last 30 days. The time range for a query cannot exceed 24 hours.
     * *   The time granularity for a query is 5 minutes.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveInteractionMetricDataRequest $request DescribeLiveInteractionMetricDataRequest
     *
     * @return DescribeLiveInteractionMetricDataResponse DescribeLiveInteractionMetricDataResponse
     */
    public function describeLiveInteractionMetricData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveInteractionMetricDataWithOptions($request, $runtime);
    }

    /**
     * @summary Checks whether a specified IP address belongs to an Alibaba Cloud point of presence (POP).
     *  *
     * @description ### [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveIpInfoRequest $request DescribeLiveIpInfoRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveIpInfoResponse DescribeLiveIpInfoResponse
     */
    public function describeLiveIpInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->IP)) {
            $query['IP'] = $request->IP;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveIpInfo',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveIpInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Checks whether a specified IP address belongs to an Alibaba Cloud point of presence (POP).
     *  *
     * @description ### [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveIpInfoRequest $request DescribeLiveIpInfoRequest
     *
     * @return DescribeLiveIpInfoResponse DescribeLiveIpInfoResponse
     */
    public function describeLiveIpInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveIpInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of triggered stream pulling for a streaming domain.
     *  *
     * @description ##
     * This operation is applicable to regular stream pulling. You can call this operation to query the configurations of regular stream pulling for a domain name.
     * ## QPS limit
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveLazyPullStreamConfigRequest $request DescribeLiveLazyPullStreamConfigRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveLazyPullStreamConfigResponse DescribeLiveLazyPullStreamConfigResponse
     */
    public function describeLiveLazyPullStreamConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveLazyPullStreamConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveLazyPullStreamConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of triggered stream pulling for a streaming domain.
     *  *
     * @description ##
     * This operation is applicable to regular stream pulling. You can call this operation to query the configurations of regular stream pulling for a domain name.
     * ## QPS limit
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveLazyPullStreamConfigRequest $request DescribeLiveLazyPullStreamConfigRequest
     *
     * @return DescribeLiveLazyPullStreamConfigResponse DescribeLiveLazyPullStreamConfigResponse
     */
    public function describeLiveLazyPullStreamConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveLazyPullStreamConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Query Interactive Message App
     *  *
     * @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveMessageAppRequest $request DescribeLiveMessageAppRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveMessageAppResponse DescribeLiveMessageAppResponse
     */
    public function describeLiveMessageAppWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->dataCenter)) {
            $query['DataCenter'] = $request->dataCenter;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveMessageApp',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveMessageAppResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Query Interactive Message App
     *  *
     * @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveMessageAppRequest $request DescribeLiveMessageAppRequest
     *
     * @return DescribeLiveMessageAppResponse DescribeLiveMessageAppResponse
     */
    public function describeLiveMessageApp($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveMessageAppWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about an interactive messaging group.
     *  *
     * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848162.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveMessageGroupRequest $request DescribeLiveMessageGroupRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveMessageGroupResponse DescribeLiveMessageGroupResponse
     */
    public function describeLiveMessageGroupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->dataCenter)) {
            $query['DataCenter'] = $request->dataCenter;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveMessageGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveMessageGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about an interactive messaging group.
     *  *
     * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848162.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveMessageGroupRequest $request DescribeLiveMessageGroupRequest
     *
     * @return DescribeLiveMessageGroupResponse DescribeLiveMessageGroupResponse
     */
    public function describeLiveMessageGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveMessageGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the mute status of users.
     *  *
     * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveMessageGroupBandRequest $request DescribeLiveMessageGroupBandRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveMessageGroupBandResponse DescribeLiveMessageGroupBandResponse
     */
    public function describeLiveMessageGroupBandWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->dataCenter)) {
            $query['DataCenter'] = $request->dataCenter;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveMessageGroupBand',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveMessageGroupBandResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the mute status of users.
     *  *
     * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveMessageGroupBandRequest $request DescribeLiveMessageGroupBandRequest
     *
     * @return DescribeLiveMessageGroupBandResponse DescribeLiveMessageGroupBandResponse
     */
    public function describeLiveMessageGroupBand($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveMessageGroupBandWithOptions($request, $runtime);
    }

    /**
     * @description Obtain the main streaming domain, and then call this operation to query live stream encapsulation configurations.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLivePackageConfigRequest $request DescribeLivePackageConfigRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLivePackageConfigResponse DescribeLivePackageConfigResponse
     */
    public function describeLivePackageConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->order)) {
            $query['Order'] = $request->order;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNum)) {
            $query['PageNum'] = $request->pageNum;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLivePackageConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLivePackageConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @description Obtain the main streaming domain, and then call this operation to query live stream encapsulation configurations.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLivePackageConfigRequest $request DescribeLivePackageConfigRequest
     *
     * @return DescribeLivePackageConfigResponse DescribeLivePackageConfigResponse
     */
    public function describeLivePackageConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLivePackageConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries available access points where acceleration circuits start.
     *  *
     * @description Before you call the CreateLivePrivateLine operation, you can call this operation to query available acceleration regions, which are access points where acceleration circuits start.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLivePrivateLineAreasRequest $request DescribeLivePrivateLineAreasRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLivePrivateLineAreasResponse DescribeLivePrivateLineAreasResponse
     */
    public function describeLivePrivateLineAreasWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLivePrivateLineAreas',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLivePrivateLineAreasResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries available access points where acceleration circuits start.
     *  *
     * @description Before you call the CreateLivePrivateLine operation, you can call this operation to query available acceleration regions, which are access points where acceleration circuits start.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLivePrivateLineAreasRequest $request DescribeLivePrivateLineAreasRequest
     *
     * @return DescribeLivePrivateLineAreasResponse DescribeLivePrivateLineAreasResponse
     */
    public function describeLivePrivateLineAreas($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLivePrivateLineAreasWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the binding information between Global Accelerator (GA) instances and acceleration circuits.
     *  *
     * @description If you set the IsGaInstance parameter to yes, the status of GA instances is queried. If you set the IsGaInstance parameter to no, the binding information between GA instances and acceleration circuits is queried.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLivePrivateLineAvailGARequest $request DescribeLivePrivateLineAvailGARequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLivePrivateLineAvailGAResponse DescribeLivePrivateLineAvailGAResponse
     */
    public function describeLivePrivateLineAvailGAWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->accelerationArea)) {
            $query['AccelerationArea'] = $request->accelerationArea;
        }
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->isGaInstance)) {
            $query['IsGaInstance'] = $request->isGaInstance;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        if (!Utils::isUnset($request->videoCenter)) {
            $query['VideoCenter'] = $request->videoCenter;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLivePrivateLineAvailGA',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLivePrivateLineAvailGAResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the binding information between Global Accelerator (GA) instances and acceleration circuits.
     *  *
     * @description If you set the IsGaInstance parameter to yes, the status of GA instances is queried. If you set the IsGaInstance parameter to no, the binding information between GA instances and acceleration circuits is queried.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLivePrivateLineAvailGARequest $request DescribeLivePrivateLineAvailGARequest
     *
     * @return DescribeLivePrivateLineAvailGAResponse DescribeLivePrivateLineAvailGAResponse
     */
    public function describeLivePrivateLineAvailGA($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLivePrivateLineAvailGAWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the production studio usage data.
     *  *
     * @description The minimum time granularity for a query is 1 hour. The maximum time range for a query is 31 days. You can query the production studio usage data in the last 90 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveProducerUsageDataRequest $request DescribeLiveProducerUsageDataRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveProducerUsageDataResponse DescribeLiveProducerUsageDataResponse
     */
    public function describeLiveProducerUsageDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->instance)) {
            $query['Instance'] = $request->instance;
        }
        if (!Utils::isUnset($request->interval)) {
            $query['Interval'] = $request->interval;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->region)) {
            $query['Region'] = $request->region;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->splitBy)) {
            $query['SplitBy'] = $request->splitBy;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->app)) {
            $query['app'] = $request->app;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveProducerUsageData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveProducerUsageDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the production studio usage data.
     *  *
     * @description The minimum time granularity for a query is 1 hour. The maximum time range for a query is 31 days. You can query the production studio usage data in the last 90 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveProducerUsageDataRequest $request DescribeLiveProducerUsageDataRequest
     *
     * @return DescribeLiveProducerUsageDataResponse DescribeLiveProducerUsageDataResponse
     */
    public function describeLiveProducerUsageData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveProducerUsageDataWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the stream pulling configurations for a domain name.
     *  *
     * @description ##
     * This operation is applicable to regular stream pulling. You can call this operation to query the regular stream pulling configurations for a domain name.
     * ## QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLivePullStreamConfigRequest $request DescribeLivePullStreamConfigRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLivePullStreamConfigResponse DescribeLivePullStreamConfigResponse
     */
    public function describeLivePullStreamConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLivePullStreamConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLivePullStreamConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the stream pulling configurations for a domain name.
     *  *
     * @description ##
     * This operation is applicable to regular stream pulling. You can call this operation to query the regular stream pulling configurations for a domain name.
     * ## QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLivePullStreamConfigRequest $request DescribeLivePullStreamConfigRequest
     *
     * @return DescribeLivePullStreamConfigResponse DescribeLivePullStreamConfigResponse
     */
    public function describeLivePullStreamConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLivePullStreamConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries pulled-stream relay tasks.
     *  *
     * @description *   You can call this operation to query the information about a pulled-stream relay task.
     * *   This operation allows you to query the configurations and status of a task with a specified ID.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLivePullToPushRequest $request DescribeLivePullToPushRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLivePullToPushResponse DescribeLivePullToPushResponse
     */
    public function describeLivePullToPushWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLivePullToPush',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLivePullToPushResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries pulled-stream relay tasks.
     *  *
     * @description *   You can call this operation to query the information about a pulled-stream relay task.
     * *   This operation allows you to query the configurations and status of a task with a specified ID.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLivePullToPushRequest $request DescribeLivePullToPushRequest
     *
     * @return DescribeLivePullToPushResponse DescribeLivePullToPushResponse
     */
    public function describeLivePullToPush($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLivePullToPushWithOptions($request, $runtime);
    }

    /**
     * @summary Queries pulled-stream relay tasks. Fuzzy match is supported.
     *  *
     * @description *   You can call this operation to query pulled-stream relay tasks.
     * *   You can query tasks by page. Fuzzy search is supported based on task IDs, task names, and destination URLs.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLivePullToPushListRequest $request DescribeLivePullToPushListRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLivePullToPushListResponse DescribeLivePullToPushListResponse
     */
    public function describeLivePullToPushListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLivePullToPushList',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLivePullToPushListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries pulled-stream relay tasks. Fuzzy match is supported.
     *  *
     * @description *   You can call this operation to query pulled-stream relay tasks.
     * *   You can query tasks by page. Fuzzy search is supported based on task IDs, task names, and destination URLs.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLivePullToPushListRequest $request DescribeLivePullToPushListRequest
     *
     * @return DescribeLivePullToPushListResponse DescribeLivePullToPushListResponse
     */
    public function describeLivePullToPushList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLivePullToPushListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the stream relay logs, which are available for download.
     *  *
     * @description *   The time granularity of the data is 1 hour.
     * *   You can query data in the last 31 days.
     * *   If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLivePushProxyLogRequest $request DescribeLivePushProxyLogRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLivePushProxyLogResponse DescribeLivePushProxyLogResponse
     */
    public function describeLivePushProxyLogWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLivePushProxyLog',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLivePushProxyLogResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the stream relay logs, which are available for download.
     *  *
     * @description *   The time granularity of the data is 1 hour.
     * *   You can query data in the last 31 days.
     * *   If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLivePushProxyLogRequest $request DescribeLivePushProxyLogRequest
     *
     * @return DescribeLivePushProxyLogResponse DescribeLivePushProxyLogResponse
     */
    public function describeLivePushProxyLog($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLivePushProxyLogWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the usage data of live center stream relay.
     *  *
     * @description *   You can call this operation to query the usage data of live center stream relay.
     * *   The maximum time range for a query is 31 days.
     * *   The minimum time granularity for a query is 1 day.
     * *   You can query the data in the last 90 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLivePushProxyUsageDataRequest $request DescribeLivePushProxyUsageDataRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLivePushProxyUsageDataResponse DescribeLivePushProxyUsageDataResponse
     */
    public function describeLivePushProxyUsageDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->region)) {
            $query['Region'] = $request->region;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->splitBy)) {
            $query['SplitBy'] = $request->splitBy;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLivePushProxyUsageData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLivePushProxyUsageDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the usage data of live center stream relay.
     *  *
     * @description *   You can call this operation to query the usage data of live center stream relay.
     * *   The maximum time range for a query is 31 days.
     * *   The minimum time granularity for a query is 1 day.
     * *   You can query the data in the last 90 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLivePushProxyUsageDataRequest $request DescribeLivePushProxyUsageDataRequest
     *
     * @return DescribeLivePushProxyUsageDataResponse DescribeLivePushProxyUsageDataResponse
     */
    public function describeLivePushProxyUsageData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLivePushProxyUsageDataWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the number of real-time log deliveries.
     *  *
     * @description *   You can collect statistics on the number of real-time log deliveries. The number of failed real-time log deliveries and the number of successful real-time log deliveries are counted.
     * *   You can query the data by UID.
     * *   You are charged for both successful and failed real-time log deliveries.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveRealtimeDeliveryAccRequest $request DescribeLiveRealtimeDeliveryAccRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveRealtimeDeliveryAccResponse DescribeLiveRealtimeDeliveryAccResponse
     */
    public function describeLiveRealtimeDeliveryAccWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->interval)) {
            $query['Interval'] = $request->interval;
        }
        if (!Utils::isUnset($request->logStore)) {
            $query['LogStore'] = $request->logStore;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->project)) {
            $query['Project'] = $request->project;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveRealtimeDeliveryAcc',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveRealtimeDeliveryAccResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the number of real-time log deliveries.
     *  *
     * @description *   You can collect statistics on the number of real-time log deliveries. The number of failed real-time log deliveries and the number of successful real-time log deliveries are counted.
     * *   You can query the data by UID.
     * *   You are charged for both successful and failed real-time log deliveries.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveRealtimeDeliveryAccRequest $request DescribeLiveRealtimeDeliveryAccRequest
     *
     * @return DescribeLiveRealtimeDeliveryAccResponse DescribeLiveRealtimeDeliveryAccResponse
     */
    public function describeLiveRealtimeDeliveryAcc($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveRealtimeDeliveryAccWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the status of authorization for real-time log delivery.
     *  *
     * @description You can call this operation to query the status of authorization for real-time log delivery.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveRealtimeLogAuthorizedRequest $request DescribeLiveRealtimeLogAuthorizedRequest
     * @param RuntimeOptions                           $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveRealtimeLogAuthorizedResponse DescribeLiveRealtimeLogAuthorizedResponse
     */
    public function describeLiveRealtimeLogAuthorizedWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveRealtimeLogAuthorized',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveRealtimeLogAuthorizedResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the status of authorization for real-time log delivery.
     *  *
     * @description You can call this operation to query the status of authorization for real-time log delivery.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveRealtimeLogAuthorizedRequest $request DescribeLiveRealtimeLogAuthorizedRequest
     *
     * @return DescribeLiveRealtimeLogAuthorizedResponse DescribeLiveRealtimeLogAuthorizedResponse
     */
    public function describeLiveRealtimeLogAuthorized($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveRealtimeLogAuthorizedWithOptions($request, $runtime);
    }

    /**
     * @summary Queries all recording configurations of an application for a streaming domain.
     *  *
     * @description Obtain the main streaming domain, and then call this operation to query the recording configurations of all applications under the main streaming domain.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveRecordConfigRequest $request DescribeLiveRecordConfigRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveRecordConfigResponse DescribeLiveRecordConfigResponse
     */
    public function describeLiveRecordConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->order)) {
            $query['Order'] = $request->order;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNum)) {
            $query['PageNum'] = $request->pageNum;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveRecordConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveRecordConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries all recording configurations of an application for a streaming domain.
     *  *
     * @description Obtain the main streaming domain, and then call this operation to query the recording configurations of all applications under the main streaming domain.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveRecordConfigRequest $request DescribeLiveRecordConfigRequest
     *
     * @return DescribeLiveRecordConfigResponse DescribeLiveRecordConfigResponse
     */
    public function describeLiveRecordConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveRecordConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configuration of callbacks for live stream recording under a domain name.
     *  *
     * @description Obtain the main streaming domain, and then call this operation to query the configuration of callbacks for live stream recording under the domain name.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveRecordNotifyConfigRequest $request DescribeLiveRecordNotifyConfigRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveRecordNotifyConfigResponse DescribeLiveRecordNotifyConfigResponse
     */
    public function describeLiveRecordNotifyConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveRecordNotifyConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveRecordNotifyConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configuration of callbacks for live stream recording under a domain name.
     *  *
     * @description Obtain the main streaming domain, and then call this operation to query the configuration of callbacks for live stream recording under the domain name.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveRecordNotifyConfigRequest $request DescribeLiveRecordNotifyConfigRequest
     *
     * @return DescribeLiveRecordNotifyConfigResponse DescribeLiveRecordNotifyConfigResponse
     */
    public function describeLiveRecordNotifyConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveRecordNotifyConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the recording callback records that are stored in Object Storage Service (OSS).
     *  *
     * @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveRecordNotifyRecordsRequest $request DescribeLiveRecordNotifyRecordsRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveRecordNotifyRecordsResponse DescribeLiveRecordNotifyRecordsResponse
     */
    public function describeLiveRecordNotifyRecordsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveRecordNotifyRecords',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveRecordNotifyRecordsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the recording callback records that are stored in Object Storage Service (OSS).
     *  *
     * @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveRecordNotifyRecordsRequest $request DescribeLiveRecordNotifyRecordsRequest
     *
     * @return DescribeLiveRecordNotifyRecordsResponse DescribeLiveRecordNotifyRecordsResponse
     */
    public function describeLiveRecordNotifyRecords($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveRecordNotifyRecordsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries Live-to-VOD configurations.
     *  *
     * @description ## [](#)Usage notes
     * Obtain the streaming domain, and then call this operation to query the Live-to-VOD configurations.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveRecordVodConfigsRequest $request DescribeLiveRecordVodConfigsRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveRecordVodConfigsResponse DescribeLiveRecordVodConfigsResponse
     */
    public function describeLiveRecordVodConfigsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNum)) {
            $query['PageNum'] = $request->pageNum;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveRecordVodConfigs',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveRecordVodConfigsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries Live-to-VOD configurations.
     *  *
     * @description ## [](#)Usage notes
     * Obtain the streaming domain, and then call this operation to query the Live-to-VOD configurations.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveRecordVodConfigsRequest $request DescribeLiveRecordVodConfigsRequest
     *
     * @return DescribeLiveRecordVodConfigsResponse DescribeLiveRecordVodConfigsResponse
     */
    public function describeLiveRecordVodConfigs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveRecordVodConfigsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the time shifting configurations under a domain name.
     *  *
     * @description This operation is applicable to the streaming domains.
     * ## QPS limit
     * A single user can perform a maximum of 10 queries per second (QPS). Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
     *  *
     * @param DescribeLiveShiftConfigsRequest $request DescribeLiveShiftConfigsRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveShiftConfigsResponse DescribeLiveShiftConfigsResponse
     */
    public function describeLiveShiftConfigsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveShiftConfigs',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveShiftConfigsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the time shifting configurations under a domain name.
     *  *
     * @description This operation is applicable to the streaming domains.
     * ## QPS limit
     * A single user can perform a maximum of 10 queries per second (QPS). Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
     *  *
     * @param DescribeLiveShiftConfigsRequest $request DescribeLiveShiftConfigsRequest
     *
     * @return DescribeLiveShiftConfigsResponse DescribeLiveShiftConfigsResponse
     */
    public function describeLiveShiftConfigs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveShiftConfigsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the snapshot configurations of a streaming domain.
     *  *
     * @description Obtain the main streaming domain, and then call this operation to query the snapshot configurations.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveSnapshotConfigRequest $request DescribeLiveSnapshotConfigRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveSnapshotConfigResponse DescribeLiveSnapshotConfigResponse
     */
    public function describeLiveSnapshotConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->order)) {
            $query['Order'] = $request->order;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNum)) {
            $query['PageNum'] = $request->pageNum;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveSnapshotConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveSnapshotConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the snapshot configurations of a streaming domain.
     *  *
     * @description Obtain the main streaming domain, and then call this operation to query the snapshot configurations.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveSnapshotConfigRequest $request DescribeLiveSnapshotConfigRequest
     *
     * @return DescribeLiveSnapshotConfigResponse DescribeLiveSnapshotConfigResponse
     */
    public function describeLiveSnapshotConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveSnapshotConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries video moderation configurations.
     *  *
     * @description *   Obtain the main streaming domain, and then call this operation to query video moderation configurations. The configurations can be sorted in ascending or descending order.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveSnapshotDetectPornConfigRequest $request DescribeLiveSnapshotDetectPornConfigRequest
     * @param RuntimeOptions                              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveSnapshotDetectPornConfigResponse DescribeLiveSnapshotDetectPornConfigResponse
     */
    public function describeLiveSnapshotDetectPornConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->order)) {
            $query['Order'] = $request->order;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNum)) {
            $query['PageNum'] = $request->pageNum;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveSnapshotDetectPornConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveSnapshotDetectPornConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries video moderation configurations.
     *  *
     * @description *   Obtain the main streaming domain, and then call this operation to query video moderation configurations. The configurations can be sorted in ascending or descending order.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveSnapshotDetectPornConfigRequest $request DescribeLiveSnapshotDetectPornConfigRequest
     *
     * @return DescribeLiveSnapshotDetectPornConfigResponse DescribeLiveSnapshotDetectPornConfigResponse
     */
    public function describeLiveSnapshotDetectPornConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveSnapshotDetectPornConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configuration of snapshot callbacks.
     *  *
     * @description You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveSnapshotNotifyConfigRequest $request DescribeLiveSnapshotNotifyConfigRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveSnapshotNotifyConfigResponse DescribeLiveSnapshotNotifyConfigResponse
     */
    public function describeLiveSnapshotNotifyConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveSnapshotNotifyConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveSnapshotNotifyConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configuration of snapshot callbacks.
     *  *
     * @description You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveSnapshotNotifyConfigRequest $request DescribeLiveSnapshotNotifyConfigRequest
     *
     * @return DescribeLiveSnapshotNotifyConfigResponse DescribeLiveSnapshotNotifyConfigResponse
     */
    public function describeLiveSnapshotNotifyConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveSnapshotNotifyConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the authentication status of an active stream.
     *  *
     * @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamAuthCheckingRequest $request DescribeLiveStreamAuthCheckingRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveStreamAuthCheckingResponse DescribeLiveStreamAuthCheckingResponse
     */
    public function describeLiveStreamAuthCheckingWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->url)) {
            $query['Url'] = $request->url;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamAuthChecking',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamAuthCheckingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the authentication status of an active stream.
     *  *
     * @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamAuthCheckingRequest $request DescribeLiveStreamAuthCheckingRequest
     *
     * @return DescribeLiveStreamAuthCheckingResponse DescribeLiveStreamAuthCheckingResponse
     */
    public function describeLiveStreamAuthChecking($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamAuthCheckingWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the frame rates and bitrates of a Real-Time Messaging Protocol (RTMP) stream within a specified time period. You can call this operation to query historical data.
     *  *
     * @description This operation allows you to query the frame rates and bitrates of an RTMP stream within a specified time period. You can call this operation to query historical data.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamBitRateDataRequest $request DescribeLiveStreamBitRateDataRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveStreamBitRateDataResponse DescribeLiveStreamBitRateDataResponse
     */
    public function describeLiveStreamBitRateDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamBitRateData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamBitRateDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the frame rates and bitrates of a Real-Time Messaging Protocol (RTMP) stream within a specified time period. You can call this operation to query historical data.
     *  *
     * @description This operation allows you to query the frame rates and bitrates of an RTMP stream within a specified time period. You can call this operation to query historical data.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamBitRateDataRequest $request DescribeLiveStreamBitRateDataRequest
     *
     * @return DescribeLiveStreamBitRateDataResponse DescribeLiveStreamBitRateDataResponse
     */
    public function describeLiveStreamBitRateData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamBitRateDataWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the numbers of online source streams and transcoded streams.
     *  *
     * @description Obtain the main streaming domain, and then call this operation to query the numbers of online source streams and transcoded streams. The streams that are returned by calling this operation are encoded in H.264 or H.265.
     * ## [](#qps-)QPS limit
     * You can call this operation once per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamCountRequest $request DescribeLiveStreamCountRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveStreamCountResponse DescribeLiveStreamCountResponse
     */
    public function describeLiveStreamCountWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamCount',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the numbers of online source streams and transcoded streams.
     *  *
     * @description Obtain the main streaming domain, and then call this operation to query the numbers of online source streams and transcoded streams. The streams that are returned by calling this operation are encoded in H.264 or H.265.
     * ## [](#qps-)QPS limit
     * You can call this operation once per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamCountRequest $request DescribeLiveStreamCountRequest
     *
     * @return DescribeLiveStreamCountResponse DescribeLiveStreamCountResponse
     */
    public function describeLiveStreamCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamCountWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the live streaming latency.
     *  *
     * @description Obtain the streaming domain, and then call this operation to query the live streaming latency.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamDelayConfigRequest $request DescribeLiveStreamDelayConfigRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveStreamDelayConfigResponse DescribeLiveStreamDelayConfigResponse
     */
    public function describeLiveStreamDelayConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamDelayConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamDelayConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the live streaming latency.
     *  *
     * @description Obtain the streaming domain, and then call this operation to query the live streaming latency.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamDelayConfigRequest $request DescribeLiveStreamDelayConfigRequest
     *
     * @return DescribeLiveStreamDelayConfigResponse DescribeLiveStreamDelayConfigResponse
     */
    public function describeLiveStreamDelayConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamDelayConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the audio and video frame rates and bitrates of a Real-Time Messaging Protocol (RTMP) stream.
     *  *
     * @description *   You can call this operation to query a set of audio and video frame rates and bitrates of an RTMP stream within a specified time range.
     * *   This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
     * *   You can query data in the last 90 days.
     * *   The data is delayed for 3 to 5 minutes.
     * *   The maximum time range that you can specify is 1 hour.
     *  *
     * @param DescribeLiveStreamDetailFrameRateAndBitRateDataRequest $request DescribeLiveStreamDetailFrameRateAndBitRateDataRequest
     * @param RuntimeOptions                                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveStreamDetailFrameRateAndBitRateDataResponse DescribeLiveStreamDetailFrameRateAndBitRateDataResponse
     */
    public function describeLiveStreamDetailFrameRateAndBitRateDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamDetailFrameRateAndBitRateData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamDetailFrameRateAndBitRateDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the audio and video frame rates and bitrates of a Real-Time Messaging Protocol (RTMP) stream.
     *  *
     * @description *   You can call this operation to query a set of audio and video frame rates and bitrates of an RTMP stream within a specified time range.
     * *   This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
     * *   You can query data in the last 90 days.
     * *   The data is delayed for 3 to 5 minutes.
     * *   The maximum time range that you can specify is 1 hour.
     *  *
     * @param DescribeLiveStreamDetailFrameRateAndBitRateDataRequest $request DescribeLiveStreamDetailFrameRateAndBitRateDataRequest
     *
     * @return DescribeLiveStreamDetailFrameRateAndBitRateDataResponse DescribeLiveStreamDetailFrameRateAndBitRateDataResponse
     */
    public function describeLiveStreamDetailFrameRateAndBitRateData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamDetailFrameRateAndBitRateDataWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the number of historical online users for a live stream.
     *  *
     * @description *   The data returned by this operation is delayed for an average of 2 to 5 minutes.
     * *   This operation queries the number of historical online users for only Flash Video (FLV) and Real-Time Messaging Protocol (RTMP) streams.
     * *   This operation does not query the number of viewers that are watching transcoded streams.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamHistoryUserNumRequest $request DescribeLiveStreamHistoryUserNumRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveStreamHistoryUserNumResponse DescribeLiveStreamHistoryUserNumResponse
     */
    public function describeLiveStreamHistoryUserNumWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamHistoryUserNum',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamHistoryUserNumResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the number of historical online users for a live stream.
     *  *
     * @description *   The data returned by this operation is delayed for an average of 2 to 5 minutes.
     * *   This operation queries the number of historical online users for only Flash Video (FLV) and Real-Time Messaging Protocol (RTMP) streams.
     * *   This operation does not query the number of viewers that are watching transcoded streams.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamHistoryUserNumRequest $request DescribeLiveStreamHistoryUserNumRequest
     *
     * @return DescribeLiveStreamHistoryUserNumResponse DescribeLiveStreamHistoryUserNumResponse
     */
    public function describeLiveStreamHistoryUserNum($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamHistoryUserNumWithOptions($request, $runtime);
    }

    /**
     * @summary Invoke DescribeLiveStreamMerge to query the primary-standby stream merging configuration.
     *  *
     * @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamMergeRequest $request DescribeLiveStreamMergeRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveStreamMergeResponse DescribeLiveStreamMergeResponse
     */
    public function describeLiveStreamMergeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->protocol)) {
            $query['Protocol'] = $request->protocol;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamMerge',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamMergeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Invoke DescribeLiveStreamMerge to query the primary-standby stream merging configuration.
     *  *
     * @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamMergeRequest $request DescribeLiveStreamMergeRequest
     *
     * @return DescribeLiveStreamMergeResponse DescribeLiveStreamMergeResponse
     */
    public function describeLiveStreamMerge($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamMergeWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the monitoring data of streams for a specified domain name. Up to 5,000 rows of data can be returned per call.
     *  *
     * @description If you call this operation to query the monitoring data of streams under a domain name for the first time, you must [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex) for backend configuration. Provide the following information in the ticket:
     * *   The domain name that you want to query
     * *   The maximum number of concurrent streams under the domain name
     * *   The maximum number of concurrent online users in each stream
     * *   The protocols used for the client requests
     * >  The review is expected to be completed within one business day after you submit the ticket.
     * ## [](#)Usage limits
     * *   By default, statistics on the number of viewers who watch streams over the HTTP Live Streaming (HLS) protocol cannot be collected.
     * *   You can specify only one domain name in each call.
     * *   The maximum time range to query is 24 hours.
     * *   The minimum data granularity to query is 1 minute.
     * *   You can query data in the last 31 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamMetricDetailDataRequest $request DescribeLiveStreamMetricDetailDataRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveStreamMetricDetailDataResponse DescribeLiveStreamMetricDetailDataResponse
     */
    public function describeLiveStreamMetricDetailDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->nextPageToken)) {
            $query['NextPageToken'] = $request->nextPageToken;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->protocol)) {
            $query['Protocol'] = $request->protocol;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamMetricDetailData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamMetricDetailDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the monitoring data of streams for a specified domain name. Up to 5,000 rows of data can be returned per call.
     *  *
     * @description If you call this operation to query the monitoring data of streams under a domain name for the first time, you must [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex) for backend configuration. Provide the following information in the ticket:
     * *   The domain name that you want to query
     * *   The maximum number of concurrent streams under the domain name
     * *   The maximum number of concurrent online users in each stream
     * *   The protocols used for the client requests
     * >  The review is expected to be completed within one business day after you submit the ticket.
     * ## [](#)Usage limits
     * *   By default, statistics on the number of viewers who watch streams over the HTTP Live Streaming (HLS) protocol cannot be collected.
     * *   You can specify only one domain name in each call.
     * *   The maximum time range to query is 24 hours.
     * *   The minimum data granularity to query is 1 minute.
     * *   You can query data in the last 31 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamMetricDetailDataRequest $request DescribeLiveStreamMetricDetailDataRequest
     *
     * @return DescribeLiveStreamMetricDetailDataResponse DescribeLiveStreamMetricDetailDataResponse
     */
    public function describeLiveStreamMetricDetailData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamMetricDetailDataWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the list of created monitoring sessions.
     *  *
     * @description [Create monitoring sessions](https://help.aliyun.com/document_detail/2848129.html) before you call this operation to query the monitoring session list. Make sure that the parameter settings meet the requirements.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamMonitorListRequest $request DescribeLiveStreamMonitorListRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveStreamMonitorListResponse DescribeLiveStreamMonitorListResponse
     */
    public function describeLiveStreamMonitorListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->monitorId)) {
            $query['MonitorId'] = $request->monitorId;
        }
        if (!Utils::isUnset($request->orderRule)) {
            $query['OrderRule'] = $request->orderRule;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNum)) {
            $query['PageNum'] = $request->pageNum;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamMonitorList',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamMonitorListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the list of created monitoring sessions.
     *  *
     * @description [Create monitoring sessions](https://help.aliyun.com/document_detail/2848129.html) before you call this operation to query the monitoring session list. Make sure that the parameter settings meet the requirements.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamMonitorListRequest $request DescribeLiveStreamMonitorListRequest
     *
     * @return DescribeLiveStreamMonitorListResponse DescribeLiveStreamMonitorListResponse
     */
    public function describeLiveStreamMonitorList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamMonitorListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries prefetch tasks in the last three days.
     *  *
     * @description You can call this operation to query prefetch tasks in the last three days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamPreloadTasksRequest $request DescribeLiveStreamPreloadTasksRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveStreamPreloadTasksResponse DescribeLiveStreamPreloadTasksResponse
     */
    public function describeLiveStreamPreloadTasksWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNum)) {
            $query['PageNum'] = $request->pageNum;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->playUrl)) {
            $query['PlayUrl'] = $request->playUrl;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamPreloadTasks',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamPreloadTasksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries prefetch tasks in the last three days.
     *  *
     * @description You can call this operation to query prefetch tasks in the last three days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamPreloadTasksRequest $request DescribeLiveStreamPreloadTasksRequest
     *
     * @return DescribeLiveStreamPreloadTasksResponse DescribeLiveStreamPreloadTasksResponse
     */
    public function describeLiveStreamPreloadTasks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamPreloadTasksWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the stream ingest data of a specified domain name at the application level and the stream level.
     *  *
     * @description *   You can query data of a single domain name in each request. If you specify multiple domain names, an error is returned.
     * *   The maximum time range to query is 24 hours.
     * *   The minimum data granularity to query is 1 minute.
     * *   You can query data in the last 31 days.
     * *   This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamPushMetricDetailDataRequest $request DescribeLiveStreamPushMetricDetailDataRequest
     * @param RuntimeOptions                                $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveStreamPushMetricDetailDataResponse DescribeLiveStreamPushMetricDetailDataResponse
     */
    public function describeLiveStreamPushMetricDetailDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->nextPageToken)) {
            $query['NextPageToken'] = $request->nextPageToken;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamPushMetricDetailData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamPushMetricDetailDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the stream ingest data of a specified domain name at the application level and the stream level.
     *  *
     * @description *   You can query data of a single domain name in each request. If you specify multiple domain names, an error is returned.
     * *   The maximum time range to query is 24 hours.
     * *   The minimum data granularity to query is 1 minute.
     * *   You can query data in the last 31 days.
     * *   This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamPushMetricDetailDataRequest $request DescribeLiveStreamPushMetricDetailDataRequest
     *
     * @return DescribeLiveStreamPushMetricDetailDataResponse DescribeLiveStreamPushMetricDetailDataResponse
     */
    public function describeLiveStreamPushMetricDetailData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamPushMetricDetailDataWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the recordings of a live stream.
     *  *
     * @description Obtain the main streaming domain, and then call this operation to query the recordings of the live stream.
     * ## QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
     *  *
     * @param DescribeLiveStreamRecordContentRequest $request DescribeLiveStreamRecordContentRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveStreamRecordContentResponse DescribeLiveStreamRecordContentResponse
     */
    public function describeLiveStreamRecordContentWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamRecordContent',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamRecordContentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the recordings of a live stream.
     *  *
     * @description Obtain the main streaming domain, and then call this operation to query the recordings of the live stream.
     * ## QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
     *  *
     * @param DescribeLiveStreamRecordContentRequest $request DescribeLiveStreamRecordContentRequest
     *
     * @return DescribeLiveStreamRecordContentResponse DescribeLiveStreamRecordContentResponse
     */
    public function describeLiveStreamRecordContent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamRecordContentWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about an index file.
     *  *
     * @description ApsaraVideo Live stores the information about M3U8 index files for six months. You can query the information about only the M3U8 index files that were created in the last six months. OSS stores M3U8 index files for a time period that is specified by the storage configuration in OSS.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamRecordIndexFileRequest $request DescribeLiveStreamRecordIndexFileRequest
     * @param RuntimeOptions                           $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveStreamRecordIndexFileResponse DescribeLiveStreamRecordIndexFileResponse
     */
    public function describeLiveStreamRecordIndexFileWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->recordId)) {
            $query['RecordId'] = $request->recordId;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamRecordIndexFile',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamRecordIndexFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about an index file.
     *  *
     * @description ApsaraVideo Live stores the information about M3U8 index files for six months. You can query the information about only the M3U8 index files that were created in the last six months. OSS stores M3U8 index files for a time period that is specified by the storage configuration in OSS.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamRecordIndexFileRequest $request DescribeLiveStreamRecordIndexFileRequest
     *
     * @return DescribeLiveStreamRecordIndexFileResponse DescribeLiveStreamRecordIndexFileResponse
     */
    public function describeLiveStreamRecordIndexFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamRecordIndexFileWithOptions($request, $runtime);
    }

    /**
     * @summary Queries all index files within a specific time period.
     *  *
     * @description *   ApsaraVideo Live stores the information about M3U8 index files for six months. You can query the information about only the M3U8 index files that were created in the last six months.
     * *   OSS stores M3U8 index files for a time period that is specified by the storage configuration in OSS.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamRecordIndexFilesRequest $request DescribeLiveStreamRecordIndexFilesRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveStreamRecordIndexFilesResponse DescribeLiveStreamRecordIndexFilesResponse
     */
    public function describeLiveStreamRecordIndexFilesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->order)) {
            $query['Order'] = $request->order;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNum)) {
            $query['PageNum'] = $request->pageNum;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamRecordIndexFiles',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamRecordIndexFilesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries all index files within a specific time period.
     *  *
     * @description *   ApsaraVideo Live stores the information about M3U8 index files for six months. You can query the information about only the M3U8 index files that were created in the last six months.
     * *   OSS stores M3U8 index files for a time period that is specified by the storage configuration in OSS.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamRecordIndexFilesRequest $request DescribeLiveStreamRecordIndexFilesRequest
     *
     * @return DescribeLiveStreamRecordIndexFilesResponse DescribeLiveStreamRecordIndexFilesResponse
     */
    public function describeLiveStreamRecordIndexFiles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamRecordIndexFilesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the snapshots that were captured within a specific time period.
     *  *
     * @description You can query only snapshots that were captured in the last year.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamSnapshotInfoRequest $request DescribeLiveStreamSnapshotInfoRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveStreamSnapshotInfoResponse DescribeLiveStreamSnapshotInfoResponse
     */
    public function describeLiveStreamSnapshotInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->limit)) {
            $query['Limit'] = $request->limit;
        }
        if (!Utils::isUnset($request->order)) {
            $query['Order'] = $request->order;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamSnapshotInfo',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamSnapshotInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the snapshots that were captured within a specific time period.
     *  *
     * @description You can query only snapshots that were captured in the last year.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamSnapshotInfoRequest $request DescribeLiveStreamSnapshotInfoRequest
     *
     * @return DescribeLiveStreamSnapshotInfoResponse DescribeLiveStreamSnapshotInfoResponse
     */
    public function describeLiveStreamSnapshotInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamSnapshotInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the status of a stream in real time.
     *  *
     * @description Obtain the streaming domain, and then call this operation to query the status of a stream in real time. If the stream is in the offline status, you can check the stream ingest callback to learn about the reason that causes the offline status. This operation does not provide detailed information.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamStateRequest $request DescribeLiveStreamStateRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveStreamStateResponse DescribeLiveStreamStateResponse
     */
    public function describeLiveStreamStateWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamState',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamStateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the status of a stream in real time.
     *  *
     * @description Obtain the streaming domain, and then call this operation to query the status of a stream in real time. If the stream is in the offline status, you can check the stream ingest callback to learn about the reason that causes the offline status. This operation does not provide detailed information.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamStateRequest $request DescribeLiveStreamStateRequest
     *
     * @return DescribeLiveStreamStateResponse DescribeLiveStreamStateResponse
     */
    public function describeLiveStreamState($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamStateWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the transcoding configurations of a streaming domain.
     *  *
     * @description Obtain the main streaming domain, and then call this operation to query the transcoding configurations.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamTranscodeInfoRequest $request DescribeLiveStreamTranscodeInfoRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveStreamTranscodeInfoResponse DescribeLiveStreamTranscodeInfoResponse
     */
    public function describeLiveStreamTranscodeInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainTranscodeName)) {
            $query['DomainTranscodeName'] = $request->domainTranscodeName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamTranscodeInfo',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamTranscodeInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the transcoding configurations of a streaming domain.
     *  *
     * @description Obtain the main streaming domain, and then call this operation to query the transcoding configurations.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamTranscodeInfoRequest $request DescribeLiveStreamTranscodeInfoRequest
     *
     * @return DescribeLiveStreamTranscodeInfoResponse DescribeLiveStreamTranscodeInfoResponse
     */
    public function describeLiveStreamTranscodeInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamTranscodeInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the transcoding data of a specified domain name at the application level and the stream level.
     *  *
     * @description *   The maximum time range for a query is 24 hours.
     * *   The minimum time granularity for a query is 5 minutes.
     * *   You can query data in the last 31 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamTranscodeMetricDataRequest $request DescribeLiveStreamTranscodeMetricDataRequest
     * @param RuntimeOptions                               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveStreamTranscodeMetricDataResponse DescribeLiveStreamTranscodeMetricDataResponse
     */
    public function describeLiveStreamTranscodeMetricDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->nextPageToken)) {
            $query['NextPageToken'] = $request->nextPageToken;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamTranscodeMetricData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamTranscodeMetricDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the transcoding data of a specified domain name at the application level and the stream level.
     *  *
     * @description *   The maximum time range for a query is 24 hours.
     * *   The minimum time granularity for a query is 5 minutes.
     * *   You can query data in the last 31 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamTranscodeMetricDataRequest $request DescribeLiveStreamTranscodeMetricDataRequest
     *
     * @return DescribeLiveStreamTranscodeMetricDataResponse DescribeLiveStreamTranscodeMetricDataResponse
     */
    public function describeLiveStreamTranscodeMetricData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamTranscodeMetricDataWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the number of transcoded streams in real time.
     *  *
     * @description You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamTranscodeStreamNumRequest $request DescribeLiveStreamTranscodeStreamNumRequest
     * @param RuntimeOptions                              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveStreamTranscodeStreamNumResponse DescribeLiveStreamTranscodeStreamNumResponse
     */
    public function describeLiveStreamTranscodeStreamNumWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->splitType)) {
            $query['SplitType'] = $request->splitType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamTranscodeStreamNum',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamTranscodeStreamNumResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the number of transcoded streams in real time.
     *  *
     * @description You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamTranscodeStreamNumRequest $request DescribeLiveStreamTranscodeStreamNumRequest
     *
     * @return DescribeLiveStreamTranscodeStreamNumResponse DescribeLiveStreamTranscodeStreamNumResponse
     */
    public function describeLiveStreamTranscodeStreamNum($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamTranscodeStreamNumWithOptions($request, $runtime);
    }

    /**
     * @summary Queries watermark rules.
     *  *
     * @description When you call this operation, you can specify the PageNumber and PageSize parameters to view watermark rules on separate pages. Make sure that the parameter settings meet the requirements.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamWatermarkRulesRequest $request DescribeLiveStreamWatermarkRulesRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveStreamWatermarkRulesResponse DescribeLiveStreamWatermarkRulesResponse
     */
    public function describeLiveStreamWatermarkRulesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domain)) {
            $query['Domain'] = $request->domain;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamWatermarkRules',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamWatermarkRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries watermark rules.
     *  *
     * @description When you call this operation, you can specify the PageNumber and PageSize parameters to view watermark rules on separate pages. Make sure that the parameter settings meet the requirements.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamWatermarkRulesRequest $request DescribeLiveStreamWatermarkRulesRequest
     *
     * @return DescribeLiveStreamWatermarkRulesResponse DescribeLiveStreamWatermarkRulesResponse
     */
    public function describeLiveStreamWatermarkRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamWatermarkRulesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries watermark templates.
     *  *
     * @description You can call this operation to query watermark templates. You can use the PageNumber parameter to view results on separate pages. Make sure that you configure parameters properly when you call this operation.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamWatermarksRequest $request DescribeLiveStreamWatermarksRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveStreamWatermarksResponse DescribeLiveStreamWatermarksResponse
     */
    public function describeLiveStreamWatermarksWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domain)) {
            $query['Domain'] = $request->domain;
        }
        if (!Utils::isUnset($request->keyWord)) {
            $query['KeyWord'] = $request->keyWord;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamWatermarks',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamWatermarksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries watermark templates.
     *  *
     * @description You can call this operation to query watermark templates. You can use the PageNumber parameter to view results on separate pages. Make sure that you configure parameters properly when you call this operation.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamWatermarksRequest $request DescribeLiveStreamWatermarksRequest
     *
     * @return DescribeLiveStreamWatermarksResponse DescribeLiveStreamWatermarksResponse
     */
    public function describeLiveStreamWatermarks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamWatermarksWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the blacklist of live stream URLs under a main streaming domain.
     *  *
     * @description The stream URLs refer to the URLs for playing in particular.
     * ## QPS limit
     * A single user can perform a maximum of 50 queries per second (QPS). Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
     *  *
     * @param DescribeLiveStreamsBlockListRequest $request DescribeLiveStreamsBlockListRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveStreamsBlockListResponse DescribeLiveStreamsBlockListResponse
     */
    public function describeLiveStreamsBlockListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNum)) {
            $query['PageNum'] = $request->pageNum;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamsBlockList',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamsBlockListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the blacklist of live stream URLs under a main streaming domain.
     *  *
     * @description The stream URLs refer to the URLs for playing in particular.
     * ## QPS limit
     * A single user can perform a maximum of 50 queries per second (QPS). Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
     *  *
     * @param DescribeLiveStreamsBlockListRequest $request DescribeLiveStreamsBlockListRequest
     *
     * @return DescribeLiveStreamsBlockListResponse DescribeLiveStreamsBlockListResponse
     */
    public function describeLiveStreamsBlockList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamsBlockListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the operation history of live streams under a domain name or in an application.
     *  *
     * @description You can call this operation to query the operation history of live streams under a domain name or in an application. The operations include all API operations that were called on live streams.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamsControlHistoryRequest $request DescribeLiveStreamsControlHistoryRequest
     * @param RuntimeOptions                           $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveStreamsControlHistoryResponse DescribeLiveStreamsControlHistoryResponse
     */
    public function describeLiveStreamsControlHistoryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamsControlHistory',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamsControlHistoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the operation history of live streams under a domain name or in an application.
     *  *
     * @description You can call this operation to query the operation history of live streams under a domain name or in an application. The operations include all API operations that were called on live streams.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamsControlHistoryRequest $request DescribeLiveStreamsControlHistoryRequest
     *
     * @return DescribeLiveStreamsControlHistoryResponse DescribeLiveStreamsControlHistoryResponse
     */
    public function describeLiveStreamsControlHistory($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamsControlHistoryWithOptions($request, $runtime);
    }

    /**
     * @summary Queries stream ingest callback records.
     *  *
     * @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamsNotifyRecordsRequest $request DescribeLiveStreamsNotifyRecordsRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveStreamsNotifyRecordsResponse DescribeLiveStreamsNotifyRecordsResponse
     */
    public function describeLiveStreamsNotifyRecordsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamsNotifyRecords',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamsNotifyRecordsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries stream ingest callback records.
     *  *
     * @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamsNotifyRecordsRequest $request DescribeLiveStreamsNotifyRecordsRequest
     *
     * @return DescribeLiveStreamsNotifyRecordsResponse DescribeLiveStreamsNotifyRecordsResponse
     */
    public function describeLiveStreamsNotifyRecords($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamsNotifyRecordsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the callback configuration for stream ingest under an ingest domain.
     *  *
     * @param DescribeLiveStreamsNotifyUrlConfigRequest $request DescribeLiveStreamsNotifyUrlConfigRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveStreamsNotifyUrlConfigResponse DescribeLiveStreamsNotifyUrlConfigResponse
     */
    public function describeLiveStreamsNotifyUrlConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamsNotifyUrlConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamsNotifyUrlConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the callback configuration for stream ingest under an ingest domain.
     *  *
     * @param DescribeLiveStreamsNotifyUrlConfigRequest $request DescribeLiveStreamsNotifyUrlConfigRequest
     *
     * @return DescribeLiveStreamsNotifyUrlConfigResponse DescribeLiveStreamsNotifyUrlConfigResponse
     */
    public function describeLiveStreamsNotifyUrlConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamsNotifyUrlConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about all active streams under a specified domain name or the active streams of an application under a specified domain name.
     *  *
     * @description You can call this operation to query the following types of streams.
     * *   all: all streams.
     * *   raw: source streams.
     * *   trans: transcoded streams.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamsOnlineListRequest $request DescribeLiveStreamsOnlineListRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveStreamsOnlineListResponse DescribeLiveStreamsOnlineListResponse
     */
    public function describeLiveStreamsOnlineListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->onlyStream)) {
            $query['OnlyStream'] = $request->onlyStream;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNum)) {
            $query['PageNum'] = $request->pageNum;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->queryType)) {
            $query['QueryType'] = $request->queryType;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        if (!Utils::isUnset($request->streamType)) {
            $query['StreamType'] = $request->streamType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamsOnlineList',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamsOnlineListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about all active streams under a specified domain name or the active streams of an application under a specified domain name.
     *  *
     * @description You can call this operation to query the following types of streams.
     * *   all: all streams.
     * *   raw: source streams.
     * *   trans: transcoded streams.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamsOnlineListRequest $request DescribeLiveStreamsOnlineListRequest
     *
     * @return DescribeLiveStreamsOnlineListResponse DescribeLiveStreamsOnlineListResponse
     */
    public function describeLiveStreamsOnlineList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamsOnlineListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the stream ingest records of a domain name or an application or stream under a domain name.
     *  *
     * @description ## [](#)Usage notes
     * This operation allows you to query streams in the last 30 days. The information of active streams during the queried period is returned. This operation supports the following sorting methods.
     * *   stream_name_desc: sorts the entries in descending order by stream name.
     * *   stream_name_asc: sorts the entries in ascending order by stream name.
     * *   publish_time_desc: sorts the entries in descending order by stream ingest time.
     * *   publish_time_asc: sorts the entries in ascending order by stream ingest time.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 3 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveStreamsPublishListRequest $request DescribeLiveStreamsPublishListRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveStreamsPublishListResponse DescribeLiveStreamsPublishListResponse
     */
    public function describeLiveStreamsPublishListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->orderBy)) {
            $query['OrderBy'] = $request->orderBy;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->queryType)) {
            $query['QueryType'] = $request->queryType;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        if (!Utils::isUnset($request->streamType)) {
            $query['StreamType'] = $request->streamType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamsPublishList',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamsPublishListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the stream ingest records of a domain name or an application or stream under a domain name.
     *  *
     * @description ## [](#)Usage notes
     * This operation allows you to query streams in the last 30 days. The information of active streams during the queried period is returned. This operation supports the following sorting methods.
     * *   stream_name_desc: sorts the entries in descending order by stream name.
     * *   stream_name_asc: sorts the entries in ascending order by stream name.
     * *   publish_time_desc: sorts the entries in descending order by stream ingest time.
     * *   publish_time_asc: sorts the entries in ascending order by stream ingest time.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 3 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveStreamsPublishListRequest $request DescribeLiveStreamsPublishListRequest
     *
     * @return DescribeLiveStreamsPublishListResponse DescribeLiveStreamsPublishListResponse
     */
    public function describeLiveStreamsPublishList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamsPublishListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the total number of live streams within a specified time range. Data is collected on a daily basis.
     *  *
     * @description *   The maximum time range for a query is 15 days.
     * *   You can query data in the last 18 months.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamsTotalCountRequest $request DescribeLiveStreamsTotalCountRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveStreamsTotalCountResponse DescribeLiveStreamsTotalCountResponse
     */
    public function describeLiveStreamsTotalCountWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->typ)) {
            $query['Typ'] = $request->typ;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamsTotalCount',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamsTotalCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the total number of live streams within a specified time range. Data is collected on a daily basis.
     *  *
     * @description *   The maximum time range for a query is 15 days.
     * *   You can query data in the last 18 months.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveStreamsTotalCountRequest $request DescribeLiveStreamsTotalCountRequest
     *
     * @return DescribeLiveStreamsTotalCountResponse DescribeLiveStreamsTotalCountResponse
     */
    public function describeLiveStreamsTotalCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamsTotalCountWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the top domain names ranked by traffic.
     *  *
     * @description *   If you do not specify the StartTime or EndTime parameter, data of the current month is queried by default. To query data within a specific time range, you must specify both the StartTime and EndTime parameters.
     * *   You can query data in the last 90 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveTopDomainsByFlowRequest $request DescribeLiveTopDomainsByFlowRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveTopDomainsByFlowResponse DescribeLiveTopDomainsByFlowResponse
     */
    public function describeLiveTopDomainsByFlowWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->limit)) {
            $query['Limit'] = $request->limit;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveTopDomainsByFlow',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveTopDomainsByFlowResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the top domain names ranked by traffic.
     *  *
     * @description *   If you do not specify the StartTime or EndTime parameter, data of the current month is queried by default. To query data within a specific time range, you must specify both the StartTime and EndTime parameters.
     * *   You can query data in the last 90 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeLiveTopDomainsByFlowRequest $request DescribeLiveTopDomainsByFlowRequest
     *
     * @return DescribeLiveTopDomainsByFlowResponse DescribeLiveTopDomainsByFlowResponse
     */
    public function describeLiveTopDomainsByFlow($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveTopDomainsByFlowWithOptions($request, $runtime);
    }

    /**
     * @summary 获取直播指定域名的原始访问日志的下载地址
     *  *
     * @param DescribeLiveTrafficDomainLogRequest $request DescribeLiveTrafficDomainLogRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveTrafficDomainLogResponse DescribeLiveTrafficDomainLogResponse
     */
    public function describeLiveTrafficDomainLogWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveTrafficDomainLog',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveTrafficDomainLogResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 获取直播指定域名的原始访问日志的下载地址
     *  *
     * @param DescribeLiveTrafficDomainLogRequest $request DescribeLiveTrafficDomainLogRequest
     *
     * @return DescribeLiveTrafficDomainLogResponse DescribeLiveTrafficDomainLogResponse
     */
    public function describeLiveTrafficDomainLog($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveTrafficDomainLogWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the audio and video data of an ingested stream within a specific period of time.
     *  *
     * @description ### Usage notes
     * - The maximum time range for a query is 24 hours.
     * - The minimum time range for a query is 1 hour.
     * - You can query data in the last 31 days.
     * ### QPS limit
     * You can call this operation up to 10 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveUpVideoAudioInfoRequest $request DescribeLiveUpVideoAudioInfoRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveUpVideoAudioInfoResponse DescribeLiveUpVideoAudioInfoResponse
     */
    public function describeLiveUpVideoAudioInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->stream)) {
            $query['Stream'] = $request->stream;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveUpVideoAudioInfo',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveUpVideoAudioInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the audio and video data of an ingested stream within a specific period of time.
     *  *
     * @description ### Usage notes
     * - The maximum time range for a query is 24 hours.
     * - The minimum time range for a query is 1 hour.
     * - You can query data in the last 31 days.
     * ### QPS limit
     * You can call this operation up to 10 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveUpVideoAudioInfoRequest $request DescribeLiveUpVideoAudioInfoRequest
     *
     * @return DescribeLiveUpVideoAudioInfoResponse DescribeLiveUpVideoAudioInfoResponse
     */
    public function describeLiveUpVideoAudioInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveUpVideoAudioInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the estimated bills of ApsaraVideo Live in your Alibaba Cloud account.
     *  *
     * @description You can call this operation to estimate resource usage of the current month based on the metering method that is specified on the first day of the month. You can call this operation to estimate resource usage of only the current month within your Alibaba Cloud account. The time range used for the estimation starts at 00:00 on the first day of the month and ends 2 hours earlier than the current time.
     * *   Pay by monthly 95th percentile bandwidth: The top 5% values between the start time and end time are excluded. The highest value among the remaining values is the estimated value.
     * *   Pay by average daily peak bandwidth per month: Estimated value = Sum of daily peak bandwidth values/Number of days. The current day is excluded.
     * *   Pay by 4th peak bandwidth per month: The estimated value is the 4th peak bandwidth value between the start time and end time. If the time range is less than four days, the estimated value is 0.
     * *   Pay by average daily 95th percentile bandwidth per month: Estimated value = Sum of daily 95th percentile bandwidth values/Number of days. The current day is excluded.
     * *   Pay by 95th percentile bandwidth with 50% off from 00:00 to 08:00: The top 5% values between the start time and end time are excluded. The highest value among the remaining values is the estimated value.
     * ## [](#qps-)QPS limit
     * You can call this operation once per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveUserBillPredictionRequest $request DescribeLiveUserBillPredictionRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveUserBillPredictionResponse DescribeLiveUserBillPredictionResponse
     */
    public function describeLiveUserBillPredictionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveUserBillPrediction',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveUserBillPredictionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the estimated bills of ApsaraVideo Live in your Alibaba Cloud account.
     *  *
     * @description You can call this operation to estimate resource usage of the current month based on the metering method that is specified on the first day of the month. You can call this operation to estimate resource usage of only the current month within your Alibaba Cloud account. The time range used for the estimation starts at 00:00 on the first day of the month and ends 2 hours earlier than the current time.
     * *   Pay by monthly 95th percentile bandwidth: The top 5% values between the start time and end time are excluded. The highest value among the remaining values is the estimated value.
     * *   Pay by average daily peak bandwidth per month: Estimated value = Sum of daily peak bandwidth values/Number of days. The current day is excluded.
     * *   Pay by 4th peak bandwidth per month: The estimated value is the 4th peak bandwidth value between the start time and end time. If the time range is less than four days, the estimated value is 0.
     * *   Pay by average daily 95th percentile bandwidth per month: Estimated value = Sum of daily 95th percentile bandwidth values/Number of days. The current day is excluded.
     * *   Pay by 95th percentile bandwidth with 50% off from 00:00 to 08:00: The top 5% values between the start time and end time are excluded. The highest value among the remaining values is the estimated value.
     * ## [](#qps-)QPS limit
     * You can call this operation once per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveUserBillPredictionRequest $request DescribeLiveUserBillPredictionRequest
     *
     * @return DescribeLiveUserBillPredictionResponse DescribeLiveUserBillPredictionResponse
     */
    public function describeLiveUserBillPrediction($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveUserBillPredictionWithOptions($request, $runtime);
    }

    /**
     * @summary Queries domain names of ApsaraVideo Live in your Alibaba Cloud account.
     *  *
     * @description ## [](#)Usage notes
     * You can call this operation to query all domain names of ApsaraVideo Live within your Alibaba Cloud account. The supported types of domain names are streaming domains and edge ingest domains.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveUserDomainsRequest $request DescribeLiveUserDomainsRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveUserDomainsResponse DescribeLiveUserDomainsResponse
     */
    public function describeLiveUserDomainsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->domainSearchType)) {
            $query['DomainSearchType'] = $request->domainSearchType;
        }
        if (!Utils::isUnset($request->domainStatus)) {
            $query['DomainStatus'] = $request->domainStatus;
        }
        if (!Utils::isUnset($request->liveDomainType)) {
            $query['LiveDomainType'] = $request->liveDomainType;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionName)) {
            $query['RegionName'] = $request->regionName;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveUserDomains',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveUserDomainsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries domain names of ApsaraVideo Live in your Alibaba Cloud account.
     *  *
     * @description ## [](#)Usage notes
     * You can call this operation to query all domain names of ApsaraVideo Live within your Alibaba Cloud account. The supported types of domain names are streaming domains and edge ingest domains.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeLiveUserDomainsRequest $request DescribeLiveUserDomainsRequest
     *
     * @return DescribeLiveUserDomainsResponse DescribeLiveUserDomainsResponse
     */
    public function describeLiveUserDomains($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveUserDomainsWithOptions($request, $runtime);
    }

    /**
     * @summary  查询指定域名流粒度批量数据
     *  *
     * @param DescribeLiveUserStreamMetricDataRequest $request DescribeLiveUserStreamMetricDataRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveUserStreamMetricDataResponse DescribeLiveUserStreamMetricDataResponse
     */
    public function describeLiveUserStreamMetricDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->protocol)) {
            $query['Protocol'] = $request->protocol;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveUserStreamMetricData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveUserStreamMetricDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary  查询指定域名流粒度批量数据
     *  *
     * @param DescribeLiveUserStreamMetricDataRequest $request DescribeLiveUserStreamMetricDataRequest
     *
     * @return DescribeLiveUserStreamMetricDataResponse DescribeLiveUserStreamMetricDataResponse
     */
    public function describeLiveUserStreamMetricData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveUserStreamMetricDataWithOptions($request, $runtime);
    }

    /**
     * @param DescribeLiveUserTagsRequest $request DescribeLiveUserTagsRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveUserTagsResponse DescribeLiveUserTagsResponse
     */
    public function describeLiveUserTagsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveUserTags',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveUserTagsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param DescribeLiveUserTagsRequest $request DescribeLiveUserTagsRequest
     *
     * @return DescribeLiveUserTagsResponse DescribeLiveUserTagsResponse
     */
    public function describeLiveUserTags($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveUserTagsWithOptions($request, $runtime);
    }

    /**
     * @summary 获取直播指定域名的原始访问日志的下载地址
     *  *
     * @param DescribeLiveUserTrafficLogRequest $request DescribeLiveUserTrafficLogRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveUserTrafficLogResponse DescribeLiveUserTrafficLogResponse
     */
    public function describeLiveUserTrafficLogWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveUserTrafficLog',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveUserTrafficLogResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 获取直播指定域名的原始访问日志的下载地址
     *  *
     * @param DescribeLiveUserTrafficLogRequest $request DescribeLiveUserTrafficLogRequest
     *
     * @return DescribeLiveUserTrafficLogResponse DescribeLiveUserTrafficLogResponse
     */
    public function describeLiveUserTrafficLog($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveUserTrafficLogWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the ownership verification content of a domain name.
     *  *
     * @description ## [](#)Usage notes
     * *   You can call this operation to query the ownership verification content of a single domain name.
     * *   You can call this operation up to 30 times per second per account.
     * *   When you call this operation, you need to specify a domain name as a request parameter.
     * *   After a successful call, the verification content and request ID are returned, which can be used for subsequent operations.
     *  *
     * @param DescribeLiveVerifyContentRequest $request DescribeLiveVerifyContentRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLiveVerifyContentResponse DescribeLiveVerifyContentResponse
     */
    public function describeLiveVerifyContentWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveVerifyContent',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveVerifyContentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the ownership verification content of a domain name.
     *  *
     * @description ## [](#)Usage notes
     * *   You can call this operation to query the ownership verification content of a single domain name.
     * *   You can call this operation up to 30 times per second per account.
     * *   When you call this operation, you need to specify a domain name as a request parameter.
     * *   After a successful call, the verification content and request ID are returned, which can be used for subsequent operations.
     *  *
     * @param DescribeLiveVerifyContentRequest $request DescribeLiveVerifyContentRequest
     *
     * @return DescribeLiveVerifyContentResponse DescribeLiveVerifyContentResponse
     */
    public function describeLiveVerifyContent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveVerifyContentWithOptions($request, $runtime);
    }

    /**
     * @summary DescribeMeterLiveBypassDuration
     *  *
     * @description ## [](#)Usage notes
     * *   The maximum time range for a query is 31 days.
     * *   The minimum time granularity for a query is 5 minutes.
     * *   You can query the data in the last 90 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeMeterLiveBypassDurationRequest $request DescribeMeterLiveBypassDurationRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeMeterLiveBypassDurationResponse DescribeMeterLiveBypassDurationResponse
     */
    public function describeMeterLiveBypassDurationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->interval)) {
            $query['Interval'] = $request->interval;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeMeterLiveBypassDuration',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeMeterLiveBypassDurationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary DescribeMeterLiveBypassDuration
     *  *
     * @description ## [](#)Usage notes
     * *   The maximum time range for a query is 31 days.
     * *   The minimum time granularity for a query is 5 minutes.
     * *   You can query the data in the last 90 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeMeterLiveBypassDurationRequest $request DescribeMeterLiveBypassDurationRequest
     *
     * @return DescribeMeterLiveBypassDurationResponse DescribeMeterLiveBypassDurationResponse
     */
    public function describeMeterLiveBypassDuration($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeMeterLiveBypassDurationWithOptions($request, $runtime);
    }

    /**
     * @summary Queries stream mixing tasks.
     *  *
     * @description You can call the [CreateMixStream](https://help.aliyun.com/document_detail/2848087.html) operation to create stream mixing tasks and then call this operation to query the list of stream mixing tasks.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeMixStreamListRequest $request DescribeMixStreamListRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeMixStreamListResponse DescribeMixStreamListResponse
     */
    public function describeMixStreamListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->mixStreamId)) {
            $query['MixStreamId'] = $request->mixStreamId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNo)) {
            $query['PageNo'] = $request->pageNo;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeMixStreamList',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeMixStreamListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries stream mixing tasks.
     *  *
     * @description You can call the [CreateMixStream](https://help.aliyun.com/document_detail/2848087.html) operation to create stream mixing tasks and then call this operation to query the list of stream mixing tasks.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeMixStreamListRequest $request DescribeMixStreamListRequest
     *
     * @return DescribeMixStreamListResponse DescribeMixStreamListResponse
     */
    public function describeMixStreamList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeMixStreamListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about the factors that cause latency of first frames within a specified period of time.
     *  *
     * @description You can call this operation to query the information about the factors that cause latency of first frames within a specified period of time. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
     *  *
     * @param DescribeRTSNativeSDKFirstFrameCostRequest $tmpReq  DescribeRTSNativeSDKFirstFrameCostRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeRTSNativeSDKFirstFrameCostResponse DescribeRTSNativeSDKFirstFrameCostResponse
     */
    public function describeRTSNativeSDKFirstFrameCostWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new DescribeRTSNativeSDKFirstFrameCostShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->domainNameList)) {
            $request->domainNameListShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->domainNameList, 'DomainNameList', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->dataInterval)) {
            $query['DataInterval'] = $request->dataInterval;
        }
        if (!Utils::isUnset($request->domainNameListShrink)) {
            $query['DomainNameList'] = $request->domainNameListShrink;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRTSNativeSDKFirstFrameCost',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRTSNativeSDKFirstFrameCostResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about the factors that cause latency of first frames within a specified period of time.
     *  *
     * @description You can call this operation to query the information about the factors that cause latency of first frames within a specified period of time. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
     *  *
     * @param DescribeRTSNativeSDKFirstFrameCostRequest $request DescribeRTSNativeSDKFirstFrameCostRequest
     *
     * @return DescribeRTSNativeSDKFirstFrameCostResponse DescribeRTSNativeSDKFirstFrameCostResponse
     */
    public function describeRTSNativeSDKFirstFrameCost($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRTSNativeSDKFirstFrameCostWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the average latency of first frames within a specified period of time.
     *  *
     * @description You can call this operation to query the average latency of first frames within a specified period of time. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
     *  *
     * @param DescribeRTSNativeSDKFirstFrameDelayRequest $tmpReq  DescribeRTSNativeSDKFirstFrameDelayRequest
     * @param RuntimeOptions                             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeRTSNativeSDKFirstFrameDelayResponse DescribeRTSNativeSDKFirstFrameDelayResponse
     */
    public function describeRTSNativeSDKFirstFrameDelayWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new DescribeRTSNativeSDKFirstFrameDelayShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->domainNameList)) {
            $request->domainNameListShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->domainNameList, 'DomainNameList', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->dataInterval)) {
            $query['DataInterval'] = $request->dataInterval;
        }
        if (!Utils::isUnset($request->domainNameListShrink)) {
            $query['DomainNameList'] = $request->domainNameListShrink;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRTSNativeSDKFirstFrameDelay',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRTSNativeSDKFirstFrameDelayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the average latency of first frames within a specified period of time.
     *  *
     * @description You can call this operation to query the average latency of first frames within a specified period of time. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
     *  *
     * @param DescribeRTSNativeSDKFirstFrameDelayRequest $request DescribeRTSNativeSDKFirstFrameDelayRequest
     *
     * @return DescribeRTSNativeSDKFirstFrameDelayResponse DescribeRTSNativeSDKFirstFrameDelayResponse
     */
    public function describeRTSNativeSDKFirstFrameDelay($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRTSNativeSDKFirstFrameDelayWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the causes of playback failures that occurred within a specified period of time. The causes are returned in the form of status codes.
     *  *
     * @description You can call this operation to query the causes of playback failures that occurred within a specified period of time. The causes are returned in the form of status codes. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
     *  *
     * @param DescribeRTSNativeSDKPlayFailStatusRequest $tmpReq  DescribeRTSNativeSDKPlayFailStatusRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeRTSNativeSDKPlayFailStatusResponse DescribeRTSNativeSDKPlayFailStatusResponse
     */
    public function describeRTSNativeSDKPlayFailStatusWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new DescribeRTSNativeSDKPlayFailStatusShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->domainNameList)) {
            $request->domainNameListShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->domainNameList, 'DomainNameList', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->dataInterval)) {
            $query['DataInterval'] = $request->dataInterval;
        }
        if (!Utils::isUnset($request->domainNameListShrink)) {
            $query['DomainNameList'] = $request->domainNameListShrink;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRTSNativeSDKPlayFailStatus',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRTSNativeSDKPlayFailStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the causes of playback failures that occurred within a specified period of time. The causes are returned in the form of status codes.
     *  *
     * @description You can call this operation to query the causes of playback failures that occurred within a specified period of time. The causes are returned in the form of status codes. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
     *  *
     * @param DescribeRTSNativeSDKPlayFailStatusRequest $request DescribeRTSNativeSDKPlayFailStatusRequest
     *
     * @return DescribeRTSNativeSDKPlayFailStatusResponse DescribeRTSNativeSDKPlayFailStatusResponse
     */
    public function describeRTSNativeSDKPlayFailStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRTSNativeSDKPlayFailStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the playback duration within a specified period of time.
     *  *
     * @description You can query the playback duration within a specified period of time. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
     *  *
     * @param DescribeRTSNativeSDKPlayTimeRequest $tmpReq  DescribeRTSNativeSDKPlayTimeRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeRTSNativeSDKPlayTimeResponse DescribeRTSNativeSDKPlayTimeResponse
     */
    public function describeRTSNativeSDKPlayTimeWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new DescribeRTSNativeSDKPlayTimeShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->domainNameList)) {
            $request->domainNameListShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->domainNameList, 'DomainNameList', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->dataInterval)) {
            $query['DataInterval'] = $request->dataInterval;
        }
        if (!Utils::isUnset($request->domainNameListShrink)) {
            $query['DomainNameList'] = $request->domainNameListShrink;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRTSNativeSDKPlayTime',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRTSNativeSDKPlayTimeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the playback duration within a specified period of time.
     *  *
     * @description You can query the playback duration within a specified period of time. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
     *  *
     * @param DescribeRTSNativeSDKPlayTimeRequest $request DescribeRTSNativeSDKPlayTimeRequest
     *
     * @return DescribeRTSNativeSDKPlayTimeResponse DescribeRTSNativeSDKPlayTimeResponse
     */
    public function describeRTSNativeSDKPlayTime($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRTSNativeSDKPlayTimeWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the total number of playbacks and the number of successful playbacks within a specified period of time.
     *  *
     * @description QPS limit You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
     *  *
     * @param DescribeRTSNativeSDKVvDataRequest $tmpReq  DescribeRTSNativeSDKVvDataRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeRTSNativeSDKVvDataResponse DescribeRTSNativeSDKVvDataResponse
     */
    public function describeRTSNativeSDKVvDataWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new DescribeRTSNativeSDKVvDataShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->domainNameList)) {
            $request->domainNameListShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->domainNameList, 'DomainNameList', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->dataInterval)) {
            $query['DataInterval'] = $request->dataInterval;
        }
        if (!Utils::isUnset($request->domainNameListShrink)) {
            $query['DomainNameList'] = $request->domainNameListShrink;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRTSNativeSDKVvData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRTSNativeSDKVvDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the total number of playbacks and the number of successful playbacks within a specified period of time.
     *  *
     * @description QPS limit You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
     *  *
     * @param DescribeRTSNativeSDKVvDataRequest $request DescribeRTSNativeSDKVvDataRequest
     *
     * @return DescribeRTSNativeSDKVvDataResponse DescribeRTSNativeSDKVvDataResponse
     */
    public function describeRTSNativeSDKVvData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRTSNativeSDKVvDataWithOptions($request, $runtime);
    }

    /**
     * @summary 查询rtc云端录制文件与任务信息
     *  *
     * @param DescribeRtcCloudRecordingFilesRequest $request DescribeRtcCloudRecordingFilesRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeRtcCloudRecordingFilesResponse DescribeRtcCloudRecordingFilesResponse
     */
    public function describeRtcCloudRecordingFilesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRtcCloudRecordingFiles',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRtcCloudRecordingFilesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询rtc云端录制文件与任务信息
     *  *
     * @param DescribeRtcCloudRecordingFilesRequest $request DescribeRtcCloudRecordingFilesRequest
     *
     * @return DescribeRtcCloudRecordingFilesResponse DescribeRtcCloudRecordingFilesResponse
     */
    public function describeRtcCloudRecordingFiles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRtcCloudRecordingFilesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about a subscription to mixed-stream relay events.
     *  *
     * @description ### Usage notes
     * - You can call this operation to query information about a subscription to mixed-stream relay events.
     * - Before you call this operation, make sure that you have called the CreateRtcMPUEventSub operation to create the subscription.
     * ### QPS limit
     * - You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeRtcMPUEventSubRequest $request DescribeRtcMPUEventSubRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeRtcMPUEventSubResponse DescribeRtcMPUEventSubResponse
     */
    public function describeRtcMPUEventSubWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRtcMPUEventSub',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRtcMPUEventSubResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about a subscription to mixed-stream relay events.
     *  *
     * @description ### Usage notes
     * - You can call this operation to query information about a subscription to mixed-stream relay events.
     * - Before you call this operation, make sure that you have called the CreateRtcMPUEventSub operation to create the subscription.
     * ### QPS limit
     * - You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeRtcMPUEventSubRequest $request DescribeRtcMPUEventSubRequest
     *
     * @return DescribeRtcMPUEventSubResponse DescribeRtcMPUEventSubResponse
     */
    public function describeRtcMPUEventSub($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRtcMPUEventSubWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of the episode list.
     *  *
     * @description You cannot call this operation if the episode list is empty. For information about how to add episodes to the episode list, see [AddShowIntoShowList](https://help.aliyun.com/document_detail/2848051.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeShowListRequest $request DescribeShowListRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeShowListResponse DescribeShowListResponse
     */
    public function describeShowListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeShowList',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeShowListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of the episode list.
     *  *
     * @description You cannot call this operation if the episode list is empty. For information about how to add episodes to the episode list, see [AddShowIntoShowList](https://help.aliyun.com/document_detail/2848051.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeShowListRequest $request DescribeShowListRequest
     *
     * @return DescribeShowListResponse DescribeShowListResponse
     */
    public function describeShowList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeShowListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries configurations of stream-level region blocking.
     *  *
     * @description Queries configurations of stream-level region blocking.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeStreamLocationBlockRequest $request DescribeStreamLocationBlockRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeStreamLocationBlockResponse DescribeStreamLocationBlockResponse
     */
    public function describeStreamLocationBlockWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->blockType)) {
            $query['BlockType'] = $request->blockType;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNum)) {
            $query['PageNum'] = $request->pageNum;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeStreamLocationBlock',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeStreamLocationBlockResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries configurations of stream-level region blocking.
     *  *
     * @description Queries configurations of stream-level region blocking.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DescribeStreamLocationBlockRequest $request DescribeStreamLocationBlockRequest
     *
     * @return DescribeStreamLocationBlockResponse DescribeStreamLocationBlockResponse
     */
    public function describeStreamLocationBlock($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeStreamLocationBlockWithOptions($request, $runtime);
    }

    /**
     * @summary Queries one or more layouts of a virtual studio.
     *  *
     * @description You must call the [AddStudioLayout](https://help.aliyun.com/document_detail/215388.html) operation to configure layouts for a virtual studio before you call this operation to query layouts.
     * ## QPS limits
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
     *  *
     * @param DescribeStudioLayoutsRequest $request DescribeStudioLayoutsRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeStudioLayoutsResponse DescribeStudioLayoutsResponse
     */
    public function describeStudioLayoutsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->layoutId)) {
            $query['LayoutId'] = $request->layoutId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeStudioLayouts',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeStudioLayoutsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries one or more layouts of a virtual studio.
     *  *
     * @description You must call the [AddStudioLayout](https://help.aliyun.com/document_detail/215388.html) operation to configure layouts for a virtual studio before you call this operation to query layouts.
     * ## QPS limits
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
     *  *
     * @param DescribeStudioLayoutsRequest $request DescribeStudioLayoutsRequest
     *
     * @return DescribeStudioLayoutsResponse DescribeStudioLayoutsResponse
     */
    public function describeStudioLayouts($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeStudioLayoutsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the stream pulling information about a live stream of a headline.
     *  *
     * @description You can call this operation to query the stream pulling information about a live stream of a headline.
     * ## [](#qps-)QPS limits
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeToutiaoLivePlayRequest $request DescribeToutiaoLivePlayRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeToutiaoLivePlayResponse DescribeToutiaoLivePlayResponse
     */
    public function describeToutiaoLivePlayWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->app)) {
            $query['App'] = $request->app;
        }
        if (!Utils::isUnset($request->domain)) {
            $query['Domain'] = $request->domain;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->stream)) {
            $query['Stream'] = $request->stream;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeToutiaoLivePlay',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeToutiaoLivePlayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the stream pulling information about a live stream of a headline.
     *  *
     * @description You can call this operation to query the stream pulling information about a live stream of a headline.
     * ## [](#qps-)QPS limits
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeToutiaoLivePlayRequest $request DescribeToutiaoLivePlayRequest
     *
     * @return DescribeToutiaoLivePlayResponse DescribeToutiaoLivePlayResponse
     */
    public function describeToutiaoLivePlay($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeToutiaoLivePlayWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the ingest information of a specified live stream that is ingested to Toutiao.
     *  *
     * @description You can call this operation to query the ingest information of a specified live stream that is ingested to Toutiao.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeToutiaoLivePublishRequest $request DescribeToutiaoLivePublishRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeToutiaoLivePublishResponse DescribeToutiaoLivePublishResponse
     */
    public function describeToutiaoLivePublishWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->app)) {
            $query['App'] = $request->app;
        }
        if (!Utils::isUnset($request->domain)) {
            $query['Domain'] = $request->domain;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->stream)) {
            $query['Stream'] = $request->stream;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeToutiaoLivePublish',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeToutiaoLivePublishResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the ingest information of a specified live stream that is ingested to Toutiao.
     *  *
     * @description You can call this operation to query the ingest information of a specified live stream that is ingested to Toutiao.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeToutiaoLivePublishRequest $request DescribeToutiaoLivePublishRequest
     *
     * @return DescribeToutiaoLivePublishResponse DescribeToutiaoLivePublishResponse
     */
    public function describeToutiaoLivePublish($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeToutiaoLivePublishWithOptions($request, $runtime);
    }

    /**
     * @summary 新增查询 uid 级别或域名app级别在线流
     *  *
     * @param DescribeUidOnlineStreamsRequest $request DescribeUidOnlineStreamsRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeUidOnlineStreamsResponse DescribeUidOnlineStreamsResponse
     */
    public function describeUidOnlineStreamsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeUidOnlineStreams',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeUidOnlineStreamsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 新增查询 uid 级别或域名app级别在线流
     *  *
     * @param DescribeUidOnlineStreamsRequest $request DescribeUidOnlineStreamsRequest
     *
     * @return DescribeUidOnlineStreamsResponse DescribeUidOnlineStreamsResponse
     */
    public function describeUidOnlineStreams($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUidOnlineStreamsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the daily peak inbound bandwidth.
     *  *
     * @description You can call this operation to query the daily peak inbound bandwidth.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeUpBpsPeakDataRequest $request DescribeUpBpsPeakDataRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeUpBpsPeakDataResponse DescribeUpBpsPeakDataResponse
     */
    public function describeUpBpsPeakDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->domainSwitch)) {
            $query['DomainSwitch'] = $request->domainSwitch;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeUpBpsPeakData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeUpBpsPeakDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the daily peak inbound bandwidth.
     *  *
     * @description You can call this operation to query the daily peak inbound bandwidth.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeUpBpsPeakDataRequest $request DescribeUpBpsPeakDataRequest
     *
     * @return DescribeUpBpsPeakDataResponse DescribeUpBpsPeakDataResponse
     */
    public function describeUpBpsPeakData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUpBpsPeakDataWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the daily peak inbound bandwidth of a leased line.
     *  *
     * @description You can call this operation to query the daily peak inbound bandwidth of a leased line.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeUpBpsPeakOfLineRequest $request DescribeUpBpsPeakOfLineRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeUpBpsPeakOfLineResponse DescribeUpBpsPeakOfLineResponse
     */
    public function describeUpBpsPeakOfLineWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->domainSwitch)) {
            $query['DomainSwitch'] = $request->domainSwitch;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->line)) {
            $query['Line'] = $request->line;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeUpBpsPeakOfLine',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeUpBpsPeakOfLineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the daily peak inbound bandwidth of a leased line.
     *  *
     * @description You can call this operation to query the daily peak inbound bandwidth of a leased line.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeUpBpsPeakOfLineRequest $request DescribeUpBpsPeakOfLineRequest
     *
     * @return DescribeUpBpsPeakOfLineResponse DescribeUpBpsPeakOfLineResponse
     */
    public function describeUpBpsPeakOfLine($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUpBpsPeakOfLineWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the daily peak number of concurrently ingested streams.
     *  *
     * @description You can call this operation to query the daily peak number of concurrently ingested streams.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeUpPeakPublishStreamDataRequest $request DescribeUpPeakPublishStreamDataRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeUpPeakPublishStreamDataResponse DescribeUpPeakPublishStreamDataResponse
     */
    public function describeUpPeakPublishStreamDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->domainSwitch)) {
            $query['DomainSwitch'] = $request->domainSwitch;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeUpPeakPublishStreamData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeUpPeakPublishStreamDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the daily peak number of concurrently ingested streams.
     *  *
     * @description You can call this operation to query the daily peak number of concurrently ingested streams.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param DescribeUpPeakPublishStreamDataRequest $request DescribeUpPeakPublishStreamDataRequest
     *
     * @return DescribeUpPeakPublishStreamDataResponse DescribeUpPeakPublishStreamDataResponse
     */
    public function describeUpPeakPublishStreamData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUpPeakPublishStreamDataWithOptions($request, $runtime);
    }

    /**
     * @summary Suspends real-time log delivery for one or more domain names.
     *  *
     * @description Obtain a domain name for which real-time log delivery is enabled, and then call this operation to suspend real-time log delivery for the domain name.
     * This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DisableLiveRealtimeLogDeliveryRequest $request DisableLiveRealtimeLogDeliveryRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DisableLiveRealtimeLogDeliveryResponse DisableLiveRealtimeLogDeliveryResponse
     */
    public function disableLiveRealtimeLogDeliveryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DisableLiveRealtimeLogDelivery',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DisableLiveRealtimeLogDeliveryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Suspends real-time log delivery for one or more domain names.
     *  *
     * @description Obtain a domain name for which real-time log delivery is enabled, and then call this operation to suspend real-time log delivery for the domain name.
     * This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DisableLiveRealtimeLogDeliveryRequest $request DisableLiveRealtimeLogDeliveryRequest
     *
     * @return DisableLiveRealtimeLogDeliveryResponse DisableLiveRealtimeLogDeliveryResponse
     */
    public function disableLiveRealtimeLogDelivery($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->disableLiveRealtimeLogDeliveryWithOptions($request, $runtime);
    }

    /**
     * @summary Dynamically updates a watermark.
     *  *
     * @description Dynamically updating a watermark means replacing the watermark template ID during live streaming. Before you call this operation to update a watermark, you must prepare the watermark template ID that is used for replacement. The watermark template ID is specified by the **TemplateId** parameter of this operation. You can call the [DescribeLiveStreamWatermarks](https://help.aliyun.com/document_detail/2848102.html) operation to obtain available watermark template IDs.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DynamicUpdateWaterMarkStreamRuleRequest $request DynamicUpdateWaterMarkStreamRuleRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return DynamicUpdateWaterMarkStreamRuleResponse DynamicUpdateWaterMarkStreamRuleResponse
     */
    public function dynamicUpdateWaterMarkStreamRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->app)) {
            $query['App'] = $request->app;
        }
        if (!Utils::isUnset($request->domain)) {
            $query['Domain'] = $request->domain;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->stream)) {
            $query['Stream'] = $request->stream;
        }
        if (!Utils::isUnset($request->templateId)) {
            $query['TemplateId'] = $request->templateId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'DynamicUpdateWaterMarkStreamRule',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DynamicUpdateWaterMarkStreamRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Dynamically updates a watermark.
     *  *
     * @description Dynamically updating a watermark means replacing the watermark template ID during live streaming. Before you call this operation to update a watermark, you must prepare the watermark template ID that is used for replacement. The watermark template ID is specified by the **TemplateId** parameter of this operation. You can call the [DescribeLiveStreamWatermarks](https://help.aliyun.com/document_detail/2848102.html) operation to obtain available watermark template IDs.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param DynamicUpdateWaterMarkStreamRuleRequest $request DynamicUpdateWaterMarkStreamRuleRequest
     *
     * @return DynamicUpdateWaterMarkStreamRuleResponse DynamicUpdateWaterMarkStreamRuleResponse
     */
    public function dynamicUpdateWaterMarkStreamRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dynamicUpdateWaterMarkStreamRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Edits an episode list.
     *  *
     * @description You can call this operation to update all configurations of episodes in an episode list or replace the episodes.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param EditPlaylistRequest $request EditPlaylistRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return EditPlaylistResponse EditPlaylistResponse
     */
    public function editPlaylistWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->programConfig)) {
            $query['ProgramConfig'] = $request->programConfig;
        }
        if (!Utils::isUnset($request->programId)) {
            $query['ProgramId'] = $request->programId;
        }
        if (!Utils::isUnset($request->programItems)) {
            $query['ProgramItems'] = $request->programItems;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'EditPlaylist',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return EditPlaylistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Edits an episode list.
     *  *
     * @description You can call this operation to update all configurations of episodes in an episode list or replace the episodes.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param EditPlaylistRequest $request EditPlaylistRequest
     *
     * @return EditPlaylistResponse EditPlaylistResponse
     */
    public function editPlaylist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->editPlaylistWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an editing task.
     *  *
     * @description You can call this operation to create an editing task by specifying the production studio ID and the episode ID. You will not receive a notification after the editing task is created. You can call the [GetEditingJobInfo](https://help.aliyun.com/document_detail/2848059.html) operation to query the status of the editing task.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param EditShowAndReplaceRequest $request EditShowAndReplaceRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return EditShowAndReplaceResponse EditShowAndReplaceResponse
     */
    public function editShowAndReplaceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->showId)) {
            $query['ShowId'] = $request->showId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->storageInfo)) {
            $query['StorageInfo'] = $request->storageInfo;
        }
        if (!Utils::isUnset($request->userData)) {
            $query['UserData'] = $request->userData;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'EditShowAndReplace',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return EditShowAndReplaceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an editing task.
     *  *
     * @description You can call this operation to create an editing task by specifying the production studio ID and the episode ID. You will not receive a notification after the editing task is created. You can call the [GetEditingJobInfo](https://help.aliyun.com/document_detail/2848059.html) operation to query the status of the editing task.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param EditShowAndReplaceRequest $request EditShowAndReplaceRequest
     *
     * @return EditShowAndReplaceResponse EditShowAndReplaceResponse
     */
    public function editShowAndReplace($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->editShowAndReplaceWithOptions($request, $runtime);
    }

    /**
     * @summary Switches a scene to the standby resource in a production studio.
     *  *
     * @description You can call this operation to switch a specified scene to the standby resource. Only a PGM scene is supported.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param EffectCasterUrgentRequest $request EffectCasterUrgentRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return EffectCasterUrgentResponse EffectCasterUrgentResponse
     */
    public function effectCasterUrgentWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->sceneId)) {
            $query['SceneId'] = $request->sceneId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'EffectCasterUrgent',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return EffectCasterUrgentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Switches a scene to the standby resource in a production studio.
     *  *
     * @description You can call this operation to switch a specified scene to the standby resource. Only a PGM scene is supported.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param EffectCasterUrgentRequest $request EffectCasterUrgentRequest
     *
     * @return EffectCasterUrgentResponse EffectCasterUrgentResponse
     */
    public function effectCasterUrgent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->effectCasterUrgentWithOptions($request, $runtime);
    }

    /**
     * @summary Updates the standby resource in a specified scene.
     *  *
     * @description Make sure that the resource is referenced by the scene.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param EffectCasterVideoResourceRequest $request EffectCasterVideoResourceRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return EffectCasterVideoResourceResponse EffectCasterVideoResourceResponse
     */
    public function effectCasterVideoResourceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceId)) {
            $query['ResourceId'] = $request->resourceId;
        }
        if (!Utils::isUnset($request->sceneId)) {
            $query['SceneId'] = $request->sceneId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'EffectCasterVideoResource',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return EffectCasterVideoResourceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates the standby resource in a specified scene.
     *  *
     * @description Make sure that the resource is referenced by the scene.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param EffectCasterVideoResourceRequest $request EffectCasterVideoResourceRequest
     *
     * @return EffectCasterVideoResourceResponse EffectCasterVideoResourceResponse
     */
    public function effectCasterVideoResource($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->effectCasterVideoResourceWithOptions($request, $runtime);
    }

    /**
     * @summary Enables real-time log delivery for one or more domain names.
     *  *
     * @description ##
     * This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
     * ## QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param EnableLiveRealtimeLogDeliveryRequest $request EnableLiveRealtimeLogDeliveryRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return EnableLiveRealtimeLogDeliveryResponse EnableLiveRealtimeLogDeliveryResponse
     */
    public function enableLiveRealtimeLogDeliveryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'EnableLiveRealtimeLogDelivery',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return EnableLiveRealtimeLogDeliveryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables real-time log delivery for one or more domain names.
     *  *
     * @description ##
     * This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
     * ## QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param EnableLiveRealtimeLogDeliveryRequest $request EnableLiveRealtimeLogDeliveryRequest
     *
     * @return EnableLiveRealtimeLogDeliveryResponse EnableLiveRealtimeLogDeliveryResponse
     */
    public function enableLiveRealtimeLogDelivery($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->enableLiveRealtimeLogDeliveryWithOptions($request, $runtime);
    }

    /**
     * @summary Disables a live stream. You can specify the time when the live stream is resumed.
     *  *
     * @description You can call this operation to disable a live stream and specify the time when the live stream is resumed. If the time is not specified, you can call the [ResumeLiveStream](https://help.aliyun.com/document_detail/2847831.html) operation to resume the live stream. This operation supports only the live streams ingested by streamers.
     * >
     * *   This operation disables a live stream by adding the stream to the blacklist. You can disable up to 10,000 live streams. If the limit is reached, you cannot disable any more live streams. Pay attention to the number of live streams that are disabled. You can call the [DescribeLiveStreamsBlockList](https://help.aliyun.com/document_detail/2847825.html) operation to query the number of live streams that are disabled.
     * *   An interrupted live stream is not added to the blacklist and does not occupy the quota.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ForbidLiveStreamRequest $request ForbidLiveStreamRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return ForbidLiveStreamResponse ForbidLiveStreamResponse
     */
    public function forbidLiveStreamWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->liveStreamType)) {
            $query['LiveStreamType'] = $request->liveStreamType;
        }
        if (!Utils::isUnset($request->oneshot)) {
            $query['Oneshot'] = $request->oneshot;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resumeTime)) {
            $query['ResumeTime'] = $request->resumeTime;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ForbidLiveStream',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ForbidLiveStreamResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Disables a live stream. You can specify the time when the live stream is resumed.
     *  *
     * @description You can call this operation to disable a live stream and specify the time when the live stream is resumed. If the time is not specified, you can call the [ResumeLiveStream](https://help.aliyun.com/document_detail/2847831.html) operation to resume the live stream. This operation supports only the live streams ingested by streamers.
     * >
     * *   This operation disables a live stream by adding the stream to the blacklist. You can disable up to 10,000 live streams. If the limit is reached, you cannot disable any more live streams. Pay attention to the number of live streams that are disabled. You can call the [DescribeLiveStreamsBlockList](https://help.aliyun.com/document_detail/2847825.html) operation to query the number of live streams that are disabled.
     * *   An interrupted live stream is not added to the blacklist and does not occupy the quota.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ForbidLiveStreamRequest $request ForbidLiveStreamRequest
     *
     * @return ForbidLiveStreamResponse ForbidLiveStreamResponse
     */
    public function forbidLiveStream($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->forbidLiveStreamWithOptions($request, $runtime);
    }

    /**
     * @summary Queries all custom stream mixing templates.
     *  *
     * @description You can call this operation to query all custom stream mixing templates. A list of template names and template configurations is returned.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param GetAllCustomTemplatesRequest $request GetAllCustomTemplatesRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetAllCustomTemplatesResponse GetAllCustomTemplatesResponse
     */
    public function getAllCustomTemplatesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->userId)) {
            $query['UserId'] = $request->userId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'GetAllCustomTemplates',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetAllCustomTemplatesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries all custom stream mixing templates.
     *  *
     * @description You can call this operation to query all custom stream mixing templates. A list of template names and template configurations is returned.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param GetAllCustomTemplatesRequest $request GetAllCustomTemplatesRequest
     *
     * @return GetAllCustomTemplatesResponse GetAllCustomTemplatesResponse
     */
    public function getAllCustomTemplates($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAllCustomTemplatesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a custom stream mixing template.
     *  *
     * @description Obtain the name of the custom stream mixing template, and then call this operation to query the information about the template.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param GetCustomTemplateRequest $request GetCustomTemplateRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return GetCustomTemplateResponse GetCustomTemplateResponse
     */
    public function getCustomTemplateWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->template)) {
            $query['Template'] = $request->template;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'GetCustomTemplate',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetCustomTemplateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a custom stream mixing template.
     *  *
     * @description Obtain the name of the custom stream mixing template, and then call this operation to query the information about the template.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param GetCustomTemplateRequest $request GetCustomTemplateRequest
     *
     * @return GetCustomTemplateResponse GetCustomTemplateResponse
     */
    public function getCustomTemplate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCustomTemplateWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of an edge transcoding task.
     *  *
     * @description To call this operation, make sure that you have the permissions to access the edge transcoding feature.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param GetEdgeTranscodeJobRequest $request GetEdgeTranscodeJobRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return GetEdgeTranscodeJobResponse GetEdgeTranscodeJobResponse
     */
    public function getEdgeTranscodeJobWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->jobId)) {
            $query['JobId'] = $request->jobId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'GetEdgeTranscodeJob',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetEdgeTranscodeJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of an edge transcoding task.
     *  *
     * @description To call this operation, make sure that you have the permissions to access the edge transcoding feature.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param GetEdgeTranscodeJobRequest $request GetEdgeTranscodeJobRequest
     *
     * @return GetEdgeTranscodeJobResponse GetEdgeTranscodeJobResponse
     */
    public function getEdgeTranscodeJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getEdgeTranscodeJobWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of an edge transcoding template.
     *  *
     * @description *   You can call this operation to query the details of an edge transcoding template.
     * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param GetEdgeTranscodeTemplateRequest $request GetEdgeTranscodeTemplateRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return GetEdgeTranscodeTemplateResponse GetEdgeTranscodeTemplateResponse
     */
    public function getEdgeTranscodeTemplateWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->templateId)) {
            $query['TemplateId'] = $request->templateId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'GetEdgeTranscodeTemplate',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetEdgeTranscodeTemplateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of an edge transcoding template.
     *  *
     * @description *   You can call this operation to query the details of an edge transcoding template.
     * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param GetEdgeTranscodeTemplateRequest $request GetEdgeTranscodeTemplateRequest
     *
     * @return GetEdgeTranscodeTemplateResponse GetEdgeTranscodeTemplateResponse
     */
    public function getEdgeTranscodeTemplate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getEdgeTranscodeTemplateWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about editing tasks.
     *  *
     * @description *   When you call this operation, you can specify the CasterId and ShowId parameters to query the information about specific editing tasks. Make sure that the parameter settings meet the requirements.
     * *   If you specify the ShowId parameter in the request, the information about the editing tasks for the specified episode is returned.
     * *   If you do not specify the ShowId parameter in the request, the information about the editing tasks for the entire episode list is returned.
     * ### [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param GetEditingJobInfoRequest $request GetEditingJobInfoRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return GetEditingJobInfoResponse GetEditingJobInfoResponse
     */
    public function getEditingJobInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->showId)) {
            $query['ShowId'] = $request->showId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'GetEditingJobInfo',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetEditingJobInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about editing tasks.
     *  *
     * @description *   When you call this operation, you can specify the CasterId and ShowId parameters to query the information about specific editing tasks. Make sure that the parameter settings meet the requirements.
     * *   If you specify the ShowId parameter in the request, the information about the editing tasks for the specified episode is returned.
     * *   If you do not specify the ShowId parameter in the request, the information about the editing tasks for the entire episode list is returned.
     * ### [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param GetEditingJobInfoRequest $request GetEditingJobInfoRequest
     *
     * @return GetEditingJobInfoResponse GetEditingJobInfoResponse
     */
    public function getEditingJobInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getEditingJobInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a specified interactive messaging application.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param GetMessageAppRequest $request GetMessageAppRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMessageAppResponse GetMessageAppResponse
     */
    public function getMessageAppWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->appId)) {
            $body['AppId'] = $request->appId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetMessageApp',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetMessageAppResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a specified interactive messaging application.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param GetMessageAppRequest $request GetMessageAppRequest
     *
     * @return GetMessageAppResponse GetMessageAppResponse
     */
    public function getMessageApp($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMessageAppWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a message group.
     *  *
     * @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param GetMessageGroupRequest $request GetMessageGroupRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMessageGroupResponse GetMessageGroupResponse
     */
    public function getMessageGroupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->appId)) {
            $body['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->groupId)) {
            $body['GroupId'] = $request->groupId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetMessageGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetMessageGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a message group.
     *  *
     * @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param GetMessageGroupRequest $request GetMessageGroupRequest
     *
     * @return GetMessageGroupResponse GetMessageGroupResponse
     */
    public function getMessageGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMessageGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Obtains a token that the client can use to establish a persistent connection over the LWP protocol and based on atomic capabilities.
     *  *
     * @description ##
     * Obtain the user ID, device ID, and device type of the client, and then pass the information to the server. When you call this operation, the server obtains a token and returns the token to the client. Different users have different user IDs, and different devices have different device IDs.
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param GetMessageTokenRequest $request GetMessageTokenRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMessageTokenResponse GetMessageTokenResponse
     */
    public function getMessageTokenWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->appId)) {
            $body['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->deviceId)) {
            $body['DeviceId'] = $request->deviceId;
        }
        if (!Utils::isUnset($request->deviceType)) {
            $body['DeviceType'] = $request->deviceType;
        }
        if (!Utils::isUnset($request->userId)) {
            $body['UserId'] = $request->userId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetMessageToken',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetMessageTokenResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Obtains a token that the client can use to establish a persistent connection over the LWP protocol and based on atomic capabilities.
     *  *
     * @description ##
     * Obtain the user ID, device ID, and device type of the client, and then pass the information to the server. When you call this operation, the server obtains a token and returns the token to the client. Different users have different user IDs, and different devices have different device IDs.
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param GetMessageTokenRequest $request GetMessageTokenRequest
     *
     * @return GetMessageTokenResponse GetMessageTokenResponse
     */
    public function getMessageToken($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMessageTokenWithOptions($request, $runtime);
    }

    /**
     * @param GetTranscodeTaskStatusRequest $request GetTranscodeTaskStatusRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return GetTranscodeTaskStatusResponse GetTranscodeTaskStatusResponse
     */
    public function getTranscodeTaskStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->app)) {
            $query['App'] = $request->app;
        }
        if (!Utils::isUnset($request->pushDomain)) {
            $query['PushDomain'] = $request->pushDomain;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        if (!Utils::isUnset($request->transcodingTemplate)) {
            $query['TranscodingTemplate'] = $request->transcodingTemplate;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'GetTranscodeTaskStatus',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetTranscodeTaskStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param GetTranscodeTaskStatusRequest $request GetTranscodeTaskStatusRequest
     *
     * @return GetTranscodeTaskStatusResponse GetTranscodeTaskStatusResponse
     */
    public function getTranscodeTaskStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getTranscodeTaskStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Configures prefetch for a live stream that is ingested based on Real-Time Communication (RTC).
     *  *
     * @description ### [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param HotLiveRtcStreamRequest $request HotLiveRtcStreamRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return HotLiveRtcStreamResponse HotLiveRtcStreamResponse
     */
    public function hotLiveRtcStreamWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->audioMsid)) {
            $query['AudioMsid'] = $request->audioMsid;
        }
        if (!Utils::isUnset($request->connectionTimeout)) {
            $query['ConnectionTimeout'] = $request->connectionTimeout;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->mediaTimeout)) {
            $query['MediaTimeout'] = $request->mediaTimeout;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionCode)) {
            $query['RegionCode'] = $request->regionCode;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        if (!Utils::isUnset($request->videoMsid)) {
            $query['VideoMsid'] = $request->videoMsid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'HotLiveRtcStream',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return HotLiveRtcStreamResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures prefetch for a live stream that is ingested based on Real-Time Communication (RTC).
     *  *
     * @description ### [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param HotLiveRtcStreamRequest $request HotLiveRtcStreamRequest
     *
     * @return HotLiveRtcStreamResponse HotLiveRtcStreamResponse
     */
    public function hotLiveRtcStream($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->hotLiveRtcStreamWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a scheduled task to start and stop the playback of a playlist at specified points in time.
     *  *
     * @description You can call this operation to create a scheduled task to start and stop the playback of an episode list at specified points in time. Make sure that the parameter settings meet the requirements.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param InitializeAutoShowListTaskRequest $request InitializeAutoShowListTaskRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return InitializeAutoShowListTaskResponse InitializeAutoShowListTaskResponse
     */
    public function initializeAutoShowListTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->callBackUrl)) {
            $query['CallBackUrl'] = $request->callBackUrl;
        }
        if (!Utils::isUnset($request->casterConfig)) {
            $query['CasterConfig'] = $request->casterConfig;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceIds)) {
            $query['ResourceIds'] = $request->resourceIds;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'InitializeAutoShowListTask',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return InitializeAutoShowListTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a scheduled task to start and stop the playback of a playlist at specified points in time.
     *  *
     * @description You can call this operation to create a scheduled task to start and stop the playback of an episode list at specified points in time. Make sure that the parameter settings meet the requirements.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param InitializeAutoShowListTaskRequest $request InitializeAutoShowListTaskRequest
     *
     * @return InitializeAutoShowListTaskResponse InitializeAutoShowListTaskResponse
     */
    public function initializeAutoShowListTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->initializeAutoShowListTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Joins a message group.
     *  *
     * @description You can call this operation up to 200 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param JoinMessageGroupRequest $request JoinMessageGroupRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return JoinMessageGroupResponse JoinMessageGroupResponse
     */
    public function joinMessageGroupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->appId)) {
            $body['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->broadCastStatistics)) {
            $body['BroadCastStatistics'] = $request->broadCastStatistics;
        }
        if (!Utils::isUnset($request->broadCastType)) {
            $body['BroadCastType'] = $request->broadCastType;
        }
        if (!Utils::isUnset($request->groupId)) {
            $body['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->userId)) {
            $body['UserId'] = $request->userId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'JoinMessageGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return JoinMessageGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Joins a message group.
     *  *
     * @description You can call this operation up to 200 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param JoinMessageGroupRequest $request JoinMessageGroupRequest
     *
     * @return JoinMessageGroupResponse JoinMessageGroupResponse
     */
    public function joinMessageGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->joinMessageGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Removes a user from an interactive messaging group.
     *  *
     * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param KickLiveMessageGroupUserRequest $request KickLiveMessageGroupUserRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return KickLiveMessageGroupUserResponse KickLiveMessageGroupUserResponse
     */
    public function kickLiveMessageGroupUserWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->dataCenter)) {
            $query['DataCenter'] = $request->dataCenter;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->kickoffUser)) {
            $query['KickoffUser'] = $request->kickoffUser;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'KickLiveMessageGroupUser',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return KickLiveMessageGroupUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Removes a user from an interactive messaging group.
     *  *
     * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param KickLiveMessageGroupUserRequest $request KickLiveMessageGroupUserRequest
     *
     * @return KickLiveMessageGroupUserResponse KickLiveMessageGroupUserResponse
     */
    public function kickLiveMessageGroupUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->kickLiveMessageGroupUserWithOptions($request, $runtime);
    }

    /**
     * @summary Leaves a message group.
     *  *
     * @description ##
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param LeaveMessageGroupRequest $request LeaveMessageGroupRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return LeaveMessageGroupResponse LeaveMessageGroupResponse
     */
    public function leaveMessageGroupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->appId)) {
            $body['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->broadCastStatistics)) {
            $body['BroadCastStatistics'] = $request->broadCastStatistics;
        }
        if (!Utils::isUnset($request->broadCastType)) {
            $body['BroadCastType'] = $request->broadCastType;
        }
        if (!Utils::isUnset($request->groupId)) {
            $body['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->userId)) {
            $body['UserId'] = $request->userId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'LeaveMessageGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return LeaveMessageGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Leaves a message group.
     *  *
     * @description ##
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param LeaveMessageGroupRequest $request LeaveMessageGroupRequest
     *
     * @return LeaveMessageGroupResponse LeaveMessageGroupResponse
     */
    public function leaveMessageGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->leaveMessageGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Queries edge transcoding tasks.
     *  *
     * @description *   You can call this operation to query edge transcoding tasks.
     * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature.
     * *   You can query only tasks created or modified in the last 180 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListEdgeTranscodeJobRequest $request ListEdgeTranscodeJobRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return ListEdgeTranscodeJobResponse ListEdgeTranscodeJobResponse
     */
    public function listEdgeTranscodeJobWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->keyword)) {
            $query['Keyword'] = $request->keyword;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNo)) {
            $query['PageNo'] = $request->pageNo;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->sortBy)) {
            $query['SortBy'] = $request->sortBy;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ListEdgeTranscodeJob',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListEdgeTranscodeJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries edge transcoding tasks.
     *  *
     * @description *   You can call this operation to query edge transcoding tasks.
     * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature.
     * *   You can query only tasks created or modified in the last 180 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListEdgeTranscodeJobRequest $request ListEdgeTranscodeJobRequest
     *
     * @return ListEdgeTranscodeJobResponse ListEdgeTranscodeJobResponse
     */
    public function listEdgeTranscodeJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listEdgeTranscodeJobWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the list of edge transcoding templates.
     *  *
     * @description *   You can call this operation to query the list of edge transcoding templates.
     * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListEdgeTranscodeTemplateRequest $request ListEdgeTranscodeTemplateRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ListEdgeTranscodeTemplateResponse ListEdgeTranscodeTemplateResponse
     */
    public function listEdgeTranscodeTemplateWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->keyword)) {
            $query['Keyword'] = $request->keyword;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNo)) {
            $query['PageNo'] = $request->pageNo;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->sortBy)) {
            $query['SortBy'] = $request->sortBy;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->videoCodec)) {
            $query['VideoCodec'] = $request->videoCodec;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ListEdgeTranscodeTemplate',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListEdgeTranscodeTemplateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the list of edge transcoding templates.
     *  *
     * @description *   You can call this operation to query the list of edge transcoding templates.
     * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListEdgeTranscodeTemplateRequest $request ListEdgeTranscodeTemplateRequest
     *
     * @return ListEdgeTranscodeTemplateResponse ListEdgeTranscodeTemplateResponse
     */
    public function listEdgeTranscodeTemplate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listEdgeTranscodeTemplateWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the events generated in channels to which you subscribe.
     *  *
     * @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListEventSubRequest $request ListEventSubRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return ListEventSubResponse ListEventSubResponse
     */
    public function listEventSubWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ListEventSub',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListEventSubResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the events generated in channels to which you subscribe.
     *  *
     * @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListEventSubRequest $request ListEventSubRequest
     *
     * @return ListEventSubResponse ListEventSubResponse
     */
    public function listEventSub($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listEventSubWithOptions($request, $runtime);
    }

    /**
     * @summary Queries callback records.
     *  *
     * @description *   The maximum time range to query is seven days.
     * *   The minimum time granularity to query is 1 minute.
     * *   You can query data in the last seven days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListEventSubEventRequest $request ListEventSubEventRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ListEventSubEventResponse ListEventSubEventResponse
     */
    public function listEventSubEventWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ListEventSubEvent',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListEventSubEventResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries callback records.
     *  *
     * @description *   The maximum time range to query is seven days.
     * *   The minimum time granularity to query is 1 minute.
     * *   You can query data in the last seven days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListEventSubEventRequest $request ListEventSubEventRequest
     *
     * @return ListEventSubEventResponse ListEventSubEventResponse
     */
    public function listEventSubEvent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listEventSubEventWithOptions($request, $runtime);
    }

    /**
     * @summary Queries stream delay configurations.
     *  *
     * @description You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListLiveDelayConfigRequest $request ListLiveDelayConfigRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ListLiveDelayConfigResponse ListLiveDelayConfigResponse
     */
    public function listLiveDelayConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domain)) {
            $query['Domain'] = $request->domain;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNum)) {
            $query['PageNum'] = $request->pageNum;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ListLiveDelayConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListLiveDelayConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries stream delay configurations.
     *  *
     * @description You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListLiveDelayConfigRequest $request ListLiveDelayConfigRequest
     *
     * @return ListLiveDelayConfigResponse ListLiveDelayConfigResponse
     */
    public function listLiveDelayConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listLiveDelayConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries interactive messaging applications.
     *  *
     * @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListLiveMessageAppsRequest $request ListLiveMessageAppsRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ListLiveMessageAppsResponse ListLiveMessageAppsResponse
     */
    public function listLiveMessageAppsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->dataCenter)) {
            $query['DataCenter'] = $request->dataCenter;
        }
        if (!Utils::isUnset($request->nextPageToken)) {
            $query['NextPageToken'] = $request->nextPageToken;
        }
        if (!Utils::isUnset($request->sortType)) {
            $query['SortType'] = $request->sortType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ListLiveMessageApps',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListLiveMessageAppsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries interactive messaging applications.
     *  *
     * @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListLiveMessageAppsRequest $request ListLiveMessageAppsRequest
     *
     * @return ListLiveMessageAppsResponse ListLiveMessageAppsResponse
     */
    public function listLiveMessageApps($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listLiveMessageAppsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries interactive messaging groups by page.
     *  *
     * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListLiveMessageGroupByPageRequest $request ListLiveMessageGroupByPageRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return ListLiveMessageGroupByPageResponse ListLiveMessageGroupByPageResponse
     */
    public function listLiveMessageGroupByPageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ListLiveMessageGroupByPage',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListLiveMessageGroupByPageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries interactive messaging groups by page.
     *  *
     * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListLiveMessageGroupByPageRequest $request ListLiveMessageGroupByPageRequest
     *
     * @return ListLiveMessageGroupByPageResponse ListLiveMessageGroupByPageResponse
     */
    public function listLiveMessageGroupByPage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listLiveMessageGroupByPageWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the messages sent in a group.
     *  *
     * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListLiveMessageGroupMessagesRequest $request ListLiveMessageGroupMessagesRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return ListLiveMessageGroupMessagesResponse ListLiveMessageGroupMessagesResponse
     */
    public function listLiveMessageGroupMessagesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->beginTime)) {
            $query['BeginTime'] = $request->beginTime;
        }
        if (!Utils::isUnset($request->dataCenter)) {
            $query['DataCenter'] = $request->dataCenter;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->msgType)) {
            $query['MsgType'] = $request->msgType;
        }
        if (!Utils::isUnset($request->nextPageToken)) {
            $query['NextPageToken'] = $request->nextPageToken;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->sortType)) {
            $query['SortType'] = $request->sortType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ListLiveMessageGroupMessages',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListLiveMessageGroupMessagesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the messages sent in a group.
     *  *
     * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListLiveMessageGroupMessagesRequest $request ListLiveMessageGroupMessagesRequest
     *
     * @return ListLiveMessageGroupMessagesResponse ListLiveMessageGroupMessagesResponse
     */
    public function listLiveMessageGroupMessages($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listLiveMessageGroupMessagesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the users in an interactive messaging group.
     *  *
     * @description *   Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * *   For a super group, which has more than 2,000 users, the user list cannot be queried. In addition, the notifications about users entering or leaving the group are sent at an interval of at least of 5 seconds. These notifications display the accurate number of users in the group for the time being, but do not display the list of all users entering or leaving the group. Once a group is upgraded to a super group, the user list of the group is immediately cleared. The super group cannot be restored to a normal group until all users in the group leave the group (that is, the group is closed). After you reopen the group, it is restored to a normal group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListLiveMessageGroupUsersRequest $request ListLiveMessageGroupUsersRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ListLiveMessageGroupUsersResponse ListLiveMessageGroupUsersResponse
     */
    public function listLiveMessageGroupUsersWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->dataCenter)) {
            $query['DataCenter'] = $request->dataCenter;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->nextPageToken)) {
            $query['NextPageToken'] = $request->nextPageToken;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->sortType)) {
            $query['SortType'] = $request->sortType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ListLiveMessageGroupUsers',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListLiveMessageGroupUsersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the users in an interactive messaging group.
     *  *
     * @description *   Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * *   For a super group, which has more than 2,000 users, the user list cannot be queried. In addition, the notifications about users entering or leaving the group are sent at an interval of at least of 5 seconds. These notifications display the accurate number of users in the group for the time being, but do not display the list of all users entering or leaving the group. Once a group is upgraded to a super group, the user list of the group is immediately cleared. The super group cannot be restored to a normal group until all users in the group leave the group (that is, the group is closed). After you reopen the group, it is restored to a normal group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListLiveMessageGroupUsersRequest $request ListLiveMessageGroupUsersRequest
     *
     * @return ListLiveMessageGroupUsersResponse ListLiveMessageGroupUsersResponse
     */
    public function listLiveMessageGroupUsers($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listLiveMessageGroupUsersWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the interactive messaging groups in an interactive messaging application.
     *  *
     * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListLiveMessageGroupsRequest $request ListLiveMessageGroupsRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return ListLiveMessageGroupsResponse ListLiveMessageGroupsResponse
     */
    public function listLiveMessageGroupsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->dataCenter)) {
            $query['DataCenter'] = $request->dataCenter;
        }
        if (!Utils::isUnset($request->groupStatus)) {
            $query['GroupStatus'] = $request->groupStatus;
        }
        if (!Utils::isUnset($request->nextPageToken)) {
            $query['NextPageToken'] = $request->nextPageToken;
        }
        if (!Utils::isUnset($request->sortType)) {
            $query['SortType'] = $request->sortType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ListLiveMessageGroups',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListLiveMessageGroupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the interactive messaging groups in an interactive messaging application.
     *  *
     * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListLiveMessageGroupsRequest $request ListLiveMessageGroupsRequest
     *
     * @return ListLiveMessageGroupsResponse ListLiveMessageGroupsResponse
     */
    public function listLiveMessageGroups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listLiveMessageGroupsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries all configurations of real-time log delivery under an Alibaba Cloud account.
     *  *
     * @description You can call this operation to query all configurations of real-time log delivery under an account. Make sure that the parameter settings meet the requirements.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListLiveRealtimeLogDeliveryRequest $request ListLiveRealtimeLogDeliveryRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return ListLiveRealtimeLogDeliveryResponse ListLiveRealtimeLogDeliveryResponse
     */
    public function listLiveRealtimeLogDeliveryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ListLiveRealtimeLogDelivery',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListLiveRealtimeLogDeliveryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries all configurations of real-time log delivery under an Alibaba Cloud account.
     *  *
     * @description You can call this operation to query all configurations of real-time log delivery under an account. Make sure that the parameter settings meet the requirements.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListLiveRealtimeLogDeliveryRequest $request ListLiveRealtimeLogDeliveryRequest
     *
     * @return ListLiveRealtimeLogDeliveryResponse ListLiveRealtimeLogDeliveryResponse
     */
    public function listLiveRealtimeLogDelivery($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listLiveRealtimeLogDeliveryWithOptions($request, $runtime);
    }

    /**
     * @summary Queries all domain names that are associated with a specific configuration of real-time log delivery.
     *  *
     * @description *   You can call this operation to query all domain names that are associated with a specific configuration of real-time log delivery. The returned results indicate whether real-time log delivery is enabled or disabled for the domain names.
     * *   You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) to query the Project, Logstore, and Region parameters.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListLiveRealtimeLogDeliveryDomainsRequest $request ListLiveRealtimeLogDeliveryDomainsRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return ListLiveRealtimeLogDeliveryDomainsResponse ListLiveRealtimeLogDeliveryDomainsResponse
     */
    public function listLiveRealtimeLogDeliveryDomainsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ListLiveRealtimeLogDeliveryDomains',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListLiveRealtimeLogDeliveryDomainsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries all domain names that are associated with a specific configuration of real-time log delivery.
     *  *
     * @description *   You can call this operation to query all domain names that are associated with a specific configuration of real-time log delivery. The returned results indicate whether real-time log delivery is enabled or disabled for the domain names.
     * *   You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) to query the Project, Logstore, and Region parameters.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListLiveRealtimeLogDeliveryDomainsRequest $request ListLiveRealtimeLogDeliveryDomainsRequest
     *
     * @return ListLiveRealtimeLogDeliveryDomainsResponse ListLiveRealtimeLogDeliveryDomainsResponse
     */
    public function listLiveRealtimeLogDeliveryDomains($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listLiveRealtimeLogDeliveryDomainsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries all configurations of real-time log delivery.
     *  *
     * @description You can call this operation to query all configurations of real-time log delivery. Make sure that the parameter settings meet the requirements.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListLiveRealtimeLogDeliveryInfosRequest $request ListLiveRealtimeLogDeliveryInfosRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return ListLiveRealtimeLogDeliveryInfosResponse ListLiveRealtimeLogDeliveryInfosResponse
     */
    public function listLiveRealtimeLogDeliveryInfosWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ListLiveRealtimeLogDeliveryInfos',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListLiveRealtimeLogDeliveryInfosResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries all configurations of real-time log delivery.
     *  *
     * @description You can call this operation to query all configurations of real-time log delivery. Make sure that the parameter settings meet the requirements.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListLiveRealtimeLogDeliveryInfosRequest $request ListLiveRealtimeLogDeliveryInfosRequest
     *
     * @return ListLiveRealtimeLogDeliveryInfosResponse ListLiveRealtimeLogDeliveryInfosResponse
     */
    public function listLiveRealtimeLogDeliveryInfos($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listLiveRealtimeLogDeliveryInfosWithOptions($request, $runtime);
    }

    /**
     * @summary Queries messages.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param ListMessageRequest $request ListMessageRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return ListMessageResponse ListMessageResponse
     */
    public function listMessageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->appId)) {
            $body['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->groupId)) {
            $body['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->pageNum)) {
            $body['PageNum'] = $request->pageNum;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->sortType)) {
            $body['SortType'] = $request->sortType;
        }
        if (!Utils::isUnset($request->type)) {
            $body['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListMessage',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListMessageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries messages.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param ListMessageRequest $request ListMessageRequest
     *
     * @return ListMessageResponse ListMessageResponse
     */
    public function listMessage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listMessageWithOptions($request, $runtime);
    }

    /**
     * @summary Queries interactive messaging applications.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param ListMessageAppRequest $request ListMessageAppRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return ListMessageAppResponse ListMessageAppResponse
     */
    public function listMessageAppWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->pageNum)) {
            $body['PageNum'] = $request->pageNum;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->sortType)) {
            $body['SortType'] = $request->sortType;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListMessageApp',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListMessageAppResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries interactive messaging applications.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param ListMessageAppRequest $request ListMessageAppRequest
     *
     * @return ListMessageAppResponse ListMessageAppResponse
     */
    public function listMessageApp($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listMessageAppWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the message groups of a specified user.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param ListMessageGroupRequest $request ListMessageGroupRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return ListMessageGroupResponse ListMessageGroupResponse
     */
    public function listMessageGroupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->appId)) {
            $body['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->pageNum)) {
            $body['PageNum'] = $request->pageNum;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->sortType)) {
            $body['SortType'] = $request->sortType;
        }
        if (!Utils::isUnset($request->userId)) {
            $body['UserId'] = $request->userId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListMessageGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListMessageGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the message groups of a specified user.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param ListMessageGroupRequest $request ListMessageGroupRequest
     *
     * @return ListMessageGroupResponse ListMessageGroupResponse
     */
    public function listMessageGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listMessageGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the members of a message group.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param ListMessageGroupUserRequest $request ListMessageGroupUserRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return ListMessageGroupUserResponse ListMessageGroupUserResponse
     */
    public function listMessageGroupUserWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->appId)) {
            $body['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->groupId)) {
            $body['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->pageNum)) {
            $body['PageNum'] = $request->pageNum;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->sortType)) {
            $body['SortType'] = $request->sortType;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListMessageGroupUser',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListMessageGroupUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the members of a message group.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param ListMessageGroupUserRequest $request ListMessageGroupUserRequest
     *
     * @return ListMessageGroupUserResponse ListMessageGroupUserResponse
     */
    public function listMessageGroupUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listMessageGroupUserWithOptions($request, $runtime);
    }

    /**
     * @summary Queries user information by user ID.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param ListMessageGroupUserByIdRequest $tmpReq  ListMessageGroupUserByIdRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return ListMessageGroupUserByIdResponse ListMessageGroupUserByIdResponse
     */
    public function listMessageGroupUserByIdWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new ListMessageGroupUserByIdShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->userIdList)) {
            $request->userIdListShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->userIdList, 'UserIdList', 'simple');
        }
        $body = [];
        if (!Utils::isUnset($request->appId)) {
            $body['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->groupId)) {
            $body['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->userIdListShrink)) {
            $body['UserIdList'] = $request->userIdListShrink;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListMessageGroupUserById',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListMessageGroupUserByIdResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries user information by user ID.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param ListMessageGroupUserByIdRequest $request ListMessageGroupUserByIdRequest
     *
     * @return ListMessageGroupUserByIdResponse ListMessageGroupUserByIdResponse
     */
    public function listMessageGroupUserById($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listMessageGroupUserByIdWithOptions($request, $runtime);
    }

    /**
     * @summary Queries muted members in a messaging group.
     *  *
     * @description ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param ListMuteGroupUserRequest $request ListMuteGroupUserRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ListMuteGroupUserResponse ListMuteGroupUserResponse
     */
    public function listMuteGroupUserWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->appId)) {
            $body['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->groupId)) {
            $body['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->operatorUserId)) {
            $body['OperatorUserId'] = $request->operatorUserId;
        }
        if (!Utils::isUnset($request->pageNum)) {
            $body['PageNum'] = $request->pageNum;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListMuteGroupUser',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListMuteGroupUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries muted members in a messaging group.
     *  *
     * @description ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param ListMuteGroupUserRequest $request ListMuteGroupUserRequest
     *
     * @return ListMuteGroupUserResponse ListMuteGroupUserResponse
     */
    public function listMuteGroupUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listMuteGroupUserWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about one or more episode lists.
     *  *
     * @description You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episode lists and then call this operation to query the episode lists.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListPlaylistRequest $request ListPlaylistRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return ListPlaylistResponse ListPlaylistResponse
     */
    public function listPlaylistWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->page)) {
            $query['Page'] = $request->page;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->programId)) {
            $query['ProgramId'] = $request->programId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ListPlaylist',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListPlaylistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about one or more episode lists.
     *  *
     * @description You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episode lists and then call this operation to query the episode lists.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListPlaylistRequest $request ListPlaylistRequest
     *
     * @return ListPlaylistResponse ListPlaylistResponse
     */
    public function listPlaylist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listPlaylistWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about episodes in an episode list.
     *  *
     * @description You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episodes to an episode list and then call this operation to query the episodes in the episode list
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListPlaylistItemsRequest $request ListPlaylistItemsRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ListPlaylistItemsResponse ListPlaylistItemsResponse
     */
    public function listPlaylistItemsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->programId)) {
            $query['ProgramId'] = $request->programId;
        }
        if (!Utils::isUnset($request->programItemIds)) {
            $query['ProgramItemIds'] = $request->programItemIds;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ListPlaylistItems',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListPlaylistItemsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about episodes in an episode list.
     *  *
     * @description You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episodes to an episode list and then call this operation to query the episodes in the episode list
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListPlaylistItemsRequest $request ListPlaylistItemsRequest
     *
     * @return ListPlaylistItemsResponse ListPlaylistItemsResponse
     */
    public function listPlaylistItems($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listPlaylistItemsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the callback records of a subscription to mixed-stream relay events.
     *  *
     * @description You can call this operation to query the callback records of a subscription to mixed-stream relay events in the last seven days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListRtcMPUEventSubRecordRequest $request ListRtcMPUEventSubRecordRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return ListRtcMPUEventSubRecordResponse ListRtcMPUEventSubRecordResponse
     */
    public function listRtcMPUEventSubRecordWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->pageNo)) {
            $query['PageNo'] = $request->pageNo;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->subId)) {
            $query['SubId'] = $request->subId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ListRtcMPUEventSubRecord',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListRtcMPUEventSubRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the callback records of a subscription to mixed-stream relay events.
     *  *
     * @description You can call this operation to query the callback records of a subscription to mixed-stream relay events in the last seven days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListRtcMPUEventSubRecordRequest $request ListRtcMPUEventSubRecordRequest
     *
     * @return ListRtcMPUEventSubRecordResponse ListRtcMPUEventSubRecordResponse
     */
    public function listRtcMPUEventSubRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listRtcMPUEventSubRecordWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the parameters of mixed-stream relay tasks.
     *  *
     * @description *   You can call the ListRtcMPUTaskDetail operation to query the parameters of mixed-stream relay tasks that were created by calling the StartLiveMPUTask operation.
     * *   By default, the query results are sorted in reverse chronological order based on the task update time.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListRtcMPUTaskDetailRequest $request ListRtcMPUTaskDetailRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return ListRtcMPUTaskDetailResponse ListRtcMPUTaskDetailResponse
     */
    public function listRtcMPUTaskDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->pageNo)) {
            $query['PageNo'] = $request->pageNo;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ListRtcMPUTaskDetail',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListRtcMPUTaskDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the parameters of mixed-stream relay tasks.
     *  *
     * @description *   You can call the ListRtcMPUTaskDetail operation to query the parameters of mixed-stream relay tasks that were created by calling the StartLiveMPUTask operation.
     * *   By default, the query results are sorted in reverse chronological order based on the task update time.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ListRtcMPUTaskDetailRequest $request ListRtcMPUTaskDetailRequest
     *
     * @return ListRtcMPUTaskDetailResponse ListRtcMPUTaskDetailResponse
     */
    public function listRtcMPUTaskDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listRtcMPUTaskDetailWithOptions($request, $runtime);
    }

    /**
     * @summary 直播回源监控数据
     *  *
     * @param LiveUpstreamQosDataRequest $tmpReq  LiveUpstreamQosDataRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return LiveUpstreamQosDataResponse LiveUpstreamQosDataResponse
     */
    public function liveUpstreamQosDataWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new LiveUpstreamQosDataShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->cdnDomains)) {
            $request->cdnDomainsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->cdnDomains, 'CdnDomains', 'json');
        }
        if (!Utils::isUnset($tmpReq->cdnIsps)) {
            $request->cdnIspsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->cdnIsps, 'CdnIsps', 'json');
        }
        if (!Utils::isUnset($tmpReq->cdnProvinces)) {
            $request->cdnProvincesShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->cdnProvinces, 'CdnProvinces', 'json');
        }
        if (!Utils::isUnset($tmpReq->kwaiSidcs)) {
            $request->kwaiSidcsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->kwaiSidcs, 'KwaiSidcs', 'json');
        }
        if (!Utils::isUnset($tmpReq->kwaiTsc)) {
            $request->kwaiTscShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->kwaiTsc, 'KwaiTsc', 'json');
        }
        if (!Utils::isUnset($tmpReq->upstreamDomains)) {
            $request->upstreamDomainsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->upstreamDomains, 'UpstreamDomains', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->cdnDomainsShrink)) {
            $query['CdnDomains'] = $request->cdnDomainsShrink;
        }
        if (!Utils::isUnset($request->cdnIspsShrink)) {
            $query['CdnIsps'] = $request->cdnIspsShrink;
        }
        if (!Utils::isUnset($request->cdnProvincesShrink)) {
            $query['CdnProvinces'] = $request->cdnProvincesShrink;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->kwaiSidcsShrink)) {
            $query['KwaiSidcs'] = $request->kwaiSidcsShrink;
        }
        if (!Utils::isUnset($request->kwaiTscShrink)) {
            $query['KwaiTsc'] = $request->kwaiTscShrink;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->region)) {
            $query['Region'] = $request->region;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->upstreamDomainsShrink)) {
            $query['UpstreamDomains'] = $request->upstreamDomainsShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'LiveUpstreamQosData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return LiveUpstreamQosDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 直播回源监控数据
     *  *
     * @param LiveUpstreamQosDataRequest $request LiveUpstreamQosDataRequest
     *
     * @return LiveUpstreamQosDataResponse LiveUpstreamQosDataResponse
     */
    public function liveUpstreamQosData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->liveUpstreamQosDataWithOptions($request, $runtime);
    }

    /**
     * @summary 咪咕定制直播拉转推启动接口
     *  *
     * @param MiguLivePullToPushStartRequest $request MiguLivePullToPushStartRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return MiguLivePullToPushStartResponse MiguLivePullToPushStartResponse
     */
    public function miguLivePullToPushStartWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->miguData)) {
            $query['MiguData'] = $request->miguData;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'MiguLivePullToPushStart',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return MiguLivePullToPushStartResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 咪咕定制直播拉转推启动接口
     *  *
     * @param MiguLivePullToPushStartRequest $request MiguLivePullToPushStartRequest
     *
     * @return MiguLivePullToPushStartResponse MiguLivePullToPushStartResponse
     */
    public function miguLivePullToPushStart($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->miguLivePullToPushStartWithOptions($request, $runtime);
    }

    /**
     * @summary 咪咕定制直播拉转推启动接口
     *  *
     * @param MiguLivePullToPushStatusRequest $request MiguLivePullToPushStatusRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return MiguLivePullToPushStatusResponse MiguLivePullToPushStatusResponse
     */
    public function miguLivePullToPushStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->miguData)) {
            $query['MiguData'] = $request->miguData;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'MiguLivePullToPushStatus',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return MiguLivePullToPushStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 咪咕定制直播拉转推启动接口
     *  *
     * @param MiguLivePullToPushStatusRequest $request MiguLivePullToPushStatusRequest
     *
     * @return MiguLivePullToPushStatusResponse MiguLivePullToPushStatusResponse
     */
    public function miguLivePullToPushStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->miguLivePullToPushStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies a component of a production studio.
     *  *
     * @description You can call this operation to modify a text, image, or subtitle component.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ModifyCasterComponentRequest $request ModifyCasterComponentRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyCasterComponentResponse ModifyCasterComponentResponse
     */
    public function modifyCasterComponentWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->captionLayerContent)) {
            $query['CaptionLayerContent'] = $request->captionLayerContent;
        }
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->componentId)) {
            $query['ComponentId'] = $request->componentId;
        }
        if (!Utils::isUnset($request->componentLayer)) {
            $query['ComponentLayer'] = $request->componentLayer;
        }
        if (!Utils::isUnset($request->componentName)) {
            $query['ComponentName'] = $request->componentName;
        }
        if (!Utils::isUnset($request->componentType)) {
            $query['ComponentType'] = $request->componentType;
        }
        if (!Utils::isUnset($request->effect)) {
            $query['Effect'] = $request->effect;
        }
        if (!Utils::isUnset($request->imageLayerContent)) {
            $query['ImageLayerContent'] = $request->imageLayerContent;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->textLayerContent)) {
            $query['TextLayerContent'] = $request->textLayerContent;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyCasterComponent',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyCasterComponentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies a component of a production studio.
     *  *
     * @description You can call this operation to modify a text, image, or subtitle component.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ModifyCasterComponentRequest $request ModifyCasterComponentRequest
     *
     * @return ModifyCasterComponentResponse ModifyCasterComponentResponse
     */
    public function modifyCasterComponent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyCasterComponentWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configurations of an episode in a production studio. You cannot change the episode type.
     *  *
     * @description You can call this operation to modify the configurations of an episode in a production studio. You cannot change the episode type.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ModifyCasterEpisodeRequest $request ModifyCasterEpisodeRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyCasterEpisodeResponse ModifyCasterEpisodeResponse
     */
    public function modifyCasterEpisodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->componentId)) {
            $query['ComponentId'] = $request->componentId;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->episodeId)) {
            $query['EpisodeId'] = $request->episodeId;
        }
        if (!Utils::isUnset($request->episodeName)) {
            $query['EpisodeName'] = $request->episodeName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceId)) {
            $query['ResourceId'] = $request->resourceId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->switchType)) {
            $query['SwitchType'] = $request->switchType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyCasterEpisode',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyCasterEpisodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configurations of an episode in a production studio. You cannot change the episode type.
     *  *
     * @description You can call this operation to modify the configurations of an episode in a production studio. You cannot change the episode type.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ModifyCasterEpisodeRequest $request ModifyCasterEpisodeRequest
     *
     * @return ModifyCasterEpisodeResponse ModifyCasterEpisodeResponse
     */
    public function modifyCasterEpisode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyCasterEpisodeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the layout configurations pf a production studio. You need to pass only parameters that you want to modify.
     *  *
     * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to modify a layout of the production studio. This operation supports the default and adaptive scaling modes.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ModifyCasterLayoutRequest $request ModifyCasterLayoutRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyCasterLayoutResponse ModifyCasterLayoutResponse
     */
    public function modifyCasterLayoutWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->audioLayer)) {
            $query['AudioLayer'] = $request->audioLayer;
        }
        if (!Utils::isUnset($request->blendList)) {
            $query['BlendList'] = $request->blendList;
        }
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->layoutId)) {
            $query['LayoutId'] = $request->layoutId;
        }
        if (!Utils::isUnset($request->mixList)) {
            $query['MixList'] = $request->mixList;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->videoLayer)) {
            $query['VideoLayer'] = $request->videoLayer;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyCasterLayout',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyCasterLayoutResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the layout configurations pf a production studio. You need to pass only parameters that you want to modify.
     *  *
     * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to modify a layout of the production studio. This operation supports the default and adaptive scaling modes.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ModifyCasterLayoutRequest $request ModifyCasterLayoutRequest
     *
     * @return ModifyCasterLayoutResponse ModifyCasterLayoutResponse
     */
    public function modifyCasterLayout($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyCasterLayoutWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the episode list for carousel playback in a production studio.
     *  *
     * @description You can call the [AddCasterProgram](https://help.aliyun.com/document_detail/2848074.html) operation to add the episode list for carousel playback in a production studio and then call this operation to modify the episode list. The supported types of episodes include video resource and component.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ModifyCasterProgramRequest $request ModifyCasterProgramRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyCasterProgramResponse ModifyCasterProgramResponse
     */
    public function modifyCasterProgramWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->episode)) {
            $query['Episode'] = $request->episode;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyCasterProgram',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyCasterProgramResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the episode list for carousel playback in a production studio.
     *  *
     * @description You can call the [AddCasterProgram](https://help.aliyun.com/document_detail/2848074.html) operation to add the episode list for carousel playback in a production studio and then call this operation to modify the episode list. The supported types of episodes include video resource and component.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ModifyCasterProgramRequest $request ModifyCasterProgramRequest
     *
     * @return ModifyCasterProgramResponse ModifyCasterProgramResponse
     */
    public function modifyCasterProgram($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyCasterProgramWithOptions($request, $runtime);
    }

    /**
     * @summary Changes the video source for a production studio.
     *  *
     * @description ## Usage notes
     * You must call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio before you call this operation to modify input sources of the production studio.
     * ## QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param ModifyCasterVideoResourceRequest $request ModifyCasterVideoResourceRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyCasterVideoResourceResponse ModifyCasterVideoResourceResponse
     */
    public function modifyCasterVideoResourceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->beginOffset)) {
            $query['BeginOffset'] = $request->beginOffset;
        }
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->endOffset)) {
            $query['EndOffset'] = $request->endOffset;
        }
        if (!Utils::isUnset($request->imageId)) {
            $query['ImageId'] = $request->imageId;
        }
        if (!Utils::isUnset($request->imageUrl)) {
            $query['ImageUrl'] = $request->imageUrl;
        }
        if (!Utils::isUnset($request->liveStreamUrl)) {
            $query['LiveStreamUrl'] = $request->liveStreamUrl;
        }
        if (!Utils::isUnset($request->materialId)) {
            $query['MaterialId'] = $request->materialId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->ptsCallbackInterval)) {
            $query['PtsCallbackInterval'] = $request->ptsCallbackInterval;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->repeatNum)) {
            $query['RepeatNum'] = $request->repeatNum;
        }
        if (!Utils::isUnset($request->resourceId)) {
            $query['ResourceId'] = $request->resourceId;
        }
        if (!Utils::isUnset($request->resourceName)) {
            $query['ResourceName'] = $request->resourceName;
        }
        if (!Utils::isUnset($request->vodUrl)) {
            $query['VodUrl'] = $request->vodUrl;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyCasterVideoResource',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyCasterVideoResourceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Changes the video source for a production studio.
     *  *
     * @description ## Usage notes
     * You must call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio before you call this operation to modify input sources of the production studio.
     * ## QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param ModifyCasterVideoResourceRequest $request ModifyCasterVideoResourceRequest
     *
     * @return ModifyCasterVideoResourceResponse ModifyCasterVideoResourceResponse
     */
    public function modifyCasterVideoResource($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyCasterVideoResourceWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies a virtual studio template.
     *  *
     * @param ModifyLiveAIStudioRequest $tmpReq  ModifyLiveAIStudioRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyLiveAIStudioResponse ModifyLiveAIStudioResponse
     */
    public function modifyLiveAIStudioWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new ModifyLiveAIStudioShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->mattingLayout)) {
            $request->mattingLayoutShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->mattingLayout, 'MattingLayout', 'json');
        }
        if (!Utils::isUnset($tmpReq->mediaLayout)) {
            $request->mediaLayoutShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->mediaLayout, 'MediaLayout', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->backgroundResourceId)) {
            $query['BackgroundResourceId'] = $request->backgroundResourceId;
        }
        if (!Utils::isUnset($request->backgroundResourceUrl)) {
            $query['BackgroundResourceUrl'] = $request->backgroundResourceUrl;
        }
        if (!Utils::isUnset($request->backgroundType)) {
            $query['BackgroundType'] = $request->backgroundType;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->height)) {
            $query['Height'] = $request->height;
        }
        if (!Utils::isUnset($request->mattingLayoutShrink)) {
            $query['MattingLayout'] = $request->mattingLayoutShrink;
        }
        if (!Utils::isUnset($request->mattingType)) {
            $query['MattingType'] = $request->mattingType;
        }
        if (!Utils::isUnset($request->mediaLayoutShrink)) {
            $query['MediaLayout'] = $request->mediaLayoutShrink;
        }
        if (!Utils::isUnset($request->mediaResourceId)) {
            $query['MediaResourceId'] = $request->mediaResourceId;
        }
        if (!Utils::isUnset($request->mediaResourceUrl)) {
            $query['MediaResourceUrl'] = $request->mediaResourceUrl;
        }
        if (!Utils::isUnset($request->mediaType)) {
            $query['MediaType'] = $request->mediaType;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->studioName)) {
            $query['StudioName'] = $request->studioName;
        }
        if (!Utils::isUnset($request->width)) {
            $query['Width'] = $request->width;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyLiveAIStudio',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyLiveAIStudioResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies a virtual studio template.
     *  *
     * @param ModifyLiveAIStudioRequest $request ModifyLiveAIStudioRequest
     *
     * @return ModifyLiveAIStudioResponse ModifyLiveAIStudioResponse
     */
    public function modifyLiveAIStudio($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyLiveAIStudioWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the acceleration region of a domain name.
     *  *
     * @description ### [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ModifyLiveDomainSchdmByPropertyRequest $request ModifyLiveDomainSchdmByPropertyRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyLiveDomainSchdmByPropertyResponse ModifyLiveDomainSchdmByPropertyResponse
     */
    public function modifyLiveDomainSchdmByPropertyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->property)) {
            $query['Property'] = $request->property;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyLiveDomainSchdmByProperty',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyLiveDomainSchdmByPropertyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the acceleration region of a domain name.
     *  *
     * @description ### [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ModifyLiveDomainSchdmByPropertyRequest $request ModifyLiveDomainSchdmByPropertyRequest
     *
     * @return ModifyLiveDomainSchdmByPropertyResponse ModifyLiveDomainSchdmByPropertyResponse
     */
    public function modifyLiveDomainSchdmByProperty($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyLiveDomainSchdmByPropertyWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the content moderation settings of an interactive messaging application.
     *  *
     * @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ModifyLiveMessageAppAuditRequest $request ModifyLiveMessageAppAuditRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyLiveMessageAppAuditResponse ModifyLiveMessageAppAuditResponse
     */
    public function modifyLiveMessageAppAuditWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->auditType)) {
            $query['AuditType'] = $request->auditType;
        }
        if (!Utils::isUnset($request->auditUrl)) {
            $query['AuditUrl'] = $request->auditUrl;
        }
        if (!Utils::isUnset($request->dataCenter)) {
            $query['DataCenter'] = $request->dataCenter;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyLiveMessageAppAudit',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyLiveMessageAppAuditResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the content moderation settings of an interactive messaging application.
     *  *
     * @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ModifyLiveMessageAppAuditRequest $request ModifyLiveMessageAppAuditRequest
     *
     * @return ModifyLiveMessageAppAuditResponse ModifyLiveMessageAppAuditResponse
     */
    public function modifyLiveMessageAppAudit($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyLiveMessageAppAuditWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the callback settings of an interactive messaging application.
     *  *
     * @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ModifyLiveMessageAppCallbackRequest $request ModifyLiveMessageAppCallbackRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyLiveMessageAppCallbackResponse ModifyLiveMessageAppCallbackResponse
     */
    public function modifyLiveMessageAppCallbackWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->dataCenter)) {
            $query['DataCenter'] = $request->dataCenter;
        }
        if (!Utils::isUnset($request->eventCallbackUrl)) {
            $query['EventCallbackUrl'] = $request->eventCallbackUrl;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyLiveMessageAppCallback',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyLiveMessageAppCallbackResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the callback settings of an interactive messaging application.
     *  *
     * @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ModifyLiveMessageAppCallbackRequest $request ModifyLiveMessageAppCallbackRequest
     *
     * @return ModifyLiveMessageAppCallbackResponse ModifyLiveMessageAppCallbackResponse
     */
    public function modifyLiveMessageAppCallback($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyLiveMessageAppCallbackWithOptions($request, $runtime);
    }

    /**
     * @summary Disables or enables an interactive messaging application.
     *  *
     * @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ModifyLiveMessageAppDisableRequest $request ModifyLiveMessageAppDisableRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyLiveMessageAppDisableResponse ModifyLiveMessageAppDisableResponse
     */
    public function modifyLiveMessageAppDisableWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->dataCenter)) {
            $query['DataCenter'] = $request->dataCenter;
        }
        if (!Utils::isUnset($request->disable)) {
            $query['Disable'] = $request->disable;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyLiveMessageAppDisable',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyLiveMessageAppDisableResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Disables or enables an interactive messaging application.
     *  *
     * @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ModifyLiveMessageAppDisableRequest $request ModifyLiveMessageAppDisableRequest
     *
     * @return ModifyLiveMessageAppDisableResponse ModifyLiveMessageAppDisableResponse
     */
    public function modifyLiveMessageAppDisable($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyLiveMessageAppDisableWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the information about an interactive messaging group.
     *  *
     * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ModifyLiveMessageGroupRequest $tmpReq  ModifyLiveMessageGroupRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyLiveMessageGroupResponse ModifyLiveMessageGroupResponse
     */
    public function modifyLiveMessageGroupWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new ModifyLiveMessageGroupShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->adminList)) {
            $request->adminListShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->adminList, 'AdminList', 'simple');
        }
        $query = [];
        if (!Utils::isUnset($request->adminListShrink)) {
            $query['AdminList'] = $request->adminListShrink;
        }
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->dataCenter)) {
            $query['DataCenter'] = $request->dataCenter;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->groupInfo)) {
            $query['GroupInfo'] = $request->groupInfo;
        }
        if (!Utils::isUnset($request->modifyAdmin)) {
            $query['ModifyAdmin'] = $request->modifyAdmin;
        }
        if (!Utils::isUnset($request->modifyInfo)) {
            $query['ModifyInfo'] = $request->modifyInfo;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyLiveMessageGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyLiveMessageGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the information about an interactive messaging group.
     *  *
     * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ModifyLiveMessageGroupRequest $request ModifyLiveMessageGroupRequest
     *
     * @return ModifyLiveMessageGroupResponse ModifyLiveMessageGroupResponse
     */
    public function modifyLiveMessageGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyLiveMessageGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the mute status of users.
     *  *
     * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ModifyLiveMessageGroupBandRequest $tmpReq  ModifyLiveMessageGroupBandRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyLiveMessageGroupBandResponse ModifyLiveMessageGroupBandResponse
     */
    public function modifyLiveMessageGroupBandWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new ModifyLiveMessageGroupBandShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->bannnedUsers)) {
            $request->bannnedUsersShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->bannnedUsers, 'BannnedUsers', 'simple');
        }
        if (!Utils::isUnset($tmpReq->exceptUsers)) {
            $request->exceptUsersShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->exceptUsers, 'ExceptUsers', 'simple');
        }
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->bannedAll)) {
            $query['BannedAll'] = $request->bannedAll;
        }
        if (!Utils::isUnset($request->bannnedUsersShrink)) {
            $query['BannnedUsers'] = $request->bannnedUsersShrink;
        }
        if (!Utils::isUnset($request->dataCenter)) {
            $query['DataCenter'] = $request->dataCenter;
        }
        if (!Utils::isUnset($request->exceptUsersShrink)) {
            $query['ExceptUsers'] = $request->exceptUsersShrink;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyLiveMessageGroupBand',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyLiveMessageGroupBandResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the mute status of users.
     *  *
     * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ModifyLiveMessageGroupBandRequest $request ModifyLiveMessageGroupBandRequest
     *
     * @return ModifyLiveMessageGroupBandResponse ModifyLiveMessageGroupBandResponse
     */
    public function modifyLiveMessageGroupBand($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyLiveMessageGroupBandWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the information about a user.
     *  *
     * @param ModifyLiveMessageUserInfoRequest $request ModifyLiveMessageUserInfoRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyLiveMessageUserInfoResponse ModifyLiveMessageUserInfoResponse
     */
    public function modifyLiveMessageUserInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->dataCenter)) {
            $query['DataCenter'] = $request->dataCenter;
        }
        if (!Utils::isUnset($request->userId)) {
            $query['UserId'] = $request->userId;
        }
        if (!Utils::isUnset($request->userMetaInfo)) {
            $query['UserMetaInfo'] = $request->userMetaInfo;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyLiveMessageUserInfo',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyLiveMessageUserInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the information about a user.
     *  *
     * @param ModifyLiveMessageUserInfoRequest $request ModifyLiveMessageUserInfoRequest
     *
     * @return ModifyLiveMessageUserInfoResponse ModifyLiveMessageUserInfoResponse
     */
    public function modifyLiveMessageUserInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyLiveMessageUserInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configuration of real-time log delivery for a domain name.
     *  *
     * @description *   You can call this operation to modify the configuration of real-time log delivery for a domain name. Logs for a domain name can be delivered to only one Logstore.
     * This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
     * *   You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) operation to query the Project, Logstore, and Region parameters.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ModifyLiveRealtimeLogDeliveryRequest $request ModifyLiveRealtimeLogDeliveryRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyLiveRealtimeLogDeliveryResponse ModifyLiveRealtimeLogDeliveryResponse
     */
    public function modifyLiveRealtimeLogDeliveryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyLiveRealtimeLogDelivery',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyLiveRealtimeLogDeliveryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configuration of real-time log delivery for a domain name.
     *  *
     * @description *   You can call this operation to modify the configuration of real-time log delivery for a domain name. Logs for a domain name can be delivered to only one Logstore.
     * This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
     * *   You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) operation to query the Project, Logstore, and Region parameters.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ModifyLiveRealtimeLogDeliveryRequest $request ModifyLiveRealtimeLogDeliveryRequest
     *
     * @return ModifyLiveRealtimeLogDeliveryResponse ModifyLiveRealtimeLogDeliveryResponse
     */
    public function modifyLiveRealtimeLogDelivery($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyLiveRealtimeLogDeliveryWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the attributes of an episode list.
     *  *
     * @description This operation allows you to change the position of an episode in an episode list, how many times an episode list is played, and the specific point in time at which the episode of the highest priority in an episode list is played.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ModifyShowListRequest $request ModifyShowListRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyShowListResponse ModifyShowListResponse
     */
    public function modifyShowListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->highPriorityShowId)) {
            $query['HighPriorityShowId'] = $request->highPriorityShowId;
        }
        if (!Utils::isUnset($request->highPriorityShowStartTime)) {
            $query['HighPriorityShowStartTime'] = $request->highPriorityShowStartTime;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->repeatTimes)) {
            $query['RepeatTimes'] = $request->repeatTimes;
        }
        if (!Utils::isUnset($request->showId)) {
            $query['ShowId'] = $request->showId;
        }
        if (!Utils::isUnset($request->spot)) {
            $query['Spot'] = $request->spot;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyShowList',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyShowListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the attributes of an episode list.
     *  *
     * @description This operation allows you to change the position of an episode in an episode list, how many times an episode list is played, and the specific point in time at which the episode of the highest priority in an episode list is played.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ModifyShowListRequest $request ModifyShowListRequest
     *
     * @return ModifyShowListResponse ModifyShowListResponse
     */
    public function modifyShowList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyShowListWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies a layout of a virtual studio.
     *  *
     * @description You can call this operation to modify a layout of a virtual studio. When you call this operation, specify only the parameters that you want to modify.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ModifyStudioLayoutRequest $request ModifyStudioLayoutRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyStudioLayoutResponse ModifyStudioLayoutResponse
     */
    public function modifyStudioLayoutWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bgImageConfig)) {
            $query['BgImageConfig'] = $request->bgImageConfig;
        }
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->commonConfig)) {
            $query['CommonConfig'] = $request->commonConfig;
        }
        if (!Utils::isUnset($request->layerOrderConfigList)) {
            $query['LayerOrderConfigList'] = $request->layerOrderConfigList;
        }
        if (!Utils::isUnset($request->layoutId)) {
            $query['LayoutId'] = $request->layoutId;
        }
        if (!Utils::isUnset($request->layoutName)) {
            $query['LayoutName'] = $request->layoutName;
        }
        if (!Utils::isUnset($request->mediaInputConfigList)) {
            $query['MediaInputConfigList'] = $request->mediaInputConfigList;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->screenInputConfigList)) {
            $query['ScreenInputConfigList'] = $request->screenInputConfigList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyStudioLayout',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyStudioLayoutResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies a layout of a virtual studio.
     *  *
     * @description You can call this operation to modify a layout of a virtual studio. When you call this operation, specify only the parameters that you want to modify.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ModifyStudioLayoutRequest $request ModifyStudioLayoutRequest
     *
     * @return ModifyStudioLayoutResponse ModifyStudioLayoutResponse
     */
    public function modifyStudioLayout($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyStudioLayoutWithOptions($request, $runtime);
    }

    /**
     * @summary Mutes a message group. In this case, all members of the message group are muted.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param MuteAllGroupUserRequest $request MuteAllGroupUserRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return MuteAllGroupUserResponse MuteAllGroupUserResponse
     */
    public function muteAllGroupUserWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->appId)) {
            $body['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->broadCastType)) {
            $body['BroadCastType'] = $request->broadCastType;
        }
        if (!Utils::isUnset($request->groupId)) {
            $body['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->operatorUserId)) {
            $body['OperatorUserId'] = $request->operatorUserId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'MuteAllGroupUser',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return MuteAllGroupUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Mutes a message group. In this case, all members of the message group are muted.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param MuteAllGroupUserRequest $request MuteAllGroupUserRequest
     *
     * @return MuteAllGroupUserResponse MuteAllGroupUserResponse
     */
    public function muteAllGroupUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->muteAllGroupUserWithOptions($request, $runtime);
    }

    /**
     * @summary Mutes members in a message group.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param MuteGroupUserRequest $tmpReq  MuteGroupUserRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return MuteGroupUserResponse MuteGroupUserResponse
     */
    public function muteGroupUserWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new MuteGroupUserShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->muteUserList)) {
            $request->muteUserListShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->muteUserList, 'MuteUserList', 'simple');
        }
        $body = [];
        if (!Utils::isUnset($request->appId)) {
            $body['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->broadCastType)) {
            $body['BroadCastType'] = $request->broadCastType;
        }
        if (!Utils::isUnset($request->groupId)) {
            $body['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->muteTime)) {
            $body['MuteTime'] = $request->muteTime;
        }
        if (!Utils::isUnset($request->muteUserListShrink)) {
            $body['MuteUserList'] = $request->muteUserListShrink;
        }
        if (!Utils::isUnset($request->operatorUserId)) {
            $body['OperatorUserId'] = $request->operatorUserId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'MuteGroupUser',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return MuteGroupUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Mutes members in a message group.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param MuteGroupUserRequest $request MuteGroupUserRequest
     *
     * @return MuteGroupUserResponse MuteGroupUserResponse
     */
    public function muteGroupUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->muteGroupUserWithOptions($request, $runtime);
    }

    /**
     * @summary Enables time shifting for a domain name, or an application or a live stream under the domain name.
     *  *
     * @description You cannot configure time shifting and delayed transcoding at the same time.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param OpenLiveShiftRequest $request OpenLiveShiftRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return OpenLiveShiftResponse OpenLiveShiftResponse
     */
    public function openLiveShiftWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->duration)) {
            $query['Duration'] = $request->duration;
        }
        if (!Utils::isUnset($request->ignoreTranscode)) {
            $query['IgnoreTranscode'] = $request->ignoreTranscode;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        if (!Utils::isUnset($request->vision)) {
            $query['Vision'] = $request->vision;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'OpenLiveShift',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return OpenLiveShiftResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables time shifting for a domain name, or an application or a live stream under the domain name.
     *  *
     * @description You cannot configure time shifting and delayed transcoding at the same time.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param OpenLiveShiftRequest $request OpenLiveShiftRequest
     *
     * @return OpenLiveShiftResponse OpenLiveShiftResponse
     */
    public function openLiveShift($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->openLiveShiftWithOptions($request, $runtime);
    }

    /**
     * @summary Switches to a specified episode.
     *  *
     * @description After you add episodes to an episode list and start live streaming, you can call this operation to switch among episodes. For information about how to add episodes to an episode list, see [AddShowIntoShowList](https://help.aliyun.com/document_detail/2848051.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param PlayChoosenShowRequest $request PlayChoosenShowRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return PlayChoosenShowResponse PlayChoosenShowResponse
     */
    public function playChoosenShowWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->showId)) {
            $query['ShowId'] = $request->showId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'PlayChoosenShow',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return PlayChoosenShowResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Switches to a specified episode.
     *  *
     * @description After you add episodes to an episode list and start live streaming, you can call this operation to switch among episodes. For information about how to add episodes to an episode list, see [AddShowIntoShowList](https://help.aliyun.com/document_detail/2848051.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param PlayChoosenShowRequest $request PlayChoosenShowRequest
     *
     * @return PlayChoosenShowResponse PlayChoosenShowResponse
     */
    public function playChoosenShow($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->playChoosenShowWithOptions($request, $runtime);
    }

    /**
     * @summary Publishes the configurations of an accelerated domain name from the canary release environment to the production environment.
     *  *
     * @description Function name is required for calling this operation. You can get the function name by calling the [DescribeLiveDomainStagingConfig](~~297374#doc-api-live-DescribeLiveDomainStagingConfig~~ "Queries the configurations in the canary release environment.") operation.
     * ## QPS limit
     * A single user can perform a maximum of 30 queries per minute. Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
     *  *
     * @param PublishLiveStagingConfigToProductionRequest $request PublishLiveStagingConfigToProductionRequest
     * @param RuntimeOptions                              $runtime runtime options for this request RuntimeOptions
     *
     * @return PublishLiveStagingConfigToProductionResponse PublishLiveStagingConfigToProductionResponse
     */
    public function publishLiveStagingConfigToProductionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->functionName)) {
            $query['FunctionName'] = $request->functionName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'PublishLiveStagingConfigToProduction',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return PublishLiveStagingConfigToProductionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Publishes the configurations of an accelerated domain name from the canary release environment to the production environment.
     *  *
     * @description Function name is required for calling this operation. You can get the function name by calling the [DescribeLiveDomainStagingConfig](~~297374#doc-api-live-DescribeLiveDomainStagingConfig~~ "Queries the configurations in the canary release environment.") operation.
     * ## QPS limit
     * A single user can perform a maximum of 30 queries per minute. Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
     *  *
     * @param PublishLiveStagingConfigToProductionRequest $request PublishLiveStagingConfigToProductionRequest
     *
     * @return PublishLiveStagingConfigToProductionResponse PublishLiveStagingConfigToProductionResponse
     */
    public function publishLiveStagingConfigToProduction($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->publishLiveStagingConfigToProductionWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the dual-stream disaster recovery records of online streams.
     *  *
     * @param QueryLiveDomainMultiStreamListRequest $request QueryLiveDomainMultiStreamListRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryLiveDomainMultiStreamListResponse QueryLiveDomainMultiStreamListResponse
     */
    public function queryLiveDomainMultiStreamListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'QueryLiveDomainMultiStreamList',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return QueryLiveDomainMultiStreamListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the dual-stream disaster recovery records of online streams.
     *  *
     * @param QueryLiveDomainMultiStreamListRequest $request QueryLiveDomainMultiStreamListRequest
     *
     * @return QueryLiveDomainMultiStreamListResponse QueryLiveDomainMultiStreamListResponse
     */
    public function queryLiveDomainMultiStreamList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryLiveDomainMultiStreamListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries interactive messaging applications based on specified conditions.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param QueryMessageAppRequest $request QueryMessageAppRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryMessageAppResponse QueryMessageAppResponse
     */
    public function queryMessageAppWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->appId)) {
            $body['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->appName)) {
            $body['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->pageNum)) {
            $body['PageNum'] = $request->pageNum;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->sortType)) {
            $body['SortType'] = $request->sortType;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'QueryMessageApp',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return QueryMessageAppResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries interactive messaging applications based on specified conditions.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param QueryMessageAppRequest $request QueryMessageAppRequest
     *
     * @return QueryMessageAppResponse QueryMessageAppResponse
     */
    public function queryMessageApp($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryMessageAppWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the status of a speech-to-text or translation task.
     *  *
     * @description You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param QueryRtcAsrTasksRequest $request QueryRtcAsrTasksRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryRtcAsrTasksResponse QueryRtcAsrTasksResponse
     */
    public function queryRtcAsrTasksWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'QueryRtcAsrTasks',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return QueryRtcAsrTasksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the status of a speech-to-text or translation task.
     *  *
     * @description You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param QueryRtcAsrTasksRequest $request QueryRtcAsrTasksRequest
     *
     * @return QueryRtcAsrTasksResponse QueryRtcAsrTasksResponse
     */
    public function queryRtcAsrTasks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryRtcAsrTasksWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configuration of authentication for snapshot callbacks.
     *  *
     * @description Before you call this operation, make sure that you have configured authentication for snapshot callbacks. For more information, see [SetSnapshotCallbackAuth](https://help.aliyun.com/document_detail/2847907.html). You can call this operation to query the configuration of authentication for snapshot callbacks for a main streaming domain. Make sure that the parameter settings meet the requirements.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param QuerySnapshotCallbackAuthRequest $request QuerySnapshotCallbackAuthRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return QuerySnapshotCallbackAuthResponse QuerySnapshotCallbackAuthResponse
     */
    public function querySnapshotCallbackAuthWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'QuerySnapshotCallbackAuth',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return QuerySnapshotCallbackAuthResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configuration of authentication for snapshot callbacks.
     *  *
     * @description Before you call this operation, make sure that you have configured authentication for snapshot callbacks. For more information, see [SetSnapshotCallbackAuth](https://help.aliyun.com/document_detail/2847907.html). You can call this operation to query the configuration of authentication for snapshot callbacks for a main streaming domain. Make sure that the parameter settings meet the requirements.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param QuerySnapshotCallbackAuthRequest $request QuerySnapshotCallbackAuthRequest
     *
     * @return QuerySnapshotCallbackAuthResponse QuerySnapshotCallbackAuthResponse
     */
    public function querySnapshotCallbackAuth($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->querySnapshotCallbackAuthWithOptions($request, $runtime);
    }

    /**
     * @summary Controls recordings manually on demand. For example, you can call this operation to start or stop recording at a specific point in time.
     *  *
     * @description *   Before you call this operation, make sure that you fully understand the billing method and pricing of live stream recording in ApsaraVideo Live. For more information, see [Billing of live stream recording](https://help.aliyun.com/document_detail/195287.html).
     * *   If a live stream is being automatically or manually recorded, you can call this operation to stop recording the live stream.
     * *   If you call this operation to start recording a live stream while it is being recorded, a TaskAlreadyStarted error is returned, indicating that the task has been started.
     * *   If a live stream that you manually record is interrupted, the recording stops.
     * *   If automatic recording is not configured for the live stream, ApsaraVideo Live does not automatically record the live stream after it is resumed.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param RealTimeRecordCommandRequest $request RealTimeRecordCommandRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return RealTimeRecordCommandResponse RealTimeRecordCommandResponse
     */
    public function realTimeRecordCommandWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->command)) {
            $query['Command'] = $request->command;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'RealTimeRecordCommand',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RealTimeRecordCommandResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Controls recordings manually on demand. For example, you can call this operation to start or stop recording at a specific point in time.
     *  *
     * @description *   Before you call this operation, make sure that you fully understand the billing method and pricing of live stream recording in ApsaraVideo Live. For more information, see [Billing of live stream recording](https://help.aliyun.com/document_detail/195287.html).
     * *   If a live stream is being automatically or manually recorded, you can call this operation to stop recording the live stream.
     * *   If you call this operation to start recording a live stream while it is being recorded, a TaskAlreadyStarted error is returned, indicating that the task has been started.
     * *   If a live stream that you manually record is interrupted, the recording stops.
     * *   If automatic recording is not configured for the live stream, ApsaraVideo Live does not automatically record the live stream after it is resumed.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param RealTimeRecordCommandRequest $request RealTimeRecordCommandRequest
     *
     * @return RealTimeRecordCommandResponse RealTimeRecordCommandResponse
     */
    public function realTimeRecordCommand($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->realTimeRecordCommandWithOptions($request, $runtime);
    }

    /**
     * @summary Restores a deleted interactive messaging group.
     *  *
     * @description *   You can call this operation to restore a deleted interactive messaging group within 30 days after you call the [DeleteLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) to delete the group.
     * *   After you restore a group, the messages that were stored in the group before it was deleted can still be queried.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param RecoverLiveMessageDeletedGroupRequest $request RecoverLiveMessageDeletedGroupRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return RecoverLiveMessageDeletedGroupResponse RecoverLiveMessageDeletedGroupResponse
     */
    public function recoverLiveMessageDeletedGroupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->dataCenter)) {
            $query['DataCenter'] = $request->dataCenter;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'RecoverLiveMessageDeletedGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RecoverLiveMessageDeletedGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Restores a deleted interactive messaging group.
     *  *
     * @description *   You can call this operation to restore a deleted interactive messaging group within 30 days after you call the [DeleteLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) to delete the group.
     * *   After you restore a group, the messages that were stored in the group before it was deleted can still be queried.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param RecoverLiveMessageDeletedGroupRequest $request RecoverLiveMessageDeletedGroupRequest
     *
     * @return RecoverLiveMessageDeletedGroupResponse RecoverLiveMessageDeletedGroupResponse
     */
    public function recoverLiveMessageDeletedGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->recoverLiveMessageDeletedGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Unmutes one or more users.
     *  *
     * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param RemoveLiveMessageGroupBandRequest $tmpReq  RemoveLiveMessageGroupBandRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return RemoveLiveMessageGroupBandResponse RemoveLiveMessageGroupBandResponse
     */
    public function removeLiveMessageGroupBandWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new RemoveLiveMessageGroupBandShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->unbannedUsers)) {
            $request->unbannedUsersShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->unbannedUsers, 'UnbannedUsers', 'simple');
        }
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->dataCenter)) {
            $query['DataCenter'] = $request->dataCenter;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->unbannedUsersShrink)) {
            $query['UnbannedUsers'] = $request->unbannedUsersShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'RemoveLiveMessageGroupBand',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RemoveLiveMessageGroupBandResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Unmutes one or more users.
     *  *
     * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param RemoveLiveMessageGroupBandRequest $request RemoveLiveMessageGroupBandRequest
     *
     * @return RemoveLiveMessageGroupBandResponse RemoveLiveMessageGroupBandResponse
     */
    public function removeLiveMessageGroupBand($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->removeLiveMessageGroupBandWithOptions($request, $runtime);
    }

    /**
     * @summary Removes a specified episode from an episode list.
     *  *
     * @description ## [](#)Usage notes
     * You cannot use this operation on empty episode lists. For information about how to add episodes to an episode list, see [AddShowIntoShowList](https://help.aliyun.com/document_detail/370861.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param RemoveShowFromShowListRequest $request RemoveShowFromShowListRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return RemoveShowFromShowListResponse RemoveShowFromShowListResponse
     */
    public function removeShowFromShowListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->showId)) {
            $query['ShowId'] = $request->showId;
        }
        if (!Utils::isUnset($request->isBatchMode)) {
            $query['isBatchMode'] = $request->isBatchMode;
        }
        if (!Utils::isUnset($request->showIdList)) {
            $query['showIdList'] = $request->showIdList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'RemoveShowFromShowList',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RemoveShowFromShowListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Removes a specified episode from an episode list.
     *  *
     * @description ## [](#)Usage notes
     * You cannot use this operation on empty episode lists. For information about how to add episodes to an episode list, see [AddShowIntoShowList](https://help.aliyun.com/document_detail/370861.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param RemoveShowFromShowListRequest $request RemoveShowFromShowListRequest
     *
     * @return RemoveShowFromShowListResponse RemoveShowFromShowListResponse
     */
    public function removeShowFromShowList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->removeShowFromShowListWithOptions($request, $runtime);
    }

    /**
     * @summary Removes users from a channel.
     *  *
     * @description You can call this operation to remove one or more users from a channel.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param RemoveTerminalsRequest $request RemoveTerminalsRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return RemoveTerminalsResponse RemoveTerminalsResponse
     */
    public function removeTerminalsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->channelId)) {
            $query['ChannelId'] = $request->channelId;
        }
        if (!Utils::isUnset($request->terminalIds)) {
            $query['TerminalIds'] = $request->terminalIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'RemoveTerminals',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RemoveTerminalsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Removes users from a channel.
     *  *
     * @description You can call this operation to remove one or more users from a channel.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param RemoveTerminalsRequest $request RemoveTerminalsRequest
     *
     * @return RemoveTerminalsResponse RemoveTerminalsResponse
     */
    public function removeTerminals($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->removeTerminalsWithOptions($request, $runtime);
    }

    /**
     * @summary Restarts a production studio.
     *  *
     * @description *   Only product studios in playlist mode and general mode are supported. Virtual studios are not supported.
     * *   After you restart a production studio, the current settings such as the resolution and screen orientation are reloaded to restore the previous playback status.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param RestartCasterRequest $request RestartCasterRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return RestartCasterResponse RestartCasterResponse
     */
    public function restartCasterWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'RestartCaster',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RestartCasterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Restarts a production studio.
     *  *
     * @description *   Only product studios in playlist mode and general mode are supported. Virtual studios are not supported.
     * *   After you restart a production studio, the current settings such as the resolution and screen orientation are reloaded to restore the previous playback status.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param RestartCasterRequest $request RestartCasterRequest
     *
     * @return RestartCasterResponse RestartCasterResponse
     */
    public function restartCaster($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->restartCasterWithOptions($request, $runtime);
    }

    /**
     * @summary Restarts a pulled-stream relay task.
     *  *
     * @description *   You can call this operation to restart a pulled-stream relay task.
     * *   You can restart a task that is running (even if the task is in an abnormal retry state) or a task that is stopped. For a task that is running, this operation stops and then restarts it. For a task that is stopped, this operation directly starts it.
     * *   You cannot restart a task if the start time specified for the task has not been reached.
     * *   If a task is restarted, the task runs based on the latest configuration of the task. This interrupts stream ingest.
     * *   If a task for a list of ApsaraVideo VOD resources is restarted, the list plays from the beginning based on the latest configuration. You can call an operation to update the video index and playback progress to achieve successive playback.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param RestartLivePullToPushRequest $request RestartLivePullToPushRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return RestartLivePullToPushResponse RestartLivePullToPushResponse
     */
    public function restartLivePullToPushWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'RestartLivePullToPush',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RestartLivePullToPushResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Restarts a pulled-stream relay task.
     *  *
     * @description *   You can call this operation to restart a pulled-stream relay task.
     * *   You can restart a task that is running (even if the task is in an abnormal retry state) or a task that is stopped. For a task that is running, this operation stops and then restarts it. For a task that is stopped, this operation directly starts it.
     * *   You cannot restart a task if the start time specified for the task has not been reached.
     * *   If a task is restarted, the task runs based on the latest configuration of the task. This interrupts stream ingest.
     * *   If a task for a list of ApsaraVideo VOD resources is restarted, the list plays from the beginning based on the latest configuration. You can call an operation to update the video index and playback progress to achieve successive playback.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param RestartLivePullToPushRequest $request RestartLivePullToPushRequest
     *
     * @return RestartLivePullToPushResponse RestartLivePullToPushResponse
     */
    public function restartLivePullToPush($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->restartLivePullToPushWithOptions($request, $runtime);
    }

    /**
     * @param RestartTranscodeTaskRequest $request RestartTranscodeTaskRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return RestartTranscodeTaskResponse RestartTranscodeTaskResponse
     */
    public function restartTranscodeTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->app)) {
            $query['App'] = $request->app;
        }
        if (!Utils::isUnset($request->pushDomain)) {
            $query['PushDomain'] = $request->pushDomain;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        if (!Utils::isUnset($request->transcodingTemplate)) {
            $query['TranscodingTemplate'] = $request->transcodingTemplate;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'RestartTranscodeTask',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RestartTranscodeTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param RestartTranscodeTaskRequest $request RestartTranscodeTaskRequest
     *
     * @return RestartTranscodeTaskResponse RestartTranscodeTaskResponse
     */
    public function restartTranscodeTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->restartTranscodeTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Resumes the ingest of a live stream.
     *  *
     * @description You can call this operation to resume the ingest of a stream. This operation supports only the live streams ingested by streamers.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ResumeLiveStreamRequest $request ResumeLiveStreamRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return ResumeLiveStreamResponse ResumeLiveStreamResponse
     */
    public function resumeLiveStreamWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->liveStreamType)) {
            $query['LiveStreamType'] = $request->liveStreamType;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'ResumeLiveStream',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ResumeLiveStreamResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Resumes the ingest of a live stream.
     *  *
     * @description You can call this operation to resume the ingest of a stream. This operation supports only the live streams ingested by streamers.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param ResumeLiveStreamRequest $request ResumeLiveStreamRequest
     *
     * @return ResumeLiveStreamResponse ResumeLiveStreamResponse
     */
    public function resumeLiveStream($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->resumeLiveStreamWithOptions($request, $runtime);
    }

    /**
     * @summary Rolls back the configurations of an accelerated domain name in the canary release environment.
     *  *
     * @description Function name is required for calling this operation. You can get the function name by calling the [DescribeLiveDomainStagingConfig](~~297374#doc-api-live-DescribeLiveDomainStagingConfig~~ "Queries the configurations in the canary release environment.") operation.
     * ## QPS limit
     * A single user can perform a maximum of 30 queries per minute. Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
     *  *
     * @param RollbackLiveStagingConfigRequest $request RollbackLiveStagingConfigRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return RollbackLiveStagingConfigResponse RollbackLiveStagingConfigResponse
     */
    public function rollbackLiveStagingConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->functionName)) {
            $query['FunctionName'] = $request->functionName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'RollbackLiveStagingConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RollbackLiveStagingConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Rolls back the configurations of an accelerated domain name in the canary release environment.
     *  *
     * @description Function name is required for calling this operation. You can get the function name by calling the [DescribeLiveDomainStagingConfig](~~297374#doc-api-live-DescribeLiveDomainStagingConfig~~ "Queries the configurations in the canary release environment.") operation.
     * ## QPS limit
     * A single user can perform a maximum of 30 queries per minute. Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
     *  *
     * @param RollbackLiveStagingConfigRequest $request RollbackLiveStagingConfigRequest
     *
     * @return RollbackLiveStagingConfigResponse RollbackLiveStagingConfigResponse
     */
    public function rollbackLiveStagingConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->rollbackLiveStagingConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Configures likes in a message group.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param SendLikeRequest $request SendLikeRequest
     * @param RuntimeOptions  $runtime runtime options for this request RuntimeOptions
     *
     * @return SendLikeResponse SendLikeResponse
     */
    public function sendLikeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->appId)) {
            $body['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->broadCastType)) {
            $body['BroadCastType'] = $request->broadCastType;
        }
        if (!Utils::isUnset($request->count)) {
            $body['Count'] = $request->count;
        }
        if (!Utils::isUnset($request->groupId)) {
            $body['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->operatorUserId)) {
            $body['OperatorUserId'] = $request->operatorUserId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'SendLike',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SendLikeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures likes in a message group.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param SendLikeRequest $request SendLikeRequest
     *
     * @return SendLikeResponse SendLikeResponse
     */
    public function sendLike($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->sendLikeWithOptions($request, $runtime);
    }

    /**
     * @summary Sends a message to a group.
     *  *
     * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group. You can send messages to a group only if the group is active, which requires that one or more users have joined the group. Offline messages are not supported. If you fail to send a message, check whether users exist in the group. If you want to send a message when all users are offline, we recommend that you store the message locally and send it after users get online.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param SendLiveMessageGroupRequest $request SendLiveMessageGroupRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return SendLiveMessageGroupResponse SendLiveMessageGroupResponse
     */
    public function sendLiveMessageGroupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->body)) {
            $query['Body'] = $request->body;
        }
        if (!Utils::isUnset($request->dataCenter)) {
            $query['DataCenter'] = $request->dataCenter;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->msgTid)) {
            $query['MsgTid'] = $request->msgTid;
        }
        if (!Utils::isUnset($request->msgType)) {
            $query['MsgType'] = $request->msgType;
        }
        if (!Utils::isUnset($request->noCache)) {
            $query['NoCache'] = $request->noCache;
        }
        if (!Utils::isUnset($request->noStorage)) {
            $query['NoStorage'] = $request->noStorage;
        }
        if (!Utils::isUnset($request->senderId)) {
            $query['SenderId'] = $request->senderId;
        }
        if (!Utils::isUnset($request->senderMetaInfo)) {
            $query['SenderMetaInfo'] = $request->senderMetaInfo;
        }
        if (!Utils::isUnset($request->staticsIncrease)) {
            $query['StaticsIncrease'] = $request->staticsIncrease;
        }
        if (!Utils::isUnset($request->weight)) {
            $query['Weight'] = $request->weight;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'SendLiveMessageGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SendLiveMessageGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Sends a message to a group.
     *  *
     * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group. You can send messages to a group only if the group is active, which requires that one or more users have joined the group. Offline messages are not supported. If you fail to send a message, check whether users exist in the group. If you want to send a message when all users are offline, we recommend that you store the message locally and send it after users get online.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param SendLiveMessageGroupRequest $request SendLiveMessageGroupRequest
     *
     * @return SendLiveMessageGroupResponse SendLiveMessageGroupResponse
     */
    public function sendLiveMessageGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->sendLiveMessageGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Sends a message to a specified user. The user is identified by ReceiverId.
     *  *
     * @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param SendLiveMessageUserRequest $request SendLiveMessageUserRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return SendLiveMessageUserResponse SendLiveMessageUserResponse
     */
    public function sendLiveMessageUserWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->body)) {
            $query['Body'] = $request->body;
        }
        if (!Utils::isUnset($request->dataCenter)) {
            $query['DataCenter'] = $request->dataCenter;
        }
        if (!Utils::isUnset($request->highReliability)) {
            $query['HighReliability'] = $request->highReliability;
        }
        if (!Utils::isUnset($request->msgTid)) {
            $query['MsgTid'] = $request->msgTid;
        }
        if (!Utils::isUnset($request->msgType)) {
            $query['MsgType'] = $request->msgType;
        }
        if (!Utils::isUnset($request->receiverId)) {
            $query['ReceiverId'] = $request->receiverId;
        }
        if (!Utils::isUnset($request->senderId)) {
            $query['SenderId'] = $request->senderId;
        }
        if (!Utils::isUnset($request->senderInfo)) {
            $query['SenderInfo'] = $request->senderInfo;
        }
        if (!Utils::isUnset($request->storage)) {
            $query['Storage'] = $request->storage;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'SendLiveMessageUser',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SendLiveMessageUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Sends a message to a specified user. The user is identified by ReceiverId.
     *  *
     * @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param SendLiveMessageUserRequest $request SendLiveMessageUserRequest
     *
     * @return SendLiveMessageUserResponse SendLiveMessageUserResponse
     */
    public function sendLiveMessageUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->sendLiveMessageUserWithOptions($request, $runtime);
    }

    /**
     * @summary Sends a message to all members in a message group.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param SendMessageToGroupRequest $request SendMessageToGroupRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return SendMessageToGroupResponse SendMessageToGroupResponse
     */
    public function sendMessageToGroupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->skipAudit)) {
            $query['SkipAudit'] = $request->skipAudit;
        }
        $body = [];
        if (!Utils::isUnset($request->appId)) {
            $body['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->data)) {
            $body['Data'] = $request->data;
        }
        if (!Utils::isUnset($request->groupId)) {
            $body['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->operatorUserId)) {
            $body['OperatorUserId'] = $request->operatorUserId;
        }
        if (!Utils::isUnset($request->type)) {
            $body['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'SendMessageToGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SendMessageToGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Sends a message to all members in a message group.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param SendMessageToGroupRequest $request SendMessageToGroupRequest
     *
     * @return SendMessageToGroupResponse SendMessageToGroupResponse
     */
    public function sendMessageToGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->sendMessageToGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Sends a message to specified users in a message group.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param SendMessageToGroupUsersRequest $tmpReq  SendMessageToGroupUsersRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return SendMessageToGroupUsersResponse SendMessageToGroupUsersResponse
     */
    public function sendMessageToGroupUsersWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new SendMessageToGroupUsersShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->receiverIdList)) {
            $request->receiverIdListShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->receiverIdList, 'ReceiverIdList', 'simple');
        }
        $query = [];
        if (!Utils::isUnset($request->skipAudit)) {
            $query['SkipAudit'] = $request->skipAudit;
        }
        $body = [];
        if (!Utils::isUnset($request->appId)) {
            $body['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->data)) {
            $body['Data'] = $request->data;
        }
        if (!Utils::isUnset($request->groupId)) {
            $body['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->operatorUserId)) {
            $body['OperatorUserId'] = $request->operatorUserId;
        }
        if (!Utils::isUnset($request->receiverIdListShrink)) {
            $body['ReceiverIdList'] = $request->receiverIdListShrink;
        }
        if (!Utils::isUnset($request->type)) {
            $body['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'SendMessageToGroupUsers',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SendMessageToGroupUsersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Sends a message to specified users in a message group.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param SendMessageToGroupUsersRequest $request SendMessageToGroupUsersRequest
     *
     * @return SendMessageToGroupUsersResponse SendMessageToGroupUsersResponse
     */
    public function sendMessageToGroupUsers($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->sendMessageToGroupUsersWithOptions($request, $runtime);
    }

    /**
     * @summary Configures a channel of a production studio.
     *  *
     * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to configure a channel for the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param SetCasterChannelRequest $request SetCasterChannelRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return SetCasterChannelResponse SetCasterChannelResponse
     */
    public function setCasterChannelWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->channelId)) {
            $query['ChannelId'] = $request->channelId;
        }
        if (!Utils::isUnset($request->faceBeauty)) {
            $query['FaceBeauty'] = $request->faceBeauty;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->playStatus)) {
            $query['PlayStatus'] = $request->playStatus;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceId)) {
            $query['ResourceId'] = $request->resourceId;
        }
        if (!Utils::isUnset($request->seekOffset)) {
            $query['SeekOffset'] = $request->seekOffset;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'SetCasterChannel',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetCasterChannelResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures a channel of a production studio.
     *  *
     * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to configure a channel for the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param SetCasterChannelRequest $request SetCasterChannelRequest
     *
     * @return SetCasterChannelResponse SetCasterChannelResponse
     */
    public function setCasterChannel($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setCasterChannelWithOptions($request, $runtime);
    }

    /**
     * @summary Configures a production studio. For example, you can specify the name of the production studio, configure the transcoding settings, and configure the recording settings.
     *  *
     * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to configure the production studio. This operation completely replaces existing configurations. If you leave a parameter empty, the corresponding configuration is cleared for the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param SetCasterConfigRequest $request SetCasterConfigRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return SetCasterConfigResponse SetCasterConfigResponse
     */
    public function setCasterConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->autoSwitchUrgentConfig)) {
            $query['AutoSwitchUrgentConfig'] = $request->autoSwitchUrgentConfig;
        }
        if (!Utils::isUnset($request->autoSwitchUrgentOn)) {
            $query['AutoSwitchUrgentOn'] = $request->autoSwitchUrgentOn;
        }
        if (!Utils::isUnset($request->callbackUrl)) {
            $query['CallbackUrl'] = $request->callbackUrl;
        }
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->casterName)) {
            $query['CasterName'] = $request->casterName;
        }
        if (!Utils::isUnset($request->channelEnable)) {
            $query['ChannelEnable'] = $request->channelEnable;
        }
        if (!Utils::isUnset($request->delay)) {
            $query['Delay'] = $request->delay;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->programEffect)) {
            $query['ProgramEffect'] = $request->programEffect;
        }
        if (!Utils::isUnset($request->programName)) {
            $query['ProgramName'] = $request->programName;
        }
        if (!Utils::isUnset($request->recordConfig)) {
            $query['RecordConfig'] = $request->recordConfig;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->sideOutputUrl)) {
            $query['SideOutputUrl'] = $request->sideOutputUrl;
        }
        if (!Utils::isUnset($request->sideOutputUrlList)) {
            $query['SideOutputUrlList'] = $request->sideOutputUrlList;
        }
        if (!Utils::isUnset($request->syncGroupsConfig)) {
            $query['SyncGroupsConfig'] = $request->syncGroupsConfig;
        }
        if (!Utils::isUnset($request->transcodeConfig)) {
            $query['TranscodeConfig'] = $request->transcodeConfig;
        }
        if (!Utils::isUnset($request->urgentImageId)) {
            $query['UrgentImageId'] = $request->urgentImageId;
        }
        if (!Utils::isUnset($request->urgentImageUrl)) {
            $query['UrgentImageUrl'] = $request->urgentImageUrl;
        }
        if (!Utils::isUnset($request->urgentLiveStreamUrl)) {
            $query['UrgentLiveStreamUrl'] = $request->urgentLiveStreamUrl;
        }
        if (!Utils::isUnset($request->urgentMaterialId)) {
            $query['UrgentMaterialId'] = $request->urgentMaterialId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'SetCasterConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetCasterConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures a production studio. For example, you can specify the name of the production studio, configure the transcoding settings, and configure the recording settings.
     *  *
     * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to configure the production studio. This operation completely replaces existing configurations. If you leave a parameter empty, the corresponding configuration is cleared for the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param SetCasterConfigRequest $request SetCasterConfigRequest
     *
     * @return SetCasterConfigResponse SetCasterConfigResponse
     */
    public function setCasterConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setCasterConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Configures all settings of a scene. This is done by clearing all previous settings of the scene and applying new settings, including the layout setting, to the scene.
     *  *
     * @description ## [](#)Usage notes
     * This operation configures a scene by clearing all previous settings of the scene and applying new settings, including the layout setting, to the scene.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param SetCasterSceneConfigRequest $request SetCasterSceneConfigRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return SetCasterSceneConfigResponse SetCasterSceneConfigResponse
     */
    public function setCasterSceneConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->componentId)) {
            $query['ComponentId'] = $request->componentId;
        }
        if (!Utils::isUnset($request->layoutId)) {
            $query['LayoutId'] = $request->layoutId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->sceneId)) {
            $query['SceneId'] = $request->sceneId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'SetCasterSceneConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetCasterSceneConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures all settings of a scene. This is done by clearing all previous settings of the scene and applying new settings, including the layout setting, to the scene.
     *  *
     * @description ## [](#)Usage notes
     * This operation configures a scene by clearing all previous settings of the scene and applying new settings, including the layout setting, to the scene.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param SetCasterSceneConfigRequest $request SetCasterSceneConfigRequest
     *
     * @return SetCasterSceneConfigResponse SetCasterSceneConfigResponse
     */
    public function setCasterSceneConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setCasterSceneConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Enables or disables the certificate of a domain name, and modifies the certificate information.
     *  *
     * @description Obtain the domain name, and then call this operation to enable or disable the certificate of a domain name and modify the certificate information.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param SetLiveDomainCertificateRequest $request SetLiveDomainCertificateRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return SetLiveDomainCertificateResponse SetLiveDomainCertificateResponse
     */
    public function setLiveDomainCertificateWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->certName)) {
            $query['CertName'] = $request->certName;
        }
        if (!Utils::isUnset($request->certType)) {
            $query['CertType'] = $request->certType;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->forceSet)) {
            $query['ForceSet'] = $request->forceSet;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->SSLPri)) {
            $query['SSLPri'] = $request->SSLPri;
        }
        if (!Utils::isUnset($request->SSLProtocol)) {
            $query['SSLProtocol'] = $request->SSLProtocol;
        }
        if (!Utils::isUnset($request->SSLPub)) {
            $query['SSLPub'] = $request->SSLPub;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'SetLiveDomainCertificate',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetLiveDomainCertificateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables or disables the certificate of a domain name, and modifies the certificate information.
     *  *
     * @description Obtain the domain name, and then call this operation to enable or disable the certificate of a domain name and modify the certificate information.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param SetLiveDomainCertificateRequest $request SetLiveDomainCertificateRequest
     *
     * @return SetLiveDomainCertificateResponse SetLiveDomainCertificateResponse
     */
    public function setLiveDomainCertificate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setLiveDomainCertificateWithOptions($request, $runtime);
    }

    /**
     * @summary Configures dual-stream disaster recovery for a streaming domain.
     *  *
     * @description You can call this operation to configure dual-stream disaster recovery for a streaming domain, which allows you to ingest two streams that have the same name.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param SetLiveDomainMultiStreamConfigRequest $request SetLiveDomainMultiStreamConfigRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return SetLiveDomainMultiStreamConfigResponse SetLiveDomainMultiStreamConfigResponse
     */
    public function setLiveDomainMultiStreamConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'SetLiveDomainMultiStreamConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetLiveDomainMultiStreamConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures dual-stream disaster recovery for a streaming domain.
     *  *
     * @description You can call this operation to configure dual-stream disaster recovery for a streaming domain, which allows you to ingest two streams that have the same name.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param SetLiveDomainMultiStreamConfigRequest $request SetLiveDomainMultiStreamConfigRequest
     *
     * @return SetLiveDomainMultiStreamConfigResponse SetLiveDomainMultiStreamConfigResponse
     */
    public function setLiveDomainMultiStreamConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setLiveDomainMultiStreamConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Manually switches between the active stream and standby stream.
     *  *
     * @param SetLiveDomainMultiStreamMasterRequest $request SetLiveDomainMultiStreamMasterRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return SetLiveDomainMultiStreamMasterResponse SetLiveDomainMultiStreamMasterResponse
     */
    public function setLiveDomainMultiStreamMasterWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'SetLiveDomainMultiStreamMaster',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetLiveDomainMultiStreamMasterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Manually switches between the active stream and standby stream.
     *  *
     * @param SetLiveDomainMultiStreamMasterRequest $request SetLiveDomainMultiStreamMasterRequest
     *
     * @return SetLiveDomainMultiStreamMasterResponse SetLiveDomainMultiStreamMasterResponse
     */
    public function setLiveDomainMultiStreamMaster($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setLiveDomainMultiStreamMasterWithOptions($request, $runtime);
    }

    /**
     * @summary Configures the auto mode of dual-stream disaster recovery.
     *  *
     * @param SetLiveDomainMultiStreamOptimalModeRequest $request SetLiveDomainMultiStreamOptimalModeRequest
     * @param RuntimeOptions                             $runtime runtime options for this request RuntimeOptions
     *
     * @return SetLiveDomainMultiStreamOptimalModeResponse SetLiveDomainMultiStreamOptimalModeResponse
     */
    public function setLiveDomainMultiStreamOptimalModeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'SetLiveDomainMultiStreamOptimalMode',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetLiveDomainMultiStreamOptimalModeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures the auto mode of dual-stream disaster recovery.
     *  *
     * @param SetLiveDomainMultiStreamOptimalModeRequest $request SetLiveDomainMultiStreamOptimalModeRequest
     *
     * @return SetLiveDomainMultiStreamOptimalModeResponse SetLiveDomainMultiStreamOptimalModeResponse
     */
    public function setLiveDomainMultiStreamOptimalMode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setLiveDomainMultiStreamOptimalModeWithOptions($request, $runtime);
    }

    /**
     * @summary Sets or modifies domain name configurations in the canary release environment.
     *  *
     * @description ## [](#)Usage notes
     * Obtain the accelerated domain name, and then call this operation to set or modify the domain name configurations in the canary release environment. For more information, see **Format of the Functions parameter**.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param SetLiveDomainStagingConfigRequest $request SetLiveDomainStagingConfigRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return SetLiveDomainStagingConfigResponse SetLiveDomainStagingConfigResponse
     */
    public function setLiveDomainStagingConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->functions)) {
            $query['Functions'] = $request->functions;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'SetLiveDomainStagingConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetLiveDomainStagingConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Sets or modifies domain name configurations in the canary release environment.
     *  *
     * @description ## [](#)Usage notes
     * Obtain the accelerated domain name, and then call this operation to set or modify the domain name configurations in the canary release environment. For more information, see **Format of the Functions parameter**.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param SetLiveDomainStagingConfigRequest $request SetLiveDomainStagingConfigRequest
     *
     * @return SetLiveDomainStagingConfigResponse SetLiveDomainStagingConfigResponse
     */
    public function setLiveDomainStagingConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setLiveDomainStagingConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Sets the configuration of edge stream relay.
     *  *
     * @description You can call the SetLiveEdgeTransfer operation to configure edge stream relay. The configuration takes effect for ingested streams that start after edge stream relay is configured. The following table describes the scenarios in which edge stream relay takes effect or not.
     * |Scenario|Analysis|Result|
     * |---|---|---|
     * |1\\. You ingest a stream before you call the SetLiveEdgeTransfer operation.|The configuration of edge stream relay is not available.|The ingested stream is not affected by your call of the SetLiveEdgeTransfer operation. Edge stream relay does not take effect.|
     * |2\\. You disconnect an ingested stream that started before you called the SetLiveEdgeTransfer operation, and then resume the ingested stream.|The configuration of edge stream relay is available.|Edge stream relay takes effect for the resumed ingested stream based on the configuration.|
     * |3\\. You ingest a stream after you call the SetLiveEdgeTransfer operation.|The configuration of edge stream relay is available.|Edge stream relay takes effect for the ingested stream based on the configuration.|
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param SetLiveEdgeTransferRequest $request SetLiveEdgeTransferRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return SetLiveEdgeTransferResponse SetLiveEdgeTransferResponse
     */
    public function setLiveEdgeTransferWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->httpDns)) {
            $query['HttpDns'] = $request->httpDns;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        if (!Utils::isUnset($request->targetDomainList)) {
            $query['TargetDomainList'] = $request->targetDomainList;
        }
        if (!Utils::isUnset($request->transferArgs)) {
            $query['TransferArgs'] = $request->transferArgs;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'SetLiveEdgeTransfer',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetLiveEdgeTransferResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Sets the configuration of edge stream relay.
     *  *
     * @description You can call the SetLiveEdgeTransfer operation to configure edge stream relay. The configuration takes effect for ingested streams that start after edge stream relay is configured. The following table describes the scenarios in which edge stream relay takes effect or not.
     * |Scenario|Analysis|Result|
     * |---|---|---|
     * |1\\. You ingest a stream before you call the SetLiveEdgeTransfer operation.|The configuration of edge stream relay is not available.|The ingested stream is not affected by your call of the SetLiveEdgeTransfer operation. Edge stream relay does not take effect.|
     * |2\\. You disconnect an ingested stream that started before you called the SetLiveEdgeTransfer operation, and then resume the ingested stream.|The configuration of edge stream relay is available.|Edge stream relay takes effect for the resumed ingested stream based on the configuration.|
     * |3\\. You ingest a stream after you call the SetLiveEdgeTransfer operation.|The configuration of edge stream relay is available.|Edge stream relay takes effect for the ingested stream based on the configuration.|
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param SetLiveEdgeTransferRequest $request SetLiveEdgeTransferRequest
     *
     * @return SetLiveEdgeTransferResponse SetLiveEdgeTransferResponse
     */
    public function setLiveEdgeTransfer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setLiveEdgeTransferWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a configuration of triggered stream pulling.
     *  *
     * @description You can call this operation to configure triggered stream pulling. The configuration lets ApsaraVideo Live automatically pull live streams from the origin server when the origin server starts to play live streams.
     * >  The IPv6 protocol is not supported.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param SetLiveLazyPullStreamInfoConfigRequest $request SetLiveLazyPullStreamInfoConfigRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return SetLiveLazyPullStreamInfoConfigResponse SetLiveLazyPullStreamInfoConfigResponse
     */
    public function setLiveLazyPullStreamInfoConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pullAppName)) {
            $query['PullAppName'] = $request->pullAppName;
        }
        if (!Utils::isUnset($request->pullDomainName)) {
            $query['PullDomainName'] = $request->pullDomainName;
        }
        if (!Utils::isUnset($request->pullProtocol)) {
            $query['PullProtocol'] = $request->pullProtocol;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->transcodeLazy)) {
            $query['TranscodeLazy'] = $request->transcodeLazy;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'SetLiveLazyPullStreamInfoConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetLiveLazyPullStreamInfoConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a configuration of triggered stream pulling.
     *  *
     * @description You can call this operation to configure triggered stream pulling. The configuration lets ApsaraVideo Live automatically pull live streams from the origin server when the origin server starts to play live streams.
     * >  The IPv6 protocol is not supported.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param SetLiveLazyPullStreamInfoConfigRequest $request SetLiveLazyPullStreamInfoConfigRequest
     *
     * @return SetLiveLazyPullStreamInfoConfigResponse SetLiveLazyPullStreamInfoConfigResponse
     */
    public function setLiveLazyPullStreamInfoConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setLiveLazyPullStreamInfoConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Configures custom supplemental enhancement information (SEI) for co-streaming.
     *  *
     * @description ## [](#)Usage notes
     * You can call this operation to configure custom SEI for a mixed-stream relay task.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param SetLiveMpuTaskSeiRequest $request SetLiveMpuTaskSeiRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return SetLiveMpuTaskSeiResponse SetLiveMpuTaskSeiResponse
     */
    public function setLiveMpuTaskSeiWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->customSei)) {
            $query['CustomSei'] = $request->customSei;
        }
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'SetLiveMpuTaskSei',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetLiveMpuTaskSeiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures custom supplemental enhancement information (SEI) for co-streaming.
     *  *
     * @description ## [](#)Usage notes
     * You can call this operation to configure custom SEI for a mixed-stream relay task.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param SetLiveMpuTaskSeiRequest $request SetLiveMpuTaskSeiRequest
     *
     * @return SetLiveMpuTaskSeiResponse SetLiveMpuTaskSeiResponse
     */
    public function setLiveMpuTaskSei($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setLiveMpuTaskSeiWithOptions($request, $runtime);
    }

    /**
     * @summary Configures stream-level region blocking.
     *  *
     * @description You can configure up to 200 stream-level region blocking rules for a domain name. If there are rules in which the same application name and the same stream name are specified, the rule that is updated the most recently takes effect.
     * ### [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param SetLiveStreamBlockRequest $request SetLiveStreamBlockRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return SetLiveStreamBlockResponse SetLiveStreamBlockResponse
     */
    public function setLiveStreamBlockWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->blockType)) {
            $query['BlockType'] = $request->blockType;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->locationList)) {
            $query['LocationList'] = $request->locationList;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->releaseTime)) {
            $query['ReleaseTime'] = $request->releaseTime;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'SetLiveStreamBlock',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetLiveStreamBlockResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures stream-level region blocking.
     *  *
     * @description You can configure up to 200 stream-level region blocking rules for a domain name. If there are rules in which the same application name and the same stream name are specified, the rule that is updated the most recently takes effect.
     * ### [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param SetLiveStreamBlockRequest $request SetLiveStreamBlockRequest
     *
     * @return SetLiveStreamBlockResponse SetLiveStreamBlockResponse
     */
    public function setLiveStreamBlock($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setLiveStreamBlockWithOptions($request, $runtime);
    }

    /**
     * @summary Configures the live streaming latency.
     *  *
     * @description *   You can call this operation to configure the latency of a streaming domain.
     * *   Because an integer number of groups of pictures (GOPs) are cached, the latency is not less than the GOP size. The actual latency is calculated based on the GOP size. For example, if RtmpDelay is set to 4 seconds and the GOP size is 2 seconds, the minimum latency is 2 seconds (4 seconds minus 2 seconds) and the maximum latency is 6 seconds (4 seconds plus 2 seconds). If the GOP size is greater than the value of RtmpDelay, for example, the GOP size is 5 seconds and RtmpDelay is set to 4 seconds, the latency ranges from 0 to 9 seconds.
     * *   Configuration for the latency of an audio-only stream is invalid. By default, the latency is close to 0.
     * *   For HTTP Live Streaming (HLS)-based playback, the segment size equals the latency divided by 3. Round the value down to the nearest integer. The value cannot be less than 1 second. Then, calculate the maximum number of segments. If the segment size is greater than or equal to 3 seconds, the maximum number of segments is 4. Otherwise, the maximum number of segments is 6.
     * *   The actual HLS segment size is not smaller than the GOP size.
     * *   The latency of HLS-based playback equals the configured segment size times 3.
     * *   If you do not call this operation, the default latency is 2 seconds for Real-Time Messaging Protocol (RTMP)-based playback and 4 seconds for Flash Video (FLV)-based playback. By default, the size of an HLS segment is 5 seconds. In this case, the latency is 15 seconds and the maximum number of segments is 6.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param SetLiveStreamDelayConfigRequest $request SetLiveStreamDelayConfigRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return SetLiveStreamDelayConfigResponse SetLiveStreamDelayConfigResponse
     */
    public function setLiveStreamDelayConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->flvDelay)) {
            $query['FlvDelay'] = $request->flvDelay;
        }
        if (!Utils::isUnset($request->flvLevel)) {
            $query['FlvLevel'] = $request->flvLevel;
        }
        if (!Utils::isUnset($request->hlsDelay)) {
            $query['HlsDelay'] = $request->hlsDelay;
        }
        if (!Utils::isUnset($request->hlsLevel)) {
            $query['HlsLevel'] = $request->hlsLevel;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->rtmpDelay)) {
            $query['RtmpDelay'] = $request->rtmpDelay;
        }
        if (!Utils::isUnset($request->rtmpLevel)) {
            $query['RtmpLevel'] = $request->rtmpLevel;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'SetLiveStreamDelayConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetLiveStreamDelayConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures the live streaming latency.
     *  *
     * @description *   You can call this operation to configure the latency of a streaming domain.
     * *   Because an integer number of groups of pictures (GOPs) are cached, the latency is not less than the GOP size. The actual latency is calculated based on the GOP size. For example, if RtmpDelay is set to 4 seconds and the GOP size is 2 seconds, the minimum latency is 2 seconds (4 seconds minus 2 seconds) and the maximum latency is 6 seconds (4 seconds plus 2 seconds). If the GOP size is greater than the value of RtmpDelay, for example, the GOP size is 5 seconds and RtmpDelay is set to 4 seconds, the latency ranges from 0 to 9 seconds.
     * *   Configuration for the latency of an audio-only stream is invalid. By default, the latency is close to 0.
     * *   For HTTP Live Streaming (HLS)-based playback, the segment size equals the latency divided by 3. Round the value down to the nearest integer. The value cannot be less than 1 second. Then, calculate the maximum number of segments. If the segment size is greater than or equal to 3 seconds, the maximum number of segments is 4. Otherwise, the maximum number of segments is 6.
     * *   The actual HLS segment size is not smaller than the GOP size.
     * *   The latency of HLS-based playback equals the configured segment size times 3.
     * *   If you do not call this operation, the default latency is 2 seconds for Real-Time Messaging Protocol (RTMP)-based playback and 4 seconds for Flash Video (FLV)-based playback. By default, the size of an HLS segment is 5 seconds. In this case, the latency is 15 seconds and the maximum number of segments is 6.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param SetLiveStreamDelayConfigRequest $request SetLiveStreamDelayConfigRequest
     *
     * @return SetLiveStreamDelayConfigResponse SetLiveStreamDelayConfigResponse
     */
    public function setLiveStreamDelayConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setLiveStreamDelayConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Configures a prefetch task. You can specify multiple URLs to prefetch at a time.
     *  *
     * @description *   You can call this operation to specify multiple URLs to prefetch at a time. You can specify up to 100 URLs in a request.
     * *   URLs in the HTTP Live Steaming (HLS) format are not supported.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param SetLiveStreamPreloadTasksRequest $request SetLiveStreamPreloadTasksRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return SetLiveStreamPreloadTasksResponse SetLiveStreamPreloadTasksResponse
     */
    public function setLiveStreamPreloadTasksWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->area)) {
            $query['Area'] = $request->area;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->playUrl)) {
            $query['PlayUrl'] = $request->playUrl;
        }
        if (!Utils::isUnset($request->preloadedEndTime)) {
            $query['PreloadedEndTime'] = $request->preloadedEndTime;
        }
        if (!Utils::isUnset($request->preloadedStartTime)) {
            $query['PreloadedStartTime'] = $request->preloadedStartTime;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'SetLiveStreamPreloadTasks',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetLiveStreamPreloadTasksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures a prefetch task. You can specify multiple URLs to prefetch at a time.
     *  *
     * @description *   You can call this operation to specify multiple URLs to prefetch at a time. You can specify up to 100 URLs in a request.
     * *   URLs in the HTTP Live Steaming (HLS) format are not supported.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param SetLiveStreamPreloadTasksRequest $request SetLiveStreamPreloadTasksRequest
     *
     * @return SetLiveStreamPreloadTasksResponse SetLiveStreamPreloadTasksResponse
     */
    public function setLiveStreamPreloadTasks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setLiveStreamPreloadTasksWithOptions($request, $runtime);
    }

    /**
     * @summary Configures stream ingest callbacks under an ingest domain.
     *  *
     * @description *   You can call this operation to configure the callback URL and authentication information of an ingest domain.
     * *   If you configure callbacks for stream ingest status, you can receive callback notifications about successful or interrupted stream ingest in a timely manner. For more information, see [Format of stream ingest callbacks](https://help.aliyun.com/document_detail/54787.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param SetLiveStreamsNotifyUrlConfigRequest $request SetLiveStreamsNotifyUrlConfigRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return SetLiveStreamsNotifyUrlConfigResponse SetLiveStreamsNotifyUrlConfigResponse
     */
    public function setLiveStreamsNotifyUrlConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->exceptionNotifyUrl)) {
            $query['ExceptionNotifyUrl'] = $request->exceptionNotifyUrl;
        }
        if (!Utils::isUnset($request->notifyAuthKey)) {
            $query['NotifyAuthKey'] = $request->notifyAuthKey;
        }
        if (!Utils::isUnset($request->notifyReqAuth)) {
            $query['NotifyReqAuth'] = $request->notifyReqAuth;
        }
        if (!Utils::isUnset($request->notifyUrl)) {
            $query['NotifyUrl'] = $request->notifyUrl;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->switchNotifyUrl)) {
            $query['SwitchNotifyUrl'] = $request->switchNotifyUrl;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'SetLiveStreamsNotifyUrlConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetLiveStreamsNotifyUrlConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures stream ingest callbacks under an ingest domain.
     *  *
     * @description *   You can call this operation to configure the callback URL and authentication information of an ingest domain.
     * *   If you configure callbacks for stream ingest status, you can receive callback notifications about successful or interrupted stream ingest in a timely manner. For more information, see [Format of stream ingest callbacks](https://help.aliyun.com/document_detail/54787.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param SetLiveStreamsNotifyUrlConfigRequest $request SetLiveStreamsNotifyUrlConfigRequest
     *
     * @return SetLiveStreamsNotifyUrlConfigResponse SetLiveStreamsNotifyUrlConfigResponse
     */
    public function setLiveStreamsNotifyUrlConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setLiveStreamsNotifyUrlConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Configures the background of the episode list.
     *  *
     * @description *   Create a production studio in playlist mode, and then call this operation to add the background material. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
     * *   You can call this operation to create, update, or delete the background of the episode list. To delete the background, leave the ResourceType, ResourceUrl, and MaterialId parameters empty.
     * >
     * *   When you select media resources from ApsaraVideo VOD, we recommend that you select resources that are stored in hosted OSS buckets. Resources stored in non-hosted OSS buckets have a validity period. Pay attention to the validity if you select resources that are stored in non-hosted OSS buckets.
     * *   When you add media resources to a production studio, we recommend that you select resources from ApsaraVideo Live and ApsaraVideo VOD. If you add a third-party stream by specifying a streaming URL, there is a possibility that the stream fails to be played. You must pay attention to the quality and validity of the third-party stream.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param SetShowListBackgroundRequest $request SetShowListBackgroundRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return SetShowListBackgroundResponse SetShowListBackgroundResponse
     */
    public function setShowListBackgroundWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->materialId)) {
            $query['MaterialId'] = $request->materialId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceType)) {
            $query['ResourceType'] = $request->resourceType;
        }
        if (!Utils::isUnset($request->resourceUrl)) {
            $query['ResourceUrl'] = $request->resourceUrl;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'SetShowListBackground',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetShowListBackgroundResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures the background of the episode list.
     *  *
     * @description *   Create a production studio in playlist mode, and then call this operation to add the background material. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
     * *   You can call this operation to create, update, or delete the background of the episode list. To delete the background, leave the ResourceType, ResourceUrl, and MaterialId parameters empty.
     * >
     * *   When you select media resources from ApsaraVideo VOD, we recommend that you select resources that are stored in hosted OSS buckets. Resources stored in non-hosted OSS buckets have a validity period. Pay attention to the validity if you select resources that are stored in non-hosted OSS buckets.
     * *   When you add media resources to a production studio, we recommend that you select resources from ApsaraVideo Live and ApsaraVideo VOD. If you add a third-party stream by specifying a streaming URL, there is a possibility that the stream fails to be played. You must pay attention to the quality and validity of the third-party stream.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param SetShowListBackgroundRequest $request SetShowListBackgroundRequest
     *
     * @return SetShowListBackgroundResponse SetShowListBackgroundResponse
     */
    public function setShowListBackground($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setShowListBackgroundWithOptions($request, $runtime);
    }

    /**
     * @summary Configures authentication for snapshot callbacks.
     *  *
     * @description *   Before you configure authentication for snapshot callbacks, you need to specify the callback URL. For more information, see [AddLiveAppSnapshotConfig](https://help.aliyun.com/document_detail/2847897.html).
     * *   You can call this operation to configure authentication for snapshot callbacks for a main streaming domain. Make sure that the parameter settings meet the requirements.
     * *   ApsaraVideo Live allows you to add a specific signature header to each HTTP or HTTPS callback request. This way, the server that receives callback messages can authenticate the signature to prevent illegal or invalid requests. For more information, see [Usage notes for callback authentication](https://help.aliyun.com/document_detail/417349.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param SetSnapshotCallbackAuthRequest $request SetSnapshotCallbackAuthRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return SetSnapshotCallbackAuthResponse SetSnapshotCallbackAuthResponse
     */
    public function setSnapshotCallbackAuthWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->callbackAuthKey)) {
            $query['CallbackAuthKey'] = $request->callbackAuthKey;
        }
        if (!Utils::isUnset($request->callbackReqAuth)) {
            $query['CallbackReqAuth'] = $request->callbackReqAuth;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'SetSnapshotCallbackAuth',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetSnapshotCallbackAuthResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures authentication for snapshot callbacks.
     *  *
     * @description *   Before you configure authentication for snapshot callbacks, you need to specify the callback URL. For more information, see [AddLiveAppSnapshotConfig](https://help.aliyun.com/document_detail/2847897.html).
     * *   You can call this operation to configure authentication for snapshot callbacks for a main streaming domain. Make sure that the parameter settings meet the requirements.
     * *   ApsaraVideo Live allows you to add a specific signature header to each HTTP or HTTPS callback request. This way, the server that receives callback messages can authenticate the signature to prevent illegal or invalid requests. For more information, see [Usage notes for callback authentication](https://help.aliyun.com/document_detail/417349.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param SetSnapshotCallbackAuthRequest $request SetSnapshotCallbackAuthRequest
     *
     * @return SetSnapshotCallbackAuthResponse SetSnapshotCallbackAuthResponse
     */
    public function setSnapshotCallbackAuth($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setSnapshotCallbackAuthWithOptions($request, $runtime);
    }

    /**
     * @summary Starts a production studio. If the production studio does not have a PVW scene or a PGM scene, this operation creates and starts such scenes and starts audio and video processing tasks.
     *  *
     * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to start the production studio. If the production studio does not have a PVW scene or a PGM scene, this operation creates and starts such scenes and starts audio and video processing tasks.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param StartCasterRequest $request StartCasterRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return StartCasterResponse StartCasterResponse
     */
    public function startCasterWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'StartCaster',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StartCasterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Starts a production studio. If the production studio does not have a PVW scene or a PGM scene, this operation creates and starts such scenes and starts audio and video processing tasks.
     *  *
     * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to start the production studio. If the production studio does not have a PVW scene or a PGM scene, this operation creates and starts such scenes and starts audio and video processing tasks.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param StartCasterRequest $request StartCasterRequest
     *
     * @return StartCasterResponse StartCasterResponse
     */
    public function startCaster($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startCasterWithOptions($request, $runtime);
    }

    /**
     * @summary Starts a specified preview (PVW) scene.
     *  *
     * @description You can call this operation to start a specified PVW scene.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param StartCasterSceneRequest $request StartCasterSceneRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return StartCasterSceneResponse StartCasterSceneResponse
     */
    public function startCasterSceneWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->sceneId)) {
            $query['SceneId'] = $request->sceneId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'StartCasterScene',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StartCasterSceneResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Starts a specified preview (PVW) scene.
     *  *
     * @description You can call this operation to start a specified PVW scene.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param StartCasterSceneRequest $request StartCasterSceneRequest
     *
     * @return StartCasterSceneResponse StartCasterSceneResponse
     */
    public function startCasterScene($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startCasterSceneWithOptions($request, $runtime);
    }

    /**
     * @summary Starts an edge transcoding task.
     *  *
     * @description *   You can call this operation to start an edge transcoding task.
     * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature and the edge transcoding task that you specify is not started.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param StartEdgeTranscodeJobRequest $request StartEdgeTranscodeJobRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return StartEdgeTranscodeJobResponse StartEdgeTranscodeJobResponse
     */
    public function startEdgeTranscodeJobWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->jobId)) {
            $query['JobId'] = $request->jobId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'StartEdgeTranscodeJob',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StartEdgeTranscodeJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Starts an edge transcoding task.
     *  *
     * @description *   You can call this operation to start an edge transcoding task.
     * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature and the edge transcoding task that you specify is not started.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param StartEdgeTranscodeJobRequest $request StartEdgeTranscodeJobRequest
     *
     * @return StartEdgeTranscodeJobResponse StartEdgeTranscodeJobResponse
     */
    public function startEdgeTranscodeJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startEdgeTranscodeJobWithOptions($request, $runtime);
    }

    /**
     * @summary Enables a disabled domain name. After the domain name is enabled, its status changes to online.
     *  *
     * @description This operation does not work if the Alibaba Cloud account to which the domain name belongs has overdue payments or the domain name is invalid.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param StartLiveDomainRequest $request StartLiveDomainRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return StartLiveDomainResponse StartLiveDomainResponse
     */
    public function startLiveDomainWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'StartLiveDomain',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StartLiveDomainResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables a disabled domain name. After the domain name is enabled, its status changes to online.
     *  *
     * @description This operation does not work if the Alibaba Cloud account to which the domain name belongs has overdue payments or the domain name is invalid.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param StartLiveDomainRequest $request StartLiveDomainRequest
     *
     * @return StartLiveDomainResponse StartLiveDomainResponse
     */
    public function startLiveDomain($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startLiveDomainWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a mixed-stream relay task.
     *  *
     * @description By default, you can create up to 200 single-stream relay tasks and up to 40 mixed-stream relay tasks for an application. To increase the quota, [submit a ticket](https://smartservice.console.aliyun.com/service/create-ticket).
     * ### [](#)Lifecycle of a stream relay task
     * **Start**
     * *   Call the StartLiveMPUTask operation to create a task.
     *     *   If no user joins the channel, an error indicating that the channel does not exist is returned.
     *     *   Stream relay is not performed if no stream is ingested. In this case, no relayed stream is available for playback.
     *     *   If the task is in the mixed-stream relay mode, make sure that at least one user is ingesting a stream, which can be relayed for playback. A black screen is displayed in the pane of a user who is not ingesting a stream.
     * *   We recommend that you record the task status, task mode, and task parameters on your business server.
     *     *   Task status: started or stopped.
     *     *   Task mode: single-stream relay or mixed-stream relay.
     *     *   Task parameters: the latest input parameters. For example, after your call of the UpdateLiveMPUTask operation is successful, record the task parameters, which are the latest.
     * *   In co-streaming or battle scenarios, the task is in the mixed-stream relay mode. If the streamer leaves the channel due to exceptions and re-joins the channel, you can directly call the StartLiveMPUTask operation on your business server to start stream relay based on the recorded task parameters.
     *     *   If the task has not been automatically cleared by the system, the task is directly started.
     *     *   If the task has not been automatically cleared by the system, a message indicating that **the task already exists** is returned.
     * **End**
     * *   After the streamer leaves the channel, you need to call the [StopLiveMPUTask](https://help.aliyun.com/document_detail/2362742.html) operation to stop the task.
     * *   If all users specified in the task have left the channel, but you do not call the StopLiveMPUTask operation, the system stops the task in 2 minutes.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 500 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param StartLiveMPUTaskRequest $tmpReq  StartLiveMPUTaskRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return StartLiveMPUTaskResponse StartLiveMPUTaskResponse
     */
    public function startLiveMPUTaskWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new StartLiveMPUTaskShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->multiStreamURL)) {
            $request->multiStreamURLShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->multiStreamURL, 'MultiStreamURL', 'json');
        }
        if (!Utils::isUnset($tmpReq->seiParams)) {
            $request->seiParamsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->seiParams, 'SeiParams', 'json');
        }
        if (!Utils::isUnset($tmpReq->singleSubParams)) {
            $request->singleSubParamsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->singleSubParams, 'SingleSubParams', 'json');
        }
        if (!Utils::isUnset($tmpReq->transcodeParams)) {
            $request->transcodeParamsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->transcodeParams, 'TranscodeParams', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->channelId)) {
            $query['ChannelId'] = $request->channelId;
        }
        if (!Utils::isUnset($request->maxIdleTime)) {
            $query['MaxIdleTime'] = $request->maxIdleTime;
        }
        if (!Utils::isUnset($request->mixMode)) {
            $query['MixMode'] = $request->mixMode;
        }
        if (!Utils::isUnset($request->multiStreamURLShrink)) {
            $query['MultiStreamURL'] = $request->multiStreamURLShrink;
        }
        if (!Utils::isUnset($request->region)) {
            $query['Region'] = $request->region;
        }
        if (!Utils::isUnset($request->seiParamsShrink)) {
            $query['SeiParams'] = $request->seiParamsShrink;
        }
        if (!Utils::isUnset($request->singleSubParamsShrink)) {
            $query['SingleSubParams'] = $request->singleSubParamsShrink;
        }
        if (!Utils::isUnset($request->streamURL)) {
            $query['StreamURL'] = $request->streamURL;
        }
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        if (!Utils::isUnset($request->transcodeParamsShrink)) {
            $query['TranscodeParams'] = $request->transcodeParamsShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'StartLiveMPUTask',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StartLiveMPUTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a mixed-stream relay task.
     *  *
     * @description By default, you can create up to 200 single-stream relay tasks and up to 40 mixed-stream relay tasks for an application. To increase the quota, [submit a ticket](https://smartservice.console.aliyun.com/service/create-ticket).
     * ### [](#)Lifecycle of a stream relay task
     * **Start**
     * *   Call the StartLiveMPUTask operation to create a task.
     *     *   If no user joins the channel, an error indicating that the channel does not exist is returned.
     *     *   Stream relay is not performed if no stream is ingested. In this case, no relayed stream is available for playback.
     *     *   If the task is in the mixed-stream relay mode, make sure that at least one user is ingesting a stream, which can be relayed for playback. A black screen is displayed in the pane of a user who is not ingesting a stream.
     * *   We recommend that you record the task status, task mode, and task parameters on your business server.
     *     *   Task status: started or stopped.
     *     *   Task mode: single-stream relay or mixed-stream relay.
     *     *   Task parameters: the latest input parameters. For example, after your call of the UpdateLiveMPUTask operation is successful, record the task parameters, which are the latest.
     * *   In co-streaming or battle scenarios, the task is in the mixed-stream relay mode. If the streamer leaves the channel due to exceptions and re-joins the channel, you can directly call the StartLiveMPUTask operation on your business server to start stream relay based on the recorded task parameters.
     *     *   If the task has not been automatically cleared by the system, the task is directly started.
     *     *   If the task has not been automatically cleared by the system, a message indicating that **the task already exists** is returned.
     * **End**
     * *   After the streamer leaves the channel, you need to call the [StopLiveMPUTask](https://help.aliyun.com/document_detail/2362742.html) operation to stop the task.
     * *   If all users specified in the task have left the channel, but you do not call the StopLiveMPUTask operation, the system stops the task in 2 minutes.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 500 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param StartLiveMPUTaskRequest $request StartLiveMPUTaskRequest
     *
     * @return StartLiveMPUTaskResponse StartLiveMPUTaskResponse
     */
    public function startLiveMPUTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startLiveMPUTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Starts live monitoring.
     *  *
     * @description You can call the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation to create a monitoring session, obtain the value of the response parameter **MonitorId**, and then start live monitoring.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param StartLiveStreamMonitorRequest $request StartLiveStreamMonitorRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return StartLiveStreamMonitorResponse StartLiveStreamMonitorResponse
     */
    public function startLiveStreamMonitorWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->monitorId)) {
            $query['MonitorId'] = $request->monitorId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'StartLiveStreamMonitor',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StartLiveStreamMonitorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Starts live monitoring.
     *  *
     * @description You can call the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation to create a monitoring session, obtain the value of the response parameter **MonitorId**, and then start live monitoring.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param StartLiveStreamMonitorRequest $request StartLiveStreamMonitorRequest
     *
     * @return StartLiveStreamMonitorResponse StartLiveStreamMonitorResponse
     */
    public function startLiveStreamMonitor($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startLiveStreamMonitorWithOptions($request, $runtime);
    }

    /**
     * @summary Starts playing an episode list.
     *  *
     * @description You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episodes to an episode list and then call this operation to start playing the episode list.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param StartPlaylistRequest $request StartPlaylistRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return StartPlaylistResponse StartPlaylistResponse
     */
    public function startPlaylistWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->offset)) {
            $query['Offset'] = $request->offset;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->programId)) {
            $query['ProgramId'] = $request->programId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resumeMode)) {
            $query['ResumeMode'] = $request->resumeMode;
        }
        if (!Utils::isUnset($request->startItemId)) {
            $query['StartItemId'] = $request->startItemId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'StartPlaylist',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StartPlaylistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Starts playing an episode list.
     *  *
     * @description You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episodes to an episode list and then call this operation to start playing the episode list.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param StartPlaylistRequest $request StartPlaylistRequest
     *
     * @return StartPlaylistResponse StartPlaylistResponse
     */
    public function startPlaylist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startPlaylistWithOptions($request, $runtime);
    }

    /**
     * @summary 启动rtc云端录制任务
     *  *
     * @param StartRtcCloudRecordingRequest $tmpReq  StartRtcCloudRecordingRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return StartRtcCloudRecordingResponse StartRtcCloudRecordingResponse
     */
    public function startRtcCloudRecordingWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new StartRtcCloudRecordingShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->mixLayoutParams)) {
            $request->mixLayoutParamsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->mixLayoutParams, 'MixLayoutParams', 'json');
        }
        if (!Utils::isUnset($tmpReq->mixTranscodeParams)) {
            $request->mixTranscodeParamsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->mixTranscodeParams, 'MixTranscodeParams', 'json');
        }
        if (!Utils::isUnset($tmpReq->recordParams)) {
            $request->recordParamsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->recordParams, 'RecordParams', 'json');
        }
        if (!Utils::isUnset($tmpReq->storageParams)) {
            $request->storageParamsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->storageParams, 'StorageParams', 'json');
        }
        if (!Utils::isUnset($tmpReq->subscribeParams)) {
            $request->subscribeParamsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->subscribeParams, 'SubscribeParams', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->channelId)) {
            $query['ChannelId'] = $request->channelId;
        }
        if (!Utils::isUnset($request->mixLayoutParamsShrink)) {
            $query['MixLayoutParams'] = $request->mixLayoutParamsShrink;
        }
        if (!Utils::isUnset($request->mixTranscodeParamsShrink)) {
            $query['MixTranscodeParams'] = $request->mixTranscodeParamsShrink;
        }
        if (!Utils::isUnset($request->notifyUrl)) {
            $query['NotifyUrl'] = $request->notifyUrl;
        }
        if (!Utils::isUnset($request->recordParamsShrink)) {
            $query['RecordParams'] = $request->recordParamsShrink;
        }
        if (!Utils::isUnset($request->storageParamsShrink)) {
            $query['StorageParams'] = $request->storageParamsShrink;
        }
        if (!Utils::isUnset($request->subscribeParamsShrink)) {
            $query['SubscribeParams'] = $request->subscribeParamsShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'StartRtcCloudRecording',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StartRtcCloudRecordingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 启动rtc云端录制任务
     *  *
     * @param StartRtcCloudRecordingRequest $request StartRtcCloudRecordingRequest
     *
     * @return StartRtcCloudRecordingResponse StartRtcCloudRecordingResponse
     */
    public function startRtcCloudRecording($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startRtcCloudRecordingWithOptions($request, $runtime);
    }

    /**
     * @summary Stops a production studio. This stops the PVW and PGM scenes of the production studio.
     *  *
     * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and call this operation to stop the production studio. When a production studio is stopped, its PVW and PGM scenes are stopped.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param StopCasterRequest $request StopCasterRequest
     * @param RuntimeOptions    $runtime runtime options for this request RuntimeOptions
     *
     * @return StopCasterResponse StopCasterResponse
     */
    public function stopCasterWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'StopCaster',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StopCasterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Stops a production studio. This stops the PVW and PGM scenes of the production studio.
     *  *
     * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and call this operation to stop the production studio. When a production studio is stopped, its PVW and PGM scenes are stopped.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param StopCasterRequest $request StopCasterRequest
     *
     * @return StopCasterResponse StopCasterResponse
     */
    public function stopCaster($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopCasterWithOptions($request, $runtime);
    }

    /**
     * @summary Stops a specified preview scene.
     *  *
     * @description ## Usage note
     * This operation is only applicable to the PVW scenes.
     *  *
     * @param StopCasterSceneRequest $request StopCasterSceneRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return StopCasterSceneResponse StopCasterSceneResponse
     */
    public function stopCasterSceneWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->sceneId)) {
            $query['SceneId'] = $request->sceneId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'StopCasterScene',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StopCasterSceneResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Stops a specified preview scene.
     *  *
     * @description ## Usage note
     * This operation is only applicable to the PVW scenes.
     *  *
     * @param StopCasterSceneRequest $request StopCasterSceneRequest
     *
     * @return StopCasterSceneResponse StopCasterSceneResponse
     */
    public function stopCasterScene($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopCasterSceneWithOptions($request, $runtime);
    }

    /**
     * @summary Stops an edge transcoding task.
     *  *
     * @description *   You can call this operation to stop an edge transcoding task.
     * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature and the edge transcoding task that you specify is running.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param StopEdgeTranscodeJobRequest $request StopEdgeTranscodeJobRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return StopEdgeTranscodeJobResponse StopEdgeTranscodeJobResponse
     */
    public function stopEdgeTranscodeJobWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->jobId)) {
            $query['JobId'] = $request->jobId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'StopEdgeTranscodeJob',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StopEdgeTranscodeJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Stops an edge transcoding task.
     *  *
     * @description *   You can call this operation to stop an edge transcoding task.
     * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature and the edge transcoding task that you specify is running.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param StopEdgeTranscodeJobRequest $request StopEdgeTranscodeJobRequest
     *
     * @return StopEdgeTranscodeJobResponse StopEdgeTranscodeJobResponse
     */
    public function stopEdgeTranscodeJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopEdgeTranscodeJobWithOptions($request, $runtime);
    }

    /**
     * @summary Disables an enabled domain name. After the domain name is disabled, its status changes to offline.
     *  *
     * @description After you disable a domain name, the information about the domain name is retained. ApsaraVideo Live automatically reroutes all requests that are destined for the domain name to the origin.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param StopLiveDomainRequest $request StopLiveDomainRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return StopLiveDomainResponse StopLiveDomainResponse
     */
    public function stopLiveDomainWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'StopLiveDomain',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StopLiveDomainResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Disables an enabled domain name. After the domain name is disabled, its status changes to offline.
     *  *
     * @description After you disable a domain name, the information about the domain name is retained. ApsaraVideo Live automatically reroutes all requests that are destined for the domain name to the origin.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param StopLiveDomainRequest $request StopLiveDomainRequest
     *
     * @return StopLiveDomainResponse StopLiveDomainResponse
     */
    public function stopLiveDomain($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopLiveDomainWithOptions($request, $runtime);
    }

    /**
     * @summary Stops a mixed-stream relay task.
     *  *
     * @description *   Make sure that a mixed-stream relay task is started before you call this operation. You can call the [StartLiveMPUTask](https://help.aliyun.com/document_detail/2848199.html) operation to start a mixed-stream relay task.
     * *   If a mixed-stream relay task becomes abnormal, the task is automatically stopped 2 minutes after the last person leaves the channel. In this case, you do not need to call the StopLiveMPUTask operation. If you need to resume a mixed-stream relay task that is stopped, call the [StartLiveMPUTask](https://help.aliyun.com/document_detail/2848199.html) operation again.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 500 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param StopLiveMPUTaskRequest $request StopLiveMPUTaskRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return StopLiveMPUTaskResponse StopLiveMPUTaskResponse
     */
    public function stopLiveMPUTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'StopLiveMPUTask',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StopLiveMPUTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Stops a mixed-stream relay task.
     *  *
     * @description *   Make sure that a mixed-stream relay task is started before you call this operation. You can call the [StartLiveMPUTask](https://help.aliyun.com/document_detail/2848199.html) operation to start a mixed-stream relay task.
     * *   If a mixed-stream relay task becomes abnormal, the task is automatically stopped 2 minutes after the last person leaves the channel. In this case, you do not need to call the StopLiveMPUTask operation. If you need to resume a mixed-stream relay task that is stopped, call the [StartLiveMPUTask](https://help.aliyun.com/document_detail/2848199.html) operation again.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 500 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param StopLiveMPUTaskRequest $request StopLiveMPUTaskRequest
     *
     * @return StopLiveMPUTaskResponse StopLiveMPUTaskResponse
     */
    public function stopLiveMPUTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopLiveMPUTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Stops a pulled-stream relay task.
     *  *
     * @description *   You can call this operation to stop a pulled-stream relay task.
     * *   You can stop a task that is running (even if the task is in an abnormal retry state). You cannot stop a task that is not running.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param StopLivePullToPushRequest $request StopLivePullToPushRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return StopLivePullToPushResponse StopLivePullToPushResponse
     */
    public function stopLivePullToPushWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'StopLivePullToPush',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StopLivePullToPushResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Stops a pulled-stream relay task.
     *  *
     * @description *   You can call this operation to stop a pulled-stream relay task.
     * *   You can stop a task that is running (even if the task is in an abnormal retry state). You cannot stop a task that is not running.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param StopLivePullToPushRequest $request StopLivePullToPushRequest
     *
     * @return StopLivePullToPushResponse StopLivePullToPushResponse
     */
    public function stopLivePullToPush($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopLivePullToPushWithOptions($request, $runtime);
    }

    /**
     * @summary Stops live monitoring.
     *  *
     * @description Before you call this operation to stop live monitoring, make sure that live monitoring is started. You can call the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation to create a monitoring session, obtain the value of the response parameter **MonitorId**, and then start live monitoring.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param StopLiveStreamMonitorRequest $request StopLiveStreamMonitorRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return StopLiveStreamMonitorResponse StopLiveStreamMonitorResponse
     */
    public function stopLiveStreamMonitorWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->monitorId)) {
            $query['MonitorId'] = $request->monitorId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'StopLiveStreamMonitor',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StopLiveStreamMonitorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Stops live monitoring.
     *  *
     * @description Before you call this operation to stop live monitoring, make sure that live monitoring is started. You can call the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation to create a monitoring session, obtain the value of the response parameter **MonitorId**, and then start live monitoring.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param StopLiveStreamMonitorRequest $request StopLiveStreamMonitorRequest
     *
     * @return StopLiveStreamMonitorResponse StopLiveStreamMonitorResponse
     */
    public function stopLiveStreamMonitor($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopLiveStreamMonitorWithOptions($request, $runtime);
    }

    /**
     * @summary Stops playing an episode list.
     *  *
     * @description You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episodes to an episode list and then call this operation to stop playing the episode list.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param StopPlaylistRequest $request StopPlaylistRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return StopPlaylistResponse StopPlaylistResponse
     */
    public function stopPlaylistWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->programId)) {
            $query['ProgramId'] = $request->programId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'StopPlaylist',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StopPlaylistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Stops playing an episode list.
     *  *
     * @description You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episodes to an episode list and then call this operation to stop playing the episode list.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param StopPlaylistRequest $request StopPlaylistRequest
     *
     * @return StopPlaylistResponse StopPlaylistResponse
     */
    public function stopPlaylist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopPlaylistWithOptions($request, $runtime);
    }

    /**
     * @summary Stops a live subtitle task.
     *  *
     * @description You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param StopRtcAsrTaskRequest $request StopRtcAsrTaskRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return StopRtcAsrTaskResponse StopRtcAsrTaskResponse
     */
    public function stopRtcAsrTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'StopRtcAsrTask',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StopRtcAsrTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Stops a live subtitle task.
     *  *
     * @description You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param StopRtcAsrTaskRequest $request StopRtcAsrTaskRequest
     *
     * @return StopRtcAsrTaskResponse StopRtcAsrTaskResponse
     */
    public function stopRtcAsrTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopRtcAsrTaskWithOptions($request, $runtime);
    }

    /**
     * @summary 停止rtc云端录制任务
     *  *
     * @param StopRtcCloudRecordingRequest $request StopRtcCloudRecordingRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return StopRtcCloudRecordingResponse StopRtcCloudRecordingResponse
     */
    public function stopRtcCloudRecordingWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'StopRtcCloudRecording',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StopRtcCloudRecordingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 停止rtc云端录制任务
     *  *
     * @param StopRtcCloudRecordingRequest $request StopRtcCloudRecordingRequest
     *
     * @return StopRtcCloudRecordingResponse StopRtcCloudRecordingResponse
     */
    public function stopRtcCloudRecording($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopRtcCloudRecordingWithOptions($request, $runtime);
    }

    /**
     * @summary The N tags that you want to add for the resource.
     *  *
     * @description The key of the tag. Valid values of N: **1 to 20**.
     *  *
     * @param TagLiveResourcesRequest $request TagLiveResourcesRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return TagLiveResourcesResponse TagLiveResourcesResponse
     */
    public function tagLiveResourcesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceId)) {
            $query['ResourceId'] = $request->resourceId;
        }
        if (!Utils::isUnset($request->resourceType)) {
            $query['ResourceType'] = $request->resourceType;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'TagLiveResources',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return TagLiveResourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The N tags that you want to add for the resource.
     *  *
     * @description The key of the tag. Valid values of N: **1 to 20**.
     *  *
     * @param TagLiveResourcesRequest $request TagLiveResourcesRequest
     *
     * @return TagLiveResourcesResponse TagLiveResourcesResponse
     */
    public function tagLiveResources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->tagLiveResourcesWithOptions($request, $runtime);
    }

    /**
     * @param UnTagLiveResourcesRequest $request UnTagLiveResourcesRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return UnTagLiveResourcesResponse UnTagLiveResourcesResponse
     */
    public function unTagLiveResourcesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->all)) {
            $query['All'] = $request->all;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceId)) {
            $query['ResourceId'] = $request->resourceId;
        }
        if (!Utils::isUnset($request->resourceType)) {
            $query['ResourceType'] = $request->resourceType;
        }
        if (!Utils::isUnset($request->tagKey)) {
            $query['TagKey'] = $request->tagKey;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'UnTagLiveResources',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UnTagLiveResourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param UnTagLiveResourcesRequest $request UnTagLiveResourcesRequest
     *
     * @return UnTagLiveResourcesResponse UnTagLiveResourcesResponse
     */
    public function unTagLiveResources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->unTagLiveResourcesWithOptions($request, $runtime);
    }

    /**
     * @summary Unmutes a group.
     *  *
     * @description *   Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * *   If a user was muted by calling the AddLiveMessageGroupBand operation, the user remains muted even after you call the UnbanLiveMessageGroup operation.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UnbanLiveMessageGroupRequest $request UnbanLiveMessageGroupRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return UnbanLiveMessageGroupResponse UnbanLiveMessageGroupResponse
     */
    public function unbanLiveMessageGroupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->dataCenter)) {
            $query['DataCenter'] = $request->dataCenter;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'UnbanLiveMessageGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UnbanLiveMessageGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Unmutes a group.
     *  *
     * @description *   Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * *   If a user was muted by calling the AddLiveMessageGroupBand operation, the user remains muted even after you call the UnbanLiveMessageGroup operation.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UnbanLiveMessageGroupRequest $request UnbanLiveMessageGroupRequest
     *
     * @return UnbanLiveMessageGroupResponse UnbanLiveMessageGroupResponse
     */
    public function unbanLiveMessageGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->unbanLiveMessageGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Changes the resource group to which a production studio belongs.
     *  *
     * @description ## [](#)Usage notes
     * To call this operation to change the resource group to which a production studio belongs, you must have access permissions on the original resource group and the destination resource group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param UpdateCasterResourceGroupRequest $request UpdateCasterResourceGroupRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateCasterResourceGroupResponse UpdateCasterResourceGroupResponse
     */
    public function updateCasterResourceGroupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->newResourceGroupId)) {
            $query['NewResourceGroupId'] = $request->newResourceGroupId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateCasterResourceGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateCasterResourceGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Changes the resource group to which a production studio belongs.
     *  *
     * @description ## [](#)Usage notes
     * To call this operation to change the resource group to which a production studio belongs, you must have access permissions on the original resource group and the destination resource group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param UpdateCasterResourceGroupRequest $request UpdateCasterResourceGroupRequest
     *
     * @return UpdateCasterResourceGroupResponse UpdateCasterResourceGroupResponse
     */
    public function updateCasterResourceGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateCasterResourceGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the audio configurations of a scene. This operation also allows you to add an audio configuration or apply an existing audio configuration to a new scene.
     *  *
     * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to modify the audio configurations of a scene in the production studio. This operation supports the audio mixing mode and the audio follows video (AFV) mode.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateCasterSceneAudioRequest $request UpdateCasterSceneAudioRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateCasterSceneAudioResponse UpdateCasterSceneAudioResponse
     */
    public function updateCasterSceneAudioWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->audioLayer)) {
            $query['AudioLayer'] = $request->audioLayer;
        }
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->followEnable)) {
            $query['FollowEnable'] = $request->followEnable;
        }
        if (!Utils::isUnset($request->mixList)) {
            $query['MixList'] = $request->mixList;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->sceneId)) {
            $query['SceneId'] = $request->sceneId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateCasterSceneAudio',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateCasterSceneAudioResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the audio configurations of a scene. This operation also allows you to add an audio configuration or apply an existing audio configuration to a new scene.
     *  *
     * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to modify the audio configurations of a scene in the production studio. This operation supports the audio mixing mode and the audio follows video (AFV) mode.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateCasterSceneAudioRequest $request UpdateCasterSceneAudioRequest
     *
     * @return UpdateCasterSceneAudioResponse UpdateCasterSceneAudioResponse
     */
    public function updateCasterSceneAudio($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateCasterSceneAudioWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies a scene, including the layout, without invalidating the previous configurations. This operation is more efficient than the SetCasterSceneConfig operation.
     *  *
     * @description You can call this operation to modify a scene, including the layout, without invalidating the previous configurations. This operation is more efficient than the SetCasterSceneConfig operation.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateCasterSceneConfigRequest $request UpdateCasterSceneConfigRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateCasterSceneConfigResponse UpdateCasterSceneConfigResponse
     */
    public function updateCasterSceneConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->casterId)) {
            $query['CasterId'] = $request->casterId;
        }
        if (!Utils::isUnset($request->componentId)) {
            $query['ComponentId'] = $request->componentId;
        }
        if (!Utils::isUnset($request->layoutId)) {
            $query['LayoutId'] = $request->layoutId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->sceneId)) {
            $query['SceneId'] = $request->sceneId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateCasterSceneConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateCasterSceneConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies a scene, including the layout, without invalidating the previous configurations. This operation is more efficient than the SetCasterSceneConfig operation.
     *  *
     * @description You can call this operation to modify a scene, including the layout, without invalidating the previous configurations. This operation is more efficient than the SetCasterSceneConfig operation.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateCasterSceneConfigRequest $request UpdateCasterSceneConfigRequest
     *
     * @return UpdateCasterSceneConfigResponse UpdateCasterSceneConfigResponse
     */
    public function updateCasterSceneConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateCasterSceneConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Updates a custom transcoding configuration.
     *  *
     * @description This operation supports the following types of custom transcoding templates:
     * *   h264: custom H.264 standard transcoding.
     * *   h264-nbhd: custom H.264 Narrowband HD™ transcoding.
     * *   h265: custom H.265 standard transcoding.
     * *   h265-nbhd: custom H.265 Narrowband HD™ transcoding.
     * *   audio: audio-only transcoding.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account.
     *  *
     * @param UpdateCustomLiveStreamTranscodeRequest $request UpdateCustomLiveStreamTranscodeRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateCustomLiveStreamTranscodeResponse UpdateCustomLiveStreamTranscodeResponse
     */
    public function updateCustomLiveStreamTranscodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->app)) {
            $query['App'] = $request->app;
        }
        if (!Utils::isUnset($request->audioBitrate)) {
            $query['AudioBitrate'] = $request->audioBitrate;
        }
        if (!Utils::isUnset($request->audioChannelNum)) {
            $query['AudioChannelNum'] = $request->audioChannelNum;
        }
        if (!Utils::isUnset($request->audioCodec)) {
            $query['AudioCodec'] = $request->audioCodec;
        }
        if (!Utils::isUnset($request->audioProfile)) {
            $query['AudioProfile'] = $request->audioProfile;
        }
        if (!Utils::isUnset($request->audioRate)) {
            $query['AudioRate'] = $request->audioRate;
        }
        if (!Utils::isUnset($request->bitrateWithSource)) {
            $query['BitrateWithSource'] = $request->bitrateWithSource;
        }
        if (!Utils::isUnset($request->domain)) {
            $query['Domain'] = $request->domain;
        }
        if (!Utils::isUnset($request->encryptParameters)) {
            $query['EncryptParameters'] = $request->encryptParameters;
        }
        if (!Utils::isUnset($request->extWithSource)) {
            $query['ExtWithSource'] = $request->extWithSource;
        }
        if (!Utils::isUnset($request->FPS)) {
            $query['FPS'] = $request->FPS;
        }
        if (!Utils::isUnset($request->fpsWithSource)) {
            $query['FpsWithSource'] = $request->fpsWithSource;
        }
        if (!Utils::isUnset($request->gop)) {
            $query['Gop'] = $request->gop;
        }
        if (!Utils::isUnset($request->height)) {
            $query['Height'] = $request->height;
        }
        if (!Utils::isUnset($request->lazy)) {
            $query['Lazy'] = $request->lazy;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->profile)) {
            $query['Profile'] = $request->profile;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resWithSource)) {
            $query['ResWithSource'] = $request->resWithSource;
        }
        if (!Utils::isUnset($request->template)) {
            $query['Template'] = $request->template;
        }
        if (!Utils::isUnset($request->templateType)) {
            $query['TemplateType'] = $request->templateType;
        }
        if (!Utils::isUnset($request->videoBitrate)) {
            $query['VideoBitrate'] = $request->videoBitrate;
        }
        if (!Utils::isUnset($request->width)) {
            $query['Width'] = $request->width;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateCustomLiveStreamTranscode',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateCustomLiveStreamTranscodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates a custom transcoding configuration.
     *  *
     * @description This operation supports the following types of custom transcoding templates:
     * *   h264: custom H.264 standard transcoding.
     * *   h264-nbhd: custom H.264 Narrowband HD™ transcoding.
     * *   h265: custom H.265 standard transcoding.
     * *   h265-nbhd: custom H.265 Narrowband HD™ transcoding.
     * *   audio: audio-only transcoding.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account.
     *  *
     * @param UpdateCustomLiveStreamTranscodeRequest $request UpdateCustomLiveStreamTranscodeRequest
     *
     * @return UpdateCustomLiveStreamTranscodeResponse UpdateCustomLiveStreamTranscodeResponse
     */
    public function updateCustomLiveStreamTranscode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateCustomLiveStreamTranscodeWithOptions($request, $runtime);
    }

    /**
     * @summary Updates an edge transcoding task.
     *  *
     * @description *   You can call this operation to update an edge transcoding task.
     * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature and the edge transcoding task that you specify is not started.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateEdgeTranscodeJobRequest $request UpdateEdgeTranscodeJobRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateEdgeTranscodeJobResponse UpdateEdgeTranscodeJobResponse
     */
    public function updateEdgeTranscodeJobWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->jobId)) {
            $query['JobId'] = $request->jobId;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->streamInput)) {
            $query['StreamInput'] = $request->streamInput;
        }
        if (!Utils::isUnset($request->streamOutput)) {
            $query['StreamOutput'] = $request->streamOutput;
        }
        if (!Utils::isUnset($request->templateId)) {
            $query['TemplateId'] = $request->templateId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateEdgeTranscodeJob',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateEdgeTranscodeJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates an edge transcoding task.
     *  *
     * @description *   You can call this operation to update an edge transcoding task.
     * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature and the edge transcoding task that you specify is not started.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateEdgeTranscodeJobRequest $request UpdateEdgeTranscodeJobRequest
     *
     * @return UpdateEdgeTranscodeJobResponse UpdateEdgeTranscodeJobResponse
     */
    public function updateEdgeTranscodeJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateEdgeTranscodeJobWithOptions($request, $runtime);
    }

    /**
     * @summary Updates a callback that is used to subscribe to channel or user events.
     *  *
     * @description *   Before you call this operation, make sure that you have called the [CreateEventSub](https://help.aliyun.com/document_detail/2848209.html) operation to create a callback that is used to subscribe to channel or user events.
     * *   An existing channel that you specify in this operation still uses its original callback configuration. The updated configuration can apply to the channel only if you restart the channel after it is closed for longer than 20 minutes.
     * *   If you only want to update specific parameters, you must also specify the other required parameters with their original values.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateEventSubRequest $request UpdateEventSubRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateEventSubResponse UpdateEventSubResponse
     */
    public function updateEventSubWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->callbackUrl)) {
            $query['CallbackUrl'] = $request->callbackUrl;
        }
        if (!Utils::isUnset($request->channelId)) {
            $query['ChannelId'] = $request->channelId;
        }
        if (!Utils::isUnset($request->events)) {
            $query['Events'] = $request->events;
        }
        if (!Utils::isUnset($request->subscribeId)) {
            $query['SubscribeId'] = $request->subscribeId;
        }
        if (!Utils::isUnset($request->users)) {
            $query['Users'] = $request->users;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateEventSub',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateEventSubResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates a callback that is used to subscribe to channel or user events.
     *  *
     * @description *   Before you call this operation, make sure that you have called the [CreateEventSub](https://help.aliyun.com/document_detail/2848209.html) operation to create a callback that is used to subscribe to channel or user events.
     * *   An existing channel that you specify in this operation still uses its original callback configuration. The updated configuration can apply to the channel only if you restart the channel after it is closed for longer than 20 minutes.
     * *   If you only want to update specific parameters, you must also specify the other required parameters with their original values.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateEventSubRequest $request UpdateEventSubRequest
     *
     * @return UpdateEventSubResponse UpdateEventSubResponse
     */
    public function updateEventSub($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateEventSubWithOptions($request, $runtime);
    }

    /**
     * @summary Updates a subtitle rule.
     *  *
     * @description You can call this operation to modify the parameters of a specified subtitle rule.
     * >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateLiveAIProduceRulesRequest $request UpdateLiveAIProduceRulesRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateLiveAIProduceRulesResponse UpdateLiveAIProduceRulesResponse
     */
    public function updateLiveAIProduceRulesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->app)) {
            $query['App'] = $request->app;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->domain)) {
            $query['Domain'] = $request->domain;
        }
        if (!Utils::isUnset($request->isLazy)) {
            $query['IsLazy'] = $request->isLazy;
        }
        if (!Utils::isUnset($request->liveTemplate)) {
            $query['LiveTemplate'] = $request->liveTemplate;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->rulesId)) {
            $query['RulesId'] = $request->rulesId;
        }
        if (!Utils::isUnset($request->studioName)) {
            $query['StudioName'] = $request->studioName;
        }
        if (!Utils::isUnset($request->subtitleId)) {
            $query['SubtitleId'] = $request->subtitleId;
        }
        if (!Utils::isUnset($request->subtitleName)) {
            $query['SubtitleName'] = $request->subtitleName;
        }
        if (!Utils::isUnset($request->suffix)) {
            $query['Suffix'] = $request->suffix;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveAIProduceRules',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveAIProduceRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates a subtitle rule.
     *  *
     * @description You can call this operation to modify the parameters of a specified subtitle rule.
     * >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateLiveAIProduceRulesRequest $request UpdateLiveAIProduceRulesRequest
     *
     * @return UpdateLiveAIProduceRulesResponse UpdateLiveAIProduceRulesResponse
     */
    public function updateLiveAIProduceRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveAIProduceRulesWithOptions($request, $runtime);
    }

    /**
     * @summary Updates a subtitle template.
     *  *
     * @param UpdateLiveAISubtitleRequest $tmpReq  UpdateLiveAISubtitleRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateLiveAISubtitleResponse UpdateLiveAISubtitleResponse
     */
    public function updateLiveAISubtitleWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new UpdateLiveAISubtitleShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->positionNormalized)) {
            $request->positionNormalizedShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->positionNormalized, 'PositionNormalized', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->bgColor)) {
            $query['BgColor'] = $request->bgColor;
        }
        if (!Utils::isUnset($request->bgWidthNormalized)) {
            $query['BgWidthNormalized'] = $request->bgWidthNormalized;
        }
        if (!Utils::isUnset($request->borderWidthNormalized)) {
            $query['BorderWidthNormalized'] = $request->borderWidthNormalized;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->dstLanguage)) {
            $query['DstLanguage'] = $request->dstLanguage;
        }
        if (!Utils::isUnset($request->fontColor)) {
            $query['FontColor'] = $request->fontColor;
        }
        if (!Utils::isUnset($request->fontName)) {
            $query['FontName'] = $request->fontName;
        }
        if (!Utils::isUnset($request->fontSizeNormalized)) {
            $query['FontSizeNormalized'] = $request->fontSizeNormalized;
        }
        if (!Utils::isUnset($request->height)) {
            $query['Height'] = $request->height;
        }
        if (!Utils::isUnset($request->maxLines)) {
            $query['MaxLines'] = $request->maxLines;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->positionNormalizedShrink)) {
            $query['PositionNormalized'] = $request->positionNormalizedShrink;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->showSourceLan)) {
            $query['ShowSourceLan'] = $request->showSourceLan;
        }
        if (!Utils::isUnset($request->srcLanguage)) {
            $query['SrcLanguage'] = $request->srcLanguage;
        }
        if (!Utils::isUnset($request->subtitleId)) {
            $query['SubtitleId'] = $request->subtitleId;
        }
        if (!Utils::isUnset($request->subtitleName)) {
            $query['SubtitleName'] = $request->subtitleName;
        }
        if (!Utils::isUnset($request->width)) {
            $query['Width'] = $request->width;
        }
        if (!Utils::isUnset($request->wordPerLine)) {
            $query['WordPerLine'] = $request->wordPerLine;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveAISubtitle',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveAISubtitleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates a subtitle template.
     *  *
     * @param UpdateLiveAISubtitleRequest $request UpdateLiveAISubtitleRequest
     *
     * @return UpdateLiveAISubtitleResponse UpdateLiveAISubtitleResponse
     */
    public function updateLiveAISubtitle($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveAISubtitleWithOptions($request, $runtime);
    }

    /**
     * @summary Updates a recording configuration for an application. The recordings are stored in Object Storage Service (OSS).
     *  *
     * @description Obtain the main streaming domain, and then call this operation to update a recording configuration.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateLiveAppRecordConfigRequest $request UpdateLiveAppRecordConfigRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateLiveAppRecordConfigResponse UpdateLiveAppRecordConfigResponse
     */
    public function updateLiveAppRecordConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->delayTime)) {
            $query['DelayTime'] = $request->delayTime;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->onDemand)) {
            $query['OnDemand'] = $request->onDemand;
        }
        if (!Utils::isUnset($request->ossEndpoint)) {
            $query['OssEndpoint'] = $request->ossEndpoint;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->recordFormat)) {
            $query['RecordFormat'] = $request->recordFormat;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        if (!Utils::isUnset($request->transcodeRecordFormat)) {
            $query['TranscodeRecordFormat'] = $request->transcodeRecordFormat;
        }
        if (!Utils::isUnset($request->transcodeTemplates)) {
            $query['TranscodeTemplates'] = $request->transcodeTemplates;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveAppRecordConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveAppRecordConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates a recording configuration for an application. The recordings are stored in Object Storage Service (OSS).
     *  *
     * @description Obtain the main streaming domain, and then call this operation to update a recording configuration.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateLiveAppRecordConfigRequest $request UpdateLiveAppRecordConfigRequest
     *
     * @return UpdateLiveAppRecordConfigResponse UpdateLiveAppRecordConfigResponse
     */
    public function updateLiveAppRecordConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveAppRecordConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies a snapshot configuration of a streaming domain. The captured snapshots are stored in Object Storage Service (OSS). The modification takes effect after you restart stream ingest.
     *  *
     * @description You can call this operation to modify a snapshot configuration of a streaming domain. The captured snapshots are stored in OSS. The modification takes effect after you restart stream ingest.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateLiveAppSnapshotConfigRequest $request UpdateLiveAppSnapshotConfigRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateLiveAppSnapshotConfigResponse UpdateLiveAppSnapshotConfigResponse
     */
    public function updateLiveAppSnapshotConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->callback)) {
            $query['Callback'] = $request->callback;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ossBucket)) {
            $query['OssBucket'] = $request->ossBucket;
        }
        if (!Utils::isUnset($request->ossEndpoint)) {
            $query['OssEndpoint'] = $request->ossEndpoint;
        }
        if (!Utils::isUnset($request->overwriteOssObject)) {
            $query['OverwriteOssObject'] = $request->overwriteOssObject;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        if (!Utils::isUnset($request->sequenceOssObject)) {
            $query['SequenceOssObject'] = $request->sequenceOssObject;
        }
        if (!Utils::isUnset($request->timeInterval)) {
            $query['TimeInterval'] = $request->timeInterval;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveAppSnapshotConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveAppSnapshotConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies a snapshot configuration of a streaming domain. The captured snapshots are stored in Object Storage Service (OSS). The modification takes effect after you restart stream ingest.
     *  *
     * @description You can call this operation to modify a snapshot configuration of a streaming domain. The captured snapshots are stored in OSS. The modification takes effect after you restart stream ingest.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateLiveAppSnapshotConfigRequest $request UpdateLiveAppSnapshotConfigRequest
     *
     * @return UpdateLiveAppSnapshotConfigResponse UpdateLiveAppSnapshotConfigResponse
     */
    public function updateLiveAppSnapshotConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveAppSnapshotConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies an audio moderation configuration.
     *  *
     * @description *   Obtain the main streaming domain, and then call this operation to modify an audio moderation configuration.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateLiveAudioAuditConfigRequest $request UpdateLiveAudioAuditConfigRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateLiveAudioAuditConfigResponse UpdateLiveAudioAuditConfigResponse
     */
    public function updateLiveAudioAuditConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->bizType)) {
            $query['BizType'] = $request->bizType;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ossBucket)) {
            $query['OssBucket'] = $request->ossBucket;
        }
        if (!Utils::isUnset($request->ossEndpoint)) {
            $query['OssEndpoint'] = $request->ossEndpoint;
        }
        if (!Utils::isUnset($request->ossObject)) {
            $query['OssObject'] = $request->ossObject;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveAudioAuditConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveAudioAuditConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies an audio moderation configuration.
     *  *
     * @description *   Obtain the main streaming domain, and then call this operation to modify an audio moderation configuration.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateLiveAudioAuditConfigRequest $request UpdateLiveAudioAuditConfigRequest
     *
     * @return UpdateLiveAudioAuditConfigResponse UpdateLiveAudioAuditConfigResponse
     */
    public function updateLiveAudioAuditConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveAudioAuditConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configuration of callbacks for audio moderation results.
     *  *
     * @param UpdateLiveAudioAuditNotifyConfigRequest $request UpdateLiveAudioAuditNotifyConfigRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateLiveAudioAuditNotifyConfigResponse UpdateLiveAudioAuditNotifyConfigResponse
     */
    public function updateLiveAudioAuditNotifyConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->callback)) {
            $query['Callback'] = $request->callback;
        }
        if (!Utils::isUnset($request->callbackTemplate)) {
            $query['CallbackTemplate'] = $request->callbackTemplate;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveAudioAuditNotifyConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveAudioAuditNotifyConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configuration of callbacks for audio moderation results.
     *  *
     * @param UpdateLiveAudioAuditNotifyConfigRequest $request UpdateLiveAudioAuditNotifyConfigRequest
     *
     * @return UpdateLiveAudioAuditNotifyConfigResponse UpdateLiveAudioAuditNotifyConfigResponse
     */
    public function updateLiveAudioAuditNotifyConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveAudioAuditNotifyConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configurations of live center stream relay.
     *  *
     * @description You can call this operation to modify only the **time-related** parameters, including TransferArgs, StartTime, and EndTime.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateLiveCenterTransferRequest $request UpdateLiveCenterTransferRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateLiveCenterTransferResponse UpdateLiveCenterTransferResponse
     */
    public function updateLiveCenterTransferWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->dstUrl)) {
            $query['DstUrl'] = $request->dstUrl;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        if (!Utils::isUnset($request->transferArgs)) {
            $query['TransferArgs'] = $request->transferArgs;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveCenterTransfer',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveCenterTransferResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configurations of live center stream relay.
     *  *
     * @description You can call this operation to modify only the **time-related** parameters, including TransferArgs, StartTime, and EndTime.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateLiveCenterTransferRequest $request UpdateLiveCenterTransferRequest
     *
     * @return UpdateLiveCenterTransferResponse UpdateLiveCenterTransferResponse
     */
    public function updateLiveCenterTransfer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveCenterTransferWithOptions($request, $runtime);
    }

    /**
     * @summary Updates a stream delay configuration.
     *  *
     * @description ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param UpdateLiveDelayConfigRequest $request UpdateLiveDelayConfigRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateLiveDelayConfigResponse UpdateLiveDelayConfigResponse
     */
    public function updateLiveDelayConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->app)) {
            $query['App'] = $request->app;
        }
        if (!Utils::isUnset($request->delayTime)) {
            $query['DelayTime'] = $request->delayTime;
        }
        if (!Utils::isUnset($request->domain)) {
            $query['Domain'] = $request->domain;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->stream)) {
            $query['Stream'] = $request->stream;
        }
        if (!Utils::isUnset($request->taskTriggerMode)) {
            $query['TaskTriggerMode'] = $request->taskTriggerMode;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveDelayConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveDelayConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates a stream delay configuration.
     *  *
     * @description ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param UpdateLiveDelayConfigRequest $request UpdateLiveDelayConfigRequest
     *
     * @return UpdateLiveDelayConfigResponse UpdateLiveDelayConfigResponse
     */
    public function updateLiveDelayConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveDelayConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configuration of callbacks for video moderation results. As a result, the callback URL that is used to receive the callback notifications is changed.
     *  *
     * @description *   Obtain the main streaming domain, and then call this operation to modify the configuration of callbacks for video moderation results.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateLiveDetectNotifyConfigRequest $request UpdateLiveDetectNotifyConfigRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateLiveDetectNotifyConfigResponse UpdateLiveDetectNotifyConfigResponse
     */
    public function updateLiveDetectNotifyConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->notifyUrl)) {
            $query['NotifyUrl'] = $request->notifyUrl;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveDetectNotifyConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveDetectNotifyConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configuration of callbacks for video moderation results. As a result, the callback URL that is used to receive the callback notifications is changed.
     *  *
     * @description *   Obtain the main streaming domain, and then call this operation to modify the configuration of callbacks for video moderation results.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateLiveDetectNotifyConfigRequest $request UpdateLiveDetectNotifyConfigRequest
     *
     * @return UpdateLiveDetectNotifyConfigResponse UpdateLiveDetectNotifyConfigResponse
     */
    public function updateLiveDetectNotifyConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveDetectNotifyConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Updates a mixed-stream relay task.
     *  *
     * @description Make sure that a mixed-stream relay task is created before you call this operation. You can call the [StartLiveMPUTask](https://help.aliyun.com/document_detail/2848199.html) operation to create a mixed-stream relay task.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 500 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateLiveMPUTaskRequest $tmpReq  UpdateLiveMPUTaskRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateLiveMPUTaskResponse UpdateLiveMPUTaskResponse
     */
    public function updateLiveMPUTaskWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new UpdateLiveMPUTaskShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->multiStreamURL)) {
            $request->multiStreamURLShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->multiStreamURL, 'MultiStreamURL', 'json');
        }
        if (!Utils::isUnset($tmpReq->seiParams)) {
            $request->seiParamsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->seiParams, 'SeiParams', 'json');
        }
        if (!Utils::isUnset($tmpReq->singleSubParams)) {
            $request->singleSubParamsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->singleSubParams, 'SingleSubParams', 'json');
        }
        if (!Utils::isUnset($tmpReq->transcodeParams)) {
            $request->transcodeParamsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->transcodeParams, 'TranscodeParams', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->channelId)) {
            $query['ChannelId'] = $request->channelId;
        }
        if (!Utils::isUnset($request->mixMode)) {
            $query['MixMode'] = $request->mixMode;
        }
        if (!Utils::isUnset($request->multiStreamURLShrink)) {
            $query['MultiStreamURL'] = $request->multiStreamURLShrink;
        }
        if (!Utils::isUnset($request->seiParamsShrink)) {
            $query['SeiParams'] = $request->seiParamsShrink;
        }
        if (!Utils::isUnset($request->singleSubParamsShrink)) {
            $query['SingleSubParams'] = $request->singleSubParamsShrink;
        }
        if (!Utils::isUnset($request->streamURL)) {
            $query['StreamURL'] = $request->streamURL;
        }
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        if (!Utils::isUnset($request->transcodeParamsShrink)) {
            $query['TranscodeParams'] = $request->transcodeParamsShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveMPUTask',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveMPUTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates a mixed-stream relay task.
     *  *
     * @description Make sure that a mixed-stream relay task is created before you call this operation. You can call the [StartLiveMPUTask](https://help.aliyun.com/document_detail/2848199.html) operation to create a mixed-stream relay task.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 500 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateLiveMPUTaskRequest $request UpdateLiveMPUTaskRequest
     *
     * @return UpdateLiveMPUTaskResponse UpdateLiveMPUTaskResponse
     */
    public function updateLiveMPUTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveMPUTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Updates a live stream encapsulation configuration.
     *  *
     * @description You can call this operation to update a live stream encapsulation configuration. The update takes effect only after you re-ingest the stream.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateLivePackageConfigRequest $request UpdateLivePackageConfigRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateLivePackageConfigResponse UpdateLivePackageConfigResponse
     */
    public function updateLivePackageConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ignoreTranscode)) {
            $query['IgnoreTranscode'] = $request->ignoreTranscode;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->partDuration)) {
            $query['PartDuration'] = $request->partDuration;
        }
        if (!Utils::isUnset($request->protocol)) {
            $query['Protocol'] = $request->protocol;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->segmentDuration)) {
            $query['SegmentDuration'] = $request->segmentDuration;
        }
        if (!Utils::isUnset($request->segmentNum)) {
            $query['SegmentNum'] = $request->segmentNum;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLivePackageConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLivePackageConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates a live stream encapsulation configuration.
     *  *
     * @description You can call this operation to update a live stream encapsulation configuration. The update takes effect only after you re-ingest the stream.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateLivePackageConfigRequest $request UpdateLivePackageConfigRequest
     *
     * @return UpdateLivePackageConfigResponse UpdateLivePackageConfigResponse
     */
    public function updateLivePackageConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLivePackageConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the stream pulling settings of a live stream, including the origin URL, start time, and end time.
     *  *
     * @description This operation is applicable to regular stream pulling. You can call this operation to modify the stream pulling settings of a live stream, including the origin URL, start time, and end time.
     * >  After this operation is complete, ApsaraVideo Live uses the updated settings for regular stream pulling. Make sure that the modification does not affect your business.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateLivePullStreamInfoConfigRequest $request UpdateLivePullStreamInfoConfigRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateLivePullStreamInfoConfigResponse UpdateLivePullStreamInfoConfigResponse
     */
    public function updateLivePullStreamInfoConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLivePullStreamInfoConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLivePullStreamInfoConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the stream pulling settings of a live stream, including the origin URL, start time, and end time.
     *  *
     * @description This operation is applicable to regular stream pulling. You can call this operation to modify the stream pulling settings of a live stream, including the origin URL, start time, and end time.
     * >  After this operation is complete, ApsaraVideo Live uses the updated settings for regular stream pulling. Make sure that the modification does not affect your business.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateLivePullStreamInfoConfigRequest $request UpdateLivePullStreamInfoConfigRequest
     *
     * @return UpdateLivePullStreamInfoConfigResponse UpdateLivePullStreamInfoConfigResponse
     */
    public function updateLivePullStreamInfoConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLivePullStreamInfoConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Updates a pulled-stream relay task.
     *  *
     * @description *   You can call this operation to update a pulled-stream relay task.
     * *   As long as the specified start time of a task has not been reached, you can modify the SourceType, Region, and DstUrl parameters of the task.
     * *   If a task is running (even if the task is in an abnormal retry state), you can modify only the CallbackUrl and RepeatTime parameters of the task. The update takes effect immediately.
     * *   If a task is stopped, you can modify all parameters of the task except SourceType, Region, and DstUrl.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateLivePullToPushRequest $tmpReq  UpdateLivePullToPushRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateLivePullToPushResponse UpdateLivePullToPushResponse
     */
    public function updateLivePullToPushWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new UpdateLivePullToPushShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->sourceUrls)) {
            $request->sourceUrlsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->sourceUrls, 'SourceUrls', 'json');
        }
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLivePullToPush',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLivePullToPushResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates a pulled-stream relay task.
     *  *
     * @description *   You can call this operation to update a pulled-stream relay task.
     * *   As long as the specified start time of a task has not been reached, you can modify the SourceType, Region, and DstUrl parameters of the task.
     * *   If a task is running (even if the task is in an abnormal retry state), you can modify only the CallbackUrl and RepeatTime parameters of the task. The update takes effect immediately.
     * *   If a task is stopped, you can modify all parameters of the task except SourceType, Region, and DstUrl.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateLivePullToPushRequest $request UpdateLivePullToPushRequest
     *
     * @return UpdateLivePullToPushResponse UpdateLivePullToPushResponse
     */
    public function updateLivePullToPush($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLivePullToPushWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the recording callback configuration of a streaming domain.
     *  *
     * @description You can call this operation to modify the following settings:
     * *   The callback URL that is used to receive notifications about recording events and status. For more information, see [Recording event callbacks](https://help.aliyun.com/document_detail/55016.html).
     * *   The callback URL for on-demand recordings. For more information, see [On-demand recording callbacks](https://help.aliyun.com/document_detail/85910.html).
     * *   The setting that specifies whether to enable callbacks for recording status.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateLiveRecordNotifyConfigRequest $request UpdateLiveRecordNotifyConfigRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateLiveRecordNotifyConfigResponse UpdateLiveRecordNotifyConfigResponse
     */
    public function updateLiveRecordNotifyConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->needStatusNotify)) {
            $query['NeedStatusNotify'] = $request->needStatusNotify;
        }
        if (!Utils::isUnset($request->notifyUrl)) {
            $query['NotifyUrl'] = $request->notifyUrl;
        }
        if (!Utils::isUnset($request->onDemandUrl)) {
            $query['OnDemandUrl'] = $request->onDemandUrl;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveRecordNotifyConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveRecordNotifyConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the recording callback configuration of a streaming domain.
     *  *
     * @description You can call this operation to modify the following settings:
     * *   The callback URL that is used to receive notifications about recording events and status. For more information, see [Recording event callbacks](https://help.aliyun.com/document_detail/55016.html).
     * *   The callback URL for on-demand recordings. For more information, see [On-demand recording callbacks](https://help.aliyun.com/document_detail/85910.html).
     * *   The setting that specifies whether to enable callbacks for recording status.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateLiveRecordNotifyConfigRequest $request UpdateLiveRecordNotifyConfigRequest
     *
     * @return UpdateLiveRecordNotifyConfigResponse UpdateLiveRecordNotifyConfigResponse
     */
    public function updateLiveRecordNotifyConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveRecordNotifyConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Updates a Live-to-VOD configuration.
     *  *
     * @description You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateLiveRecordVodConfigRequest $request UpdateLiveRecordVodConfigRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateLiveRecordVodConfigResponse UpdateLiveRecordVodConfigResponse
     */
    public function updateLiveRecordVodConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->autoCompose)) {
            $query['AutoCompose'] = $request->autoCompose;
        }
        if (!Utils::isUnset($request->composeVodTranscodeGroupId)) {
            $query['ComposeVodTranscodeGroupId'] = $request->composeVodTranscodeGroupId;
        }
        if (!Utils::isUnset($request->cycleDuration)) {
            $query['CycleDuration'] = $request->cycleDuration;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->onDemand)) {
            $query['OnDemand'] = $request->onDemand;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->streamName)) {
            $query['StreamName'] = $request->streamName;
        }
        if (!Utils::isUnset($request->vodTranscodeGroupId)) {
            $query['VodTranscodeGroupId'] = $request->vodTranscodeGroupId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveRecordVodConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveRecordVodConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates a Live-to-VOD configuration.
     *  *
     * @description You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateLiveRecordVodConfigRequest $request UpdateLiveRecordVodConfigRequest
     *
     * @return UpdateLiveRecordVodConfigResponse UpdateLiveRecordVodConfigResponse
     */
    public function updateLiveRecordVodConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveRecordVodConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies a video moderation configuration.
     *  *
     * @description *   Obtain the main streaming domain, and then call this operation to modify a video moderation configuration.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateLiveSnapshotDetectPornConfigRequest $request UpdateLiveSnapshotDetectPornConfigRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateLiveSnapshotDetectPornConfigResponse UpdateLiveSnapshotDetectPornConfigResponse
     */
    public function updateLiveSnapshotDetectPornConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->interval)) {
            $query['Interval'] = $request->interval;
        }
        if (!Utils::isUnset($request->ossBucket)) {
            $query['OssBucket'] = $request->ossBucket;
        }
        if (!Utils::isUnset($request->ossEndpoint)) {
            $query['OssEndpoint'] = $request->ossEndpoint;
        }
        if (!Utils::isUnset($request->ossObject)) {
            $query['OssObject'] = $request->ossObject;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->scene)) {
            $query['Scene'] = $request->scene;
        }
        if (!Utils::isUnset($request->securityToken)) {
            $query['SecurityToken'] = $request->securityToken;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveSnapshotDetectPornConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveSnapshotDetectPornConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies a video moderation configuration.
     *  *
     * @description *   Obtain the main streaming domain, and then call this operation to modify a video moderation configuration.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateLiveSnapshotDetectPornConfigRequest $request UpdateLiveSnapshotDetectPornConfigRequest
     *
     * @return UpdateLiveSnapshotDetectPornConfigResponse UpdateLiveSnapshotDetectPornConfigResponse
     */
    public function updateLiveSnapshotDetectPornConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveSnapshotDetectPornConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configuration of snapshot callbacks.
     *  *
     * @description You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateLiveSnapshotNotifyConfigRequest $request UpdateLiveSnapshotNotifyConfigRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateLiveSnapshotNotifyConfigResponse UpdateLiveSnapshotNotifyConfigResponse
     */
    public function updateLiveSnapshotNotifyConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->notifyAuthKey)) {
            $query['NotifyAuthKey'] = $request->notifyAuthKey;
        }
        if (!Utils::isUnset($request->notifyReqAuth)) {
            $query['NotifyReqAuth'] = $request->notifyReqAuth;
        }
        if (!Utils::isUnset($request->notifyUrl)) {
            $query['NotifyUrl'] = $request->notifyUrl;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveSnapshotNotifyConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveSnapshotNotifyConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configuration of snapshot callbacks.
     *  *
     * @description You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateLiveSnapshotNotifyConfigRequest $request UpdateLiveSnapshotNotifyConfigRequest
     *
     * @return UpdateLiveSnapshotNotifyConfigResponse UpdateLiveSnapshotNotifyConfigResponse
     */
    public function updateLiveSnapshotNotifyConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveSnapshotNotifyConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Updates the configurations of a monitoring session.
     *  *
     * @description You can call this operation to update the configurations of a monitoring session. The updates that you make to the input source configurations when the monitoring session is in the Running state immediately take effect.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateLiveStreamMonitorRequest $request UpdateLiveStreamMonitorRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateLiveStreamMonitorResponse UpdateLiveStreamMonitorResponse
     */
    public function updateLiveStreamMonitorWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->app)) {
            $query['App'] = $request->app;
        }
        if (!Utils::isUnset($request->callbackUrl)) {
            $query['CallbackUrl'] = $request->callbackUrl;
        }
        if (!Utils::isUnset($request->dingTalkWebHookUrl)) {
            $query['DingTalkWebHookUrl'] = $request->dingTalkWebHookUrl;
        }
        if (!Utils::isUnset($request->domain)) {
            $query['Domain'] = $request->domain;
        }
        if (!Utils::isUnset($request->inputList)) {
            $query['InputList'] = $request->inputList;
        }
        if (!Utils::isUnset($request->monitorConfig)) {
            $query['MonitorConfig'] = $request->monitorConfig;
        }
        if (!Utils::isUnset($request->monitorId)) {
            $query['MonitorId'] = $request->monitorId;
        }
        if (!Utils::isUnset($request->monitorName)) {
            $query['MonitorName'] = $request->monitorName;
        }
        if (!Utils::isUnset($request->outputTemplate)) {
            $query['OutputTemplate'] = $request->outputTemplate;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->stream)) {
            $query['Stream'] = $request->stream;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveStreamMonitor',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveStreamMonitorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates the configurations of a monitoring session.
     *  *
     * @description You can call this operation to update the configurations of a monitoring session. The updates that you make to the input source configurations when the monitoring session is in the Running state immediately take effect.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateLiveStreamMonitorRequest $request UpdateLiveStreamMonitorRequest
     *
     * @return UpdateLiveStreamMonitorResponse UpdateLiveStreamMonitorResponse
     */
    public function updateLiveStreamMonitor($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveStreamMonitorWithOptions($request, $runtime);
    }

    /**
     * @summary Updates a default transcoding configuration.
     *  *
     * @description You must obtain the customer master key (CMK) in Key Management Service (KMS) before you call this operation to update a transcoding configuration. Only standard transcoding templates and Narrowband HD™ transcoding templates are supported for this operation.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account.
     *  *
     * @param UpdateLiveStreamTranscodeRequest $request UpdateLiveStreamTranscodeRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateLiveStreamTranscodeResponse UpdateLiveStreamTranscodeResponse
     */
    public function updateLiveStreamTranscodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->app)) {
            $query['App'] = $request->app;
        }
        if (!Utils::isUnset($request->domain)) {
            $query['Domain'] = $request->domain;
        }
        if (!Utils::isUnset($request->encryptParameters)) {
            $query['EncryptParameters'] = $request->encryptParameters;
        }
        if (!Utils::isUnset($request->lazy)) {
            $query['Lazy'] = $request->lazy;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->template)) {
            $query['Template'] = $request->template;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveStreamTranscode',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveStreamTranscodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates a default transcoding configuration.
     *  *
     * @description You must obtain the customer master key (CMK) in Key Management Service (KMS) before you call this operation to update a transcoding configuration. Only standard transcoding templates and Narrowband HD™ transcoding templates are supported for this operation.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account.
     *  *
     * @param UpdateLiveStreamTranscodeRequest $request UpdateLiveStreamTranscodeRequest
     *
     * @return UpdateLiveStreamTranscodeResponse UpdateLiveStreamTranscodeResponse
     */
    public function updateLiveStreamTranscode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveStreamTranscodeWithOptions($request, $runtime);
    }

    /**
     * @summary Updates a watermark template.
     *  *
     * @description This operation allows you to modify the parameters of a watermark template with a specified ID.
     * ## QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
     *  *
     * @param UpdateLiveStreamWatermarkRequest $request UpdateLiveStreamWatermarkRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateLiveStreamWatermarkResponse UpdateLiveStreamWatermarkResponse
     */
    public function updateLiveStreamWatermarkWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->height)) {
            $query['Height'] = $request->height;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->offsetCorner)) {
            $query['OffsetCorner'] = $request->offsetCorner;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pictureUrl)) {
            $query['PictureUrl'] = $request->pictureUrl;
        }
        if (!Utils::isUnset($request->refHeight)) {
            $query['RefHeight'] = $request->refHeight;
        }
        if (!Utils::isUnset($request->refWidth)) {
            $query['RefWidth'] = $request->refWidth;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->templateId)) {
            $query['TemplateId'] = $request->templateId;
        }
        if (!Utils::isUnset($request->transparency)) {
            $query['Transparency'] = $request->transparency;
        }
        if (!Utils::isUnset($request->XOffset)) {
            $query['XOffset'] = $request->XOffset;
        }
        if (!Utils::isUnset($request->YOffset)) {
            $query['YOffset'] = $request->YOffset;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveStreamWatermark',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveStreamWatermarkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates a watermark template.
     *  *
     * @description This operation allows you to modify the parameters of a watermark template with a specified ID.
     * ## QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
     *  *
     * @param UpdateLiveStreamWatermarkRequest $request UpdateLiveStreamWatermarkRequest
     *
     * @return UpdateLiveStreamWatermarkResponse UpdateLiveStreamWatermarkResponse
     */
    public function updateLiveStreamWatermark($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveStreamWatermarkWithOptions($request, $runtime);
    }

    /**
     * @summary Updates a watermark rule.
     *  *
     * @description This operation allows you to modify the parameters of a watermark rule with a specified ID.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateLiveStreamWatermarkRuleRequest $request UpdateLiveStreamWatermarkRuleRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateLiveStreamWatermarkRuleResponse UpdateLiveStreamWatermarkRuleResponse
     */
    public function updateLiveStreamWatermarkRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->ruleId)) {
            $query['RuleId'] = $request->ruleId;
        }
        if (!Utils::isUnset($request->templateId)) {
            $query['TemplateId'] = $request->templateId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveStreamWatermarkRule',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveStreamWatermarkRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates a watermark rule.
     *  *
     * @description This operation allows you to modify the parameters of a watermark rule with a specified ID.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateLiveStreamWatermarkRuleRequest $request UpdateLiveStreamWatermarkRuleRequest
     *
     * @return UpdateLiveStreamWatermarkRuleResponse UpdateLiveStreamWatermarkRuleResponse
     */
    public function updateLiveStreamWatermarkRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveStreamWatermarkRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Updates the configurations of an interactive message application.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param UpdateMessageAppRequest $tmpReq  UpdateMessageAppRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateMessageAppResponse UpdateMessageAppResponse
     */
    public function updateMessageAppWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new UpdateMessageAppShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->appConfig)) {
            $request->appConfigShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->appConfig, 'AppConfig', 'json');
        }
        if (!Utils::isUnset($tmpReq->extension)) {
            $request->extensionShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->extension, 'Extension', 'json');
        }
        $body = [];
        if (!Utils::isUnset($request->appConfigShrink)) {
            $body['AppConfig'] = $request->appConfigShrink;
        }
        if (!Utils::isUnset($request->appId)) {
            $body['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->appName)) {
            $body['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->extensionShrink)) {
            $body['Extension'] = $request->extensionShrink;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'UpdateMessageApp',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateMessageAppResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates the configurations of an interactive message application.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param UpdateMessageAppRequest $request UpdateMessageAppRequest
     *
     * @return UpdateMessageAppResponse UpdateMessageAppResponse
     */
    public function updateMessageApp($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateMessageAppWithOptions($request, $runtime);
    }

    /**
     * @summary Updates the information about a message group.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param UpdateMessageGroupRequest $tmpReq  UpdateMessageGroupRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateMessageGroupResponse UpdateMessageGroupResponse
     */
    public function updateMessageGroupWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new UpdateMessageGroupShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->extension)) {
            $request->extensionShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->extension, 'Extension', 'json');
        }
        $body = [];
        if (!Utils::isUnset($request->appId)) {
            $body['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->extensionShrink)) {
            $body['Extension'] = $request->extensionShrink;
        }
        if (!Utils::isUnset($request->groupId)) {
            $body['GroupId'] = $request->groupId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'UpdateMessageGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateMessageGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates the information about a message group.
     *  *
     * @description ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param UpdateMessageGroupRequest $request UpdateMessageGroupRequest
     *
     * @return UpdateMessageGroupResponse UpdateMessageGroupResponse
     */
    public function updateMessageGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateMessageGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Updates a stream mixing task.
     *  *
     * @description You can call this operation to update a stream mixing task. This operation allows you to modify the input sources and layout, but not other parameters such as the output resolution.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateMixStreamRequest $request UpdateMixStreamRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateMixStreamResponse UpdateMixStreamResponse
     */
    public function updateMixStreamWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->inputStreamList)) {
            $query['InputStreamList'] = $request->inputStreamList;
        }
        if (!Utils::isUnset($request->layoutId)) {
            $query['LayoutId'] = $request->layoutId;
        }
        if (!Utils::isUnset($request->mixStreamId)) {
            $query['MixStreamId'] = $request->mixStreamId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateMixStream',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateMixStreamResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates a stream mixing task.
     *  *
     * @description You can call this operation to update a stream mixing task. This operation allows you to modify the input sources and layout, but not other parameters such as the output resolution.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateMixStreamRequest $request UpdateMixStreamRequest
     *
     * @return UpdateMixStreamResponse UpdateMixStreamResponse
     */
    public function updateMixStream($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateMixStreamWithOptions($request, $runtime);
    }

    /**
     * @summary 更新rtc云端录制任务
     *  *
     * @param UpdateRtcCloudRecordingRequest $tmpReq  UpdateRtcCloudRecordingRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateRtcCloudRecordingResponse UpdateRtcCloudRecordingResponse
     */
    public function updateRtcCloudRecordingWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new UpdateRtcCloudRecordingShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->mixLayoutParams)) {
            $request->mixLayoutParamsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->mixLayoutParams, 'MixLayoutParams', 'json');
        }
        if (!Utils::isUnset($tmpReq->subscribeParams)) {
            $request->subscribeParamsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->subscribeParams, 'SubscribeParams', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->mixLayoutParamsShrink)) {
            $query['MixLayoutParams'] = $request->mixLayoutParamsShrink;
        }
        if (!Utils::isUnset($request->subscribeParamsShrink)) {
            $query['SubscribeParams'] = $request->subscribeParamsShrink;
        }
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateRtcCloudRecording',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateRtcCloudRecordingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 更新rtc云端录制任务
     *  *
     * @param UpdateRtcCloudRecordingRequest $request UpdateRtcCloudRecordingRequest
     *
     * @return UpdateRtcCloudRecordingResponse UpdateRtcCloudRecordingResponse
     */
    public function updateRtcCloudRecording($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateRtcCloudRecordingWithOptions($request, $runtime);
    }

    /**
     * @summary Updates a subscription to mixed-stream relay events.
     *  *
     * @description *   You can call this operation to update a subscription to mixed-stream relay events. You can modify parameters such as the callback URL and channel IDs.
     * *   Before you call this operation, make sure that you have called the CreateRtcMPUEventSub operation to create the subscription.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateRtcMPUEventSubRequest $request UpdateRtcMPUEventSubRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateRtcMPUEventSubResponse UpdateRtcMPUEventSubResponse
     */
    public function updateRtcMPUEventSubWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appId)) {
            $query['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->callbackUrl)) {
            $query['CallbackUrl'] = $request->callbackUrl;
        }
        if (!Utils::isUnset($request->channelIds)) {
            $query['ChannelIds'] = $request->channelIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateRtcMPUEventSub',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateRtcMPUEventSubResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates a subscription to mixed-stream relay events.
     *  *
     * @description *   You can call this operation to update a subscription to mixed-stream relay events. You can modify parameters such as the callback URL and channel IDs.
     * *   Before you call this operation, make sure that you have called the CreateRtcMPUEventSub operation to create the subscription.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param UpdateRtcMPUEventSubRequest $request UpdateRtcMPUEventSubRequest
     *
     * @return UpdateRtcMPUEventSubResponse UpdateRtcMPUEventSubResponse
     */
    public function updateRtcMPUEventSub($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateRtcMPUEventSubWithOptions($request, $runtime);
    }

    /**
     * @summary Updates a custom Real-Time Streaming (RTS) transcoding configuration.
     *  *
     * @description This operation supports the following types of custom transcoding templates: h264, h264-nbhd, h264-origin, and audio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account.
     *  *
     * @param UpdateRtsLiveStreamTranscodeRequest $request UpdateRtsLiveStreamTranscodeRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateRtsLiveStreamTranscodeResponse UpdateRtsLiveStreamTranscodeResponse
     */
    public function updateRtsLiveStreamTranscodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->app)) {
            $query['App'] = $request->app;
        }
        if (!Utils::isUnset($request->audioBitrate)) {
            $query['AudioBitrate'] = $request->audioBitrate;
        }
        if (!Utils::isUnset($request->audioChannelNum)) {
            $query['AudioChannelNum'] = $request->audioChannelNum;
        }
        if (!Utils::isUnset($request->audioCodec)) {
            $query['AudioCodec'] = $request->audioCodec;
        }
        if (!Utils::isUnset($request->audioProfile)) {
            $query['AudioProfile'] = $request->audioProfile;
        }
        if (!Utils::isUnset($request->audioRate)) {
            $query['AudioRate'] = $request->audioRate;
        }
        if (!Utils::isUnset($request->deleteBframes)) {
            $query['DeleteBframes'] = $request->deleteBframes;
        }
        if (!Utils::isUnset($request->domain)) {
            $query['Domain'] = $request->domain;
        }
        if (!Utils::isUnset($request->FPS)) {
            $query['FPS'] = $request->FPS;
        }
        if (!Utils::isUnset($request->gop)) {
            $query['Gop'] = $request->gop;
        }
        if (!Utils::isUnset($request->height)) {
            $query['Height'] = $request->height;
        }
        if (!Utils::isUnset($request->lazy)) {
            $query['Lazy'] = $request->lazy;
        }
        if (!Utils::isUnset($request->opus)) {
            $query['Opus'] = $request->opus;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->profile)) {
            $query['Profile'] = $request->profile;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->template)) {
            $query['Template'] = $request->template;
        }
        if (!Utils::isUnset($request->templateType)) {
            $query['TemplateType'] = $request->templateType;
        }
        if (!Utils::isUnset($request->videoBitrate)) {
            $query['VideoBitrate'] = $request->videoBitrate;
        }
        if (!Utils::isUnset($request->width)) {
            $query['Width'] = $request->width;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateRtsLiveStreamTranscode',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateRtsLiveStreamTranscodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates a custom Real-Time Streaming (RTS) transcoding configuration.
     *  *
     * @description This operation supports the following types of custom transcoding templates: h264, h264-nbhd, h264-origin, and audio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account.
     *  *
     * @param UpdateRtsLiveStreamTranscodeRequest $request UpdateRtsLiveStreamTranscodeRequest
     *
     * @return UpdateRtsLiveStreamTranscodeResponse UpdateRtsLiveStreamTranscodeResponse
     */
    public function updateRtsLiveStreamTranscode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateRtsLiveStreamTranscodeWithOptions($request, $runtime);
    }

    /**
     * @summary Verifies the ownership of a domain name.
     *  *
     * @description ### [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param VerifyLiveDomainOwnerRequest $request VerifyLiveDomainOwnerRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return VerifyLiveDomainOwnerResponse VerifyLiveDomainOwnerResponse
     */
    public function verifyLiveDomainOwnerWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->verifyType)) {
            $query['VerifyType'] = $request->verifyType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action' => 'VerifyLiveDomainOwner',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return VerifyLiveDomainOwnerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Verifies the ownership of a domain name.
     *  *
     * @description ### [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *  *
     * @param VerifyLiveDomainOwnerRequest $request VerifyLiveDomainOwnerRequest
     *
     * @return VerifyLiveDomainOwnerResponse VerifyLiveDomainOwnerResponse
     */
    public function verifyLiveDomainOwner($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->verifyLiveDomainOwnerWithOptions($request, $runtime);
    }
}
