<?php

// This file is auto-generated, don't edit it. Thanks.

namespace AlibabaCloud\SDK\Live\V20161101;

use AlibabaCloud\Dara\Models\RuntimeOptions;
use AlibabaCloud\SDK\Live\V20161101\Models\AddCasterComponentRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddCasterComponentResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddCasterEpisodeGroupContentRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddCasterEpisodeGroupContentResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddCasterEpisodeGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddCasterEpisodeGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddCasterEpisodeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddCasterEpisodeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddCasterLayoutRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddCasterLayoutResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddCasterProgramRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddCasterProgramResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddCasterVideoResourceRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddCasterVideoResourceResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddCustomLiveStreamTranscodeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddCustomLiveStreamTranscodeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveAIProduceRulesRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveAIProduceRulesResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveAISubtitleRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveAISubtitleResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveAISubtitleShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveAppRecordConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveAppRecordConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveAppSnapshotConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveAppSnapshotConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveAudioAuditConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveAudioAuditConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveAudioAuditNotifyConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveAudioAuditNotifyConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveCenterTransferRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveCenterTransferResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveDetectNotifyConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveDetectNotifyConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveDomainMappingRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveDomainMappingResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveDomainPlayMappingRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveDomainPlayMappingResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveDomainRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveDomainResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveMessageGroupBandRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveMessageGroupBandResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveMessageGroupBandShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLivePackageConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLivePackageConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLivePullStreamInfoConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLivePullStreamInfoConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveRecordNotifyConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveRecordNotifyConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveRecordVodConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveRecordVodConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveSnapshotDetectPornConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveSnapshotDetectPornConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveSnapshotNotifyConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveSnapshotNotifyConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveStreamMergeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveStreamMergeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveStreamTranscodeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveStreamTranscodeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveStreamWatermarkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveStreamWatermarkResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveStreamWatermarkRuleRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddLiveStreamWatermarkRuleResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddPlaylistItemsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddPlaylistItemsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddRtsLiveStreamTranscodeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddRtsLiveStreamTranscodeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddShowIntoShowListRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddShowIntoShowListResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddStudioLayoutRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddStudioLayoutResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\AddTrancodeSEIRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\AddTrancodeSEIResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\BanLiveMessageGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\BanLiveMessageGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\BanLiveMessageGroupShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\BatchDeleteLiveDomainConfigsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\BatchDeleteLiveDomainConfigsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\BatchGetOnlineUsersRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\BatchGetOnlineUsersResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\BatchSetLiveDomainConfigsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\BatchSetLiveDomainConfigsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CancelMuteAllGroupUserRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CancelMuteAllGroupUserResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CancelMuteGroupUserRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CancelMuteGroupUserResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CancelMuteGroupUserShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ChangeLiveDomainResourceGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ChangeLiveDomainResourceGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CheckLiveMessageUsersInGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CheckLiveMessageUsersInGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CheckLiveMessageUsersInGroupShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CheckLiveMessageUsersOnlineRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CheckLiveMessageUsersOnlineResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CheckLiveMessageUsersOnlineShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CloseLiveShiftRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CloseLiveShiftResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CopyCasterRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CopyCasterResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CopyCasterSceneConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CopyCasterSceneConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateCasterRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateCasterResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateCustomTemplateRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateCustomTemplateResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateEdgeTranscodeJobRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateEdgeTranscodeJobResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateEventSubRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateEventSubResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLiveAIStudioRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLiveAIStudioResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLiveAIStudioShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLiveDelayConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLiveDelayConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLiveMessageAppRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLiveMessageAppResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLiveMessageGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLiveMessageGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLiveMessageGroupShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLivePrivateLineRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLivePrivateLineResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLivePullToPushRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLivePullToPushResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLivePullToPushShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLiveRealTimeLogDeliveryRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLiveRealTimeLogDeliveryResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLiveStreamMonitorRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLiveStreamMonitorResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLiveStreamRecordIndexFilesRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateLiveStreamRecordIndexFilesResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateMessageAppRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateMessageAppResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateMessageAppShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateMessageGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateMessageGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateMessageGroupShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateMixStreamRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateMixStreamResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateRoomRealTimeStreamAddressRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateRoomRealTimeStreamAddressResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateRtcAsrTaskRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateRtcAsrTaskResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateRtcMPUEventSubRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateRtcMPUEventSubResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateRTCWhipStreamAddressRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\CreateRTCWhipStreamAddressResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCasterComponentRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCasterComponentResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCasterEpisodeGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCasterEpisodeGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCasterEpisodeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCasterEpisodeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCasterLayoutRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCasterLayoutResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCasterProgramRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCasterProgramResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCasterRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCasterResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCasterSceneConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCasterSceneConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCasterVideoResourceRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCasterVideoResourceResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteChannelRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteChannelResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCustomTemplateRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteCustomTemplateResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteEdgeTranscodeJobRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteEdgeTranscodeJobResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteEventSubRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteEventSubResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveAIProduceRulesRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveAIProduceRulesResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveAIStudioRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveAIStudioResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveAISubtitleRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveAISubtitleResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveAppRecordConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveAppRecordConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveAppSnapshotConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveAppSnapshotConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveAudioAuditConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveAudioAuditConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveAudioAuditNotifyConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveAudioAuditNotifyConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveCenterTransferRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveCenterTransferResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveDelayConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveDelayConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveDetectNotifyConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveDetectNotifyConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveDomainMappingRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveDomainMappingResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveDomainPlayMappingRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveDomainPlayMappingResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveDomainRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveDomainResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveEdgeTransferRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveEdgeTransferResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveLazyPullStreamInfoConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveLazyPullStreamInfoConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveMessageGroupMessageRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveMessageGroupMessageResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveMessageGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveMessageGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveMessageUserMessageRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveMessageUserMessageResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLivePackageConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLivePackageConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLivePrivateLineRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLivePrivateLineResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLivePullStreamInfoConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLivePullStreamInfoConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLivePullToPushRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLivePullToPushResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveRealtimeLogDeliveryRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveRealtimeLogDeliveryResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveRealTimeLogLogstoreRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveRealTimeLogLogstoreResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveRecordNotifyConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveRecordNotifyConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveRecordVodConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveRecordVodConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveSnapshotDetectPornConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveSnapshotDetectPornConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveSnapshotNotifyConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveSnapshotNotifyConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveSpecificStagingConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveSpecificStagingConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveStreamBlockRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveStreamBlockResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveStreamMergeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveStreamMergeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveStreamMonitorRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveStreamMonitorResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveStreamRecordIndexFilesRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveStreamRecordIndexFilesResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveStreamsNotifyUrlConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveStreamsNotifyUrlConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveStreamTranscodeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveStreamTranscodeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveStreamWatermarkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveStreamWatermarkResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveStreamWatermarkRuleRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteLiveStreamWatermarkRuleResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteMessageAppRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteMessageAppResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteMixStreamRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteMixStreamResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeletePlaylistItemsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeletePlaylistItemsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeletePlaylistRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeletePlaylistResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteRtcAsrTaskRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteRtcAsrTaskResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteRtcMPUEventSubRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteRtcMPUEventSubResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteSnapshotCallbackAuthRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteSnapshotCallbackAuthResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteSnapshotFilesRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteSnapshotFilesResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteStudioLayoutRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DeleteStudioLayoutResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeAutoShowListTasksRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeAutoShowListTasksResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterChannelsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterChannelsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterComponentsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterComponentsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterLayoutsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterLayoutsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterProgramRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterProgramResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterSceneAudioRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterSceneAudioResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterScenesRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterScenesResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCastersRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCastersResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterStreamUrlRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterStreamUrlResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterVideoResourcesRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeCasterVideoResourcesResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeChannelParticipantsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeChannelParticipantsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeChannelUsersRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeChannelUsersResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeDomainUsageDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeDomainUsageDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeDomainWithIntegrityRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeDomainWithIntegrityResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeHlsLiveStreamRealTimeBpsDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeHlsLiveStreamRealTimeBpsDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveAIProduceRulesRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveAIProduceRulesResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveAIStudioRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveAIStudioResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveAISubtitleRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveAISubtitleResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveAudioAuditConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveAudioAuditConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveAudioAuditNotifyConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveAudioAuditNotifyConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveCdnDiagnoseInfoRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveCdnDiagnoseInfoResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveCenterStreamRateDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveCenterStreamRateDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveCenterTransferRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveCenterTransferResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveCertificateDetailRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveCertificateDetailResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveCertificateListRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveCertificateListResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDelayConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDelayConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDelayedStreamingUsageRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDelayedStreamingUsageResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDetectNotifyConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDetectNotifyConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDetectPornDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDetectPornDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainBpsDataByLayerRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainBpsDataByLayerResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainBpsDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainBpsDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainByCertificateRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainByCertificateResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainCertificateInfoRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainCertificateInfoResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainConfigsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainConfigsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainDetailRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainDetailResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainEdgeLogRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainEdgeLogResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainFrameRateAndBitRateDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainFrameRateAndBitRateDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainLimitRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainLimitResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainLogExTtlRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainLogExTtlResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainLogRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainLogResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainMappingRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainMappingResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainMonitoringUsageDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainMonitoringUsageDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainMultiStreamConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainMultiStreamConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainOnlineUserNumRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainOnlineUserNumResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainPublishErrorCodeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainPublishErrorCodeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainPushBpsDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainPushBpsDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainPushTrafficDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainPushTrafficDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainPvUvDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainPvUvDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainRealTimeBpsDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainRealTimeBpsDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainRealTimeHttpCodeDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainRealTimeHttpCodeDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainRealtimeLogDeliveryRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainRealtimeLogDeliveryResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainRealTimeTrafficDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainRealTimeTrafficDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainRecordUsageDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainRecordUsageDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainSnapshotDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainSnapshotDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainStagingConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainStagingConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainStreamTranscodeDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainStreamTranscodeDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainTimeShiftDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainTimeShiftDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainTrafficDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainTrafficDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainTranscodeParamsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDomainTranscodeParamsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDrmUsageDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveDrmUsageDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveEdgeTransferRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveEdgeTransferResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveGrtnDurationRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveGrtnDurationResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveHttpsDomainListRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveHttpsDomainListResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveInteractionMetricDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveInteractionMetricDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveIpInfoRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveIpInfoResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveLazyPullStreamConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveLazyPullStreamConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveMessageAppRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveMessageAppResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveMessageGroupBandRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveMessageGroupBandResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveMessageGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveMessageGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLivePackageConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLivePackageConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLivePrivateLineAreasRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLivePrivateLineAreasResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLivePrivateLineAvailGARequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLivePrivateLineAvailGAResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveProducerUsageDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveProducerUsageDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLivePullStreamConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLivePullStreamConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLivePullToPushListRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLivePullToPushListResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLivePullToPushRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLivePullToPushResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLivePushProxyLogRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLivePushProxyLogResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLivePushProxyUsageDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLivePushProxyUsageDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveRealtimeDeliveryAccRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveRealtimeDeliveryAccResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveRealtimeLogAuthorizedRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveRealtimeLogAuthorizedResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveRecordConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveRecordConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveRecordNotifyConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveRecordNotifyConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveRecordNotifyRecordsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveRecordNotifyRecordsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveRecordVodConfigsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveRecordVodConfigsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveShiftConfigsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveShiftConfigsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveSnapshotConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveSnapshotConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveSnapshotDetectPornConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveSnapshotDetectPornConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveSnapshotNotifyConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveSnapshotNotifyConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamAuthCheckingRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamAuthCheckingResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamBitRateDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamBitRateDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamCountRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamCountResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamDelayConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamDelayConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamDetailFrameRateAndBitRateDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamDetailFrameRateAndBitRateDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamHistoryUserNumRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamHistoryUserNumResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamMergeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamMergeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamMetricDetailDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamMetricDetailDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamMonitorListRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamMonitorListResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamPreloadTasksRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamPreloadTasksResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamPushMetricDetailDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamPushMetricDetailDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamRecordContentRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamRecordContentResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamRecordIndexFileRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamRecordIndexFileResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamRecordIndexFilesRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamRecordIndexFilesResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamsBlockListRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamsBlockListResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamsControlHistoryRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamsControlHistoryResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamSnapshotInfoRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamSnapshotInfoResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamsNotifyRecordsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamsNotifyRecordsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamsNotifyUrlConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamsNotifyUrlConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamsOnlineListRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamsOnlineListResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamsPublishListRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamsPublishListResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamStateRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamStateResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamsTotalCountRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamsTotalCountResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamTranscodeInfoRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamTranscodeInfoResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamTranscodeMetricDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamTranscodeMetricDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamTranscodeStreamNumRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamTranscodeStreamNumResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamWatermarkRulesRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamWatermarkRulesResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamWatermarksRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveStreamWatermarksResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveTopDomainsByFlowRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveTopDomainsByFlowResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveTrafficDomainLogRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveTrafficDomainLogResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveUpVideoAudioInfoRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveUpVideoAudioInfoResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveUserBillPredictionRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveUserBillPredictionResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveUserDomainsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveUserDomainsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveUserStreamMetricDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveUserStreamMetricDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveUserTagsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveUserTagsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveUserTrafficLogRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveUserTrafficLogResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveVerifyContentRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeLiveVerifyContentResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeMeterLiveBypassDurationRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeMeterLiveBypassDurationResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeMixStreamListRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeMixStreamListResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRtcCloudRecordingFilesRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRtcCloudRecordingFilesResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRtcMPUEventSubRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRtcMPUEventSubResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRTSNativeSDKFirstFrameCostRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRTSNativeSDKFirstFrameCostResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRTSNativeSDKFirstFrameCostShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRTSNativeSDKFirstFrameDelayRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRTSNativeSDKFirstFrameDelayResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRTSNativeSDKFirstFrameDelayShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRTSNativeSDKPlayFailStatusRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRTSNativeSDKPlayFailStatusResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRTSNativeSDKPlayFailStatusShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRTSNativeSDKPlayTimeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRTSNativeSDKPlayTimeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRTSNativeSDKPlayTimeShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRTSNativeSDKVvDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRTSNativeSDKVvDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeRTSNativeSDKVvDataShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeShowListRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeShowListResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeStreamLocationBlockRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeStreamLocationBlockResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeStudioLayoutsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeStudioLayoutsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeToutiaoLivePlayRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeToutiaoLivePlayResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeToutiaoLivePublishRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeToutiaoLivePublishResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeUidOnlineStreamsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeUidOnlineStreamsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeUpBpsPeakDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeUpBpsPeakDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeUpBpsPeakOfLineRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeUpBpsPeakOfLineResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeUpPeakPublishStreamDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DescribeUpPeakPublishStreamDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DisableLiveRealtimeLogDeliveryRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DisableLiveRealtimeLogDeliveryResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\DynamicUpdateWaterMarkStreamRuleRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\DynamicUpdateWaterMarkStreamRuleResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\EditPlaylistRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\EditPlaylistResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\EditShowAndReplaceRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\EditShowAndReplaceResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\EffectCasterUrgentRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\EffectCasterUrgentResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\EffectCasterVideoResourceRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\EffectCasterVideoResourceResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\EnableLiveRealtimeLogDeliveryRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\EnableLiveRealtimeLogDeliveryResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ForbidLiveStreamRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ForbidLiveStreamResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\GetAllCustomTemplatesRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\GetAllCustomTemplatesResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\GetCustomTemplateRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\GetCustomTemplateResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\GetEdgeTranscodeJobRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\GetEdgeTranscodeJobResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\GetEdgeTranscodeTemplateRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\GetEdgeTranscodeTemplateResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\GetEditingJobInfoRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\GetEditingJobInfoResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\GetMessageAppRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\GetMessageAppResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\GetMessageGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\GetMessageGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\GetMessageTokenRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\GetMessageTokenResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\GetTranscodeTaskStatusRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\GetTranscodeTaskStatusResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\HotLiveRtcStreamRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\HotLiveRtcStreamResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\InitializeAutoShowListTaskRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\InitializeAutoShowListTaskResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\JoinMessageGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\JoinMessageGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\KickLiveMessageGroupUserRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\KickLiveMessageGroupUserResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\LeaveMessageGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\LeaveMessageGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListEdgeTranscodeJobRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListEdgeTranscodeJobResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListEdgeTranscodeTemplateRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListEdgeTranscodeTemplateResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListEventSubEventRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListEventSubEventResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListEventSubRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListEventSubResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveDelayConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveDelayConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveMessageAppsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveMessageAppsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveMessageGroupByPageRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveMessageGroupByPageResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveMessageGroupMessagesRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveMessageGroupMessagesResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveMessageGroupsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveMessageGroupsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveMessageGroupUsersRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveMessageGroupUsersResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveRealtimeLogDeliveryDomainsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveRealtimeLogDeliveryDomainsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveRealtimeLogDeliveryInfosRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveRealtimeLogDeliveryInfosResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveRealtimeLogDeliveryRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListLiveRealtimeLogDeliveryResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListMessageAppRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListMessageAppResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListMessageGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListMessageGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListMessageGroupUserByIdRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListMessageGroupUserByIdResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListMessageGroupUserByIdShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListMessageGroupUserRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListMessageGroupUserResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListMessageRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListMessageResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListMuteGroupUserRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListMuteGroupUserResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListPlaylistItemsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListPlaylistItemsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListPlaylistRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListPlaylistResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListRtcMPUEventSubRecordRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListRtcMPUEventSubRecordResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ListRtcMPUTaskDetailRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ListRtcMPUTaskDetailResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\LiveUpstreamQosDataRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\LiveUpstreamQosDataResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\LiveUpstreamQosDataShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\MiguLivePullToPushStartRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\MiguLivePullToPushStartResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\MiguLivePullToPushStatusRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\MiguLivePullToPushStatusResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyCasterComponentRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyCasterComponentResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyCasterEpisodeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyCasterEpisodeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyCasterLayoutRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyCasterLayoutResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyCasterProgramRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyCasterProgramResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyCasterVideoResourceRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyCasterVideoResourceResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveAIStudioRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveAIStudioResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveAIStudioShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveDomainSchdmByPropertyRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveDomainSchdmByPropertyResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveMessageAppAuditRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveMessageAppAuditResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveMessageAppCallbackRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveMessageAppCallbackResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveMessageAppDisableRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveMessageAppDisableResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveMessageGroupBandRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveMessageGroupBandResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveMessageGroupBandShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveMessageGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveMessageGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveMessageGroupShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveMessageUserInfoRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveMessageUserInfoResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveRealtimeLogDeliveryRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyLiveRealtimeLogDeliveryResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyShowListRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyShowListResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyStudioLayoutRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ModifyStudioLayoutResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\MuteAllGroupUserRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\MuteAllGroupUserResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\MuteGroupUserRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\MuteGroupUserResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\MuteGroupUserShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\OpenLiveShiftRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\OpenLiveShiftResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\PlayChoosenShowRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\PlayChoosenShowResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\PublishLiveStagingConfigToProductionRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\PublishLiveStagingConfigToProductionResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\QueryLiveDomainMultiStreamListRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\QueryLiveDomainMultiStreamListResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\QueryMessageAppRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\QueryMessageAppResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\QueryRtcAsrTasksRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\QueryRtcAsrTasksResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\QuerySnapshotCallbackAuthRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\QuerySnapshotCallbackAuthResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\RealTimeRecordCommandRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\RealTimeRecordCommandResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\RecoverLiveMessageDeletedGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\RecoverLiveMessageDeletedGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\RemoveLiveMessageGroupBandRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\RemoveLiveMessageGroupBandResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\RemoveLiveMessageGroupBandShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\RemoveShowFromShowListRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\RemoveShowFromShowListResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\RemoveTerminalsRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\RemoveTerminalsResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\RestartCasterRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\RestartCasterResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\RestartLivePullToPushRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\RestartLivePullToPushResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\RestartTranscodeTaskRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\RestartTranscodeTaskResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\ResumeLiveStreamRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\ResumeLiveStreamResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\RollbackLiveStagingConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\RollbackLiveStagingConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SendLikeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SendLikeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SendLiveMessageGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SendLiveMessageGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SendLiveMessageUserRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SendLiveMessageUserResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SendMessageToGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SendMessageToGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SendMessageToGroupUsersRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SendMessageToGroupUsersResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SendMessageToGroupUsersShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetCasterChannelRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetCasterChannelResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SetCasterConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetCasterConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SetCasterSceneConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetCasterSceneConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveDomainCertificateRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveDomainCertificateResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveDomainMultiStreamConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveDomainMultiStreamConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveDomainMultiStreamMasterRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveDomainMultiStreamMasterResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveDomainMultiStreamOptimalModeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveDomainMultiStreamOptimalModeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveDomainStagingConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveDomainStagingConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveEdgeTransferRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveEdgeTransferResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveLazyPullStreamInfoConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveLazyPullStreamInfoConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveMpuTaskSeiRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveMpuTaskSeiResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveStreamBlockRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveStreamBlockResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveStreamDelayConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveStreamDelayConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveStreamPreloadTasksRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveStreamPreloadTasksResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveStreamsNotifyUrlConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetLiveStreamsNotifyUrlConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SetShowListBackgroundRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetShowListBackgroundResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\SetSnapshotCallbackAuthRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\SetSnapshotCallbackAuthResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StartCasterRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StartCasterResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StartCasterSceneRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StartCasterSceneResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StartEdgeTranscodeJobRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StartEdgeTranscodeJobResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StartLiveDomainRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StartLiveDomainResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StartLiveMPUTaskRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StartLiveMPUTaskResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StartLiveMPUTaskShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StartLiveStreamMonitorRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StartLiveStreamMonitorResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StartPlaylistRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StartPlaylistResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StartRtcCloudRecordingRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StartRtcCloudRecordingResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StartRtcCloudRecordingShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StopCasterRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StopCasterResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StopCasterSceneRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StopCasterSceneResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StopEdgeTranscodeJobRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StopEdgeTranscodeJobResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StopLiveDomainRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StopLiveDomainResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StopLiveMPUTaskRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StopLiveMPUTaskResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StopLivePullToPushRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StopLivePullToPushResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StopLiveStreamMonitorRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StopLiveStreamMonitorResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StopPlaylistRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StopPlaylistResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StopRtcAsrTaskRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StopRtcAsrTaskResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\StopRtcCloudRecordingRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\StopRtcCloudRecordingResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\TagLiveResourcesRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\TagLiveResourcesResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UnbanLiveMessageGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UnbanLiveMessageGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UnTagLiveResourcesRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UnTagLiveResourcesResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateCasterResourceGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateCasterResourceGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateCasterSceneAudioRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateCasterSceneAudioResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateCasterSceneConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateCasterSceneConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateCustomLiveStreamTranscodeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateCustomLiveStreamTranscodeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateEdgeTranscodeJobRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateEdgeTranscodeJobResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateEventSubRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateEventSubResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveAIProduceRulesRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveAIProduceRulesResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveAISubtitleRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveAISubtitleResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveAISubtitleShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveAppRecordConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveAppRecordConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveAppSnapshotConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveAppSnapshotConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveAudioAuditConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveAudioAuditConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveAudioAuditNotifyConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveAudioAuditNotifyConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveCenterTransferRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveCenterTransferResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveDelayConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveDelayConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveDetectNotifyConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveDetectNotifyConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveMPUTaskRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveMPUTaskResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveMPUTaskShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLivePackageConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLivePackageConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLivePullStreamInfoConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLivePullStreamInfoConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLivePullToPushRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLivePullToPushResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLivePullToPushShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveRecordNotifyConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveRecordNotifyConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveRecordVodConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveRecordVodConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveSnapshotDetectPornConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveSnapshotDetectPornConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveSnapshotNotifyConfigRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveSnapshotNotifyConfigResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveStreamMonitorRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveStreamMonitorResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveStreamTranscodeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveStreamTranscodeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveStreamWatermarkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveStreamWatermarkResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveStreamWatermarkRuleRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateLiveStreamWatermarkRuleResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateMessageAppRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateMessageAppResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateMessageAppShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateMessageGroupRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateMessageGroupResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateMessageGroupShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateMixStreamRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateMixStreamResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateRtcCloudRecordingRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateRtcCloudRecordingResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateRtcCloudRecordingShrinkRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateRtcMPUEventSubRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateRtcMPUEventSubResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateRtsLiveStreamTranscodeRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\UpdateRtsLiveStreamTranscodeResponse;
use AlibabaCloud\SDK\Live\V20161101\Models\VerifyLiveDomainOwnerRequest;
use AlibabaCloud\SDK\Live\V20161101\Models\VerifyLiveDomainOwnerResponse;
use Darabonba\OpenApi\Models\OpenApiRequest;
use Darabonba\OpenApi\Models\Params;
use Darabonba\OpenApi\OpenApiClient;
use Darabonba\OpenApi\Utils;

class Live extends OpenApiClient
{
    public function __construct($config)
    {
        parent::__construct($config);
        $this->_endpointRule = 'regional';
        $this->_endpointMap = [
            'cn-qingdao' => 'live.aliyuncs.com',
            'cn-beijing' => 'live.aliyuncs.com',
            'cn-hangzhou' => 'live.aliyuncs.com',
            'cn-shanghai' => 'live.aliyuncs.com',
            'cn-shenzhen' => 'live.aliyuncs.com',
            'ap-southeast-1' => 'live.aliyuncs.com',
            'ap-southeast-5' => 'live.aliyuncs.com',
            'ap-northeast-1' => 'live.aliyuncs.com',
            'eu-central-1' => 'live.aliyuncs.com',
            'ap-south-1' => 'live.aliyuncs.com',
            'ap-northeast-2-pop' => 'live.aliyuncs.com',
            'ap-southeast-2' => 'live.aliyuncs.com',
            'ap-southeast-3' => 'live.aliyuncs.com',
            'cn-beijing-finance-1' => 'live.aliyuncs.com',
            'cn-beijing-finance-pop' => 'live.aliyuncs.com',
            'cn-beijing-gov-1' => 'live.aliyuncs.com',
            'cn-beijing-nu16-b01' => 'live.aliyuncs.com',
            'cn-chengdu' => 'live.aliyuncs.com',
            'cn-edge-1' => 'live.aliyuncs.com',
            'cn-fujian' => 'live.aliyuncs.com',
            'cn-haidian-cm12-c01' => 'live.aliyuncs.com',
            'cn-hangzhou-bj-b01' => 'live.aliyuncs.com',
            'cn-hangzhou-finance' => 'live.aliyuncs.com',
            'cn-hangzhou-internal-prod-1' => 'live.aliyuncs.com',
            'cn-hangzhou-internal-test-1' => 'live.aliyuncs.com',
            'cn-hangzhou-internal-test-2' => 'live.aliyuncs.com',
            'cn-hangzhou-internal-test-3' => 'live.aliyuncs.com',
            'cn-hangzhou-test-306' => 'live.aliyuncs.com',
            'cn-hongkong' => 'live.aliyuncs.com',
            'cn-hongkong-finance-pop' => 'live.aliyuncs.com',
            'cn-huhehaote' => 'live.aliyuncs.com',
            'cn-huhehaote-nebula-1' => 'live.aliyuncs.com',
            'cn-north-2-gov-1' => 'live.aliyuncs.com',
            'cn-qingdao-nebula' => 'live.aliyuncs.com',
            'cn-shanghai-et15-b01' => 'live.aliyuncs.com',
            'cn-shanghai-et2-b01' => 'live.aliyuncs.com',
            'cn-shanghai-finance-1' => 'live.aliyuncs.com',
            'cn-shanghai-inner' => 'live.aliyuncs.com',
            'cn-shanghai-internal-test-1' => 'live.aliyuncs.com',
            'cn-shenzhen-finance-1' => 'live.aliyuncs.com',
            'cn-shenzhen-inner' => 'live.aliyuncs.com',
            'cn-shenzhen-st4-d01' => 'live.aliyuncs.com',
            'cn-shenzhen-su18-b01' => 'live.aliyuncs.com',
            'cn-wuhan' => 'live.aliyuncs.com',
            'cn-wulanchabu' => 'live.aliyuncs.com',
            'cn-yushanfang' => 'live.aliyuncs.com',
            'cn-zhangbei' => 'live.aliyuncs.com',
            'cn-zhangbei-na61-b01' => 'live.aliyuncs.com',
            'cn-zhangjiakou' => 'live.aliyuncs.com',
            'cn-zhangjiakou-na62-a01' => 'live.aliyuncs.com',
            'cn-zhengzhou-nebula-1' => 'live.aliyuncs.com',
            'eu-west-1' => 'live.aliyuncs.com',
            'eu-west-1-oxs' => 'live.aliyuncs.com',
            'me-east-1' => 'live.aliyuncs.com',
            'rus-west-1-pop' => 'live.aliyuncs.com',
            'us-east-1' => 'live.aliyuncs.com',
            'us-west-1' => 'live.aliyuncs.com',
        ];
        $this->checkConfig($config);
        $this->_endpoint = $this->getEndpoint('live', $this->_regionId, $this->_endpointRule, $this->_network, $this->_suffix, $this->_endpointMap, $this->_endpoint);
    }

    /**
     * @param string   $productId
     * @param string   $regionId
     * @param string   $endpointRule
     * @param string   $network
     * @param string   $suffix
     * @param string[] $endpointMap
     * @param string   $endpoint
     *
     * @return string
     */
    public function getEndpoint($productId, $regionId, $endpointRule, $network, $suffix, $endpointMap, $endpoint)
    {
        if (null !== $endpoint) {
            return $endpoint;
        }

        if (null !== $endpointMap && null !== @$endpointMap[$regionId]) {
            return @$endpointMap[$regionId];
        }

        return Utils::getEndpointRules($productId, $regionId, $endpointRule, $network, $suffix);
    }

    /**
     * Adds a component to a production studio.
     *
     * @remarks
     * Before you call this operation to add a component to a production studio, you must first create the production studio and learn about the production studio layouts. You can call this operation to add three types of components: image, text, and subtitle. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddCasterComponentRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddCasterComponentResponse
     *
     * @param AddCasterComponentRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return AddCasterComponentResponse
     */
    public function addCasterComponentWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->captionLayerContent) {
            @$query['CaptionLayerContent'] = $request->captionLayerContent;
        }

        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->componentLayer) {
            @$query['ComponentLayer'] = $request->componentLayer;
        }

        if (null !== $request->componentName) {
            @$query['ComponentName'] = $request->componentName;
        }

        if (null !== $request->componentType) {
            @$query['ComponentType'] = $request->componentType;
        }

        if (null !== $request->effect) {
            @$query['Effect'] = $request->effect;
        }

        if (null !== $request->htmlLayerContent) {
            @$query['HtmlLayerContent'] = $request->htmlLayerContent;
        }

        if (null !== $request->imageLayerContent) {
            @$query['ImageLayerContent'] = $request->imageLayerContent;
        }

        if (null !== $request->layerOrder) {
            @$query['LayerOrder'] = $request->layerOrder;
        }

        if (null !== $request->locationId) {
            @$query['LocationId'] = $request->locationId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->textLayerContent) {
            @$query['TextLayerContent'] = $request->textLayerContent;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddCasterComponent',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddCasterComponentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds a component to a production studio.
     *
     * @remarks
     * Before you call this operation to add a component to a production studio, you must first create the production studio and learn about the production studio layouts. You can call this operation to add three types of components: image, text, and subtitle. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddCasterComponentRequest
     *
     * @returns AddCasterComponentResponse
     *
     * @param AddCasterComponentRequest $request
     *
     * @return AddCasterComponentResponse
     */
    public function addCasterComponent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addCasterComponentWithOptions($request, $runtime);
    }

    /**
     * Adds an episode to a production studio.
     *
     * @remarks
     * To call this operation, you must obtain the production studio ID in advance. The production studio ID is generated after the production studio is created.
     * *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
     * *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
     * >  You can find the ID of the production studio in the Instance ID/Name column.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddCasterEpisodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddCasterEpisodeResponse
     *
     * @param AddCasterEpisodeRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return AddCasterEpisodeResponse
     */
    public function addCasterEpisodeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->componentId) {
            @$query['ComponentId'] = $request->componentId;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->episodeName) {
            @$query['EpisodeName'] = $request->episodeName;
        }

        if (null !== $request->episodeType) {
            @$query['EpisodeType'] = $request->episodeType;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->switchType) {
            @$query['SwitchType'] = $request->switchType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddCasterEpisode',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddCasterEpisodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds an episode to a production studio.
     *
     * @remarks
     * To call this operation, you must obtain the production studio ID in advance. The production studio ID is generated after the production studio is created.
     * *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
     * *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
     * >  You can find the ID of the production studio in the Instance ID/Name column.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddCasterEpisodeRequest
     *
     * @returns AddCasterEpisodeResponse
     *
     * @param AddCasterEpisodeRequest $request
     *
     * @return AddCasterEpisodeResponse
     */
    public function addCasterEpisode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addCasterEpisodeWithOptions($request, $runtime);
    }

    /**
     * Adds an episode list to a production studio.
     *
     * @remarks
     * You need to create a production studio and obtain the production studio configurations before you call this operation to create an episode list in the production studio. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddCasterEpisodeGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddCasterEpisodeGroupResponse
     *
     * @param AddCasterEpisodeGroupRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return AddCasterEpisodeGroupResponse
     */
    public function addCasterEpisodeGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->callbackUrl) {
            @$query['CallbackUrl'] = $request->callbackUrl;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->item) {
            @$query['Item'] = $request->item;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->repeatNum) {
            @$query['RepeatNum'] = $request->repeatNum;
        }

        if (null !== $request->sideOutputUrl) {
            @$query['SideOutputUrl'] = $request->sideOutputUrl;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddCasterEpisodeGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddCasterEpisodeGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds an episode list to a production studio.
     *
     * @remarks
     * You need to create a production studio and obtain the production studio configurations before you call this operation to create an episode list in the production studio. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddCasterEpisodeGroupRequest
     *
     * @returns AddCasterEpisodeGroupResponse
     *
     * @param AddCasterEpisodeGroupRequest $request
     *
     * @return AddCasterEpisodeGroupResponse
     */
    public function addCasterEpisodeGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addCasterEpisodeGroupWithOptions($request, $runtime);
    }

    /**
     * Adds information about an episode list in a production studio.
     *
     * @remarks
     * You need to create a production studio and add an episode list to the production studio before you call this operation to add information about the episode list in the production studio. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddCasterEpisodeGroupContentRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddCasterEpisodeGroupContentResponse
     *
     * @param AddCasterEpisodeGroupContentRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return AddCasterEpisodeGroupContentResponse
     */
    public function addCasterEpisodeGroupContentWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->content) {
            @$query['Content'] = $request->content;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddCasterEpisodeGroupContent',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddCasterEpisodeGroupContentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds information about an episode list in a production studio.
     *
     * @remarks
     * You need to create a production studio and add an episode list to the production studio before you call this operation to add information about the episode list in the production studio. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddCasterEpisodeGroupContentRequest
     *
     * @returns AddCasterEpisodeGroupContentResponse
     *
     * @param AddCasterEpisodeGroupContentRequest $request
     *
     * @return AddCasterEpisodeGroupContentResponse
     */
    public function addCasterEpisodeGroupContent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addCasterEpisodeGroupContentWithOptions($request, $runtime);
    }

    /**
     * Adds a layout for a production studio.
     *
     * @remarks
     * First, create a director desk and add video resources to the director desk, then call this interface to add the director desk layout. To create a director desk using the API, refer to [Create Director Desk](https://help.aliyun.com/document_detail/69338.html).
     * ## QPS Limitation
     * The per-user QPS limit for this interface is 10 times/second. Exceeding this limit will result in API calls being throttled, which may impact your business operations. Please use the API reasonably. For more information, see [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - AddCasterLayoutRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddCasterLayoutResponse
     *
     * @param AddCasterLayoutRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return AddCasterLayoutResponse
     */
    public function addCasterLayoutWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->audioLayer) {
            @$query['AudioLayer'] = $request->audioLayer;
        }

        if (null !== $request->blendList) {
            @$query['BlendList'] = $request->blendList;
        }

        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->mixList) {
            @$query['MixList'] = $request->mixList;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->videoLayer) {
            @$query['VideoLayer'] = $request->videoLayer;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddCasterLayout',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddCasterLayoutResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds a layout for a production studio.
     *
     * @remarks
     * First, create a director desk and add video resources to the director desk, then call this interface to add the director desk layout. To create a director desk using the API, refer to [Create Director Desk](https://help.aliyun.com/document_detail/69338.html).
     * ## QPS Limitation
     * The per-user QPS limit for this interface is 10 times/second. Exceeding this limit will result in API calls being throttled, which may impact your business operations. Please use the API reasonably. For more information, see [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - AddCasterLayoutRequest
     *
     * @returns AddCasterLayoutResponse
     *
     * @param AddCasterLayoutRequest $request
     *
     * @return AddCasterLayoutResponse
     */
    public function addCasterLayout($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addCasterLayoutWithOptions($request, $runtime);
    }

    /**
     * Adds the episode list for carousel playback in a production studio.
     *
     * @remarks
     * Create a production studio, add input sources to the production studio, and then call this operation to add the episode list for carousel playback in the production studio. This operation supports videos and components as episodes. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddCasterProgramRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddCasterProgramResponse
     *
     * @param AddCasterProgramRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return AddCasterProgramResponse
     */
    public function addCasterProgramWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->episode) {
            @$query['Episode'] = $request->episode;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddCasterProgram',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddCasterProgramResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds the episode list for carousel playback in a production studio.
     *
     * @remarks
     * Create a production studio, add input sources to the production studio, and then call this operation to add the episode list for carousel playback in the production studio. This operation supports videos and components as episodes. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddCasterProgramRequest
     *
     * @returns AddCasterProgramResponse
     *
     * @param AddCasterProgramRequest $request
     *
     * @return AddCasterProgramResponse
     */
    public function addCasterProgram($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addCasterProgramWithOptions($request, $runtime);
    }

    /**
     * Adds an input source to a production studio. The number of input sources is limited by the number of input channels of the production studio.
     *
     * @remarks
     * ##
     * Create a production studio, and then call this operation to add a video source to the production studio. The number of video sources is limited by the number of input channels of the production studio. For information about how to create a production studio by calling an API operation, see [CreateCaster](https://help.aliyun.com/document_detail/69338.html).
     * ## QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - AddCasterVideoResourceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddCasterVideoResourceResponse
     *
     * @param AddCasterVideoResourceRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return AddCasterVideoResourceResponse
     */
    public function addCasterVideoResourceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->beginOffset) {
            @$query['BeginOffset'] = $request->beginOffset;
        }

        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->endOffset) {
            @$query['EndOffset'] = $request->endOffset;
        }

        if (null !== $request->fixedDelayDuration) {
            @$query['FixedDelayDuration'] = $request->fixedDelayDuration;
        }

        if (null !== $request->imageId) {
            @$query['ImageId'] = $request->imageId;
        }

        if (null !== $request->imageUrl) {
            @$query['ImageUrl'] = $request->imageUrl;
        }

        if (null !== $request->liveStreamUrl) {
            @$query['LiveStreamUrl'] = $request->liveStreamUrl;
        }

        if (null !== $request->locationId) {
            @$query['LocationId'] = $request->locationId;
        }

        if (null !== $request->materialId) {
            @$query['MaterialId'] = $request->materialId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->ptsCallbackInterval) {
            @$query['PtsCallbackInterval'] = $request->ptsCallbackInterval;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->repeatNum) {
            @$query['RepeatNum'] = $request->repeatNum;
        }

        if (null !== $request->resourceName) {
            @$query['ResourceName'] = $request->resourceName;
        }

        if (null !== $request->vodUrl) {
            @$query['VodUrl'] = $request->vodUrl;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddCasterVideoResource',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddCasterVideoResourceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds an input source to a production studio. The number of input sources is limited by the number of input channels of the production studio.
     *
     * @remarks
     * ##
     * Create a production studio, and then call this operation to add a video source to the production studio. The number of video sources is limited by the number of input channels of the production studio. For information about how to create a production studio by calling an API operation, see [CreateCaster](https://help.aliyun.com/document_detail/69338.html).
     * ## QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - AddCasterVideoResourceRequest
     *
     * @returns AddCasterVideoResourceResponse
     *
     * @param AddCasterVideoResourceRequest $request
     *
     * @return AddCasterVideoResourceResponse
     */
    public function addCasterVideoResource($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addCasterVideoResourceWithOptions($request, $runtime);
    }

    /**
     * Adds a custom transcoding configuration for a streaming domain.
     *
     * @remarks
     * This operation supports the following types of custom transcoding templates:
     * *   h264: H.264
     * *   h264-nbhd: H.264 Narrowband HD™
     * *   h265: H.265
     * *   h265-nbhd: H.265 Narrowband HD™
     * *   audio: audio-only
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - AddCustomLiveStreamTranscodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddCustomLiveStreamTranscodeResponse
     *
     * @param AddCustomLiveStreamTranscodeRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return AddCustomLiveStreamTranscodeResponse
     */
    public function addCustomLiveStreamTranscodeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->app) {
            @$query['App'] = $request->app;
        }

        if (null !== $request->audioBitrate) {
            @$query['AudioBitrate'] = $request->audioBitrate;
        }

        if (null !== $request->audioChannelNum) {
            @$query['AudioChannelNum'] = $request->audioChannelNum;
        }

        if (null !== $request->audioCodec) {
            @$query['AudioCodec'] = $request->audioCodec;
        }

        if (null !== $request->audioProfile) {
            @$query['AudioProfile'] = $request->audioProfile;
        }

        if (null !== $request->audioRate) {
            @$query['AudioRate'] = $request->audioRate;
        }

        if (null !== $request->bitrateWithSource) {
            @$query['BitrateWithSource'] = $request->bitrateWithSource;
        }

        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->encryptParameters) {
            @$query['EncryptParameters'] = $request->encryptParameters;
        }

        if (null !== $request->extWithSource) {
            @$query['ExtWithSource'] = $request->extWithSource;
        }

        if (null !== $request->FPS) {
            @$query['FPS'] = $request->FPS;
        }

        if (null !== $request->fpsWithSource) {
            @$query['FpsWithSource'] = $request->fpsWithSource;
        }

        if (null !== $request->gop) {
            @$query['Gop'] = $request->gop;
        }

        if (null !== $request->height) {
            @$query['Height'] = $request->height;
        }

        if (null !== $request->kmsKeyExpireInterval) {
            @$query['KmsKeyExpireInterval'] = $request->kmsKeyExpireInterval;
        }

        if (null !== $request->kmsKeyID) {
            @$query['KmsKeyID'] = $request->kmsKeyID;
        }

        if (null !== $request->kmsUID) {
            @$query['KmsUID'] = $request->kmsUID;
        }

        if (null !== $request->lazy) {
            @$query['Lazy'] = $request->lazy;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->profile) {
            @$query['Profile'] = $request->profile;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resWithSource) {
            @$query['ResWithSource'] = $request->resWithSource;
        }

        if (null !== $request->template) {
            @$query['Template'] = $request->template;
        }

        if (null !== $request->templateType) {
            @$query['TemplateType'] = $request->templateType;
        }

        if (null !== $request->videoBitrate) {
            @$query['VideoBitrate'] = $request->videoBitrate;
        }

        if (null !== $request->width) {
            @$query['Width'] = $request->width;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddCustomLiveStreamTranscode',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddCustomLiveStreamTranscodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds a custom transcoding configuration for a streaming domain.
     *
     * @remarks
     * This operation supports the following types of custom transcoding templates:
     * *   h264: H.264
     * *   h264-nbhd: H.264 Narrowband HD™
     * *   h265: H.265
     * *   h265-nbhd: H.265 Narrowband HD™
     * *   audio: audio-only
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - AddCustomLiveStreamTranscodeRequest
     *
     * @returns AddCustomLiveStreamTranscodeResponse
     *
     * @param AddCustomLiveStreamTranscodeRequest $request
     *
     * @return AddCustomLiveStreamTranscodeResponse
     */
    public function addCustomLiveStreamTranscode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addCustomLiveStreamTranscodeWithOptions($request, $runtime);
    }

    /**
     * Adds a subtitle rule.
     *
     * @remarks
     *   After you call the [AddLiveAISubtitle](https://help.aliyun.com/document_detail/2848222.html) operation to add a subtitle template, you can call this operation to create a subtitle rule for the template.
     * *   You must add "_Subtitle template name" after the stream name in the streaming URL to play the subtitle stream.
     *     *   RTMP: rtmp://example.aliyundoc.com/app/stream_{Subtitle template name}?auth_key={Access token}
     *     *   FLV: http://example.aliyundoc.com/app/stream_{Subtitle template name}.flv?auth_key={Access token}
     *     *   M3U8: http://example.aliyundoc.com/app/stream_{Subtitle template name}.m3u8?auth_key={Access token}
     * >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddLiveAIProduceRulesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddLiveAIProduceRulesResponse
     *
     * @param AddLiveAIProduceRulesRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return AddLiveAIProduceRulesResponse
     */
    public function addLiveAIProduceRulesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->app) {
            @$query['App'] = $request->app;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->isLazy) {
            @$query['IsLazy'] = $request->isLazy;
        }

        if (null !== $request->liveTemplate) {
            @$query['LiveTemplate'] = $request->liveTemplate;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->studioName) {
            @$query['StudioName'] = $request->studioName;
        }

        if (null !== $request->subtitleName) {
            @$query['SubtitleName'] = $request->subtitleName;
        }

        if (null !== $request->suffix) {
            @$query['Suffix'] = $request->suffix;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveAIProduceRules',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveAIProduceRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds a subtitle rule.
     *
     * @remarks
     *   After you call the [AddLiveAISubtitle](https://help.aliyun.com/document_detail/2848222.html) operation to add a subtitle template, you can call this operation to create a subtitle rule for the template.
     * *   You must add "_Subtitle template name" after the stream name in the streaming URL to play the subtitle stream.
     *     *   RTMP: rtmp://example.aliyundoc.com/app/stream_{Subtitle template name}?auth_key={Access token}
     *     *   FLV: http://example.aliyundoc.com/app/stream_{Subtitle template name}.flv?auth_key={Access token}
     *     *   M3U8: http://example.aliyundoc.com/app/stream_{Subtitle template name}.m3u8?auth_key={Access token}
     * >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddLiveAIProduceRulesRequest
     *
     * @returns AddLiveAIProduceRulesResponse
     *
     * @param AddLiveAIProduceRulesRequest $request
     *
     * @return AddLiveAIProduceRulesResponse
     */
    public function addLiveAIProduceRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveAIProduceRulesWithOptions($request, $runtime);
    }

    /**
     * Adds a subtitle template.
     *
     * @remarks
     * ## Instructions
     * - This interface supports adding live caption template configurations, with templates configurable to describe caption content, layout, and more.
     * - After adding caption templates, you also need to call the [AddLiveAIProduceRules](https://help.aliyun.com/document_detail/2799676.html) interface to add caption rules. Restarting the stream will then enable captions in the broadcast.
     * - Real-time captions are currently supported in Beijing, Shanghai, Singapore, Indonesia, and Saudi regions.
     * >Notice: The real-time caption feature is currently in beta testing. Each user can add up to 300 caption templates.
     * ## QPS Limit
     * The QPS limit for this interface per user is 60 requests/second. Exceeding this limit will result in API throttling, which may impact your services. Please use judiciously. For more information, refer to [QPS Limitations](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param tmpReq - AddLiveAISubtitleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddLiveAISubtitleResponse
     *
     * @param AddLiveAISubtitleRequest $tmpReq
     * @param RuntimeOptions           $runtime
     *
     * @return AddLiveAISubtitleResponse
     */
    public function addLiveAISubtitleWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new AddLiveAISubtitleShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->positionNormalized) {
            $request->positionNormalizedShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->positionNormalized, 'PositionNormalized', 'json');
        }

        $query = [];
        if (null !== $request->bgColor) {
            @$query['BgColor'] = $request->bgColor;
        }

        if (null !== $request->bgWidthNormalized) {
            @$query['BgWidthNormalized'] = $request->bgWidthNormalized;
        }

        if (null !== $request->borderWidthNormalized) {
            @$query['BorderWidthNormalized'] = $request->borderWidthNormalized;
        }

        if (null !== $request->copyFrom) {
            @$query['CopyFrom'] = $request->copyFrom;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->dstLanguage) {
            @$query['DstLanguage'] = $request->dstLanguage;
        }

        if (null !== $request->fontColor) {
            @$query['FontColor'] = $request->fontColor;
        }

        if (null !== $request->fontName) {
            @$query['FontName'] = $request->fontName;
        }

        if (null !== $request->fontSizeNormalized) {
            @$query['FontSizeNormalized'] = $request->fontSizeNormalized;
        }

        if (null !== $request->height) {
            @$query['Height'] = $request->height;
        }

        if (null !== $request->maxLines) {
            @$query['MaxLines'] = $request->maxLines;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->positionNormalizedShrink) {
            @$query['PositionNormalized'] = $request->positionNormalizedShrink;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->showSourceLan) {
            @$query['ShowSourceLan'] = $request->showSourceLan;
        }

        if (null !== $request->srcLanguage) {
            @$query['SrcLanguage'] = $request->srcLanguage;
        }

        if (null !== $request->subtitleName) {
            @$query['SubtitleName'] = $request->subtitleName;
        }

        if (null !== $request->width) {
            @$query['Width'] = $request->width;
        }

        if (null !== $request->wordPerLine) {
            @$query['WordPerLine'] = $request->wordPerLine;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveAISubtitle',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveAISubtitleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds a subtitle template.
     *
     * @remarks
     * ## Instructions
     * - This interface supports adding live caption template configurations, with templates configurable to describe caption content, layout, and more.
     * - After adding caption templates, you also need to call the [AddLiveAIProduceRules](https://help.aliyun.com/document_detail/2799676.html) interface to add caption rules. Restarting the stream will then enable captions in the broadcast.
     * - Real-time captions are currently supported in Beijing, Shanghai, Singapore, Indonesia, and Saudi regions.
     * >Notice: The real-time caption feature is currently in beta testing. Each user can add up to 300 caption templates.
     * ## QPS Limit
     * The QPS limit for this interface per user is 60 requests/second. Exceeding this limit will result in API throttling, which may impact your services. Please use judiciously. For more information, refer to [QPS Limitations](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - AddLiveAISubtitleRequest
     *
     * @returns AddLiveAISubtitleResponse
     *
     * @param AddLiveAISubtitleRequest $request
     *
     * @return AddLiveAISubtitleResponse
     */
    public function addLiveAISubtitle($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveAISubtitleWithOptions($request, $runtime);
    }

    /**
     * Configure APP recording, with output saved to OSS.
     *
     * @remarks
     * The live stream recording feature allows you to record a live stream and stores the recordings in a specified location. You can view the recordings whenever you want to. Recordings that are stored in OSS support multiple formats, such as Transport Stream (TS), MP4, Flash Video (FLV), and Common Media Application Format (CMAF). You can use different recording policies, including automatic recording, on-demand recording, and manual recording. By calling this operation, you can configure the recording template. For more information about live stream recording, see [Live stream recording](https://help.aliyun.com/document_detail/199357.html).
     * A configuration is identified by the DomainName, AppName, and StreamName parameters all together. If you try to call this operation to add a configuration that has the same DomainName, AppName, and StreamName parameters as an existing configuration, an error indicating that the configuration already exists is returned.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddLiveAppRecordConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddLiveAppRecordConfigResponse
     *
     * @param AddLiveAppRecordConfigRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return AddLiveAppRecordConfigResponse
     */
    public function addLiveAppRecordConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->delayTime) {
            @$query['DelayTime'] = $request->delayTime;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->onDemand) {
            @$query['OnDemand'] = $request->onDemand;
        }

        if (null !== $request->ossBucket) {
            @$query['OssBucket'] = $request->ossBucket;
        }

        if (null !== $request->ossEndpoint) {
            @$query['OssEndpoint'] = $request->ossEndpoint;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->recordFormat) {
            @$query['RecordFormat'] = $request->recordFormat;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        if (null !== $request->transcodeRecordFormat) {
            @$query['TranscodeRecordFormat'] = $request->transcodeRecordFormat;
        }

        if (null !== $request->transcodeTemplates) {
            @$query['TranscodeTemplates'] = $request->transcodeTemplates;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveAppRecordConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveAppRecordConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configure APP recording, with output saved to OSS.
     *
     * @remarks
     * The live stream recording feature allows you to record a live stream and stores the recordings in a specified location. You can view the recordings whenever you want to. Recordings that are stored in OSS support multiple formats, such as Transport Stream (TS), MP4, Flash Video (FLV), and Common Media Application Format (CMAF). You can use different recording policies, including automatic recording, on-demand recording, and manual recording. By calling this operation, you can configure the recording template. For more information about live stream recording, see [Live stream recording](https://help.aliyun.com/document_detail/199357.html).
     * A configuration is identified by the DomainName, AppName, and StreamName parameters all together. If you try to call this operation to add a configuration that has the same DomainName, AppName, and StreamName parameters as an existing configuration, an error indicating that the configuration already exists is returned.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddLiveAppRecordConfigRequest
     *
     * @returns AddLiveAppRecordConfigResponse
     *
     * @param AddLiveAppRecordConfigRequest $request
     *
     * @return AddLiveAppRecordConfigResponse
     */
    public function addLiveAppRecordConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveAppRecordConfigWithOptions($request, $runtime);
    }

    /**
     * Configures the snapshot feature for a streaming domain. The captured snapshots are stored in Object Storage Service (OSS). The configuration takes effect after you restart stream ingest.
     *
     * @remarks
     *   Before you call this operation, make sure that you fully understand the billing method and pricing of live stream snapshots in ApsaraVideo Live. For more information, see [Billing of live stream snapshots](https://help.aliyun.com/document_detail/195286.html).
     * *   Make sure that Object Storage Service (OSS) is activated and a specific bucket is created. This way, ApsaraVideo Live can store live stream snapshots in the bucket. For more information, see [Configure OSS](https://help.aliyun.com/document_detail/84932.html).
     * *   If you store snapshots in OSS, storage fees are generated. For more information, see [Storage fees](https://help.aliyun.com/document_detail/173534.html).
     * *   The OSS bucket must reside in the same region as the live center of the streaming domain. Cross-region snapshot capture is not supported.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddLiveAppSnapshotConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddLiveAppSnapshotConfigResponse
     *
     * @param AddLiveAppSnapshotConfigRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return AddLiveAppSnapshotConfigResponse
     */
    public function addLiveAppSnapshotConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->callback) {
            @$query['Callback'] = $request->callback;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ossBucket) {
            @$query['OssBucket'] = $request->ossBucket;
        }

        if (null !== $request->ossEndpoint) {
            @$query['OssEndpoint'] = $request->ossEndpoint;
        }

        if (null !== $request->overwriteOssObject) {
            @$query['OverwriteOssObject'] = $request->overwriteOssObject;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        if (null !== $request->sequenceOssObject) {
            @$query['SequenceOssObject'] = $request->sequenceOssObject;
        }

        if (null !== $request->timeInterval) {
            @$query['TimeInterval'] = $request->timeInterval;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveAppSnapshotConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveAppSnapshotConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures the snapshot feature for a streaming domain. The captured snapshots are stored in Object Storage Service (OSS). The configuration takes effect after you restart stream ingest.
     *
     * @remarks
     *   Before you call this operation, make sure that you fully understand the billing method and pricing of live stream snapshots in ApsaraVideo Live. For more information, see [Billing of live stream snapshots](https://help.aliyun.com/document_detail/195286.html).
     * *   Make sure that Object Storage Service (OSS) is activated and a specific bucket is created. This way, ApsaraVideo Live can store live stream snapshots in the bucket. For more information, see [Configure OSS](https://help.aliyun.com/document_detail/84932.html).
     * *   If you store snapshots in OSS, storage fees are generated. For more information, see [Storage fees](https://help.aliyun.com/document_detail/173534.html).
     * *   The OSS bucket must reside in the same region as the live center of the streaming domain. Cross-region snapshot capture is not supported.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddLiveAppSnapshotConfigRequest
     *
     * @returns AddLiveAppSnapshotConfigResponse
     *
     * @param AddLiveAppSnapshotConfigRequest $request
     *
     * @return AddLiveAppSnapshotConfigResponse
     */
    public function addLiveAppSnapshotConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveAppSnapshotConfigWithOptions($request, $runtime);
    }

    /**
     * Adds an audio moderation configuration.
     *
     * @remarks
     *   The content moderation feature detects undesirable sensitive content in the audio from live streams and returns callbacks to notify you of the violations. Then, you can manually review the content and take actions accordingly.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddLiveAudioAuditConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddLiveAudioAuditConfigResponse
     *
     * @param AddLiveAudioAuditConfigRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return AddLiveAudioAuditConfigResponse
     */
    public function addLiveAudioAuditConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->bizType) {
            @$query['BizType'] = $request->bizType;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ossBucket) {
            @$query['OssBucket'] = $request->ossBucket;
        }

        if (null !== $request->ossEndpoint) {
            @$query['OssEndpoint'] = $request->ossEndpoint;
        }

        if (null !== $request->ossObject) {
            @$query['OssObject'] = $request->ossObject;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveAudioAuditConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveAudioAuditConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds an audio moderation configuration.
     *
     * @remarks
     *   The content moderation feature detects undesirable sensitive content in the audio from live streams and returns callbacks to notify you of the violations. Then, you can manually review the content and take actions accordingly.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddLiveAudioAuditConfigRequest
     *
     * @returns AddLiveAudioAuditConfigResponse
     *
     * @param AddLiveAudioAuditConfigRequest $request
     *
     * @return AddLiveAudioAuditConfigResponse
     */
    public function addLiveAudioAuditConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveAudioAuditConfigWithOptions($request, $runtime);
    }

    /**
     * Configures callbacks for audio moderation results.
     *
     * @remarks
     *   The content moderation feature returns the audio moderation results based on the configured callback template.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddLiveAudioAuditNotifyConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddLiveAudioAuditNotifyConfigResponse
     *
     * @param AddLiveAudioAuditNotifyConfigRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return AddLiveAudioAuditNotifyConfigResponse
     */
    public function addLiveAudioAuditNotifyConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->callback) {
            @$query['Callback'] = $request->callback;
        }

        if (null !== $request->callbackTemplate) {
            @$query['CallbackTemplate'] = $request->callbackTemplate;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveAudioAuditNotifyConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveAudioAuditNotifyConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures callbacks for audio moderation results.
     *
     * @remarks
     *   The content moderation feature returns the audio moderation results based on the configured callback template.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddLiveAudioAuditNotifyConfigRequest
     *
     * @returns AddLiveAudioAuditNotifyConfigResponse
     *
     * @param AddLiveAudioAuditNotifyConfigRequest $request
     *
     * @return AddLiveAudioAuditNotifyConfigResponse
     */
    public function addLiveAudioAuditNotifyConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveAudioAuditNotifyConfigWithOptions($request, $runtime);
    }

    /**
     * Adds a configuration of live center stream relay.
     *
     * @remarks
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddLiveCenterTransferRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddLiveCenterTransferResponse
     *
     * @param AddLiveCenterTransferRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return AddLiveCenterTransferResponse
     */
    public function addLiveCenterTransferWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->dstUrl) {
            @$query['DstUrl'] = $request->dstUrl;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        if (null !== $request->transferArgs) {
            @$query['TransferArgs'] = $request->transferArgs;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveCenterTransfer',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveCenterTransferResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds a configuration of live center stream relay.
     *
     * @remarks
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddLiveCenterTransferRequest
     *
     * @returns AddLiveCenterTransferResponse
     *
     * @param AddLiveCenterTransferRequest $request
     *
     * @return AddLiveCenterTransferResponse
     */
    public function addLiveCenterTransfer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveCenterTransferWithOptions($request, $runtime);
    }

    /**
     * Configures callbacks for video moderation results. As a result, a callback URL that is used to receive the callback notifications is added.
     *
     * @remarks
     *   The automated review feature sends notifications about violations to the callback URL in real time. Then, you can manually review the content and take actions accordingly.
     * *   Only some live centers support the automated review feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
     *
     * @param request - AddLiveDetectNotifyConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddLiveDetectNotifyConfigResponse
     *
     * @param AddLiveDetectNotifyConfigRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return AddLiveDetectNotifyConfigResponse
     */
    public function addLiveDetectNotifyConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->notifyUrl) {
            @$query['NotifyUrl'] = $request->notifyUrl;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveDetectNotifyConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveDetectNotifyConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures callbacks for video moderation results. As a result, a callback URL that is used to receive the callback notifications is added.
     *
     * @remarks
     *   The automated review feature sends notifications about violations to the callback URL in real time. Then, you can manually review the content and take actions accordingly.
     * *   Only some live centers support the automated review feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
     *
     * @param request - AddLiveDetectNotifyConfigRequest
     *
     * @returns AddLiveDetectNotifyConfigResponse
     *
     * @param AddLiveDetectNotifyConfigRequest $request
     *
     * @return AddLiveDetectNotifyConfigResponse
     */
    public function addLiveDetectNotifyConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveDetectNotifyConfigWithOptions($request, $runtime);
    }

    /**
     * Adds a domain name to ApsaraVideo Live. This operation allows you to add only one domain name at a time.
     *
     * @remarks
     *   You must activate ApsaraVideo Live before you add a domain name. For more information, see [Activate ApsaraVideo Live](https://help.aliyun.com/document_detail/195292.html).
     * *   ApsaraVideo Live verifies the ownership of a new domain name that you add. After the verification is passed, the domain name is added to ApsaraVideo Live. ApsaraVideo Live allows you to use a Domain Name System (DNS) record or a verification file to verify the ownership of a domain name. For more information, see [Verify the ownership of a domain name](https://help.aliyun.com/document_detail/184466.html).
     * *   To use ApsaraVideo Live to ingest and play streams, you must add an ingest domain and a streaming domain. You can add only one domain name at a time.
     * *   After you add a domain name, you must configure a CNAME record for the domain name. For more information, see [Add a CNAME record](https://help.aliyun.com/document_detail/84929.html).
     * *   After you add an ingest domain and a streaming domain, you must associate the streaming domain with the ingest domain. For more information, see [Associate a streaming domain with an ingest domain](https://help.aliyun.com/document_detail/199338.html).
     * >  From February 19, 2019, domain names that are added by calling the AddLiveDomain operation do not support live center ingest. Domain names that are added by using Alibaba Cloud CDN also do not support live center ingest. When you call the AddLiveDomain operation, you can set the LiveDomainType parameter to liveEdge to add an ingest domain that uses edge ingest or set the LiveDomainType parameter to liveVideo to add a streaming domain. You can associate a streaming domain with an ingest domain by calling the AddLiveDomainMapping operation. Domain names added before February 19, 2019, for which live center ingest was configured, are not affected.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddLiveDomainRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddLiveDomainResponse
     *
     * @param AddLiveDomainRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return AddLiveDomainResponse
     */
    public function addLiveDomainWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->checkUrl) {
            @$query['CheckUrl'] = $request->checkUrl;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->liveDomainType) {
            @$query['LiveDomainType'] = $request->liveDomainType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->region) {
            @$query['Region'] = $request->region;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->scope) {
            @$query['Scope'] = $request->scope;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->topLevelDomain) {
            @$query['TopLevelDomain'] = $request->topLevelDomain;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveDomain',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveDomainResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds a domain name to ApsaraVideo Live. This operation allows you to add only one domain name at a time.
     *
     * @remarks
     *   You must activate ApsaraVideo Live before you add a domain name. For more information, see [Activate ApsaraVideo Live](https://help.aliyun.com/document_detail/195292.html).
     * *   ApsaraVideo Live verifies the ownership of a new domain name that you add. After the verification is passed, the domain name is added to ApsaraVideo Live. ApsaraVideo Live allows you to use a Domain Name System (DNS) record or a verification file to verify the ownership of a domain name. For more information, see [Verify the ownership of a domain name](https://help.aliyun.com/document_detail/184466.html).
     * *   To use ApsaraVideo Live to ingest and play streams, you must add an ingest domain and a streaming domain. You can add only one domain name at a time.
     * *   After you add a domain name, you must configure a CNAME record for the domain name. For more information, see [Add a CNAME record](https://help.aliyun.com/document_detail/84929.html).
     * *   After you add an ingest domain and a streaming domain, you must associate the streaming domain with the ingest domain. For more information, see [Associate a streaming domain with an ingest domain](https://help.aliyun.com/document_detail/199338.html).
     * >  From February 19, 2019, domain names that are added by calling the AddLiveDomain operation do not support live center ingest. Domain names that are added by using Alibaba Cloud CDN also do not support live center ingest. When you call the AddLiveDomain operation, you can set the LiveDomainType parameter to liveEdge to add an ingest domain that uses edge ingest or set the LiveDomainType parameter to liveVideo to add a streaming domain. You can associate a streaming domain with an ingest domain by calling the AddLiveDomainMapping operation. Domain names added before February 19, 2019, for which live center ingest was configured, are not affected.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddLiveDomainRequest
     *
     * @returns AddLiveDomainResponse
     *
     * @param AddLiveDomainRequest $request
     *
     * @return AddLiveDomainResponse
     */
    public function addLiveDomain($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveDomainWithOptions($request, $runtime);
    }

    /**
     * Creates the mapping between a streaming domain and an ingest domain.
     *
     * @remarks
     * Call the [AddLiveDomain](https://help.aliyun.com/document_detail/88327.html) operation to add a streaming domain and an ingest domain, and then call this operation to create the mapping between the two domain names.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - AddLiveDomainMappingRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddLiveDomainMappingResponse
     *
     * @param AddLiveDomainMappingRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return AddLiveDomainMappingResponse
     */
    public function addLiveDomainMappingWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pullDomain) {
            @$query['PullDomain'] = $request->pullDomain;
        }

        if (null !== $request->pushDomain) {
            @$query['PushDomain'] = $request->pushDomain;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveDomainMapping',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveDomainMappingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates the mapping between a streaming domain and an ingest domain.
     *
     * @remarks
     * Call the [AddLiveDomain](https://help.aliyun.com/document_detail/88327.html) operation to add a streaming domain and an ingest domain, and then call this operation to create the mapping between the two domain names.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - AddLiveDomainMappingRequest
     *
     * @returns AddLiveDomainMappingResponse
     *
     * @param AddLiveDomainMappingRequest $request
     *
     * @return AddLiveDomainMappingResponse
     */
    public function addLiveDomainMapping($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveDomainMappingWithOptions($request, $runtime);
    }

    /**
     * Maps a sub-streaming domain to a main streaming domain.
     *
     * @remarks
     * You can call the [AddLiveDomain](https://help.aliyun.com/document_detail/88327.html) operation to add a main streaming domain and a sub-streaming domain and then call this operation to map the sub-streaming domain to the main streaming domain.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddLiveDomainPlayMappingRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddLiveDomainPlayMappingResponse
     *
     * @param AddLiveDomainPlayMappingRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return AddLiveDomainPlayMappingResponse
     */
    public function addLiveDomainPlayMappingWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->playDomain) {
            @$query['PlayDomain'] = $request->playDomain;
        }

        if (null !== $request->pullDomain) {
            @$query['PullDomain'] = $request->pullDomain;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveDomainPlayMapping',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveDomainPlayMappingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Maps a sub-streaming domain to a main streaming domain.
     *
     * @remarks
     * You can call the [AddLiveDomain](https://help.aliyun.com/document_detail/88327.html) operation to add a main streaming domain and a sub-streaming domain and then call this operation to map the sub-streaming domain to the main streaming domain.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddLiveDomainPlayMappingRequest
     *
     * @returns AddLiveDomainPlayMappingResponse
     *
     * @param AddLiveDomainPlayMappingRequest $request
     *
     * @return AddLiveDomainPlayMappingResponse
     */
    public function addLiveDomainPlayMapping($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveDomainPlayMappingWithOptions($request, $runtime);
    }

    /**
     * Mutes one or more users.
     *
     * @remarks
     * Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param tmpReq - AddLiveMessageGroupBandRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddLiveMessageGroupBandResponse
     *
     * @param AddLiveMessageGroupBandRequest $tmpReq
     * @param RuntimeOptions                 $runtime
     *
     * @return AddLiveMessageGroupBandResponse
     */
    public function addLiveMessageGroupBandWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new AddLiveMessageGroupBandShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->bannedUsers) {
            $request->bannedUsersShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->bannedUsers, 'BannedUsers', 'simple');
        }

        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->bannedUsersShrink) {
            @$query['BannedUsers'] = $request->bannedUsersShrink;
        }

        if (null !== $request->dataCenter) {
            @$query['DataCenter'] = $request->dataCenter;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveMessageGroupBand',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveMessageGroupBandResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Mutes one or more users.
     *
     * @remarks
     * Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddLiveMessageGroupBandRequest
     *
     * @returns AddLiveMessageGroupBandResponse
     *
     * @param AddLiveMessageGroupBandRequest $request
     *
     * @return AddLiveMessageGroupBandResponse
     */
    public function addLiveMessageGroupBand($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveMessageGroupBandWithOptions($request, $runtime);
    }

    /**
     * Adds a live stream encapsulation configuration.
     *
     * @remarks
     *   The first time you configure encapsulation for a domain name, domain acceleration is automatically configured and takes effect in 3 to 5 minutes.
     * *   If the streaming domain resides in a region outside China, including Singapore, Germany (Frankfurt), Japan (Tokyo), and Indonesia (Jakarta), you may encounter high latency issues. We recommend that you test and verify whether the settings meet expectations.
     * *   You can call this operation to add a live stream encapsulation configuration. The configuration takes effect only after you re-ingest the stream.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddLivePackageConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddLivePackageConfigResponse
     *
     * @param AddLivePackageConfigRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return AddLivePackageConfigResponse
     */
    public function addLivePackageConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ignoreTranscode) {
            @$query['IgnoreTranscode'] = $request->ignoreTranscode;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->partDuration) {
            @$query['PartDuration'] = $request->partDuration;
        }

        if (null !== $request->protocol) {
            @$query['Protocol'] = $request->protocol;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->segmentDuration) {
            @$query['SegmentDuration'] = $request->segmentDuration;
        }

        if (null !== $request->segmentNum) {
            @$query['SegmentNum'] = $request->segmentNum;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLivePackageConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLivePackageConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds a live stream encapsulation configuration.
     *
     * @remarks
     *   The first time you configure encapsulation for a domain name, domain acceleration is automatically configured and takes effect in 3 to 5 minutes.
     * *   If the streaming domain resides in a region outside China, including Singapore, Germany (Frankfurt), Japan (Tokyo), and Indonesia (Jakarta), you may encounter high latency issues. We recommend that you test and verify whether the settings meet expectations.
     * *   You can call this operation to add a live stream encapsulation configuration. The configuration takes effect only after you re-ingest the stream.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddLivePackageConfigRequest
     *
     * @returns AddLivePackageConfigResponse
     *
     * @param AddLivePackageConfigRequest $request
     *
     * @return AddLivePackageConfigResponse
     */
    public function addLivePackageConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLivePackageConfigWithOptions($request, $runtime);
    }

    /**
     * Creates a stream pulling configuration for a live stream, which includes parameters such as the origin URL, start time, and end time.
     *
     * @remarks
     *   Before you call this operation, make sure that you fully understand the billing method and pricing of stream pulling in ApsaraVideo Live. For more information, see [Billing of standard streaming](https://help.aliyun.com/document_detail/195284.html).
     * *   Stream pulling refers to the process of pulling live streams from third-party streaming URLs to a live center of ApsaraVideo Live for CDN acceleration.
     * *   You can call this operation only for regular stream pulling. That is, you can specify the start time and end time to pull live streams.
     * *   Regular stream pulling and triggered stream pulling are supported in the ApsaraVideo Live console. For more information, see [Configure stream pulling](https://help.aliyun.com/document_detail/199452.html).
     * *   You can specify custom values for the AppName and StreamName parameters. Streaming URLs that are generated vary based on different values of the AppName and StreamName parameters. You can use the [URL generator](https://help.aliyun.com/document_detail/197400.html) to generate a streaming URL.
     * *   A configuration is identified by the DomainName, AppName, and StreamName parameters all together. If you try to call this operation to add a configuration that has the same DomainName, AppName, and StreamName parameters as an existing configuration, an error indicating that the configuration already exists is returned.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddLivePullStreamInfoConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddLivePullStreamInfoConfigResponse
     *
     * @param AddLivePullStreamInfoConfigRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return AddLivePullStreamInfoConfigResponse
     */
    public function addLivePullStreamInfoConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->sourceUrl) {
            @$query['SourceUrl'] = $request->sourceUrl;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLivePullStreamInfoConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLivePullStreamInfoConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a stream pulling configuration for a live stream, which includes parameters such as the origin URL, start time, and end time.
     *
     * @remarks
     *   Before you call this operation, make sure that you fully understand the billing method and pricing of stream pulling in ApsaraVideo Live. For more information, see [Billing of standard streaming](https://help.aliyun.com/document_detail/195284.html).
     * *   Stream pulling refers to the process of pulling live streams from third-party streaming URLs to a live center of ApsaraVideo Live for CDN acceleration.
     * *   You can call this operation only for regular stream pulling. That is, you can specify the start time and end time to pull live streams.
     * *   Regular stream pulling and triggered stream pulling are supported in the ApsaraVideo Live console. For more information, see [Configure stream pulling](https://help.aliyun.com/document_detail/199452.html).
     * *   You can specify custom values for the AppName and StreamName parameters. Streaming URLs that are generated vary based on different values of the AppName and StreamName parameters. You can use the [URL generator](https://help.aliyun.com/document_detail/197400.html) to generate a streaming URL.
     * *   A configuration is identified by the DomainName, AppName, and StreamName parameters all together. If you try to call this operation to add a configuration that has the same DomainName, AppName, and StreamName parameters as an existing configuration, an error indicating that the configuration already exists is returned.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddLivePullStreamInfoConfigRequest
     *
     * @returns AddLivePullStreamInfoConfigResponse
     *
     * @param AddLivePullStreamInfoConfigRequest $request
     *
     * @return AddLivePullStreamInfoConfigResponse
     */
    public function addLivePullStreamInfoConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLivePullStreamInfoConfigWithOptions($request, $runtime);
    }

    /**
     * Configures recording callbacks for a domain name.
     *
     * @remarks
     * Before you call this operation to configure recording callbacks for a domain name, you can query whether the domain name already has recording callbacks configured. For more information, see [DescribeLiveRecordNotifyConfig](https://help.aliyun.com/document_detail/2847893.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddLiveRecordNotifyConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddLiveRecordNotifyConfigResponse
     *
     * @param AddLiveRecordNotifyConfigRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return AddLiveRecordNotifyConfigResponse
     */
    public function addLiveRecordNotifyConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->needStatusNotify) {
            @$query['NeedStatusNotify'] = $request->needStatusNotify;
        }

        if (null !== $request->notifyUrl) {
            @$query['NotifyUrl'] = $request->notifyUrl;
        }

        if (null !== $request->onDemandUrl) {
            @$query['OnDemandUrl'] = $request->onDemandUrl;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveRecordNotifyConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveRecordNotifyConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures recording callbacks for a domain name.
     *
     * @remarks
     * Before you call this operation to configure recording callbacks for a domain name, you can query whether the domain name already has recording callbacks configured. For more information, see [DescribeLiveRecordNotifyConfig](https://help.aliyun.com/document_detail/2847893.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddLiveRecordNotifyConfigRequest
     *
     * @returns AddLiveRecordNotifyConfigResponse
     *
     * @param AddLiveRecordNotifyConfigRequest $request
     *
     * @return AddLiveRecordNotifyConfigResponse
     */
    public function addLiveRecordNotifyConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveRecordNotifyConfigWithOptions($request, $runtime);
    }

    /**
     * Adds a Live-to-VOD configuration to store recordings in the media library of ApsaraVideo VOD.
     *
     * @remarks
     * You can call this operation to configure the Live-to-VOD feature to store recordings in the media library of ApsaraVideo VOD.
     * >  You cannot configure the Live-to-VOD feature by using a Finance Cloud account.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddLiveRecordVodConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddLiveRecordVodConfigResponse
     *
     * @param AddLiveRecordVodConfigRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return AddLiveRecordVodConfigResponse
     */
    public function addLiveRecordVodConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->autoCompose) {
            @$query['AutoCompose'] = $request->autoCompose;
        }

        if (null !== $request->composeVodTranscodeGroupId) {
            @$query['ComposeVodTranscodeGroupId'] = $request->composeVodTranscodeGroupId;
        }

        if (null !== $request->cycleDuration) {
            @$query['CycleDuration'] = $request->cycleDuration;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->onDemand) {
            @$query['OnDemand'] = $request->onDemand;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->storageLocation) {
            @$query['StorageLocation'] = $request->storageLocation;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        if (null !== $request->vodTranscodeGroupId) {
            @$query['VodTranscodeGroupId'] = $request->vodTranscodeGroupId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveRecordVodConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveRecordVodConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds a Live-to-VOD configuration to store recordings in the media library of ApsaraVideo VOD.
     *
     * @remarks
     * You can call this operation to configure the Live-to-VOD feature to store recordings in the media library of ApsaraVideo VOD.
     * >  You cannot configure the Live-to-VOD feature by using a Finance Cloud account.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddLiveRecordVodConfigRequest
     *
     * @returns AddLiveRecordVodConfigResponse
     *
     * @param AddLiveRecordVodConfigRequest $request
     *
     * @return AddLiveRecordVodConfigResponse
     */
    public function addLiveRecordVodConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveRecordVodConfigWithOptions($request, $runtime);
    }

    /**
     * Adds a video moderation configuration for live streams in an application under a domain name.
     *
     * @remarks
     * - The live streaming audit function identifies and reviews违规sensitive content at the domain and App level, and promptly notifies users of such violations via callbacks. Users can then review the content and take appropriate actions.
     * - Currently, only some live streaming centers support intelligent auditing. For a list of live streaming centers that support this feature, please refer to [Service Regions](https://help.aliyun.com/document_detail/193730.html).
     * ## QPS Limitation
     * The QPS limit for this API per user is 30 requests/second. Exceeding this limit will result in API throttling, which may impact your services. Please use the API judiciously. For more information, see [QPS Limitations](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - AddLiveSnapshotDetectPornConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddLiveSnapshotDetectPornConfigResponse
     *
     * @param AddLiveSnapshotDetectPornConfigRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return AddLiveSnapshotDetectPornConfigResponse
     */
    public function addLiveSnapshotDetectPornConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->interval) {
            @$query['Interval'] = $request->interval;
        }

        if (null !== $request->ossBucket) {
            @$query['OssBucket'] = $request->ossBucket;
        }

        if (null !== $request->ossEndpoint) {
            @$query['OssEndpoint'] = $request->ossEndpoint;
        }

        if (null !== $request->ossObject) {
            @$query['OssObject'] = $request->ossObject;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->scene) {
            @$query['Scene'] = $request->scene;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveSnapshotDetectPornConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveSnapshotDetectPornConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds a video moderation configuration for live streams in an application under a domain name.
     *
     * @remarks
     * - The live streaming audit function identifies and reviews违规sensitive content at the domain and App level, and promptly notifies users of such violations via callbacks. Users can then review the content and take appropriate actions.
     * - Currently, only some live streaming centers support intelligent auditing. For a list of live streaming centers that support this feature, please refer to [Service Regions](https://help.aliyun.com/document_detail/193730.html).
     * ## QPS Limitation
     * The QPS limit for this API per user is 30 requests/second. Exceeding this limit will result in API throttling, which may impact your services. Please use the API judiciously. For more information, see [QPS Limitations](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - AddLiveSnapshotDetectPornConfigRequest
     *
     * @returns AddLiveSnapshotDetectPornConfigResponse
     *
     * @param AddLiveSnapshotDetectPornConfigRequest $request
     *
     * @return AddLiveSnapshotDetectPornConfigResponse
     */
    public function addLiveSnapshotDetectPornConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveSnapshotDetectPornConfigWithOptions($request, $runtime);
    }

    /**
     * Configures snapshot callbacks.
     *
     * @remarks
     * ### QPS Limit
     * The QPS limit for this API per user is 30 times/second. Exceeding this limit will result in API calls being throttled, which may impact your business operations. Please use the API reasonably. For more information, please refer to [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - AddLiveSnapshotNotifyConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddLiveSnapshotNotifyConfigResponse
     *
     * @param AddLiveSnapshotNotifyConfigRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return AddLiveSnapshotNotifyConfigResponse
     */
    public function addLiveSnapshotNotifyConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->notifyAuthKey) {
            @$query['NotifyAuthKey'] = $request->notifyAuthKey;
        }

        if (null !== $request->notifyReqAuth) {
            @$query['NotifyReqAuth'] = $request->notifyReqAuth;
        }

        if (null !== $request->notifyUrl) {
            @$query['NotifyUrl'] = $request->notifyUrl;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveSnapshotNotifyConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveSnapshotNotifyConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures snapshot callbacks.
     *
     * @remarks
     * ### QPS Limit
     * The QPS limit for this API per user is 30 times/second. Exceeding this limit will result in API calls being throttled, which may impact your business operations. Please use the API reasonably. For more information, please refer to [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - AddLiveSnapshotNotifyConfigRequest
     *
     * @returns AddLiveSnapshotNotifyConfigResponse
     *
     * @param AddLiveSnapshotNotifyConfigRequest $request
     *
     * @return AddLiveSnapshotNotifyConfigResponse
     */
    public function addLiveSnapshotNotifyConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveSnapshotNotifyConfigWithOptions($request, $runtime);
    }

    /**
     * Invoke AddLiveStreamMerge to add primary and backup stream merging configuration.
     *
     * @remarks
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddLiveStreamMergeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddLiveStreamMergeResponse
     *
     * @param AddLiveStreamMergeRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return AddLiveStreamMergeResponse
     */
    public function addLiveStreamMergeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->inAppName1) {
            @$query['InAppName1'] = $request->inAppName1;
        }

        if (null !== $request->inAppName2) {
            @$query['InAppName2'] = $request->inAppName2;
        }

        if (null !== $request->inStreamName1) {
            @$query['InStreamName1'] = $request->inStreamName1;
        }

        if (null !== $request->inStreamName2) {
            @$query['InStreamName2'] = $request->inStreamName2;
        }

        if (null !== $request->liveMerger) {
            @$query['LiveMerger'] = $request->liveMerger;
        }

        if (null !== $request->mergeParameters) {
            @$query['MergeParameters'] = $request->mergeParameters;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->protocol) {
            @$query['Protocol'] = $request->protocol;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveStreamMerge',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveStreamMergeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Invoke AddLiveStreamMerge to add primary and backup stream merging configuration.
     *
     * @remarks
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddLiveStreamMergeRequest
     *
     * @returns AddLiveStreamMergeResponse
     *
     * @param AddLiveStreamMergeRequest $request
     *
     * @return AddLiveStreamMergeResponse
     */
    public function addLiveStreamMerge($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveStreamMergeWithOptions($request, $runtime);
    }

    /**
     * Adds transcoding configurations for a streaming domain.
     *
     * @remarks
     * You must obtain the customer master key (CMK) in Key Management Service (KMS) before you call this operation to add transcoding configurations. Only standard transcoding templates and Narrowband HD™ transcoding templates are supported for this operation.
     * ## QPS limits
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
     *
     * @param request - AddLiveStreamTranscodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddLiveStreamTranscodeResponse
     *
     * @param AddLiveStreamTranscodeRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return AddLiveStreamTranscodeResponse
     */
    public function addLiveStreamTranscodeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->app) {
            @$query['App'] = $request->app;
        }

        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->encryptParameters) {
            @$query['EncryptParameters'] = $request->encryptParameters;
        }

        if (null !== $request->lazy) {
            @$query['Lazy'] = $request->lazy;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->template) {
            @$query['Template'] = $request->template;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveStreamTranscode',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveStreamTranscodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds transcoding configurations for a streaming domain.
     *
     * @remarks
     * You must obtain the customer master key (CMK) in Key Management Service (KMS) before you call this operation to add transcoding configurations. Only standard transcoding templates and Narrowband HD™ transcoding templates are supported for this operation.
     * ## QPS limits
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
     *
     * @param request - AddLiveStreamTranscodeRequest
     *
     * @returns AddLiveStreamTranscodeResponse
     *
     * @param AddLiveStreamTranscodeRequest $request
     *
     * @return AddLiveStreamTranscodeResponse
     */
    public function addLiveStreamTranscode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveStreamTranscodeWithOptions($request, $runtime);
    }

    /**
     * Creates a watermark template.
     *
     * @remarks
     *   You can call this operation to create a watermark template and configure information such as the watermark content and layout in the template.
     * *   After you create a watermark template, you must also call the [AddLiveStreamWatermarkRule](https://help.aliyun.com/document_detail/2848100.html) operation to add a watermark rule. A live stream in progress can contain the watermark only after the stream is re-ingested.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddLiveStreamWatermarkRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddLiveStreamWatermarkResponse
     *
     * @param AddLiveStreamWatermarkRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return AddLiveStreamWatermarkResponse
     */
    public function addLiveStreamWatermarkWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->height) {
            @$query['Height'] = $request->height;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->offsetCorner) {
            @$query['OffsetCorner'] = $request->offsetCorner;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pictureUrl) {
            @$query['PictureUrl'] = $request->pictureUrl;
        }

        if (null !== $request->refHeight) {
            @$query['RefHeight'] = $request->refHeight;
        }

        if (null !== $request->refWidth) {
            @$query['RefWidth'] = $request->refWidth;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->transparency) {
            @$query['Transparency'] = $request->transparency;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        if (null !== $request->XOffset) {
            @$query['XOffset'] = $request->XOffset;
        }

        if (null !== $request->YOffset) {
            @$query['YOffset'] = $request->YOffset;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveStreamWatermark',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveStreamWatermarkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a watermark template.
     *
     * @remarks
     *   You can call this operation to create a watermark template and configure information such as the watermark content and layout in the template.
     * *   After you create a watermark template, you must also call the [AddLiveStreamWatermarkRule](https://help.aliyun.com/document_detail/2848100.html) operation to add a watermark rule. A live stream in progress can contain the watermark only after the stream is re-ingested.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddLiveStreamWatermarkRequest
     *
     * @returns AddLiveStreamWatermarkResponse
     *
     * @param AddLiveStreamWatermarkRequest $request
     *
     * @return AddLiveStreamWatermarkResponse
     */
    public function addLiveStreamWatermark($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveStreamWatermarkWithOptions($request, $runtime);
    }

    /**
     * Adds a watermark rule.
     *
     * @remarks
     * After calling the [AddLiveStreamWatermark](https://help.aliyun.com/document_detail/469416.html) API to add a watermark template, you can use this interface to add watermark rules.
     * ## QPS Limit
     *  The QPS limit for this interface per user is 60 times/second. Exceeding the limit will result in API calls being throttled, which may impact your business. Please use it reasonably. For more information, see [QPS Limit](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - AddLiveStreamWatermarkRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddLiveStreamWatermarkRuleResponse
     *
     * @param AddLiveStreamWatermarkRuleRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return AddLiveStreamWatermarkRuleResponse
     */
    public function addLiveStreamWatermarkRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->app) {
            @$query['App'] = $request->app;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->stream) {
            @$query['Stream'] = $request->stream;
        }

        if (null !== $request->templateId) {
            @$query['TemplateId'] = $request->templateId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddLiveStreamWatermarkRule',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddLiveStreamWatermarkRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds a watermark rule.
     *
     * @remarks
     * After calling the [AddLiveStreamWatermark](https://help.aliyun.com/document_detail/469416.html) API to add a watermark template, you can use this interface to add watermark rules.
     * ## QPS Limit
     *  The QPS limit for this interface per user is 60 times/second. Exceeding the limit will result in API calls being throttled, which may impact your business. Please use it reasonably. For more information, see [QPS Limit](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - AddLiveStreamWatermarkRuleRequest
     *
     * @returns AddLiveStreamWatermarkRuleResponse
     *
     * @param AddLiveStreamWatermarkRuleRequest $request
     *
     * @return AddLiveStreamWatermarkRuleResponse
     */
    public function addLiveStreamWatermarkRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addLiveStreamWatermarkRuleWithOptions($request, $runtime);
    }

    /**
     * Adds episodes to an episode list.
     *
     * @remarks
     * Create a production studio, add a layout and components to the production studio, and then call this operation to add episodes. If no episode list exists in the production studio, this operation creates an episode list for the production studio. For more information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddPlaylistItemsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddPlaylistItemsResponse
     *
     * @param AddPlaylistItemsRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return AddPlaylistItemsResponse
     */
    public function addPlaylistItemsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->programConfig) {
            @$query['ProgramConfig'] = $request->programConfig;
        }

        if (null !== $request->programId) {
            @$query['ProgramId'] = $request->programId;
        }

        if (null !== $request->programItems) {
            @$query['ProgramItems'] = $request->programItems;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddPlaylistItems',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddPlaylistItemsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds episodes to an episode list.
     *
     * @remarks
     * Create a production studio, add a layout and components to the production studio, and then call this operation to add episodes. If no episode list exists in the production studio, this operation creates an episode list for the production studio. For more information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddPlaylistItemsRequest
     *
     * @returns AddPlaylistItemsResponse
     *
     * @param AddPlaylistItemsRequest $request
     *
     * @return AddPlaylistItemsResponse
     */
    public function addPlaylistItems($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addPlaylistItemsWithOptions($request, $runtime);
    }

    /**
     * Creates a Real-Time Streaming (RTS) transcoding configuration for a streaming domain.
     *
     * @remarks
     * You can call this operation to add an RTS transcoding configuration. This operation supports four template types: h264, h264-nbhd, h264-origin, and audio.
     * ## QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - AddRtsLiveStreamTranscodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddRtsLiveStreamTranscodeResponse
     *
     * @param AddRtsLiveStreamTranscodeRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return AddRtsLiveStreamTranscodeResponse
     */
    public function addRtsLiveStreamTranscodeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->app) {
            @$query['App'] = $request->app;
        }

        if (null !== $request->audioBitrate) {
            @$query['AudioBitrate'] = $request->audioBitrate;
        }

        if (null !== $request->audioChannelNum) {
            @$query['AudioChannelNum'] = $request->audioChannelNum;
        }

        if (null !== $request->audioCodec) {
            @$query['AudioCodec'] = $request->audioCodec;
        }

        if (null !== $request->audioProfile) {
            @$query['AudioProfile'] = $request->audioProfile;
        }

        if (null !== $request->audioRate) {
            @$query['AudioRate'] = $request->audioRate;
        }

        if (null !== $request->deleteBframes) {
            @$query['DeleteBframes'] = $request->deleteBframes;
        }

        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->FPS) {
            @$query['FPS'] = $request->FPS;
        }

        if (null !== $request->gop) {
            @$query['Gop'] = $request->gop;
        }

        if (null !== $request->height) {
            @$query['Height'] = $request->height;
        }

        if (null !== $request->lazy) {
            @$query['Lazy'] = $request->lazy;
        }

        if (null !== $request->opus) {
            @$query['Opus'] = $request->opus;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->profile) {
            @$query['Profile'] = $request->profile;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->template) {
            @$query['Template'] = $request->template;
        }

        if (null !== $request->templateType) {
            @$query['TemplateType'] = $request->templateType;
        }

        if (null !== $request->videoBitrate) {
            @$query['VideoBitrate'] = $request->videoBitrate;
        }

        if (null !== $request->width) {
            @$query['Width'] = $request->width;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddRtsLiveStreamTranscode',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddRtsLiveStreamTranscodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a Real-Time Streaming (RTS) transcoding configuration for a streaming domain.
     *
     * @remarks
     * You can call this operation to add an RTS transcoding configuration. This operation supports four template types: h264, h264-nbhd, h264-origin, and audio.
     * ## QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - AddRtsLiveStreamTranscodeRequest
     *
     * @returns AddRtsLiveStreamTranscodeResponse
     *
     * @param AddRtsLiveStreamTranscodeRequest $request
     *
     * @return AddRtsLiveStreamTranscodeResponse
     */
    public function addRtsLiveStreamTranscode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addRtsLiveStreamTranscodeWithOptions($request, $runtime);
    }

    /**
     * Adds an episode to an episode list.
     *
     * @remarks
     * You must create a production studio in the new playlist mode and add media resources to the production studio before you can call this operation. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
     * You can add up to 1,000 episodes to an episode list.
     * >
     * *   When you select media resources from ApsaraVideo VOD, we recommend that you select resources that are stored in hosted OSS buckets. Resources stored in non-hosted OSS buckets have a validity period. Pay attention to the validity if you select resources that are stored in non-hosted OSS buckets.
     * *   When you add media resources to a production studio, we recommend that you select resources from ApsaraVideo Live and ApsaraVideo VOD. If you add a third-party stream by specifying a streaming URL, there is a possibility that the stream fails to be played. You must pay attention to the quality and validity of the third-party stream.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddShowIntoShowListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddShowIntoShowListResponse
     *
     * @param AddShowIntoShowListRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return AddShowIntoShowListResponse
     */
    public function addShowIntoShowListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->duration) {
            @$query['Duration'] = $request->duration;
        }

        if (null !== $request->liveInputType) {
            @$query['LiveInputType'] = $request->liveInputType;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->repeatTimes) {
            @$query['RepeatTimes'] = $request->repeatTimes;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        if (null !== $request->resourceUrl) {
            @$query['ResourceUrl'] = $request->resourceUrl;
        }

        if (null !== $request->showName) {
            @$query['ShowName'] = $request->showName;
        }

        if (null !== $request->spot) {
            @$query['Spot'] = $request->spot;
        }

        if (null !== $request->isBatchMode) {
            @$query['isBatchMode'] = $request->isBatchMode;
        }

        if (null !== $request->showList) {
            @$query['showList'] = $request->showList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddShowIntoShowList',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddShowIntoShowListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds an episode to an episode list.
     *
     * @remarks
     * You must create a production studio in the new playlist mode and add media resources to the production studio before you can call this operation. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
     * You can add up to 1,000 episodes to an episode list.
     * >
     * *   When you select media resources from ApsaraVideo VOD, we recommend that you select resources that are stored in hosted OSS buckets. Resources stored in non-hosted OSS buckets have a validity period. Pay attention to the validity if you select resources that are stored in non-hosted OSS buckets.
     * *   When you add media resources to a production studio, we recommend that you select resources from ApsaraVideo Live and ApsaraVideo VOD. If you add a third-party stream by specifying a streaming URL, there is a possibility that the stream fails to be played. You must pay attention to the quality and validity of the third-party stream.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddShowIntoShowListRequest
     *
     * @returns AddShowIntoShowListResponse
     *
     * @param AddShowIntoShowListRequest $request
     *
     * @return AddShowIntoShowListResponse
     */
    public function addShowIntoShowList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addShowIntoShowListWithOptions($request, $runtime);
    }

    /**
     * Configures a layout for a virtual studio.
     *
     * @remarks
     * You can call this operation to configure a common layout or a studio layout for a virtual studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddStudioLayoutRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddStudioLayoutResponse
     *
     * @param AddStudioLayoutRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return AddStudioLayoutResponse
     */
    public function addStudioLayoutWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bgImageConfig) {
            @$query['BgImageConfig'] = $request->bgImageConfig;
        }

        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->commonConfig) {
            @$query['CommonConfig'] = $request->commonConfig;
        }

        if (null !== $request->layerOrderConfigList) {
            @$query['LayerOrderConfigList'] = $request->layerOrderConfigList;
        }

        if (null !== $request->layoutName) {
            @$query['LayoutName'] = $request->layoutName;
        }

        if (null !== $request->layoutType) {
            @$query['LayoutType'] = $request->layoutType;
        }

        if (null !== $request->mediaInputConfigList) {
            @$query['MediaInputConfigList'] = $request->mediaInputConfigList;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->screenInputConfigList) {
            @$query['ScreenInputConfigList'] = $request->screenInputConfigList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddStudioLayout',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddStudioLayoutResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures a layout for a virtual studio.
     *
     * @remarks
     * You can call this operation to configure a common layout or a studio layout for a virtual studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddStudioLayoutRequest
     *
     * @returns AddStudioLayoutResponse
     *
     * @param AddStudioLayoutRequest $request
     *
     * @return AddStudioLayoutResponse
     */
    public function addStudioLayout($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addStudioLayoutWithOptions($request, $runtime);
    }

    /**
     * Inserts supplemental enhancement information (SEI) to transcoded streams.
     *
     * @remarks
     * Obtain the streaming domain, and then call this operation to insert SEI to the transcoded streams. Make sure that the stream name is the name of the source stream. This way, the SEI is inserted to all the transcoded streams.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddTrancodeSEIRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddTrancodeSEIResponse
     *
     * @param AddTrancodeSEIRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return AddTrancodeSEIResponse
     */
    public function addTrancodeSEIWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->delay) {
            @$query['Delay'] = $request->delay;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pattern) {
            @$query['Pattern'] = $request->pattern;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->repeat) {
            @$query['Repeat'] = $request->repeat;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        if (null !== $request->text) {
            @$query['Text'] = $request->text;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddTrancodeSEI',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddTrancodeSEIResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Inserts supplemental enhancement information (SEI) to transcoded streams.
     *
     * @remarks
     * Obtain the streaming domain, and then call this operation to insert SEI to the transcoded streams. Make sure that the stream name is the name of the source stream. This way, the SEI is inserted to all the transcoded streams.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - AddTrancodeSEIRequest
     *
     * @returns AddTrancodeSEIResponse
     *
     * @param AddTrancodeSEIRequest $request
     *
     * @return AddTrancodeSEIResponse
     */
    public function addTrancodeSEI($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addTrancodeSEIWithOptions($request, $runtime);
    }

    /**
     * Mutes a group.
     *
     * @remarks
     * Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param tmpReq - BanLiveMessageGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns BanLiveMessageGroupResponse
     *
     * @param BanLiveMessageGroupRequest $tmpReq
     * @param RuntimeOptions             $runtime
     *
     * @return BanLiveMessageGroupResponse
     */
    public function banLiveMessageGroupWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new BanLiveMessageGroupShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->exceptUsers) {
            $request->exceptUsersShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->exceptUsers, 'ExceptUsers', 'simple');
        }

        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->dataCenter) {
            @$query['DataCenter'] = $request->dataCenter;
        }

        if (null !== $request->exceptUsersShrink) {
            @$query['ExceptUsers'] = $request->exceptUsersShrink;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'BanLiveMessageGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return BanLiveMessageGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Mutes a group.
     *
     * @remarks
     * Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - BanLiveMessageGroupRequest
     *
     * @returns BanLiveMessageGroupResponse
     *
     * @param BanLiveMessageGroupRequest $request
     *
     * @return BanLiveMessageGroupResponse
     */
    public function banLiveMessageGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->banLiveMessageGroupWithOptions($request, $runtime);
    }

    /**
     * Deletes the configurations of multiple domain names at a time.
     *
     * @remarks
     * Obtain the domain names for which you want to delete the configurations, and then call this operation to delete the configurations of these domain domains at a time.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - BatchDeleteLiveDomainConfigsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns BatchDeleteLiveDomainConfigsResponse
     *
     * @param BatchDeleteLiveDomainConfigsRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return BatchDeleteLiveDomainConfigsResponse
     */
    public function batchDeleteLiveDomainConfigsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainNames) {
            @$query['DomainNames'] = $request->domainNames;
        }

        if (null !== $request->functionNames) {
            @$query['FunctionNames'] = $request->functionNames;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'BatchDeleteLiveDomainConfigs',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return BatchDeleteLiveDomainConfigsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the configurations of multiple domain names at a time.
     *
     * @remarks
     * Obtain the domain names for which you want to delete the configurations, and then call this operation to delete the configurations of these domain domains at a time.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - BatchDeleteLiveDomainConfigsRequest
     *
     * @returns BatchDeleteLiveDomainConfigsResponse
     *
     * @param BatchDeleteLiveDomainConfigsRequest $request
     *
     * @return BatchDeleteLiveDomainConfigsResponse
     */
    public function batchDeleteLiveDomainConfigs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->batchDeleteLiveDomainConfigsWithOptions($request, $runtime);
    }

    /**
     * 根据一个或多个用户uid查询用户是否在线
     *
     * @remarks
     * ## Usage notes
     * You can query whether up to 20 users are online at a time.
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - BatchGetOnlineUsersRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns BatchGetOnlineUsersResponse
     *
     * @param BatchGetOnlineUsersRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return BatchGetOnlineUsersResponse
     */
    public function batchGetOnlineUsersWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->appId) {
            @$body['AppId'] = $request->appId;
        }

        if (null !== $request->groupId) {
            @$body['GroupId'] = $request->groupId;
        }

        if (null !== $request->userIds) {
            @$body['UserIds'] = $request->userIds;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'BatchGetOnlineUsers',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return BatchGetOnlineUsersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 根据一个或多个用户uid查询用户是否在线
     *
     * @remarks
     * ## Usage notes
     * You can query whether up to 20 users are online at a time.
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - BatchGetOnlineUsersRequest
     *
     * @returns BatchGetOnlineUsersResponse
     *
     * @param BatchGetOnlineUsersRequest $request
     *
     * @return BatchGetOnlineUsersResponse
     */
    public function batchGetOnlineUsers($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->batchGetOnlineUsersWithOptions($request, $runtime);
    }

    /**
     * Configures multiple domain names at a time.
     *
     * @remarks
     * Obtain the domain names that you want to configure, and then call this operation to configure the domain names in batches.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - BatchSetLiveDomainConfigsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns BatchSetLiveDomainConfigsResponse
     *
     * @param BatchSetLiveDomainConfigsRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return BatchSetLiveDomainConfigsResponse
     */
    public function batchSetLiveDomainConfigsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainNames) {
            @$query['DomainNames'] = $request->domainNames;
        }

        if (null !== $request->functions) {
            @$query['Functions'] = $request->functions;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'BatchSetLiveDomainConfigs',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return BatchSetLiveDomainConfigsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures multiple domain names at a time.
     *
     * @remarks
     * Obtain the domain names that you want to configure, and then call this operation to configure the domain names in batches.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - BatchSetLiveDomainConfigsRequest
     *
     * @returns BatchSetLiveDomainConfigsResponse
     *
     * @param BatchSetLiveDomainConfigsRequest $request
     *
     * @return BatchSetLiveDomainConfigsResponse
     */
    public function batchSetLiveDomainConfigs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->batchSetLiveDomainConfigsWithOptions($request, $runtime);
    }

    /**
     * Unmutes a message group.
     *
     * @remarks
     * ## QPS限制
     * 本接口的单用户QPS限制为100次/秒。超过限制，API调用会被限流，这可能会影响您的业务，请合理调用。更多信息，请参见[QPS限制](https://help.aliyun.com/document_detail/343507.html)。
     *
     * @param request - CancelMuteAllGroupUserRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CancelMuteAllGroupUserResponse
     *
     * @param CancelMuteAllGroupUserRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return CancelMuteAllGroupUserResponse
     */
    public function cancelMuteAllGroupUserWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->appId) {
            @$body['AppId'] = $request->appId;
        }

        if (null !== $request->broadCastType) {
            @$body['BroadCastType'] = $request->broadCastType;
        }

        if (null !== $request->groupId) {
            @$body['GroupId'] = $request->groupId;
        }

        if (null !== $request->operatorUserId) {
            @$body['OperatorUserId'] = $request->operatorUserId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CancelMuteAllGroupUser',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CancelMuteAllGroupUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Unmutes a message group.
     *
     * @remarks
     * ## QPS限制
     * 本接口的单用户QPS限制为100次/秒。超过限制，API调用会被限流，这可能会影响您的业务，请合理调用。更多信息，请参见[QPS限制](https://help.aliyun.com/document_detail/343507.html)。
     *
     * @param request - CancelMuteAllGroupUserRequest
     *
     * @returns CancelMuteAllGroupUserResponse
     *
     * @param CancelMuteAllGroupUserRequest $request
     *
     * @return CancelMuteAllGroupUserResponse
     */
    public function cancelMuteAllGroupUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->cancelMuteAllGroupUserWithOptions($request, $runtime);
    }

    /**
     * Unmutes members in a message group.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param tmpReq - CancelMuteGroupUserRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CancelMuteGroupUserResponse
     *
     * @param CancelMuteGroupUserRequest $tmpReq
     * @param RuntimeOptions             $runtime
     *
     * @return CancelMuteGroupUserResponse
     */
    public function cancelMuteGroupUserWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new CancelMuteGroupUserShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->cancelMuteUserList) {
            $request->cancelMuteUserListShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->cancelMuteUserList, 'CancelMuteUserList', 'simple');
        }

        $body = [];
        if (null !== $request->appId) {
            @$body['AppId'] = $request->appId;
        }

        if (null !== $request->broadCastType) {
            @$body['BroadCastType'] = $request->broadCastType;
        }

        if (null !== $request->cancelMuteUserListShrink) {
            @$body['CancelMuteUserList'] = $request->cancelMuteUserListShrink;
        }

        if (null !== $request->groupId) {
            @$body['GroupId'] = $request->groupId;
        }

        if (null !== $request->operatorUserId) {
            @$body['OperatorUserId'] = $request->operatorUserId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CancelMuteGroupUser',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CancelMuteGroupUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Unmutes members in a message group.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - CancelMuteGroupUserRequest
     *
     * @returns CancelMuteGroupUserResponse
     *
     * @param CancelMuteGroupUserRequest $request
     *
     * @return CancelMuteGroupUserResponse
     */
    public function cancelMuteGroupUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->cancelMuteGroupUserWithOptions($request, $runtime);
    }

    /**
     * Changes the resource group to which a domain name belongs. In this case, you move the domain name from the original resource group to another resource group.
     *
     * @remarks
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ChangeLiveDomainResourceGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ChangeLiveDomainResourceGroupResponse
     *
     * @param ChangeLiveDomainResourceGroupRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return ChangeLiveDomainResourceGroupResponse
     */
    public function changeLiveDomainResourceGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->newResourceGroupId) {
            @$query['NewResourceGroupId'] = $request->newResourceGroupId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ChangeLiveDomainResourceGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ChangeLiveDomainResourceGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the resource group to which a domain name belongs. In this case, you move the domain name from the original resource group to another resource group.
     *
     * @remarks
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ChangeLiveDomainResourceGroupRequest
     *
     * @returns ChangeLiveDomainResourceGroupResponse
     *
     * @param ChangeLiveDomainResourceGroupRequest $request
     *
     * @return ChangeLiveDomainResourceGroupResponse
     */
    public function changeLiveDomainResourceGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->changeLiveDomainResourceGroupWithOptions($request, $runtime);
    }

    /**
     * Queries whether a user is in an interactive messaging group.
     *
     * @remarks
     * Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param tmpReq - CheckLiveMessageUsersInGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CheckLiveMessageUsersInGroupResponse
     *
     * @param CheckLiveMessageUsersInGroupRequest $tmpReq
     * @param RuntimeOptions                      $runtime
     *
     * @return CheckLiveMessageUsersInGroupResponse
     */
    public function checkLiveMessageUsersInGroupWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new CheckLiveMessageUsersInGroupShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->userIds) {
            $request->userIdsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->userIds, 'UserIds', 'simple');
        }

        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->dataCenter) {
            @$query['DataCenter'] = $request->dataCenter;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        if (null !== $request->userIdsShrink) {
            @$query['UserIds'] = $request->userIdsShrink;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CheckLiveMessageUsersInGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CheckLiveMessageUsersInGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries whether a user is in an interactive messaging group.
     *
     * @remarks
     * Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CheckLiveMessageUsersInGroupRequest
     *
     * @returns CheckLiveMessageUsersInGroupResponse
     *
     * @param CheckLiveMessageUsersInGroupRequest $request
     *
     * @return CheckLiveMessageUsersInGroupResponse
     */
    public function checkLiveMessageUsersInGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkLiveMessageUsersInGroupWithOptions($request, $runtime);
    }

    /**
     * Queries whether one or more specified users are online.
     *
     * @remarks
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param tmpReq - CheckLiveMessageUsersOnlineRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CheckLiveMessageUsersOnlineResponse
     *
     * @param CheckLiveMessageUsersOnlineRequest $tmpReq
     * @param RuntimeOptions                     $runtime
     *
     * @return CheckLiveMessageUsersOnlineResponse
     */
    public function checkLiveMessageUsersOnlineWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new CheckLiveMessageUsersOnlineShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->userIds) {
            $request->userIdsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->userIds, 'UserIds', 'simple');
        }

        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->dataCenter) {
            @$query['DataCenter'] = $request->dataCenter;
        }

        if (null !== $request->userIdsShrink) {
            @$query['UserIds'] = $request->userIdsShrink;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CheckLiveMessageUsersOnline',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CheckLiveMessageUsersOnlineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries whether one or more specified users are online.
     *
     * @remarks
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CheckLiveMessageUsersOnlineRequest
     *
     * @returns CheckLiveMessageUsersOnlineResponse
     *
     * @param CheckLiveMessageUsersOnlineRequest $request
     *
     * @return CheckLiveMessageUsersOnlineResponse
     */
    public function checkLiveMessageUsersOnline($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkLiveMessageUsersOnlineWithOptions($request, $runtime);
    }

    /**
     * Disables time shifting for a domain name, or an application or a live stream under the domain name.
     *
     * @remarks
     * Obtain the streaming domain, and then call this operation to disable time shifting for the streaming domain or an application or a live stream under the streaming domain.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CloseLiveShiftRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CloseLiveShiftResponse
     *
     * @param CloseLiveShiftRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return CloseLiveShiftResponse
     */
    public function closeLiveShiftWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CloseLiveShift',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CloseLiveShiftResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Disables time shifting for a domain name, or an application or a live stream under the domain name.
     *
     * @remarks
     * Obtain the streaming domain, and then call this operation to disable time shifting for the streaming domain or an application or a live stream under the streaming domain.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CloseLiveShiftRequest
     *
     * @returns CloseLiveShiftResponse
     *
     * @param CloseLiveShiftRequest $request
     *
     * @return CloseLiveShiftResponse
     */
    public function closeLiveShift($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->closeLiveShiftWithOptions($request, $runtime);
    }

    /**
     * Duplicates a production studio.
     *
     * @remarks
     * You can call this operation to duplicate a production studio. This way, a new, identical production studio is created.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CopyCasterRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CopyCasterResponse
     *
     * @param CopyCasterRequest $request
     * @param RuntimeOptions    $runtime
     *
     * @return CopyCasterResponse
     */
    public function copyCasterWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterName) {
            @$query['CasterName'] = $request->casterName;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->srcCasterId) {
            @$query['SrcCasterId'] = $request->srcCasterId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CopyCaster',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CopyCasterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Duplicates a production studio.
     *
     * @remarks
     * You can call this operation to duplicate a production studio. This way, a new, identical production studio is created.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CopyCasterRequest
     *
     * @returns CopyCasterResponse
     *
     * @param CopyCasterRequest $request
     *
     * @return CopyCasterResponse
     */
    public function copyCaster($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->copyCasterWithOptions($request, $runtime);
    }

    /**
     * Applies the configuration of a PVW scene to a PGM scene.
     *
     * @remarks
     *   Streaming fees and transcoding fees are calculated based on the corresponding output resolutions and durations. For more information, see [Billing of production studios](https://help.aliyun.com/document_detail/64531.html).
     * *   You can call this operation to apply the configuration of a source scene to a destination scene. This operation takes effect only if the source scene is a PVW scene and the destination scene is a PGM scene. A PVW scene is a preview scene, and a PGM scene is a program scene.
     * *   The PVW scene and PGM scene must be in the same production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CopyCasterSceneConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CopyCasterSceneConfigResponse
     *
     * @param CopyCasterSceneConfigRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return CopyCasterSceneConfigResponse
     */
    public function copyCasterSceneConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->fromSceneId) {
            @$query['FromSceneId'] = $request->fromSceneId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->toSceneId) {
            @$query['ToSceneId'] = $request->toSceneId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CopyCasterSceneConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CopyCasterSceneConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Applies the configuration of a PVW scene to a PGM scene.
     *
     * @remarks
     *   Streaming fees and transcoding fees are calculated based on the corresponding output resolutions and durations. For more information, see [Billing of production studios](https://help.aliyun.com/document_detail/64531.html).
     * *   You can call this operation to apply the configuration of a source scene to a destination scene. This operation takes effect only if the source scene is a PVW scene and the destination scene is a PGM scene. A PVW scene is a preview scene, and a PGM scene is a program scene.
     * *   The PVW scene and PGM scene must be in the same production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CopyCasterSceneConfigRequest
     *
     * @returns CopyCasterSceneConfigResponse
     *
     * @param CopyCasterSceneConfigRequest $request
     *
     * @return CopyCasterSceneConfigResponse
     */
    public function copyCasterSceneConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->copyCasterSceneConfigWithOptions($request, $runtime);
    }

    /**
     * Creates a production studio.
     *
     * @remarks
     * You must enable the production studio feature before you can call this operation to create a production studio. For more information, see [Enable the production studio feature](https://help.aliyun.com/document_detail/60361.html).
     * You can call this operation to create production studios in general mode or playlist mode. Production studios in playlist mode can be used for carousel playback.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CreateCasterRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateCasterResponse
     *
     * @param CreateCasterRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return CreateCasterResponse
     */
    public function createCasterWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterName) {
            @$query['CasterName'] = $request->casterName;
        }

        if (null !== $request->casterTemplate) {
            @$query['CasterTemplate'] = $request->casterTemplate;
        }

        if (null !== $request->chargeType) {
            @$query['ChargeType'] = $request->chargeType;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->expireTime) {
            @$query['ExpireTime'] = $request->expireTime;
        }

        if (null !== $request->normType) {
            @$query['NormType'] = $request->normType;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->purchaseTime) {
            @$query['PurchaseTime'] = $request->purchaseTime;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateCaster',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateCasterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a production studio.
     *
     * @remarks
     * You must enable the production studio feature before you can call this operation to create a production studio. For more information, see [Enable the production studio feature](https://help.aliyun.com/document_detail/60361.html).
     * You can call this operation to create production studios in general mode or playlist mode. Production studios in playlist mode can be used for carousel playback.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CreateCasterRequest
     *
     * @returns CreateCasterResponse
     *
     * @param CreateCasterRequest $request
     *
     * @return CreateCasterResponse
     */
    public function createCaster($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createCasterWithOptions($request, $runtime);
    }

    /**
     * Creates a custom stream mixing template.
     *
     * @remarks
     * After you call this operation to create a custom template, record the template name. When you call the [CreateMixStream](https://help.aliyun.com/document_detail/2848087.html) operation to create a stream mixing task, you can set the MixStreamTemplate parameter to the name of the custom template. This way, you can use the custom template for stream mixing.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CreateCustomTemplateRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateCustomTemplateResponse
     *
     * @param CreateCustomTemplateRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return CreateCustomTemplateResponse
     */
    public function createCustomTemplateWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->customTemplate) {
            @$query['CustomTemplate'] = $request->customTemplate;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->template) {
            @$query['Template'] = $request->template;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateCustomTemplate',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateCustomTemplateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a custom stream mixing template.
     *
     * @remarks
     * After you call this operation to create a custom template, record the template name. When you call the [CreateMixStream](https://help.aliyun.com/document_detail/2848087.html) operation to create a stream mixing task, you can set the MixStreamTemplate parameter to the name of the custom template. This way, you can use the custom template for stream mixing.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CreateCustomTemplateRequest
     *
     * @returns CreateCustomTemplateResponse
     *
     * @param CreateCustomTemplateRequest $request
     *
     * @return CreateCustomTemplateResponse
     */
    public function createCustomTemplate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createCustomTemplateWithOptions($request, $runtime);
    }

    /**
     * Creates an edge transcoding task.
     *
     * @remarks
     *   You can call this operation to create an edge transcoding task.
     * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CreateEdgeTranscodeJobRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateEdgeTranscodeJobResponse
     *
     * @param CreateEdgeTranscodeJobRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return CreateEdgeTranscodeJobResponse
     */
    public function createEdgeTranscodeJobWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->streamInput) {
            @$query['StreamInput'] = $request->streamInput;
        }

        if (null !== $request->streamOutput) {
            @$query['StreamOutput'] = $request->streamOutput;
        }

        if (null !== $request->templateId) {
            @$query['TemplateId'] = $request->templateId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateEdgeTranscodeJob',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateEdgeTranscodeJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an edge transcoding task.
     *
     * @remarks
     *   You can call this operation to create an edge transcoding task.
     * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CreateEdgeTranscodeJobRequest
     *
     * @returns CreateEdgeTranscodeJobResponse
     *
     * @param CreateEdgeTranscodeJobRequest $request
     *
     * @return CreateEdgeTranscodeJobResponse
     */
    public function createEdgeTranscodeJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createEdgeTranscodeJobWithOptions($request, $runtime);
    }

    /**
     * Creates a callback to subscribe to channel or user events.
     *
     * @remarks
     * You can call this operation to create a callback to subscribe to channel or user events. When you create a callback, you can configure parameters such as the callback URL and event type.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CreateEventSubRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateEventSubResponse
     *
     * @param CreateEventSubRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return CreateEventSubResponse
     */
    public function createEventSubWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->callbackUrl) {
            @$query['CallbackUrl'] = $request->callbackUrl;
        }

        if (null !== $request->channelId) {
            @$query['ChannelId'] = $request->channelId;
        }

        if (null !== $request->events) {
            @$query['Events'] = $request->events;
        }

        if (null !== $request->users) {
            @$query['Users'] = $request->users;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateEventSub',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateEventSubResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a callback to subscribe to channel or user events.
     *
     * @remarks
     * You can call this operation to create a callback to subscribe to channel or user events. When you create a callback, you can configure parameters such as the callback URL and event type.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CreateEventSubRequest
     *
     * @returns CreateEventSubResponse
     *
     * @param CreateEventSubRequest $request
     *
     * @return CreateEventSubResponse
     */
    public function createEventSub($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createEventSubWithOptions($request, $runtime);
    }

    /**
     * Creates a lightweight virtual studio template.
     *
     * @remarks
     * >  The lightweight virtual studio feature is in invitational preview. You can add up to 300 virtual studio templates.
     *
     * @param tmpReq - CreateLiveAIStudioRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateLiveAIStudioResponse
     *
     * @param CreateLiveAIStudioRequest $tmpReq
     * @param RuntimeOptions            $runtime
     *
     * @return CreateLiveAIStudioResponse
     */
    public function createLiveAIStudioWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new CreateLiveAIStudioShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->mattingLayout) {
            $request->mattingLayoutShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->mattingLayout, 'MattingLayout', 'json');
        }

        if (null !== $tmpReq->mediaLayout) {
            $request->mediaLayoutShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->mediaLayout, 'MediaLayout', 'json');
        }

        $query = [];
        if (null !== $request->backgroundResourceId) {
            @$query['BackgroundResourceId'] = $request->backgroundResourceId;
        }

        if (null !== $request->backgroundResourceUrl) {
            @$query['BackgroundResourceUrl'] = $request->backgroundResourceUrl;
        }

        if (null !== $request->backgroundType) {
            @$query['BackgroundType'] = $request->backgroundType;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->height) {
            @$query['Height'] = $request->height;
        }

        if (null !== $request->mattingLayoutShrink) {
            @$query['MattingLayout'] = $request->mattingLayoutShrink;
        }

        if (null !== $request->mattingType) {
            @$query['MattingType'] = $request->mattingType;
        }

        if (null !== $request->mediaLayoutShrink) {
            @$query['MediaLayout'] = $request->mediaLayoutShrink;
        }

        if (null !== $request->mediaResourceId) {
            @$query['MediaResourceId'] = $request->mediaResourceId;
        }

        if (null !== $request->mediaResourceUrl) {
            @$query['MediaResourceUrl'] = $request->mediaResourceUrl;
        }

        if (null !== $request->mediaType) {
            @$query['MediaType'] = $request->mediaType;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->studioName) {
            @$query['StudioName'] = $request->studioName;
        }

        if (null !== $request->width) {
            @$query['Width'] = $request->width;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateLiveAIStudio',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateLiveAIStudioResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a lightweight virtual studio template.
     *
     * @remarks
     * >  The lightweight virtual studio feature is in invitational preview. You can add up to 300 virtual studio templates.
     *
     * @param request - CreateLiveAIStudioRequest
     *
     * @returns CreateLiveAIStudioResponse
     *
     * @param CreateLiveAIStudioRequest $request
     *
     * @return CreateLiveAIStudioResponse
     */
    public function createLiveAIStudio($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createLiveAIStudioWithOptions($request, $runtime);
    }

    /**
     * Adds a stream delay configuration.
     *
     * @remarks
     * Stream delay is different from latency caused by streaming protocols. Stream delay is a feature that allows you to delay the playback of a live stream that is processed in the cloud.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CreateLiveDelayConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateLiveDelayConfigResponse
     *
     * @param CreateLiveDelayConfigRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return CreateLiveDelayConfigResponse
     */
    public function createLiveDelayConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->app) {
            @$query['App'] = $request->app;
        }

        if (null !== $request->delayTime) {
            @$query['DelayTime'] = $request->delayTime;
        }

        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->stream) {
            @$query['Stream'] = $request->stream;
        }

        if (null !== $request->taskTriggerMode) {
            @$query['TaskTriggerMode'] = $request->taskTriggerMode;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateLiveDelayConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateLiveDelayConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds a stream delay configuration.
     *
     * @remarks
     * Stream delay is different from latency caused by streaming protocols. Stream delay is a feature that allows you to delay the playback of a live stream that is processed in the cloud.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CreateLiveDelayConfigRequest
     *
     * @returns CreateLiveDelayConfigResponse
     *
     * @param CreateLiveDelayConfigRequest $request
     *
     * @return CreateLiveDelayConfigResponse
     */
    public function createLiveDelayConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createLiveDelayConfigWithOptions($request, $runtime);
    }

    /**
     * Creates an interactive messaging application.
     *
     * @remarks
     *   When you call other operations to manage the interactive messaging application, you must specify the same data center in which the application is created.
     * *   You can create up to 300 interactive messaging applications in an Alibaba Cloud account.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CreateLiveMessageAppRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateLiveMessageAppResponse
     *
     * @param CreateLiveMessageAppRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return CreateLiveMessageAppResponse
     */
    public function createLiveMessageAppWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->auditType) {
            @$query['AuditType'] = $request->auditType;
        }

        if (null !== $request->auditUrl) {
            @$query['AuditUrl'] = $request->auditUrl;
        }

        if (null !== $request->dataCenter) {
            @$query['DataCenter'] = $request->dataCenter;
        }

        if (null !== $request->eventCallbackUrl) {
            @$query['EventCallbackUrl'] = $request->eventCallbackUrl;
        }

        if (null !== $request->msgLifeCycle) {
            @$query['MsgLifeCycle'] = $request->msgLifeCycle;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateLiveMessageApp',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateLiveMessageAppResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an interactive messaging application.
     *
     * @remarks
     *   When you call other operations to manage the interactive messaging application, you must specify the same data center in which the application is created.
     * *   You can create up to 300 interactive messaging applications in an Alibaba Cloud account.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CreateLiveMessageAppRequest
     *
     * @returns CreateLiveMessageAppResponse
     *
     * @param CreateLiveMessageAppRequest $request
     *
     * @return CreateLiveMessageAppResponse
     */
    public function createLiveMessageApp($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createLiveMessageAppWithOptions($request, $runtime);
    }

    /**
     * Creates an interactive messaging group.
     *
     * @remarks
     *   Before you call this operation, make sure that you have called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create an interactive messaging application.
     * *   You can create up to 5,000 interactive messaging groups in an interactive messaging application.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param tmpReq - CreateLiveMessageGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateLiveMessageGroupResponse
     *
     * @param CreateLiveMessageGroupRequest $tmpReq
     * @param RuntimeOptions                $runtime
     *
     * @return CreateLiveMessageGroupResponse
     */
    public function createLiveMessageGroupWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new CreateLiveMessageGroupShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->administrators) {
            $request->administratorsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->administrators, 'Administrators', 'simple');
        }

        $query = [];
        if (null !== $request->administratorsShrink) {
            @$query['Administrators'] = $request->administratorsShrink;
        }

        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->creatorId) {
            @$query['CreatorId'] = $request->creatorId;
        }

        if (null !== $request->dataCenter) {
            @$query['DataCenter'] = $request->dataCenter;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        if (null !== $request->groupInfo) {
            @$query['GroupInfo'] = $request->groupInfo;
        }

        if (null !== $request->groupName) {
            @$query['GroupName'] = $request->groupName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateLiveMessageGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateLiveMessageGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an interactive messaging group.
     *
     * @remarks
     *   Before you call this operation, make sure that you have called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create an interactive messaging application.
     * *   You can create up to 5,000 interactive messaging groups in an interactive messaging application.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CreateLiveMessageGroupRequest
     *
     * @returns CreateLiveMessageGroupResponse
     *
     * @param CreateLiveMessageGroupRequest $request
     *
     * @return CreateLiveMessageGroupResponse
     */
    public function createLiveMessageGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createLiveMessageGroupWithOptions($request, $runtime);
    }

    /**
     * Creates a Global Accelerator (GA) instance and binds it to an acceleration circuit.
     *
     * @remarks
     *   You can call this operation to create a GA instance and bind it to an acceleration circuit. The granularity is at the stream level. You need to specify the access points where the acceleration circuit starts and ends.
     * *   The settings take effect only if the value of AppName and the value of StreamName are the same as the application name and stream name that are specified in the streaming URL.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CreateLivePrivateLineRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateLivePrivateLineResponse
     *
     * @param CreateLivePrivateLineRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return CreateLivePrivateLineResponse
     */
    public function createLivePrivateLineWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accelerationArea) {
            @$query['AccelerationArea'] = $request->accelerationArea;
        }

        if (null !== $request->accelerationType) {
            @$query['AccelerationType'] = $request->accelerationType;
        }

        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->maxBandwidth) {
            @$query['MaxBandwidth'] = $request->maxBandwidth;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->reuse) {
            @$query['Reuse'] = $request->reuse;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        if (null !== $request->videoCenter) {
            @$query['VideoCenter'] = $request->videoCenter;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateLivePrivateLine',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateLivePrivateLineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a Global Accelerator (GA) instance and binds it to an acceleration circuit.
     *
     * @remarks
     *   You can call this operation to create a GA instance and bind it to an acceleration circuit. The granularity is at the stream level. You need to specify the access points where the acceleration circuit starts and ends.
     * *   The settings take effect only if the value of AppName and the value of StreamName are the same as the application name and stream name that are specified in the streaming URL.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CreateLivePrivateLineRequest
     *
     * @returns CreateLivePrivateLineResponse
     *
     * @param CreateLivePrivateLineRequest $request
     *
     * @return CreateLivePrivateLineResponse
     */
    public function createLivePrivateLine($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createLivePrivateLineWithOptions($request, $runtime);
    }

    /**
     * Creates a pulled-stream relay task.
     *
     * @remarks
     * >  The pulled-stream relay feature is in public preview. You can use it free of charge. After the public preview ends, fees will be charged. The specific end time will be announced.
     * *   You can call this operation to create a pulled-stream relay task.
     * *   The pulled source can be a live stream or video-on-demand (VOD) resources.
     * *   After a task is created, it starts at the specified start time and ends at the specified end time. A task that ends is automatically deleted.
     * *   Make sure that the destination URL specified in the task is not used by another task. Otherwise, conflicts occur and stream ingest fails.
     * *   The events for pulled-stream relay callbacks include state changes of a pulled-stream relay task and exit of a pulled-stream relay task. For more information, see [Pulled-stream relay callbacks](https://help.aliyun.com/document_detail/2846768.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param tmpReq - CreateLivePullToPushRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateLivePullToPushResponse
     *
     * @param CreateLivePullToPushRequest $tmpReq
     * @param RuntimeOptions              $runtime
     *
     * @return CreateLivePullToPushResponse
     */
    public function createLivePullToPushWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new CreateLivePullToPushShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->sourceUrls) {
            $request->sourceUrlsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->sourceUrls, 'SourceUrls', 'json');
        }

        $query = [];
        if (null !== $request->callbackUrl) {
            @$query['CallbackUrl'] = $request->callbackUrl;
        }

        if (null !== $request->dstUrl) {
            @$query['DstUrl'] = $request->dstUrl;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->fileIndex) {
            @$query['FileIndex'] = $request->fileIndex;
        }

        if (null !== $request->offset) {
            @$query['Offset'] = $request->offset;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->region) {
            @$query['Region'] = $request->region;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->repeatNumber) {
            @$query['RepeatNumber'] = $request->repeatNumber;
        }

        if (null !== $request->retryCount) {
            @$query['RetryCount'] = $request->retryCount;
        }

        if (null !== $request->retryInterval) {
            @$query['RetryInterval'] = $request->retryInterval;
        }

        if (null !== $request->sourceProtocol) {
            @$query['SourceProtocol'] = $request->sourceProtocol;
        }

        if (null !== $request->sourceType) {
            @$query['SourceType'] = $request->sourceType;
        }

        if (null !== $request->sourceUrlsShrink) {
            @$query['SourceUrls'] = $request->sourceUrlsShrink;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->taskName) {
            @$query['TaskName'] = $request->taskName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateLivePullToPush',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateLivePullToPushResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a pulled-stream relay task.
     *
     * @remarks
     * >  The pulled-stream relay feature is in public preview. You can use it free of charge. After the public preview ends, fees will be charged. The specific end time will be announced.
     * *   You can call this operation to create a pulled-stream relay task.
     * *   The pulled source can be a live stream or video-on-demand (VOD) resources.
     * *   After a task is created, it starts at the specified start time and ends at the specified end time. A task that ends is automatically deleted.
     * *   Make sure that the destination URL specified in the task is not used by another task. Otherwise, conflicts occur and stream ingest fails.
     * *   The events for pulled-stream relay callbacks include state changes of a pulled-stream relay task and exit of a pulled-stream relay task. For more information, see [Pulled-stream relay callbacks](https://help.aliyun.com/document_detail/2846768.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CreateLivePullToPushRequest
     *
     * @returns CreateLivePullToPushResponse
     *
     * @param CreateLivePullToPushRequest $request
     *
     * @return CreateLivePullToPushResponse
     */
    public function createLivePullToPush($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createLivePullToPushWithOptions($request, $runtime);
    }

    /**
     * Configures real-time log delivery for a domain name.
     *
     * @remarks
     * ##
     * Obtain the streaming domain, and then call this operation to configure real-time log delivery for the streaming domain.
     * This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
     * ## QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - CreateLiveRealTimeLogDeliveryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateLiveRealTimeLogDeliveryResponse
     *
     * @param CreateLiveRealTimeLogDeliveryRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return CreateLiveRealTimeLogDeliveryResponse
     */
    public function createLiveRealTimeLogDeliveryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateLiveRealTimeLogDelivery',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateLiveRealTimeLogDeliveryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures real-time log delivery for a domain name.
     *
     * @remarks
     * ##
     * Obtain the streaming domain, and then call this operation to configure real-time log delivery for the streaming domain.
     * This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
     * ## QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - CreateLiveRealTimeLogDeliveryRequest
     *
     * @returns CreateLiveRealTimeLogDeliveryResponse
     *
     * @param CreateLiveRealTimeLogDeliveryRequest $request
     *
     * @return CreateLiveRealTimeLogDeliveryResponse
     */
    public function createLiveRealTimeLogDelivery($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createLiveRealTimeLogDeliveryWithOptions($request, $runtime);
    }

    /**
     * Creates a monitoring session.
     *
     * @remarks
     * You can call this operation to create a monitoring session. Make sure that the parameter settings meet the requirements.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CreateLiveStreamMonitorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateLiveStreamMonitorResponse
     *
     * @param CreateLiveStreamMonitorRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return CreateLiveStreamMonitorResponse
     */
    public function createLiveStreamMonitorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->app) {
            @$query['App'] = $request->app;
        }

        if (null !== $request->callbackUrl) {
            @$query['CallbackUrl'] = $request->callbackUrl;
        }

        if (null !== $request->dingTalkWebHookUrl) {
            @$query['DingTalkWebHookUrl'] = $request->dingTalkWebHookUrl;
        }

        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->inputList) {
            @$query['InputList'] = $request->inputList;
        }

        if (null !== $request->monitorConfig) {
            @$query['MonitorConfig'] = $request->monitorConfig;
        }

        if (null !== $request->monitorName) {
            @$query['MonitorName'] = $request->monitorName;
        }

        if (null !== $request->outputTemplate) {
            @$query['OutputTemplate'] = $request->outputTemplate;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->stream) {
            @$query['Stream'] = $request->stream;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateLiveStreamMonitor',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateLiveStreamMonitorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a monitoring session.
     *
     * @remarks
     * You can call this operation to create a monitoring session. Make sure that the parameter settings meet the requirements.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CreateLiveStreamMonitorRequest
     *
     * @returns CreateLiveStreamMonitorResponse
     *
     * @param CreateLiveStreamMonitorRequest $request
     *
     * @return CreateLiveStreamMonitorResponse
     */
    public function createLiveStreamMonitor($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createLiveStreamMonitorWithOptions($request, $runtime);
    }

    /**
     * Creates an M3U8 index file for a recording in a specified time period.
     *
     * @remarks
     * You must have configured Object Storage Service (OSS) before you call this operation. For more information, see [Configure OSS](https://help.aliyun.com/document_detail/84932.html). ApsaraVideo Live allows you to record a live stream in the M3U8 format and store the M3U8 file in OSS. You can edit the TS segments that are included in the stored M3U8 file in real time.
     * >
     * *   You can create an index file only after a live stream is ingested. If no live stream is available within the specified time range or the name of the specified live stream is invalid, the index file fails to be created.
     * *   The time range that is specified by the StartTime and EndTime parameters must be the duration of at least one TS segment. The default duration of a TS segment is 30 seconds.
     * *   ApsaraVideo Live stores the information about TS segments for only three months. You can create M3U8 index files only for the recordings of the last three months.
     * *   OSS stores TS segments for a time period that is specified by the storage configuration in OSS. For more information, see [Configure lifecycle rules](https://help.aliyun.com/document_detail/31904.html).
     * *   ApsaraVideo Live stores the information about M3U8 index files for six months. You can query the information about only the M3U8 index files that were created in the last six months.
     * *   OSS stores M3U8 index files for a time period that is specified by the storage configuration in OSS.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 45 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CreateLiveStreamRecordIndexFilesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateLiveStreamRecordIndexFilesResponse
     *
     * @param CreateLiveStreamRecordIndexFilesRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return CreateLiveStreamRecordIndexFilesResponse
     */
    public function createLiveStreamRecordIndexFilesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->endTimeIncluded) {
            @$query['EndTimeIncluded'] = $request->endTimeIncluded;
        }

        if (null !== $request->ossBucket) {
            @$query['OssBucket'] = $request->ossBucket;
        }

        if (null !== $request->ossEndpoint) {
            @$query['OssEndpoint'] = $request->ossEndpoint;
        }

        if (null !== $request->ossObject) {
            @$query['OssObject'] = $request->ossObject;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateLiveStreamRecordIndexFiles',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateLiveStreamRecordIndexFilesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an M3U8 index file for a recording in a specified time period.
     *
     * @remarks
     * You must have configured Object Storage Service (OSS) before you call this operation. For more information, see [Configure OSS](https://help.aliyun.com/document_detail/84932.html). ApsaraVideo Live allows you to record a live stream in the M3U8 format and store the M3U8 file in OSS. You can edit the TS segments that are included in the stored M3U8 file in real time.
     * >
     * *   You can create an index file only after a live stream is ingested. If no live stream is available within the specified time range or the name of the specified live stream is invalid, the index file fails to be created.
     * *   The time range that is specified by the StartTime and EndTime parameters must be the duration of at least one TS segment. The default duration of a TS segment is 30 seconds.
     * *   ApsaraVideo Live stores the information about TS segments for only three months. You can create M3U8 index files only for the recordings of the last three months.
     * *   OSS stores TS segments for a time period that is specified by the storage configuration in OSS. For more information, see [Configure lifecycle rules](https://help.aliyun.com/document_detail/31904.html).
     * *   ApsaraVideo Live stores the information about M3U8 index files for six months. You can query the information about only the M3U8 index files that were created in the last six months.
     * *   OSS stores M3U8 index files for a time period that is specified by the storage configuration in OSS.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 45 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CreateLiveStreamRecordIndexFilesRequest
     *
     * @returns CreateLiveStreamRecordIndexFilesResponse
     *
     * @param CreateLiveStreamRecordIndexFilesRequest $request
     *
     * @return CreateLiveStreamRecordIndexFilesResponse
     */
    public function createLiveStreamRecordIndexFiles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createLiveStreamRecordIndexFilesWithOptions($request, $runtime);
    }

    /**
     * Creates an interactive messaging application.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param tmpReq - CreateMessageAppRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateMessageAppResponse
     *
     * @param CreateMessageAppRequest $tmpReq
     * @param RuntimeOptions          $runtime
     *
     * @return CreateMessageAppResponse
     */
    public function createMessageAppWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new CreateMessageAppShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->appConfig) {
            $request->appConfigShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->appConfig, 'AppConfig', 'json');
        }

        if (null !== $tmpReq->extension) {
            $request->extensionShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->extension, 'Extension', 'json');
        }

        $body = [];
        if (null !== $request->appConfigShrink) {
            @$body['AppConfig'] = $request->appConfigShrink;
        }

        if (null !== $request->appName) {
            @$body['AppName'] = $request->appName;
        }

        if (null !== $request->extensionShrink) {
            @$body['Extension'] = $request->extensionShrink;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateMessageApp',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateMessageAppResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an interactive messaging application.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - CreateMessageAppRequest
     *
     * @returns CreateMessageAppResponse
     *
     * @param CreateMessageAppRequest $request
     *
     * @return CreateMessageAppResponse
     */
    public function createMessageApp($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createMessageAppWithOptions($request, $runtime);
    }

    /**
     * Creates a message group.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param tmpReq - CreateMessageGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateMessageGroupResponse
     *
     * @param CreateMessageGroupRequest $tmpReq
     * @param RuntimeOptions            $runtime
     *
     * @return CreateMessageGroupResponse
     */
    public function createMessageGroupWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new CreateMessageGroupShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->extension) {
            $request->extensionShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->extension, 'Extension', 'json');
        }

        $body = [];
        if (null !== $request->appId) {
            @$body['AppId'] = $request->appId;
        }

        if (null !== $request->creatorId) {
            @$body['CreatorId'] = $request->creatorId;
        }

        if (null !== $request->extensionShrink) {
            @$body['Extension'] = $request->extensionShrink;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateMessageGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateMessageGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a message group.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - CreateMessageGroupRequest
     *
     * @returns CreateMessageGroupResponse
     *
     * @param CreateMessageGroupRequest $request
     *
     * @return CreateMessageGroupResponse
     */
    public function createMessageGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createMessageGroupWithOptions($request, $runtime);
    }

    /**
     * Creates a stream mixing task.
     *
     * @remarks
     * You can call this operation to create a stream mixing task. This operation supports preset layouts and custom layouts.
     * If you have any questions or suggestions about the use of the stream mixing feature, you are welcome to search the group ID 34935990 in DingTalk to join the developer group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CreateMixStreamRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateMixStreamResponse
     *
     * @param CreateMixStreamRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return CreateMixStreamResponse
     */
    public function createMixStreamWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->callbackConfig) {
            @$query['CallbackConfig'] = $request->callbackConfig;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->inputStreamList) {
            @$query['InputStreamList'] = $request->inputStreamList;
        }

        if (null !== $request->layoutId) {
            @$query['LayoutId'] = $request->layoutId;
        }

        if (null !== $request->outputConfig) {
            @$query['OutputConfig'] = $request->outputConfig;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateMixStream',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateMixStreamResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a stream mixing task.
     *
     * @remarks
     * You can call this operation to create a stream mixing task. This operation supports preset layouts and custom layouts.
     * If you have any questions or suggestions about the use of the stream mixing feature, you are welcome to search the group ID 34935990 in DingTalk to join the developer group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CreateMixStreamRequest
     *
     * @returns CreateMixStreamResponse
     *
     * @param CreateMixStreamRequest $request
     *
     * @return CreateMixStreamResponse
     */
    public function createMixStream($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createMixStreamWithOptions($request, $runtime);
    }

    /**
     * 创建房间whip协议推流地址
     *
     * @param request - CreateRTCWhipStreamAddressRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateRTCWhipStreamAddressResponse
     *
     * @param CreateRTCWhipStreamAddressRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return CreateRTCWhipStreamAddressResponse
     */
    public function createRTCWhipStreamAddressWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->channelId) {
            @$query['ChannelId'] = $request->channelId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->displayName) {
            @$query['DisplayName'] = $request->displayName;
        }

        if (null !== $request->expireTime) {
            @$query['ExpireTime'] = $request->expireTime;
        }

        if (null !== $request->userId) {
            @$query['UserId'] = $request->userId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateRTCWhipStreamAddress',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateRTCWhipStreamAddressResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 创建房间whip协议推流地址
     *
     * @param request - CreateRTCWhipStreamAddressRequest
     *
     * @returns CreateRTCWhipStreamAddressResponse
     *
     * @param CreateRTCWhipStreamAddressRequest $request
     *
     * @return CreateRTCWhipStreamAddressResponse
     */
    public function createRTCWhipStreamAddress($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createRTCWhipStreamAddressWithOptions($request, $runtime);
    }

    /**
     * Creates a Real-Time Messaging Protocol (RTMP) ingest URL for a channel.
     *
     * @remarks
     * ### [](#)Usage notes
     * To use the interactive streaming feature, you must use ApsaraVideo Real-time Communication (ARTC) SDK to join a channel and ingest streams over Real-Time Communication (RTC). In specific scenarios, you can ingest streams over Real-Time Messaging Protocol (RTMP) by using tools such as Open Broadcaster Software (OBS). Then, ApsaraVideo Live automatically converts the RTMP streams to RTC streams and distributes the RTC streams to viewers. You can call this operation to generate an ingest URL in the RTMP format. After you ingest RTMP streams, ApsaraVideo Live automatically converts the streams to RTC streams. Do not call this operation if you require only regular live streaming. To quickly ingest RTMP streams and start live streaming, see [Get started with ApsaraVideo Live](https://help.aliyun.com/document_detail/198676.html).
     * ## [](#)Procedure
     * 1.  Call this operation to generate an ingest URL in the RTMP format.
     * 2.  Ingest a stream by using the ingest URL. Other users in the channel can watch the stream.
     * 3.  Stop ingesting the stream. Other users in the channel see that the user who ingested the stream leaves the channel.
     * >
     * *   You can repeat Steps 2 and 3 within the validity period of the ingest URL.
     * *   We recommend that you call the [DescribeChannelParticipants](https://help.aliyun.com/document_detail/610801.html) operation to query online users in the channel at regular intervals. This way, you can check whether the user who ingests the stream is still in the channel. If the user who ingests the stream is not in the channel, the stream may be interrupted. In this case, we recommend that you stop ingesting the stream and perform Step 2.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - CreateRoomRealTimeStreamAddressRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateRoomRealTimeStreamAddressResponse
     *
     * @param CreateRoomRealTimeStreamAddressRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return CreateRoomRealTimeStreamAddressResponse
     */
    public function createRoomRealTimeStreamAddressWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateRoomRealTimeStreamAddress',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateRoomRealTimeStreamAddressResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a Real-Time Messaging Protocol (RTMP) ingest URL for a channel.
     *
     * @remarks
     * ### [](#)Usage notes
     * To use the interactive streaming feature, you must use ApsaraVideo Real-time Communication (ARTC) SDK to join a channel and ingest streams over Real-Time Communication (RTC). In specific scenarios, you can ingest streams over Real-Time Messaging Protocol (RTMP) by using tools such as Open Broadcaster Software (OBS). Then, ApsaraVideo Live automatically converts the RTMP streams to RTC streams and distributes the RTC streams to viewers. You can call this operation to generate an ingest URL in the RTMP format. After you ingest RTMP streams, ApsaraVideo Live automatically converts the streams to RTC streams. Do not call this operation if you require only regular live streaming. To quickly ingest RTMP streams and start live streaming, see [Get started with ApsaraVideo Live](https://help.aliyun.com/document_detail/198676.html).
     * ## [](#)Procedure
     * 1.  Call this operation to generate an ingest URL in the RTMP format.
     * 2.  Ingest a stream by using the ingest URL. Other users in the channel can watch the stream.
     * 3.  Stop ingesting the stream. Other users in the channel see that the user who ingested the stream leaves the channel.
     * >
     * *   You can repeat Steps 2 and 3 within the validity period of the ingest URL.
     * *   We recommend that you call the [DescribeChannelParticipants](https://help.aliyun.com/document_detail/610801.html) operation to query online users in the channel at regular intervals. This way, you can check whether the user who ingests the stream is still in the channel. If the user who ingests the stream is not in the channel, the stream may be interrupted. In this case, we recommend that you stop ingesting the stream and perform Step 2.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - CreateRoomRealTimeStreamAddressRequest
     *
     * @returns CreateRoomRealTimeStreamAddressResponse
     *
     * @param CreateRoomRealTimeStreamAddressRequest $request
     *
     * @return CreateRoomRealTimeStreamAddressResponse
     */
    public function createRoomRealTimeStreamAddress($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createRoomRealTimeStreamAddressWithOptions($request, $runtime);
    }

    /**
     * Creates a live subtitle task to transcribe an audio stream to text in real time.
     *
     * @remarks
     * You can call this operation to create a live subtitle task that transcribes audio in a live stream to text in real time.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CreateRtcAsrTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateRtcAsrTaskResponse
     *
     * @param CreateRtcAsrTaskRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return CreateRtcAsrTaskResponse
     */
    public function createRtcAsrTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->authKey) {
            @$query['AuthKey'] = $request->authKey;
        }

        if (null !== $request->autoTerminateDelay) {
            @$query['AutoTerminateDelay'] = $request->autoTerminateDelay;
        }

        if (null !== $request->autoTerminateEnabled) {
            @$query['AutoTerminateEnabled'] = $request->autoTerminateEnabled;
        }

        if (null !== $request->callbackURL) {
            @$query['CallbackURL'] = $request->callbackURL;
        }

        if (null !== $request->channelID) {
            @$query['ChannelID'] = $request->channelID;
        }

        if (null !== $request->language) {
            @$query['Language'] = $request->language;
        }

        if (null !== $request->mode) {
            @$query['Mode'] = $request->mode;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->reportInterval) {
            @$query['ReportInterval'] = $request->reportInterval;
        }

        if (null !== $request->rtcUserId) {
            @$query['RtcUserId'] = $request->rtcUserId;
        }

        if (null !== $request->SDKAppID) {
            @$query['SDKAppID'] = $request->SDKAppID;
        }

        if (null !== $request->streamURL) {
            @$query['StreamURL'] = $request->streamURL;
        }

        if (null !== $request->targetLanguages) {
            @$query['TargetLanguages'] = $request->targetLanguages;
        }

        if (null !== $request->translateEnabled) {
            @$query['TranslateEnabled'] = $request->translateEnabled;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateRtcAsrTask',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateRtcAsrTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a live subtitle task to transcribe an audio stream to text in real time.
     *
     * @remarks
     * You can call this operation to create a live subtitle task that transcribes audio in a live stream to text in real time.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CreateRtcAsrTaskRequest
     *
     * @returns CreateRtcAsrTaskResponse
     *
     * @param CreateRtcAsrTaskRequest $request
     *
     * @return CreateRtcAsrTaskResponse
     */
    public function createRtcAsrTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createRtcAsrTaskWithOptions($request, $runtime);
    }

    /**
     * Creates a subscription to mixed-stream relay events.
     *
     * @remarks
     * You can call this operation to create a subscription to mixed-stream relay events. You can configure parameters such as the callback URL, application to which you want to subscribe, and channel information when you create a subscription.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CreateRtcMPUEventSubRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateRtcMPUEventSubResponse
     *
     * @param CreateRtcMPUEventSubRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return CreateRtcMPUEventSubResponse
     */
    public function createRtcMPUEventSubWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->callbackUrl) {
            @$query['CallbackUrl'] = $request->callbackUrl;
        }

        if (null !== $request->channelIds) {
            @$query['ChannelIds'] = $request->channelIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateRtcMPUEventSub',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateRtcMPUEventSubResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a subscription to mixed-stream relay events.
     *
     * @remarks
     * You can call this operation to create a subscription to mixed-stream relay events. You can configure parameters such as the callback URL, application to which you want to subscribe, and channel information when you create a subscription.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - CreateRtcMPUEventSubRequest
     *
     * @returns CreateRtcMPUEventSubResponse
     *
     * @param CreateRtcMPUEventSubRequest $request
     *
     * @return CreateRtcMPUEventSubResponse
     */
    public function createRtcMPUEventSub($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createRtcMPUEventSubWithOptions($request, $runtime);
    }

    /**
     * Deletes a production studio.
     *
     * @remarks
     *   You can delete only production studios that are closed.
     * *   When a production studio is deleted, the scenes, components, and layouts of the production studio are also deleted.
     * *   You cannot recover a deleted production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteCasterRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteCasterResponse
     *
     * @param DeleteCasterRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return DeleteCasterResponse
     */
    public function deleteCasterWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteCaster',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteCasterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a production studio.
     *
     * @remarks
     *   You can delete only production studios that are closed.
     * *   When a production studio is deleted, the scenes, components, and layouts of the production studio are also deleted.
     * *   You cannot recover a deleted production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteCasterRequest
     *
     * @returns DeleteCasterResponse
     *
     * @param DeleteCasterRequest $request
     *
     * @return DeleteCasterResponse
     */
    public function deleteCaster($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCasterWithOptions($request, $runtime);
    }

    /**
     * Deletes a component in a production studio.
     *
     * @remarks
     * You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to delete a component in the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteCasterComponentRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteCasterComponentResponse
     *
     * @param DeleteCasterComponentRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DeleteCasterComponentResponse
     */
    public function deleteCasterComponentWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->componentId) {
            @$query['ComponentId'] = $request->componentId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteCasterComponent',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteCasterComponentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a component in a production studio.
     *
     * @remarks
     * You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to delete a component in the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteCasterComponentRequest
     *
     * @returns DeleteCasterComponentResponse
     *
     * @param DeleteCasterComponentRequest $request
     *
     * @return DeleteCasterComponentResponse
     */
    public function deleteCasterComponent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCasterComponentWithOptions($request, $runtime);
    }

    /**
     * Deletes an episode in a production studio.
     *
     * @remarks
     * Before you call this operation to delete an episode in a production studio, you must obtain the ID of the production studio and the ID of the episode.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteCasterEpisodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteCasterEpisodeResponse
     *
     * @param DeleteCasterEpisodeRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DeleteCasterEpisodeResponse
     */
    public function deleteCasterEpisodeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->episodeId) {
            @$query['EpisodeId'] = $request->episodeId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteCasterEpisode',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteCasterEpisodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an episode in a production studio.
     *
     * @remarks
     * Before you call this operation to delete an episode in a production studio, you must obtain the ID of the production studio and the ID of the episode.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteCasterEpisodeRequest
     *
     * @returns DeleteCasterEpisodeResponse
     *
     * @param DeleteCasterEpisodeRequest $request
     *
     * @return DeleteCasterEpisodeResponse
     */
    public function deleteCasterEpisode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCasterEpisodeWithOptions($request, $runtime);
    }

    /**
     * Deletes an episode list in a production studio.
     *
     * @remarks
     * Before you call this operation to delete an episode list in a production studio, make sure that you have called the [AddCasterEpisodeGroup](https://help.aliyun.com/document_detail/2848071.html) operation to add the episode list in the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteCasterEpisodeGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteCasterEpisodeGroupResponse
     *
     * @param DeleteCasterEpisodeGroupRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DeleteCasterEpisodeGroupResponse
     */
    public function deleteCasterEpisodeGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->programId) {
            @$query['ProgramId'] = $request->programId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteCasterEpisodeGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteCasterEpisodeGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an episode list in a production studio.
     *
     * @remarks
     * Before you call this operation to delete an episode list in a production studio, make sure that you have called the [AddCasterEpisodeGroup](https://help.aliyun.com/document_detail/2848071.html) operation to add the episode list in the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteCasterEpisodeGroupRequest
     *
     * @returns DeleteCasterEpisodeGroupResponse
     *
     * @param DeleteCasterEpisodeGroupRequest $request
     *
     * @return DeleteCasterEpisodeGroupResponse
     */
    public function deleteCasterEpisodeGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCasterEpisodeGroupWithOptions($request, $runtime);
    }

    /**
     * Deletes a layout in a production studio.
     *
     * @remarks
     * You can call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio and then call this operation to delete a layout in the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DeleteCasterLayoutRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteCasterLayoutResponse
     *
     * @param DeleteCasterLayoutRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return DeleteCasterLayoutResponse
     */
    public function deleteCasterLayoutWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->layoutId) {
            @$query['LayoutId'] = $request->layoutId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteCasterLayout',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteCasterLayoutResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a layout in a production studio.
     *
     * @remarks
     * You can call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio and then call this operation to delete a layout in the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DeleteCasterLayoutRequest
     *
     * @returns DeleteCasterLayoutResponse
     *
     * @param DeleteCasterLayoutRequest $request
     *
     * @return DeleteCasterLayoutResponse
     */
    public function deleteCasterLayout($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCasterLayoutWithOptions($request, $runtime);
    }

    /**
     * Deletes the episode list for carousel playback in a production studio.
     *
     * @remarks
     * You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to delete the episode list for carousel playback in the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteCasterProgramRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteCasterProgramResponse
     *
     * @param DeleteCasterProgramRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DeleteCasterProgramResponse
     */
    public function deleteCasterProgramWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteCasterProgram',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteCasterProgramResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the episode list for carousel playback in a production studio.
     *
     * @remarks
     * You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to delete the episode list for carousel playback in the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteCasterProgramRequest
     *
     * @returns DeleteCasterProgramResponse
     *
     * @param DeleteCasterProgramRequest $request
     *
     * @return DeleteCasterProgramResponse
     */
    public function deleteCasterProgram($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCasterProgramWithOptions($request, $runtime);
    }

    /**
     * Deletes the settings of a scene.
     *
     * @remarks
     * You can call this operation to delete the settings of a scene, such as the component setting, layout setting, or both of them.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DeleteCasterSceneConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteCasterSceneConfigResponse
     *
     * @param DeleteCasterSceneConfigRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DeleteCasterSceneConfigResponse
     */
    public function deleteCasterSceneConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->sceneId) {
            @$query['SceneId'] = $request->sceneId;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteCasterSceneConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteCasterSceneConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the settings of a scene.
     *
     * @remarks
     * You can call this operation to delete the settings of a scene, such as the component setting, layout setting, or both of them.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DeleteCasterSceneConfigRequest
     *
     * @returns DeleteCasterSceneConfigResponse
     *
     * @param DeleteCasterSceneConfigRequest $request
     *
     * @return DeleteCasterSceneConfigResponse
     */
    public function deleteCasterSceneConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCasterSceneConfigWithOptions($request, $runtime);
    }

    /**
     * Removes an input source from a production studio.
     *
     * @remarks
     * Before you call this operation to remove an input source from a production studio, make sure that you have called the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DeleteCasterVideoResourceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteCasterVideoResourceResponse
     *
     * @param DeleteCasterVideoResourceRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DeleteCasterVideoResourceResponse
     */
    public function deleteCasterVideoResourceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteCasterVideoResource',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteCasterVideoResourceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Removes an input source from a production studio.
     *
     * @remarks
     * Before you call this operation to remove an input source from a production studio, make sure that you have called the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DeleteCasterVideoResourceRequest
     *
     * @returns DeleteCasterVideoResourceResponse
     *
     * @param DeleteCasterVideoResourceRequest $request
     *
     * @return DeleteCasterVideoResourceResponse
     */
    public function deleteCasterVideoResource($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCasterVideoResourceWithOptions($request, $runtime);
    }

    /**
     * Deletes a channel.
     *
     * @remarks
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteChannelRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteChannelResponse
     *
     * @param DeleteChannelRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return DeleteChannelResponse
     */
    public function deleteChannelWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->channelId) {
            @$query['ChannelId'] = $request->channelId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteChannel',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteChannelResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a channel.
     *
     * @remarks
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteChannelRequest
     *
     * @returns DeleteChannelResponse
     *
     * @param DeleteChannelRequest $request
     *
     * @return DeleteChannelResponse
     */
    public function deleteChannel($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteChannelWithOptions($request, $runtime);
    }

    /**
     * Deletes a custom stream mixing template.
     *
     * @remarks
     * Obtain the name of the custom stream mixing template that you want to delete, and then call this operation to delete the template.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteCustomTemplateRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteCustomTemplateResponse
     *
     * @param DeleteCustomTemplateRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DeleteCustomTemplateResponse
     */
    public function deleteCustomTemplateWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->template) {
            @$query['Template'] = $request->template;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteCustomTemplate',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteCustomTemplateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a custom stream mixing template.
     *
     * @remarks
     * Obtain the name of the custom stream mixing template that you want to delete, and then call this operation to delete the template.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteCustomTemplateRequest
     *
     * @returns DeleteCustomTemplateResponse
     *
     * @param DeleteCustomTemplateRequest $request
     *
     * @return DeleteCustomTemplateResponse
     */
    public function deleteCustomTemplate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCustomTemplateWithOptions($request, $runtime);
    }

    /**
     * Deletes an edge transcoding task.
     *
     * @remarks
     *   You can call this operation to delete an edge transcoding task.
     * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteEdgeTranscodeJobRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteEdgeTranscodeJobResponse
     *
     * @param DeleteEdgeTranscodeJobRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DeleteEdgeTranscodeJobResponse
     */
    public function deleteEdgeTranscodeJobWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->jobId) {
            @$query['JobId'] = $request->jobId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteEdgeTranscodeJob',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteEdgeTranscodeJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an edge transcoding task.
     *
     * @remarks
     *   You can call this operation to delete an edge transcoding task.
     * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteEdgeTranscodeJobRequest
     *
     * @returns DeleteEdgeTranscodeJobResponse
     *
     * @param DeleteEdgeTranscodeJobRequest $request
     *
     * @return DeleteEdgeTranscodeJobResponse
     */
    public function deleteEdgeTranscodeJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteEdgeTranscodeJobWithOptions($request, $runtime);
    }

    /**
     * Deletes a callback that is used to subscribe to channel or user events.
     *
     * @remarks
     * Before you call this operation, make sure that you have called the [CreateEventSubscribe](https://help.aliyun.com/document_detail/2848209.html) operation to create a callback that is used to subscribe to channel or user events.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteEventSubRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteEventSubResponse
     *
     * @param DeleteEventSubRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return DeleteEventSubResponse
     */
    public function deleteEventSubWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->subscribeId) {
            @$query['SubscribeId'] = $request->subscribeId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteEventSub',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteEventSubResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a callback that is used to subscribe to channel or user events.
     *
     * @remarks
     * Before you call this operation, make sure that you have called the [CreateEventSubscribe](https://help.aliyun.com/document_detail/2848209.html) operation to create a callback that is used to subscribe to channel or user events.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteEventSubRequest
     *
     * @returns DeleteEventSubResponse
     *
     * @param DeleteEventSubRequest $request
     *
     * @return DeleteEventSubResponse
     */
    public function deleteEventSub($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteEventSubWithOptions($request, $runtime);
    }

    /**
     * Deletes a subtitle rule.
     *
     * @remarks
     * You can call this operation to delete a specified subtitle rule.
     * >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveAIProduceRulesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLiveAIProduceRulesResponse
     *
     * @param DeleteLiveAIProduceRulesRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DeleteLiveAIProduceRulesResponse
     */
    public function deleteLiveAIProduceRulesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->app) {
            @$query['App'] = $request->app;
        }

        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->rulesId) {
            @$query['RulesId'] = $request->rulesId;
        }

        if (null !== $request->suffixName) {
            @$query['SuffixName'] = $request->suffixName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveAIProduceRules',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveAIProduceRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a subtitle rule.
     *
     * @remarks
     * You can call this operation to delete a specified subtitle rule.
     * >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveAIProduceRulesRequest
     *
     * @returns DeleteLiveAIProduceRulesResponse
     *
     * @param DeleteLiveAIProduceRulesRequest $request
     *
     * @return DeleteLiveAIProduceRulesResponse
     */
    public function deleteLiveAIProduceRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveAIProduceRulesWithOptions($request, $runtime);
    }

    /**
     * Deletes a virtual studio template.
     *
     * @remarks
     * To delete a virtual studio template, you must first unbind the rules. Otherwise, an error occurs.
     * >  The lightweight virtual studio feature is in invitational preview. You can add up to 300 virtual studio templates.
     *
     * @param request - DeleteLiveAIStudioRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLiveAIStudioResponse
     *
     * @param DeleteLiveAIStudioRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return DeleteLiveAIStudioResponse
     */
    public function deleteLiveAIStudioWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->studioId) {
            @$query['StudioId'] = $request->studioId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveAIStudio',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveAIStudioResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a virtual studio template.
     *
     * @remarks
     * To delete a virtual studio template, you must first unbind the rules. Otherwise, an error occurs.
     * >  The lightweight virtual studio feature is in invitational preview. You can add up to 300 virtual studio templates.
     *
     * @param request - DeleteLiveAIStudioRequest
     *
     * @returns DeleteLiveAIStudioResponse
     *
     * @param DeleteLiveAIStudioRequest $request
     *
     * @return DeleteLiveAIStudioResponse
     */
    public function deleteLiveAIStudio($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveAIStudioWithOptions($request, $runtime);
    }

    /**
     * Deletes a specified subtitle template.
     *
     * @remarks
     * You can call this operation to delete a specified subtitle template for live streaming.
     * >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DeleteLiveAISubtitleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLiveAISubtitleResponse
     *
     * @param DeleteLiveAISubtitleRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DeleteLiveAISubtitleResponse
     */
    public function deleteLiveAISubtitleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->subtitleId) {
            @$query['SubtitleId'] = $request->subtitleId;
        }

        if (null !== $request->subtitleName) {
            @$query['SubtitleName'] = $request->subtitleName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveAISubtitle',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveAISubtitleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a specified subtitle template.
     *
     * @remarks
     * You can call this operation to delete a specified subtitle template for live streaming.
     * >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DeleteLiveAISubtitleRequest
     *
     * @returns DeleteLiveAISubtitleResponse
     *
     * @param DeleteLiveAISubtitleRequest $request
     *
     * @return DeleteLiveAISubtitleResponse
     */
    public function deleteLiveAISubtitle($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveAISubtitleWithOptions($request, $runtime);
    }

    /**
     * Deletes a recording configuration at the application level.
     *
     * @remarks
     * Obtain the main streaming domain, and then call this operation to delete a recording configuration at the application level.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveAppRecordConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLiveAppRecordConfigResponse
     *
     * @param DeleteLiveAppRecordConfigRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DeleteLiveAppRecordConfigResponse
     */
    public function deleteLiveAppRecordConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveAppRecordConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveAppRecordConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a recording configuration at the application level.
     *
     * @remarks
     * Obtain the main streaming domain, and then call this operation to delete a recording configuration at the application level.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveAppRecordConfigRequest
     *
     * @returns DeleteLiveAppRecordConfigResponse
     *
     * @param DeleteLiveAppRecordConfigRequest $request
     *
     * @return DeleteLiveAppRecordConfigResponse
     */
    public function deleteLiveAppRecordConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveAppRecordConfigWithOptions($request, $runtime);
    }

    /**
     * Deletes the snapshot configuration for live streams in an application. The deletion takes effect after you restart stream ingest.
     *
     * @remarks
     * You can call this operation to delete the snapshot configuration for live streams in an application. The deletion takes effect after you restart stream ingest.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveAppSnapshotConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLiveAppSnapshotConfigResponse
     *
     * @param DeleteLiveAppSnapshotConfigRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DeleteLiveAppSnapshotConfigResponse
     */
    public function deleteLiveAppSnapshotConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveAppSnapshotConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveAppSnapshotConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the snapshot configuration for live streams in an application. The deletion takes effect after you restart stream ingest.
     *
     * @remarks
     * You can call this operation to delete the snapshot configuration for live streams in an application. The deletion takes effect after you restart stream ingest.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveAppSnapshotConfigRequest
     *
     * @returns DeleteLiveAppSnapshotConfigResponse
     *
     * @param DeleteLiveAppSnapshotConfigRequest $request
     *
     * @return DeleteLiveAppSnapshotConfigResponse
     */
    public function deleteLiveAppSnapshotConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveAppSnapshotConfigWithOptions($request, $runtime);
    }

    /**
     * Deletes an audio moderation configuration.
     *
     * @remarks
     *   Obtain the main streaming domain, and then call this operation to delete an audio moderation configuration.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DeleteLiveAudioAuditConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLiveAudioAuditConfigResponse
     *
     * @param DeleteLiveAudioAuditConfigRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DeleteLiveAudioAuditConfigResponse
     */
    public function deleteLiveAudioAuditConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveAudioAuditConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveAudioAuditConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an audio moderation configuration.
     *
     * @remarks
     *   Obtain the main streaming domain, and then call this operation to delete an audio moderation configuration.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DeleteLiveAudioAuditConfigRequest
     *
     * @returns DeleteLiveAudioAuditConfigResponse
     *
     * @param DeleteLiveAudioAuditConfigRequest $request
     *
     * @return DeleteLiveAudioAuditConfigResponse
     */
    public function deleteLiveAudioAuditConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveAudioAuditConfigWithOptions($request, $runtime);
    }

    /**
     * Deletes the configuration of callbacks for audio moderation results.
     *
     * @remarks
     *   Obtain the main streaming domain, and then call this operation to delete the configuration of callbacks for audio moderation results.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveAudioAuditNotifyConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLiveAudioAuditNotifyConfigResponse
     *
     * @param DeleteLiveAudioAuditNotifyConfigRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return DeleteLiveAudioAuditNotifyConfigResponse
     */
    public function deleteLiveAudioAuditNotifyConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveAudioAuditNotifyConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveAudioAuditNotifyConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the configuration of callbacks for audio moderation results.
     *
     * @remarks
     *   Obtain the main streaming domain, and then call this operation to delete the configuration of callbacks for audio moderation results.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveAudioAuditNotifyConfigRequest
     *
     * @returns DeleteLiveAudioAuditNotifyConfigResponse
     *
     * @param DeleteLiveAudioAuditNotifyConfigRequest $request
     *
     * @return DeleteLiveAudioAuditNotifyConfigResponse
     */
    public function deleteLiveAudioAuditNotifyConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveAudioAuditNotifyConfigWithOptions($request, $runtime);
    }

    /**
     * Deletes a configuration of live center stream relay.
     *
     * @remarks
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveCenterTransferRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLiveCenterTransferResponse
     *
     * @param DeleteLiveCenterTransferRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DeleteLiveCenterTransferResponse
     */
    public function deleteLiveCenterTransferWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->dstUrl) {
            @$query['DstUrl'] = $request->dstUrl;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveCenterTransfer',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveCenterTransferResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a configuration of live center stream relay.
     *
     * @remarks
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveCenterTransferRequest
     *
     * @returns DeleteLiveCenterTransferResponse
     *
     * @param DeleteLiveCenterTransferRequest $request
     *
     * @return DeleteLiveCenterTransferResponse
     */
    public function deleteLiveCenterTransfer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveCenterTransferWithOptions($request, $runtime);
    }

    /**
     * Deletes a stream delay configuration.
     *
     * @remarks
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveDelayConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLiveDelayConfigResponse
     *
     * @param DeleteLiveDelayConfigRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DeleteLiveDelayConfigResponse
     */
    public function deleteLiveDelayConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->app) {
            @$query['App'] = $request->app;
        }

        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->stream) {
            @$query['Stream'] = $request->stream;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveDelayConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveDelayConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a stream delay configuration.
     *
     * @remarks
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveDelayConfigRequest
     *
     * @returns DeleteLiveDelayConfigResponse
     *
     * @param DeleteLiveDelayConfigRequest $request
     *
     * @return DeleteLiveDelayConfigResponse
     */
    public function deleteLiveDelayConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveDelayConfigWithOptions($request, $runtime);
    }

    /**
     * Deletes the configuration of callbacks for video moderation results.
     *
     * @remarks
     * ## [](#)Usage notes
     * *   Obtain the main streaming domain, and then call this operation to delete the configuration of callbacks for video moderation results.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveDetectNotifyConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLiveDetectNotifyConfigResponse
     *
     * @param DeleteLiveDetectNotifyConfigRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DeleteLiveDetectNotifyConfigResponse
     */
    public function deleteLiveDetectNotifyConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveDetectNotifyConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveDetectNotifyConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the configuration of callbacks for video moderation results.
     *
     * @remarks
     * ## [](#)Usage notes
     * *   Obtain the main streaming domain, and then call this operation to delete the configuration of callbacks for video moderation results.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveDetectNotifyConfigRequest
     *
     * @returns DeleteLiveDetectNotifyConfigResponse
     *
     * @param DeleteLiveDetectNotifyConfigRequest $request
     *
     * @return DeleteLiveDetectNotifyConfigResponse
     */
    public function deleteLiveDetectNotifyConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveDetectNotifyConfigWithOptions($request, $runtime);
    }

    /**
     * Removes a domain name from ApsaraVideo Live.
     *
     * @remarks
     *   After you successfully call the DeleteLiveDomain operation, all records of the specified domain name are deleted. Exercise caution when you perform this operation.
     * *   We recommend that you restore to an A record for the domain name at the DNS provider before you remove the domain name. Otherwise, the domain name may become inaccessible. If your domain name is registered with Alibaba Cloud, log on to the [Alibaba Cloud DNS console](https://account.aliyun.com/login/login.htm?oauth_callback=https%3A%2F%2Fdns.console.aliyun.com%2F%3Fspm%3Da2c4g.11186623.0.0.3cda841fcvk7Qs\\&lang=zh) and navigate to the **Domain Name Resolution** page. Find the domain name and then click **DNS Settings** in the Actions column. On the page that appears, change the CNAME record to an A record. If your domain name is registered with another DNS provider, configure similar settings on the platform of that DNS provider.
     * *   If you want to only suspend the use of the domain name, we recommend that you call the [StopLiveDomain](https://help.aliyun.com/document_detail/88329.html) operation.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DeleteLiveDomainRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLiveDomainResponse
     *
     * @param DeleteLiveDomainRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DeleteLiveDomainResponse
     */
    public function deleteLiveDomainWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveDomain',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveDomainResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Removes a domain name from ApsaraVideo Live.
     *
     * @remarks
     *   After you successfully call the DeleteLiveDomain operation, all records of the specified domain name are deleted. Exercise caution when you perform this operation.
     * *   We recommend that you restore to an A record for the domain name at the DNS provider before you remove the domain name. Otherwise, the domain name may become inaccessible. If your domain name is registered with Alibaba Cloud, log on to the [Alibaba Cloud DNS console](https://account.aliyun.com/login/login.htm?oauth_callback=https%3A%2F%2Fdns.console.aliyun.com%2F%3Fspm%3Da2c4g.11186623.0.0.3cda841fcvk7Qs\\&lang=zh) and navigate to the **Domain Name Resolution** page. Find the domain name and then click **DNS Settings** in the Actions column. On the page that appears, change the CNAME record to an A record. If your domain name is registered with another DNS provider, configure similar settings on the platform of that DNS provider.
     * *   If you want to only suspend the use of the domain name, we recommend that you call the [StopLiveDomain](https://help.aliyun.com/document_detail/88329.html) operation.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DeleteLiveDomainRequest
     *
     * @returns DeleteLiveDomainResponse
     *
     * @param DeleteLiveDomainRequest $request
     *
     * @return DeleteLiveDomainResponse
     */
    public function deleteLiveDomain($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveDomainWithOptions($request, $runtime);
    }

    /**
     * Deletes the mapping between a streaming domain and an ingest domain.
     *
     * @remarks
     * Make sure that the streaming domain has been mapped to the ingest domain before you call this operation to delete the mapping. For more information about how to map a streaming domain to an ingest domain, see [AddLiveDomainMapping](https://help.aliyun.com/document_detail/88782.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DeleteLiveDomainMappingRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLiveDomainMappingResponse
     *
     * @param DeleteLiveDomainMappingRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DeleteLiveDomainMappingResponse
     */
    public function deleteLiveDomainMappingWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pullDomain) {
            @$query['PullDomain'] = $request->pullDomain;
        }

        if (null !== $request->pushDomain) {
            @$query['PushDomain'] = $request->pushDomain;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveDomainMapping',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveDomainMappingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the mapping between a streaming domain and an ingest domain.
     *
     * @remarks
     * Make sure that the streaming domain has been mapped to the ingest domain before you call this operation to delete the mapping. For more information about how to map a streaming domain to an ingest domain, see [AddLiveDomainMapping](https://help.aliyun.com/document_detail/88782.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DeleteLiveDomainMappingRequest
     *
     * @returns DeleteLiveDomainMappingResponse
     *
     * @param DeleteLiveDomainMappingRequest $request
     *
     * @return DeleteLiveDomainMappingResponse
     */
    public function deleteLiveDomainMapping($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveDomainMappingWithOptions($request, $runtime);
    }

    /**
     * Deletes the mapping between a main streaming domain and a sub-streaming domain.
     *
     * @remarks
     * Before you call this operation, make sure that the mapping between the main streaming domain and the sub-streaming domain is created. For more information about how to call an operation to create the mapping between a main streaming domain and a sub-streaming domain, see [AddLiveDomainPlayMapping](https://help.aliyun.com/document_detail/173091.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveDomainPlayMappingRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLiveDomainPlayMappingResponse
     *
     * @param DeleteLiveDomainPlayMappingRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DeleteLiveDomainPlayMappingResponse
     */
    public function deleteLiveDomainPlayMappingWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->playDomain) {
            @$query['PlayDomain'] = $request->playDomain;
        }

        if (null !== $request->pullDomain) {
            @$query['PullDomain'] = $request->pullDomain;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveDomainPlayMapping',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveDomainPlayMappingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the mapping between a main streaming domain and a sub-streaming domain.
     *
     * @remarks
     * Before you call this operation, make sure that the mapping between the main streaming domain and the sub-streaming domain is created. For more information about how to call an operation to create the mapping between a main streaming domain and a sub-streaming domain, see [AddLiveDomainPlayMapping](https://help.aliyun.com/document_detail/173091.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveDomainPlayMappingRequest
     *
     * @returns DeleteLiveDomainPlayMappingResponse
     *
     * @param DeleteLiveDomainPlayMappingRequest $request
     *
     * @return DeleteLiveDomainPlayMappingResponse
     */
    public function deleteLiveDomainPlayMapping($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveDomainPlayMappingWithOptions($request, $runtime);
    }

    /**
     * Deletes the configuration of edge stream relay.
     *
     * @remarks
     * You can call the DeleteLiveEdgeTransfer operation to delete the configuration of edge stream relay for a specific domain name. Ingested streams that are already relayed based on the configuration are not affected. The following table describes the scenarios in which edge stream relay takes effect or not.
     * |Scenario|Analysis|Result|
     * |---|---|---|
     * |1\\. You ingest a stream after you call the SetLiveEdgeTransfer operation to configure edge stream relay. Then, you call the DeleteLiveEdgeTransfer operation to delete the configuration.|The configuration of edge stream relay is available when you ingest the stream.|The ingested stream is not affected, and stream relay is not interrupted.|
     * |2\\. You call the DeleteLiveEdgeTransfer operation to delete the configuration of edge stream relay after you ingest a stream. Then, you disconnect and resume the ingested stream.|The configuration of edge stream relay is not available after you resume the ingested stream.|Edge stream relay does not take effect.|
     * |3\\. You call the DeleteLiveEdgeTransfer operation before you ingest a stream.|The configuration of edge stream relay is not available.|Edge stream relay does not take effect.|
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveEdgeTransferRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLiveEdgeTransferResponse
     *
     * @param DeleteLiveEdgeTransferRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DeleteLiveEdgeTransferResponse
     */
    public function deleteLiveEdgeTransferWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveEdgeTransfer',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveEdgeTransferResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the configuration of edge stream relay.
     *
     * @remarks
     * You can call the DeleteLiveEdgeTransfer operation to delete the configuration of edge stream relay for a specific domain name. Ingested streams that are already relayed based on the configuration are not affected. The following table describes the scenarios in which edge stream relay takes effect or not.
     * |Scenario|Analysis|Result|
     * |---|---|---|
     * |1\\. You ingest a stream after you call the SetLiveEdgeTransfer operation to configure edge stream relay. Then, you call the DeleteLiveEdgeTransfer operation to delete the configuration.|The configuration of edge stream relay is available when you ingest the stream.|The ingested stream is not affected, and stream relay is not interrupted.|
     * |2\\. You call the DeleteLiveEdgeTransfer operation to delete the configuration of edge stream relay after you ingest a stream. Then, you disconnect and resume the ingested stream.|The configuration of edge stream relay is not available after you resume the ingested stream.|Edge stream relay does not take effect.|
     * |3\\. You call the DeleteLiveEdgeTransfer operation before you ingest a stream.|The configuration of edge stream relay is not available.|Edge stream relay does not take effect.|
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveEdgeTransferRequest
     *
     * @returns DeleteLiveEdgeTransferResponse
     *
     * @param DeleteLiveEdgeTransferRequest $request
     *
     * @return DeleteLiveEdgeTransferResponse
     */
    public function deleteLiveEdgeTransfer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveEdgeTransferWithOptions($request, $runtime);
    }

    /**
     * Deletes a configuration of triggered stream pulling.
     *
     * @remarks
     * This operation is application to triggered stream pulling. You can call this operation to delete a configuration of triggered stream pulling. If you set the AppName parameter to ali_all_app, configurations of triggered stream pulling for all applications under the domain name are deleted.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveLazyPullStreamInfoConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLiveLazyPullStreamInfoConfigResponse
     *
     * @param DeleteLiveLazyPullStreamInfoConfigRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return DeleteLiveLazyPullStreamInfoConfigResponse
     */
    public function deleteLiveLazyPullStreamInfoConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveLazyPullStreamInfoConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveLazyPullStreamInfoConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a configuration of triggered stream pulling.
     *
     * @remarks
     * This operation is application to triggered stream pulling. You can call this operation to delete a configuration of triggered stream pulling. If you set the AppName parameter to ali_all_app, configurations of triggered stream pulling for all applications under the domain name are deleted.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveLazyPullStreamInfoConfigRequest
     *
     * @returns DeleteLiveLazyPullStreamInfoConfigResponse
     *
     * @param DeleteLiveLazyPullStreamInfoConfigRequest $request
     *
     * @return DeleteLiveLazyPullStreamInfoConfigResponse
     */
    public function deleteLiveLazyPullStreamInfoConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveLazyPullStreamInfoConfigWithOptions($request, $runtime);
    }

    /**
     * Deletes an interactive messaging group.
     *
     * @remarks
     *   Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * *   After you delete an interactive messaging group, it is no longer available. Every user in the group is notified that the group is closed.
     * *   After you delete an interactive messaging group, messages in the group are retained for 30 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveMessageGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLiveMessageGroupResponse
     *
     * @param DeleteLiveMessageGroupRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DeleteLiveMessageGroupResponse
     */
    public function deleteLiveMessageGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->dataCenter) {
            @$query['DataCenter'] = $request->dataCenter;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        if (null !== $request->operatorId) {
            @$query['OperatorId'] = $request->operatorId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveMessageGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveMessageGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an interactive messaging group.
     *
     * @remarks
     *   Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * *   After you delete an interactive messaging group, it is no longer available. Every user in the group is notified that the group is closed.
     * *   After you delete an interactive messaging group, messages in the group are retained for 30 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveMessageGroupRequest
     *
     * @returns DeleteLiveMessageGroupResponse
     *
     * @param DeleteLiveMessageGroupRequest $request
     *
     * @return DeleteLiveMessageGroupResponse
     */
    public function deleteLiveMessageGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveMessageGroupWithOptions($request, $runtime);
    }

    /**
     * Deletes a message that was sent to an interactive messaging group.
     *
     * @remarks
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveMessageGroupMessageRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLiveMessageGroupMessageResponse
     *
     * @param DeleteLiveMessageGroupMessageRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DeleteLiveMessageGroupMessageResponse
     */
    public function deleteLiveMessageGroupMessageWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->dataCenter) {
            @$query['DataCenter'] = $request->dataCenter;
        }

        if (null !== $request->deleterId) {
            @$query['DeleterId'] = $request->deleterId;
        }

        if (null !== $request->deleterInfo) {
            @$query['DeleterInfo'] = $request->deleterInfo;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        if (null !== $request->messageId) {
            @$query['MessageId'] = $request->messageId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveMessageGroupMessage',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveMessageGroupMessageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a message that was sent to an interactive messaging group.
     *
     * @remarks
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveMessageGroupMessageRequest
     *
     * @returns DeleteLiveMessageGroupMessageResponse
     *
     * @param DeleteLiveMessageGroupMessageRequest $request
     *
     * @return DeleteLiveMessageGroupMessageResponse
     */
    public function deleteLiveMessageGroupMessage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveMessageGroupMessageWithOptions($request, $runtime);
    }

    /**
     * Deletes a message that is sent to a user.
     *
     * @remarks
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DeleteLiveMessageUserMessageRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLiveMessageUserMessageResponse
     *
     * @param DeleteLiveMessageUserMessageRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DeleteLiveMessageUserMessageResponse
     */
    public function deleteLiveMessageUserMessageWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->dataCenter) {
            @$query['DataCenter'] = $request->dataCenter;
        }

        if (null !== $request->deleterId) {
            @$query['DeleterId'] = $request->deleterId;
        }

        if (null !== $request->deleterInfo) {
            @$query['DeleterInfo'] = $request->deleterInfo;
        }

        if (null !== $request->messageId) {
            @$query['MessageId'] = $request->messageId;
        }

        if (null !== $request->receiverId) {
            @$query['ReceiverId'] = $request->receiverId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveMessageUserMessage',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveMessageUserMessageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a message that is sent to a user.
     *
     * @remarks
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DeleteLiveMessageUserMessageRequest
     *
     * @returns DeleteLiveMessageUserMessageResponse
     *
     * @param DeleteLiveMessageUserMessageRequest $request
     *
     * @return DeleteLiveMessageUserMessageResponse
     */
    public function deleteLiveMessageUserMessage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveMessageUserMessageWithOptions($request, $runtime);
    }

    /**
     * @remarks
     * You can call this operation to delete a live stream encapsulation configuration. The deletion takes effect after you re-ingest the stream.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLivePackageConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLivePackageConfigResponse
     *
     * @param DeleteLivePackageConfigRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DeleteLivePackageConfigResponse
     */
    public function deleteLivePackageConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLivePackageConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLivePackageConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @remarks
     * You can call this operation to delete a live stream encapsulation configuration. The deletion takes effect after you re-ingest the stream.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLivePackageConfigRequest
     *
     * @returns DeleteLivePackageConfigResponse
     *
     * @param DeleteLivePackageConfigRequest $request
     *
     * @return DeleteLivePackageConfigResponse
     */
    public function deleteLivePackageConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLivePackageConfigWithOptions($request, $runtime);
    }

    /**
     * Unbinds a Global Accelerator (GA) instance from an acceleration circuit.
     *
     * @remarks
     * After you unbind a GA instance from an acceleration circuit, your stream ingest and streaming are no longer accelerated by the GA instance. The GA instance still exists. If you want to release the GA instance, delete it in the GA console.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLivePrivateLineRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLivePrivateLineResponse
     *
     * @param DeleteLivePrivateLineRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DeleteLivePrivateLineResponse
     */
    public function deleteLivePrivateLineWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accelerationType) {
            @$query['AccelerationType'] = $request->accelerationType;
        }

        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLivePrivateLine',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLivePrivateLineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Unbinds a Global Accelerator (GA) instance from an acceleration circuit.
     *
     * @remarks
     * After you unbind a GA instance from an acceleration circuit, your stream ingest and streaming are no longer accelerated by the GA instance. The GA instance still exists. If you want to release the GA instance, delete it in the GA console.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLivePrivateLineRequest
     *
     * @returns DeleteLivePrivateLineResponse
     *
     * @param DeleteLivePrivateLineRequest $request
     *
     * @return DeleteLivePrivateLineResponse
     */
    public function deleteLivePrivateLine($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLivePrivateLineWithOptions($request, $runtime);
    }

    /**
     * Deletes a stream pulling configuration.
     *
     * @remarks
     * This operation is applicable to regular stream pulling. You can call this operation to delete a configuration of regular stream pulling.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLivePullStreamInfoConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLivePullStreamInfoConfigResponse
     *
     * @param DeleteLivePullStreamInfoConfigRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DeleteLivePullStreamInfoConfigResponse
     */
    public function deleteLivePullStreamInfoConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLivePullStreamInfoConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLivePullStreamInfoConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a stream pulling configuration.
     *
     * @remarks
     * This operation is applicable to regular stream pulling. You can call this operation to delete a configuration of regular stream pulling.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLivePullStreamInfoConfigRequest
     *
     * @returns DeleteLivePullStreamInfoConfigResponse
     *
     * @param DeleteLivePullStreamInfoConfigRequest $request
     *
     * @return DeleteLivePullStreamInfoConfigResponse
     */
    public function deleteLivePullStreamInfoConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLivePullStreamInfoConfigWithOptions($request, $runtime);
    }

    /**
     * Deletes a pulled-stream relay task.
     *
     * @remarks
     *   You can call this operation to delete a pulled-stream relay task.
     * *   If you delete a running task, the task is immediately stopped and cannot be restarted.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLivePullToPushRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLivePullToPushResponse
     *
     * @param DeleteLivePullToPushRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DeleteLivePullToPushResponse
     */
    public function deleteLivePullToPushWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLivePullToPush',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLivePullToPushResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a pulled-stream relay task.
     *
     * @remarks
     *   You can call this operation to delete a pulled-stream relay task.
     * *   If you delete a running task, the task is immediately stopped and cannot be restarted.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLivePullToPushRequest
     *
     * @returns DeleteLivePullToPushResponse
     *
     * @param DeleteLivePullToPushRequest $request
     *
     * @return DeleteLivePullToPushResponse
     */
    public function deleteLivePullToPush($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLivePullToPushWithOptions($request, $runtime);
    }

    /**
     * Deletes the Logstore that is specified by a configuration of real-time log delivery.
     *
     * @remarks
     *   You can call this operation to delete the Logstore that is specified by a configuration of real-time log delivery. Make sure that all parameters meet the requirements when you call this operation.
     * *   You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) operation to query the Project, Logstore, and Region parameters.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveRealTimeLogLogstoreRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLiveRealTimeLogLogstoreResponse
     *
     * @param DeleteLiveRealTimeLogLogstoreRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DeleteLiveRealTimeLogLogstoreResponse
     */
    public function deleteLiveRealTimeLogLogstoreWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveRealTimeLogLogstore',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveRealTimeLogLogstoreResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the Logstore that is specified by a configuration of real-time log delivery.
     *
     * @remarks
     *   You can call this operation to delete the Logstore that is specified by a configuration of real-time log delivery. Make sure that all parameters meet the requirements when you call this operation.
     * *   You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) operation to query the Project, Logstore, and Region parameters.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveRealTimeLogLogstoreRequest
     *
     * @returns DeleteLiveRealTimeLogLogstoreResponse
     *
     * @param DeleteLiveRealTimeLogLogstoreRequest $request
     *
     * @return DeleteLiveRealTimeLogLogstoreResponse
     */
    public function deleteLiveRealTimeLogLogstore($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveRealTimeLogLogstoreWithOptions($request, $runtime);
    }

    /**
     * Deletes the configurations of real-time log delivery for one or more domain names.
     *
     * @remarks
     *
     *  * *   This operation is applicable to only streaming domains. If you want to configure real-tome log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
     * *   You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) to query the Project, Logstore, and Region parameters.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveRealtimeLogDeliveryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLiveRealtimeLogDeliveryResponse
     *
     * @param DeleteLiveRealtimeLogDeliveryRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DeleteLiveRealtimeLogDeliveryResponse
     */
    public function deleteLiveRealtimeLogDeliveryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveRealtimeLogDelivery',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveRealtimeLogDeliveryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the configurations of real-time log delivery for one or more domain names.
     *
     * @remarks
     *
     *  * *   This operation is applicable to only streaming domains. If you want to configure real-tome log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
     * *   You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) to query the Project, Logstore, and Region parameters.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveRealtimeLogDeliveryRequest
     *
     * @returns DeleteLiveRealtimeLogDeliveryResponse
     *
     * @param DeleteLiveRealtimeLogDeliveryRequest $request
     *
     * @return DeleteLiveRealtimeLogDeliveryResponse
     */
    public function deleteLiveRealtimeLogDelivery($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveRealtimeLogDeliveryWithOptions($request, $runtime);
    }

    /**
     * Deletes the configuration of callbacks for live stream recording under a domain name.
     *
     * @remarks
     * Obtain the main streaming domain, and then call this operation to delete the configuration of callbacks for live stream recording under the main streaming domain.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveRecordNotifyConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLiveRecordNotifyConfigResponse
     *
     * @param DeleteLiveRecordNotifyConfigRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DeleteLiveRecordNotifyConfigResponse
     */
    public function deleteLiveRecordNotifyConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveRecordNotifyConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveRecordNotifyConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the configuration of callbacks for live stream recording under a domain name.
     *
     * @remarks
     * Obtain the main streaming domain, and then call this operation to delete the configuration of callbacks for live stream recording under the main streaming domain.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveRecordNotifyConfigRequest
     *
     * @returns DeleteLiveRecordNotifyConfigResponse
     *
     * @param DeleteLiveRecordNotifyConfigRequest $request
     *
     * @return DeleteLiveRecordNotifyConfigResponse
     */
    public function deleteLiveRecordNotifyConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveRecordNotifyConfigWithOptions($request, $runtime);
    }

    /**
     * Deletes a Live-to-VOD configuration.
     *
     * @remarks
     * Obtain the main streaming domain, and then call this operation to delete a Live-to-VOD configuration.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveRecordVodConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLiveRecordVodConfigResponse
     *
     * @param DeleteLiveRecordVodConfigRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DeleteLiveRecordVodConfigResponse
     */
    public function deleteLiveRecordVodConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveRecordVodConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveRecordVodConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a Live-to-VOD configuration.
     *
     * @remarks
     * Obtain the main streaming domain, and then call this operation to delete a Live-to-VOD configuration.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveRecordVodConfigRequest
     *
     * @returns DeleteLiveRecordVodConfigResponse
     *
     * @param DeleteLiveRecordVodConfigRequest $request
     *
     * @return DeleteLiveRecordVodConfigResponse
     */
    public function deleteLiveRecordVodConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveRecordVodConfigWithOptions($request, $runtime);
    }

    /**
     * Deletes a video moderation configuration.
     *
     * @remarks
     *   Obtain the main streaming domain, and then call this operation to delete a video moderation configuration.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveSnapshotDetectPornConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLiveSnapshotDetectPornConfigResponse
     *
     * @param DeleteLiveSnapshotDetectPornConfigRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return DeleteLiveSnapshotDetectPornConfigResponse
     */
    public function deleteLiveSnapshotDetectPornConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveSnapshotDetectPornConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveSnapshotDetectPornConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a video moderation configuration.
     *
     * @remarks
     *   Obtain the main streaming domain, and then call this operation to delete a video moderation configuration.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveSnapshotDetectPornConfigRequest
     *
     * @returns DeleteLiveSnapshotDetectPornConfigResponse
     *
     * @param DeleteLiveSnapshotDetectPornConfigRequest $request
     *
     * @return DeleteLiveSnapshotDetectPornConfigResponse
     */
    public function deleteLiveSnapshotDetectPornConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveSnapshotDetectPornConfigWithOptions($request, $runtime);
    }

    /**
     * Deletes the configuration of snapshot callbacks.
     *
     * @remarks
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveSnapshotNotifyConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLiveSnapshotNotifyConfigResponse
     *
     * @param DeleteLiveSnapshotNotifyConfigRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DeleteLiveSnapshotNotifyConfigResponse
     */
    public function deleteLiveSnapshotNotifyConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveSnapshotNotifyConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveSnapshotNotifyConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the configuration of snapshot callbacks.
     *
     * @remarks
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveSnapshotNotifyConfigRequest
     *
     * @returns DeleteLiveSnapshotNotifyConfigResponse
     *
     * @param DeleteLiveSnapshotNotifyConfigRequest $request
     *
     * @return DeleteLiveSnapshotNotifyConfigResponse
     */
    public function deleteLiveSnapshotNotifyConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveSnapshotNotifyConfigWithOptions($request, $runtime);
    }

    /**
     * Deletes domain configurations in the canary release environment.
     *
     * @remarks
     * ## [](#)Usage notes
     * Before you call this operation to delete a domain configuration in the canary release environment, you can call the [DescribeLiveDomainStagingConfig](https://help.aliyun.com/document_detail/297374.html) operation to obtain the configuration ID.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DeleteLiveSpecificStagingConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLiveSpecificStagingConfigResponse
     *
     * @param DeleteLiveSpecificStagingConfigRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return DeleteLiveSpecificStagingConfigResponse
     */
    public function deleteLiveSpecificStagingConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->configId) {
            @$query['ConfigId'] = $request->configId;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveSpecificStagingConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveSpecificStagingConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes domain configurations in the canary release environment.
     *
     * @remarks
     * ## [](#)Usage notes
     * Before you call this operation to delete a domain configuration in the canary release environment, you can call the [DescribeLiveDomainStagingConfig](https://help.aliyun.com/document_detail/297374.html) operation to obtain the configuration ID.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DeleteLiveSpecificStagingConfigRequest
     *
     * @returns DeleteLiveSpecificStagingConfigResponse
     *
     * @param DeleteLiveSpecificStagingConfigRequest $request
     *
     * @return DeleteLiveSpecificStagingConfigResponse
     */
    public function deleteLiveSpecificStagingConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveSpecificStagingConfigWithOptions($request, $runtime);
    }

    /**
     * Deletes a configuration of stream-level region blocking.
     *
     * @remarks
     * You can call this operation to delete a configuration of stream-level region blocking.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveStreamBlockRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLiveStreamBlockResponse
     *
     * @param DeleteLiveStreamBlockRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DeleteLiveStreamBlockResponse
     */
    public function deleteLiveStreamBlockWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveStreamBlock',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveStreamBlockResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a configuration of stream-level region blocking.
     *
     * @remarks
     * You can call this operation to delete a configuration of stream-level region blocking.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveStreamBlockRequest
     *
     * @returns DeleteLiveStreamBlockResponse
     *
     * @param DeleteLiveStreamBlockRequest $request
     *
     * @return DeleteLiveStreamBlockResponse
     */
    public function deleteLiveStreamBlock($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveStreamBlockWithOptions($request, $runtime);
    }

    /**
     * Deletes an active mixed stream.
     *
     * @remarks
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveStreamMergeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLiveStreamMergeResponse
     *
     * @param DeleteLiveStreamMergeRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DeleteLiveStreamMergeResponse
     */
    public function deleteLiveStreamMergeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveStreamMerge',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveStreamMergeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an active mixed stream.
     *
     * @remarks
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveStreamMergeRequest
     *
     * @returns DeleteLiveStreamMergeResponse
     *
     * @param DeleteLiveStreamMergeRequest $request
     *
     * @return DeleteLiveStreamMergeResponse
     */
    public function deleteLiveStreamMerge($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveStreamMergeWithOptions($request, $runtime);
    }

    /**
     * Deletes a monitoring session.
     *
     * @remarks
     * Before you call this operation, obtain the monitoring session ID from the response parameter **MonitorId** of the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation.
     * >  You cannot delete a monitoring session that is in the started state. If you try to delete it, a 400 error is reported.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveStreamMonitorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLiveStreamMonitorResponse
     *
     * @param DeleteLiveStreamMonitorRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DeleteLiveStreamMonitorResponse
     */
    public function deleteLiveStreamMonitorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->monitorId) {
            @$query['MonitorId'] = $request->monitorId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveStreamMonitor',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveStreamMonitorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a monitoring session.
     *
     * @remarks
     * Before you call this operation, obtain the monitoring session ID from the response parameter **MonitorId** of the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation.
     * >  You cannot delete a monitoring session that is in the started state. If you try to delete it, a 400 error is reported.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveStreamMonitorRequest
     *
     * @returns DeleteLiveStreamMonitorResponse
     *
     * @param DeleteLiveStreamMonitorRequest $request
     *
     * @return DeleteLiveStreamMonitorResponse
     */
    public function deleteLiveStreamMonitor($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveStreamMonitorWithOptions($request, $runtime);
    }

    /**
     * Deletes live stream recordings.
     *
     * @remarks
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveStreamRecordIndexFilesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLiveStreamRecordIndexFilesResponse
     *
     * @param DeleteLiveStreamRecordIndexFilesRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return DeleteLiveStreamRecordIndexFilesResponse
     */
    public function deleteLiveStreamRecordIndexFilesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->recordId) {
            @$query['RecordId'] = $request->recordId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->removeFile) {
            @$query['RemoveFile'] = $request->removeFile;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveStreamRecordIndexFiles',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveStreamRecordIndexFilesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes live stream recordings.
     *
     * @remarks
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveStreamRecordIndexFilesRequest
     *
     * @returns DeleteLiveStreamRecordIndexFilesResponse
     *
     * @param DeleteLiveStreamRecordIndexFilesRequest $request
     *
     * @return DeleteLiveStreamRecordIndexFilesResponse
     */
    public function deleteLiveStreamRecordIndexFiles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveStreamRecordIndexFilesWithOptions($request, $runtime);
    }

    /**
     * Deletes a transcoding configuration.
     *
     * @remarks
     * Standard transcoding templates, Narrowband HD™ transcoding templates, and custom transcoding templates are supported for this operation.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveStreamTranscodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLiveStreamTranscodeResponse
     *
     * @param DeleteLiveStreamTranscodeRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DeleteLiveStreamTranscodeResponse
     */
    public function deleteLiveStreamTranscodeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->app) {
            @$query['App'] = $request->app;
        }

        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        if (null !== $request->template) {
            @$query['Template'] = $request->template;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveStreamTranscode',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveStreamTranscodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a transcoding configuration.
     *
     * @remarks
     * Standard transcoding templates, Narrowband HD™ transcoding templates, and custom transcoding templates are supported for this operation.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveStreamTranscodeRequest
     *
     * @returns DeleteLiveStreamTranscodeResponse
     *
     * @param DeleteLiveStreamTranscodeRequest $request
     *
     * @return DeleteLiveStreamTranscodeResponse
     */
    public function deleteLiveStreamTranscode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveStreamTranscodeWithOptions($request, $runtime);
    }

    /**
     * Deletes a specified watermark template.
     *
     * @remarks
     * This interface supports deleting the watermark template with the specified TemplateId for live streaming.
     * ## QPS Limitation
     *  The per-user QPS limit for this interface is 60 times/second. Exceeding this limit will result in API throttling, which may impact your business operations. Please use it reasonably. For more information, please refer to [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DeleteLiveStreamWatermarkRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLiveStreamWatermarkResponse
     *
     * @param DeleteLiveStreamWatermarkRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DeleteLiveStreamWatermarkResponse
     */
    public function deleteLiveStreamWatermarkWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->templateId) {
            @$query['TemplateId'] = $request->templateId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveStreamWatermark',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveStreamWatermarkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a specified watermark template.
     *
     * @remarks
     * This interface supports deleting the watermark template with the specified TemplateId for live streaming.
     * ## QPS Limitation
     *  The per-user QPS limit for this interface is 60 times/second. Exceeding this limit will result in API throttling, which may impact your business operations. Please use it reasonably. For more information, please refer to [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DeleteLiveStreamWatermarkRequest
     *
     * @returns DeleteLiveStreamWatermarkResponse
     *
     * @param DeleteLiveStreamWatermarkRequest $request
     *
     * @return DeleteLiveStreamWatermarkResponse
     */
    public function deleteLiveStreamWatermark($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveStreamWatermarkWithOptions($request, $runtime);
    }

    /**
     * Deletes a watermark rule.
     *
     * @remarks
     * You can call this operation to delete a watermark rule with a specified ID.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveStreamWatermarkRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLiveStreamWatermarkRuleResponse
     *
     * @param DeleteLiveStreamWatermarkRuleRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DeleteLiveStreamWatermarkRuleResponse
     */
    public function deleteLiveStreamWatermarkRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->app) {
            @$query['App'] = $request->app;
        }

        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->ruleId) {
            @$query['RuleId'] = $request->ruleId;
        }

        if (null !== $request->stream) {
            @$query['Stream'] = $request->stream;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveStreamWatermarkRule',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveStreamWatermarkRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a watermark rule.
     *
     * @remarks
     * You can call this operation to delete a watermark rule with a specified ID.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveStreamWatermarkRuleRequest
     *
     * @returns DeleteLiveStreamWatermarkRuleResponse
     *
     * @param DeleteLiveStreamWatermarkRuleRequest $request
     *
     * @return DeleteLiveStreamWatermarkRuleResponse
     */
    public function deleteLiveStreamWatermarkRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveStreamWatermarkRuleWithOptions($request, $runtime);
    }

    /**
     * Deletes the callback configuration for stream ingest under an ingest domain.
     *
     * @remarks
     * Obtain the ingest domain, and then call this operation to delete the callback configuration for stream ingest under the ingest domain.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveStreamsNotifyUrlConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLiveStreamsNotifyUrlConfigResponse
     *
     * @param DeleteLiveStreamsNotifyUrlConfigRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return DeleteLiveStreamsNotifyUrlConfigResponse
     */
    public function deleteLiveStreamsNotifyUrlConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLiveStreamsNotifyUrlConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLiveStreamsNotifyUrlConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the callback configuration for stream ingest under an ingest domain.
     *
     * @remarks
     * Obtain the ingest domain, and then call this operation to delete the callback configuration for stream ingest under the ingest domain.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteLiveStreamsNotifyUrlConfigRequest
     *
     * @returns DeleteLiveStreamsNotifyUrlConfigResponse
     *
     * @param DeleteLiveStreamsNotifyUrlConfigRequest $request
     *
     * @return DeleteLiveStreamsNotifyUrlConfigResponse
     */
    public function deleteLiveStreamsNotifyUrlConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLiveStreamsNotifyUrlConfigWithOptions($request, $runtime);
    }

    /**
     * Deletes an interactive messaging application.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DeleteMessageAppRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteMessageAppResponse
     *
     * @param DeleteMessageAppRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DeleteMessageAppResponse
     */
    public function deleteMessageAppWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->appId) {
            @$body['AppId'] = $request->appId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'DeleteMessageApp',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteMessageAppResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an interactive messaging application.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DeleteMessageAppRequest
     *
     * @returns DeleteMessageAppResponse
     *
     * @param DeleteMessageAppRequest $request
     *
     * @return DeleteMessageAppResponse
     */
    public function deleteMessageApp($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteMessageAppWithOptions($request, $runtime);
    }

    /**
     * Deletes a stream mixing task.
     *
     * @remarks
     * You can call the [CreateMixStream](https://help.aliyun.com/document_detail/2848087.html) operation to create a stream mixing task and then call this operation to delete the stream mixing task. If you no longer need a mixed stream, be sure to delete it. Mixed streams that are not deleted are continuously ingested.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteMixStreamRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteMixStreamResponse
     *
     * @param DeleteMixStreamRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return DeleteMixStreamResponse
     */
    public function deleteMixStreamWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->mixStreamId) {
            @$query['MixStreamId'] = $request->mixStreamId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteMixStream',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteMixStreamResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a stream mixing task.
     *
     * @remarks
     * You can call the [CreateMixStream](https://help.aliyun.com/document_detail/2848087.html) operation to create a stream mixing task and then call this operation to delete the stream mixing task. If you no longer need a mixed stream, be sure to delete it. Mixed streams that are not deleted are continuously ingested.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteMixStreamRequest
     *
     * @returns DeleteMixStreamResponse
     *
     * @param DeleteMixStreamRequest $request
     *
     * @return DeleteMixStreamResponse
     */
    public function deleteMixStream($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteMixStreamWithOptions($request, $runtime);
    }

    /**
     * Deletes an episode list.
     *
     * @remarks
     * Before you call this operation to delete an episode list, make sure that you have called the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to create the episode list.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeletePlaylistRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeletePlaylistResponse
     *
     * @param DeletePlaylistRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return DeletePlaylistResponse
     */
    public function deletePlaylistWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->programId) {
            @$query['ProgramId'] = $request->programId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeletePlaylist',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeletePlaylistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an episode list.
     *
     * @remarks
     * Before you call this operation to delete an episode list, make sure that you have called the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to create the episode list.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeletePlaylistRequest
     *
     * @returns DeletePlaylistResponse
     *
     * @param DeletePlaylistRequest $request
     *
     * @return DeletePlaylistResponse
     */
    public function deletePlaylist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deletePlaylistWithOptions($request, $runtime);
    }

    /**
     * Removes episodes from an episode list.
     *
     * @remarks
     * Before you call this operation to remove an episode, make sure that you have called the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add the episode.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeletePlaylistItemsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeletePlaylistItemsResponse
     *
     * @param DeletePlaylistItemsRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DeletePlaylistItemsResponse
     */
    public function deletePlaylistItemsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->programId) {
            @$query['ProgramId'] = $request->programId;
        }

        if (null !== $request->programItemIds) {
            @$query['ProgramItemIds'] = $request->programItemIds;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeletePlaylistItems',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeletePlaylistItemsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Removes episodes from an episode list.
     *
     * @remarks
     * Before you call this operation to remove an episode, make sure that you have called the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add the episode.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeletePlaylistItemsRequest
     *
     * @returns DeletePlaylistItemsResponse
     *
     * @param DeletePlaylistItemsRequest $request
     *
     * @return DeletePlaylistItemsResponse
     */
    public function deletePlaylistItems($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deletePlaylistItemsWithOptions($request, $runtime);
    }

    /**
     * Deletes a live subtitle task.
     *
     * @remarks
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteRtcAsrTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteRtcAsrTaskResponse
     *
     * @param DeleteRtcAsrTaskRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DeleteRtcAsrTaskResponse
     */
    public function deleteRtcAsrTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteRtcAsrTask',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteRtcAsrTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a live subtitle task.
     *
     * @remarks
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteRtcAsrTaskRequest
     *
     * @returns DeleteRtcAsrTaskResponse
     *
     * @param DeleteRtcAsrTaskRequest $request
     *
     * @return DeleteRtcAsrTaskResponse
     */
    public function deleteRtcAsrTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteRtcAsrTaskWithOptions($request, $runtime);
    }

    /**
     * Deletes a subscription to mixed-stream relay events.
     *
     * @remarks
     *   You can call this operation to delete a subscription to mixed-stream relay events.
     * *   Before you call this operation, make sure that you have called the CreateRtcMPUEventSub operation to create the subscription.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DeleteRtcMPUEventSubRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteRtcMPUEventSubResponse
     *
     * @param DeleteRtcMPUEventSubRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DeleteRtcMPUEventSubResponse
     */
    public function deleteRtcMPUEventSubWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteRtcMPUEventSub',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteRtcMPUEventSubResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a subscription to mixed-stream relay events.
     *
     * @remarks
     *   You can call this operation to delete a subscription to mixed-stream relay events.
     * *   Before you call this operation, make sure that you have called the CreateRtcMPUEventSub operation to create the subscription.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DeleteRtcMPUEventSubRequest
     *
     * @returns DeleteRtcMPUEventSubResponse
     *
     * @param DeleteRtcMPUEventSubRequest $request
     *
     * @return DeleteRtcMPUEventSubResponse
     */
    public function deleteRtcMPUEventSub($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteRtcMPUEventSubWithOptions($request, $runtime);
    }

    /**
     * Deletes the configuration of authentication for snapshot callbacks.
     *
     * @remarks
     * You can call this operation to delete the configuration of authentication for snapshot callbacks for a main streaming domain. For an ongoing live stream, the deletion takes effect after you re-ingest the stream. Snapshot callbacks for the stream are no longer authenticated.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteSnapshotCallbackAuthRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteSnapshotCallbackAuthResponse
     *
     * @param DeleteSnapshotCallbackAuthRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DeleteSnapshotCallbackAuthResponse
     */
    public function deleteSnapshotCallbackAuthWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteSnapshotCallbackAuth',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteSnapshotCallbackAuthResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the configuration of authentication for snapshot callbacks.
     *
     * @remarks
     * You can call this operation to delete the configuration of authentication for snapshot callbacks for a main streaming domain. For an ongoing live stream, the deletion takes effect after you re-ingest the stream. Snapshot callbacks for the stream are no longer authenticated.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteSnapshotCallbackAuthRequest
     *
     * @returns DeleteSnapshotCallbackAuthResponse
     *
     * @param DeleteSnapshotCallbackAuthRequest $request
     *
     * @return DeleteSnapshotCallbackAuthResponse
     */
    public function deleteSnapshotCallbackAuth($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteSnapshotCallbackAuthWithOptions($request, $runtime);
    }

    /**
     * Deletes snapshots.
     *
     * @remarks
     * You can delete only snapshots that were captured in the last year.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteSnapshotFilesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteSnapshotFilesResponse
     *
     * @param DeleteSnapshotFilesRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DeleteSnapshotFilesResponse
     */
    public function deleteSnapshotFilesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->createTimestampList) {
            @$query['CreateTimestampList'] = $request->createTimestampList;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->removeFile) {
            @$query['RemoveFile'] = $request->removeFile;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteSnapshotFiles',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteSnapshotFilesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes snapshots.
     *
     * @remarks
     * You can delete only snapshots that were captured in the last year.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteSnapshotFilesRequest
     *
     * @returns DeleteSnapshotFilesResponse
     *
     * @param DeleteSnapshotFilesRequest $request
     *
     * @return DeleteSnapshotFilesResponse
     */
    public function deleteSnapshotFiles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteSnapshotFilesWithOptions($request, $runtime);
    }

    /**
     * Deletes a layout in a virtual studio.
     *
     * @remarks
     * You can call this operation to delete a layout in a virtual studio. You can delete only one layout in a call.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteStudioLayoutRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteStudioLayoutResponse
     *
     * @param DeleteStudioLayoutRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return DeleteStudioLayoutResponse
     */
    public function deleteStudioLayoutWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->layoutId) {
            @$query['LayoutId'] = $request->layoutId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteStudioLayout',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteStudioLayoutResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a layout in a virtual studio.
     *
     * @remarks
     * You can call this operation to delete a layout in a virtual studio. You can delete only one layout in a call.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DeleteStudioLayoutRequest
     *
     * @returns DeleteStudioLayoutResponse
     *
     * @param DeleteStudioLayoutRequest $request
     *
     * @return DeleteStudioLayoutResponse
     */
    public function deleteStudioLayout($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteStudioLayoutWithOptions($request, $runtime);
    }

    /**
     * Queries scheduled tasks that are used to start and stop playing an episode list at specified points in time.
     *
     * @remarks
     * You can call this operation to query scheduled tasks that are used to start and stop playing an episode list at specified points in time. Make sure that the parameter settings meet the requirements.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeAutoShowListTasksRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAutoShowListTasksResponse
     *
     * @param DescribeAutoShowListTasksRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeAutoShowListTasksResponse
     */
    public function describeAutoShowListTasksWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeAutoShowListTasks',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAutoShowListTasksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries scheduled tasks that are used to start and stop playing an episode list at specified points in time.
     *
     * @remarks
     * You can call this operation to query scheduled tasks that are used to start and stop playing an episode list at specified points in time. Make sure that the parameter settings meet the requirements.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeAutoShowListTasksRequest
     *
     * @returns DescribeAutoShowListTasksResponse
     *
     * @param DescribeAutoShowListTasksRequest $request
     *
     * @return DescribeAutoShowListTasksResponse
     */
    public function describeAutoShowListTasks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAutoShowListTasksWithOptions($request, $runtime);
    }

    /**
     * Queries the channels of a production studio.
     *
     * @remarks
     * You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to query the channels of the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeCasterChannelsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCasterChannelsResponse
     *
     * @param DescribeCasterChannelsRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DescribeCasterChannelsResponse
     */
    public function describeCasterChannelsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCasterChannels',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCasterChannelsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the channels of a production studio.
     *
     * @remarks
     * You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to query the channels of the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeCasterChannelsRequest
     *
     * @returns DescribeCasterChannelsResponse
     *
     * @param DescribeCasterChannelsRequest $request
     *
     * @return DescribeCasterChannelsResponse
     */
    public function describeCasterChannels($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCasterChannelsWithOptions($request, $runtime);
    }

    /**
     * Queries the components of a production studio.
     *
     * @remarks
     * You can call the [AddCasterComponent](https://help.aliyun.com/document_detail/2848030.html) operation to add components to a production studio and then call this operation to query the components of the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeCasterComponentsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCasterComponentsResponse
     *
     * @param DescribeCasterComponentsRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeCasterComponentsResponse
     */
    public function describeCasterComponentsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->componentId) {
            @$query['ComponentId'] = $request->componentId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCasterComponents',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCasterComponentsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the components of a production studio.
     *
     * @remarks
     * You can call the [AddCasterComponent](https://help.aliyun.com/document_detail/2848030.html) operation to add components to a production studio and then call this operation to query the components of the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeCasterComponentsRequest
     *
     * @returns DescribeCasterComponentsResponse
     *
     * @param DescribeCasterComponentsRequest $request
     *
     * @return DescribeCasterComponentsResponse
     */
    public function describeCasterComponents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCasterComponentsWithOptions($request, $runtime);
    }

    /**
     * Queries the configurations of a production studio.
     *
     * @remarks
     * You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to query the configurations of the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeCasterConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCasterConfigResponse
     *
     * @param DescribeCasterConfigRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DescribeCasterConfigResponse
     */
    public function describeCasterConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCasterConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCasterConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configurations of a production studio.
     *
     * @remarks
     * You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to query the configurations of the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeCasterConfigRequest
     *
     * @returns DescribeCasterConfigResponse
     *
     * @param DescribeCasterConfigRequest $request
     *
     * @return DescribeCasterConfigResponse
     */
    public function describeCasterConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCasterConfigWithOptions($request, $runtime);
    }

    /**
     * Queries a specified layout or all layouts of a production studio.
     *
     * @remarks
     * You can call this operation to query layouts of a production studio. If no layout ID is specified, the operation returns all layouts of the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeCasterLayoutsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCasterLayoutsResponse
     *
     * @param DescribeCasterLayoutsRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DescribeCasterLayoutsResponse
     */
    public function describeCasterLayoutsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->layoutId) {
            @$query['LayoutId'] = $request->layoutId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCasterLayouts',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCasterLayoutsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a specified layout or all layouts of a production studio.
     *
     * @remarks
     * You can call this operation to query layouts of a production studio. If no layout ID is specified, the operation returns all layouts of the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeCasterLayoutsRequest
     *
     * @returns DescribeCasterLayoutsResponse
     *
     * @param DescribeCasterLayoutsRequest $request
     *
     * @return DescribeCasterLayoutsResponse
     */
    public function describeCasterLayouts($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCasterLayoutsWithOptions($request, $runtime);
    }

    /**
     * Queries the information about the episode list for carousel playback in a production studio.
     *
     * @remarks
     * You can call this operation to query episodes in the episode list for carousel playback. The supported types of episodes include video resource and component.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeCasterProgramRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCasterProgramResponse
     *
     * @param DescribeCasterProgramRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DescribeCasterProgramResponse
     */
    public function describeCasterProgramWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->episodeId) {
            @$query['EpisodeId'] = $request->episodeId;
        }

        if (null !== $request->episodeType) {
            @$query['EpisodeType'] = $request->episodeType;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNum) {
            @$query['PageNum'] = $request->pageNum;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCasterProgram',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCasterProgramResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about the episode list for carousel playback in a production studio.
     *
     * @remarks
     * You can call this operation to query episodes in the episode list for carousel playback. The supported types of episodes include video resource and component.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeCasterProgramRequest
     *
     * @returns DescribeCasterProgramResponse
     *
     * @param DescribeCasterProgramRequest $request
     *
     * @return DescribeCasterProgramResponse
     */
    public function describeCasterProgram($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCasterProgramWithOptions($request, $runtime);
    }

    /**
     * Queries the audio configurations of a scene.
     *
     * @remarks
     * ## [](#)Usage notes
     * You can call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio and then call this operation to query the audio configurations of a scene in the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeCasterSceneAudioRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCasterSceneAudioResponse
     *
     * @param DescribeCasterSceneAudioRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeCasterSceneAudioResponse
     */
    public function describeCasterSceneAudioWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->sceneId) {
            @$query['SceneId'] = $request->sceneId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCasterSceneAudio',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCasterSceneAudioResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the audio configurations of a scene.
     *
     * @remarks
     * ## [](#)Usage notes
     * You can call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio and then call this operation to query the audio configurations of a scene in the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeCasterSceneAudioRequest
     *
     * @returns DescribeCasterSceneAudioResponse
     *
     * @param DescribeCasterSceneAudioRequest $request
     *
     * @return DescribeCasterSceneAudioResponse
     */
    public function describeCasterSceneAudio($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCasterSceneAudioWithOptions($request, $runtime);
    }

    /**
     * Queries the scenes of a production studio.
     *
     * @remarks
     * You can call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio and then call this operation to query the scenes of the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeCasterScenesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCasterScenesResponse
     *
     * @param DescribeCasterScenesRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DescribeCasterScenesResponse
     */
    public function describeCasterScenesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->sceneId) {
            @$query['SceneId'] = $request->sceneId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCasterScenes',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCasterScenesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the scenes of a production studio.
     *
     * @remarks
     * You can call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio and then call this operation to query the scenes of the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeCasterScenesRequest
     *
     * @returns DescribeCasterScenesResponse
     *
     * @param DescribeCasterScenesRequest $request
     *
     * @return DescribeCasterScenesResponse
     */
    public function describeCasterScenes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCasterScenesWithOptions($request, $runtime);
    }

    /**
     * Queries the streaming URLs of a production studio.
     *
     * @remarks
     * You must create a production studio before calling this operation to query the information.
     * ## QPS limit
     * A single user can perform a maximum of 15 queries per second (QPS). Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
     *
     * @param request - DescribeCasterStreamUrlRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCasterStreamUrlResponse
     *
     * @param DescribeCasterStreamUrlRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeCasterStreamUrlResponse
     */
    public function describeCasterStreamUrlWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCasterStreamUrl',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCasterStreamUrlResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the streaming URLs of a production studio.
     *
     * @remarks
     * You must create a production studio before calling this operation to query the information.
     * ## QPS limit
     * A single user can perform a maximum of 15 queries per second (QPS). Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
     *
     * @param request - DescribeCasterStreamUrlRequest
     *
     * @returns DescribeCasterStreamUrlResponse
     *
     * @param DescribeCasterStreamUrlRequest $request
     *
     * @return DescribeCasterStreamUrlResponse
     */
    public function describeCasterStreamUrl($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCasterStreamUrlWithOptions($request, $runtime);
    }

    /**
     * Queries the input sources of a production studio.
     *
     * @remarks
     * You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to query the input sources of the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeCasterVideoResourcesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCasterVideoResourcesResponse
     *
     * @param DescribeCasterVideoResourcesRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribeCasterVideoResourcesResponse
     */
    public function describeCasterVideoResourcesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCasterVideoResources',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCasterVideoResourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the input sources of a production studio.
     *
     * @remarks
     * You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to query the input sources of the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeCasterVideoResourcesRequest
     *
     * @returns DescribeCasterVideoResourcesResponse
     *
     * @param DescribeCasterVideoResourcesRequest $request
     *
     * @return DescribeCasterVideoResourcesResponse
     */
    public function describeCasterVideoResources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCasterVideoResourcesWithOptions($request, $runtime);
    }

    /**
     * Queries the list of production studios.
     *
     * @remarks
     * You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848012.html) operation to create a production studio and then call this operation to query the production studio list. The status of a production studio can be idle or streaming.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeCastersRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCastersResponse
     *
     * @param DescribeCastersRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return DescribeCastersResponse
     */
    public function describeCastersWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->casterName) {
            @$query['CasterName'] = $request->casterName;
        }

        if (null !== $request->chargeType) {
            @$query['ChargeType'] = $request->chargeType;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->normType) {
            @$query['NormType'] = $request->normType;
        }

        if (null !== $request->orderByModifyAsc) {
            @$query['OrderByModifyAsc'] = $request->orderByModifyAsc;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNum) {
            @$query['PageNum'] = $request->pageNum;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCasters',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCastersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the list of production studios.
     *
     * @remarks
     * You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848012.html) operation to create a production studio and then call this operation to query the production studio list. The status of a production studio can be idle or streaming.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeCastersRequest
     *
     * @returns DescribeCastersResponse
     *
     * @param DescribeCastersRequest $request
     *
     * @return DescribeCastersResponse
     */
    public function describeCasters($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCastersWithOptions($request, $runtime);
    }

    /**
     * Queries online users in a channel.
     *
     * @remarks
     * You can call this operation to query online users in a channel. The returned result does not include details about the users.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeChannelParticipantsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeChannelParticipantsResponse
     *
     * @param DescribeChannelParticipantsRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeChannelParticipantsResponse
     */
    public function describeChannelParticipantsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->channelId) {
            @$query['ChannelId'] = $request->channelId;
        }

        if (null !== $request->order) {
            @$query['Order'] = $request->order;
        }

        if (null !== $request->pageNum) {
            @$query['PageNum'] = $request->pageNum;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeChannelParticipants',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeChannelParticipantsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries online users in a channel.
     *
     * @remarks
     * You can call this operation to query online users in a channel. The returned result does not include details about the users.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeChannelParticipantsRequest
     *
     * @returns DescribeChannelParticipantsResponse
     *
     * @param DescribeChannelParticipantsRequest $request
     *
     * @return DescribeChannelParticipantsResponse
     */
    public function describeChannelParticipants($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeChannelParticipantsWithOptions($request, $runtime);
    }

    /**
     * Queries the details of online users in a channel.
     *
     * @remarks
     * You can call this operation to query information about online users in a channel, such as the total number of users during live streaming.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeChannelUsersRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeChannelUsersResponse
     *
     * @param DescribeChannelUsersRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DescribeChannelUsersResponse
     */
    public function describeChannelUsersWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->channelId) {
            @$query['ChannelId'] = $request->channelId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeChannelUsers',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeChannelUsersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of online users in a channel.
     *
     * @remarks
     * You can call this operation to query information about online users in a channel, such as the total number of users during live streaming.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeChannelUsersRequest
     *
     * @returns DescribeChannelUsersResponse
     *
     * @param DescribeChannelUsersRequest $request
     *
     * @return DescribeChannelUsersResponse
     */
    public function describeChannelUsers($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeChannelUsersWithOptions($request, $runtime);
    }

    /**
     * Queries the resource usage data of specific domain names in a specified billable region.
     *
     * @remarks
     * You can query the resource usage data of up to 100 domain names at a time. Separate multiple domain names with commas (,). If you do not specify the DomainName parameter, the resource usage data of all domain names within your Alibaba Cloud account is returned.
     * * The resource usage data includes network traffic that is measured in bytes, bandwidth that is measured in bit/s, and the number of requests.
     * * If you do not specify the Interval parameter, you can query the resource usage data in the last 12 months that spans a period of up to 31 days per call. If you specify a time range of 1 to 3 days in a call, the time interval between the entries that are returned is 1 hour. If you specify a time range of more than 3 days in a call, the time interval between the entries that are returned is 1 day.
     * * The following table describes the maximum time range per query, the time period within which historical data is available, and the data delay if you specify the Interval parameter.
     * |Time granularity|Maximum time range per query|Historical data available|Data delay|
     * |---|---|---|---|
     * |5 minutes|3 days|93 days|15 minutes|
     * |1 hour|31 days|186 days|4 hours|
     * |1 day|90 days|366 days|04:00 on the next day|
     * ## QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeDomainUsageDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDomainUsageDataResponse
     *
     * @param DescribeDomainUsageDataRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeDomainUsageDataResponse
     */
    public function describeDomainUsageDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->area) {
            @$query['Area'] = $request->area;
        }

        if (null !== $request->dataProtocol) {
            @$query['DataProtocol'] = $request->dataProtocol;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->field) {
            @$query['Field'] = $request->field;
        }

        if (null !== $request->interval) {
            @$query['Interval'] = $request->interval;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDomainUsageData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDomainUsageDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the resource usage data of specific domain names in a specified billable region.
     *
     * @remarks
     * You can query the resource usage data of up to 100 domain names at a time. Separate multiple domain names with commas (,). If you do not specify the DomainName parameter, the resource usage data of all domain names within your Alibaba Cloud account is returned.
     * * The resource usage data includes network traffic that is measured in bytes, bandwidth that is measured in bit/s, and the number of requests.
     * * If you do not specify the Interval parameter, you can query the resource usage data in the last 12 months that spans a period of up to 31 days per call. If you specify a time range of 1 to 3 days in a call, the time interval between the entries that are returned is 1 hour. If you specify a time range of more than 3 days in a call, the time interval between the entries that are returned is 1 day.
     * * The following table describes the maximum time range per query, the time period within which historical data is available, and the data delay if you specify the Interval parameter.
     * |Time granularity|Maximum time range per query|Historical data available|Data delay|
     * |---|---|---|---|
     * |5 minutes|3 days|93 days|15 minutes|
     * |1 hour|31 days|186 days|4 hours|
     * |1 day|90 days|366 days|04:00 on the next day|
     * ## QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeDomainUsageDataRequest
     *
     * @returns DescribeDomainUsageDataResponse
     *
     * @param DescribeDomainUsageDataRequest $request
     *
     * @return DescribeDomainUsageDataResponse
     */
    public function describeDomainUsageData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDomainUsageDataWithOptions($request, $runtime);
    }

    /**
     * Obtains domain integrity.
     *
     * @remarks
     * You can call this operation to obtain domain integrity.
     * ## [](#qps-)QPS limits
     * You can call this API operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeDomainWithIntegrityRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDomainWithIntegrityResponse
     *
     * @param DescribeDomainWithIntegrityRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeDomainWithIntegrityResponse
     */
    public function describeDomainWithIntegrityWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDomainWithIntegrity',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDomainWithIntegrityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Obtains domain integrity.
     *
     * @remarks
     * You can call this operation to obtain domain integrity.
     * ## [](#qps-)QPS limits
     * You can call this API operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeDomainWithIntegrityRequest
     *
     * @returns DescribeDomainWithIntegrityResponse
     *
     * @param DescribeDomainWithIntegrityRequest $request
     *
     * @return DescribeDomainWithIntegrityResponse
     */
    public function describeDomainWithIntegrity($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDomainWithIntegrityWithOptions($request, $runtime);
    }

    /**
     * Queries the information about HTTP Live Streaming (HLS) streams, such as the number of online users and bandwidth.
     *
     * @remarks
     * You can call this operation to query the information about HTTP Live Streaming (HLS) streams, such as the number of online users and bandwidth.
     * *   The number of online users for an HLS stream is counted based on the universally unique identifiers (UUIDs) of users that are placed after the M3U8 URL.
     * *   You can query the data of up to 100 domain names in a single request. If the DomainName parameter is left empty, the data of all domain names under the account is queried.
     *
     * @param request - DescribeHlsLiveStreamRealTimeBpsDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeHlsLiveStreamRealTimeBpsDataResponse
     *
     * @param DescribeHlsLiveStreamRealTimeBpsDataRequest $request
     * @param RuntimeOptions                              $runtime
     *
     * @return DescribeHlsLiveStreamRealTimeBpsDataResponse
     */
    public function describeHlsLiveStreamRealTimeBpsDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeHlsLiveStreamRealTimeBpsData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeHlsLiveStreamRealTimeBpsDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about HTTP Live Streaming (HLS) streams, such as the number of online users and bandwidth.
     *
     * @remarks
     * You can call this operation to query the information about HTTP Live Streaming (HLS) streams, such as the number of online users and bandwidth.
     * *   The number of online users for an HLS stream is counted based on the universally unique identifiers (UUIDs) of users that are placed after the M3U8 URL.
     * *   You can query the data of up to 100 domain names in a single request. If the DomainName parameter is left empty, the data of all domain names under the account is queried.
     *
     * @param request - DescribeHlsLiveStreamRealTimeBpsDataRequest
     *
     * @returns DescribeHlsLiveStreamRealTimeBpsDataResponse
     *
     * @param DescribeHlsLiveStreamRealTimeBpsDataRequest $request
     *
     * @return DescribeHlsLiveStreamRealTimeBpsDataResponse
     */
    public function describeHlsLiveStreamRealTimeBpsData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeHlsLiveStreamRealTimeBpsDataWithOptions($request, $runtime);
    }

    /**
     * Queries subtitle rules.
     *
     * @remarks
     * You can call this operation to query subtitle rules. Make sure that the parameter settings meet the requirements.
     * >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveAIProduceRulesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveAIProduceRulesResponse
     *
     * @param DescribeLiveAIProduceRulesRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeLiveAIProduceRulesResponse
     */
    public function describeLiveAIProduceRulesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->app) {
            @$query['App'] = $request->app;
        }

        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->rulesId) {
            @$query['RulesId'] = $request->rulesId;
        }

        if (null !== $request->suffixName) {
            @$query['SuffixName'] = $request->suffixName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveAIProduceRules',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveAIProduceRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries subtitle rules.
     *
     * @remarks
     * You can call this operation to query subtitle rules. Make sure that the parameter settings meet the requirements.
     * >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveAIProduceRulesRequest
     *
     * @returns DescribeLiveAIProduceRulesResponse
     *
     * @param DescribeLiveAIProduceRulesRequest $request
     *
     * @return DescribeLiveAIProduceRulesResponse
     */
    public function describeLiveAIProduceRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveAIProduceRulesWithOptions($request, $runtime);
    }

    /**
     * Queries the virtual studio templates within your Alibaba Cloud account.
     *
     * @param request - DescribeLiveAIStudioRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveAIStudioResponse
     *
     * @param DescribeLiveAIStudioRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DescribeLiveAIStudioResponse
     */
    public function describeLiveAIStudioWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->studioId) {
            @$query['StudioId'] = $request->studioId;
        }

        if (null !== $request->studioName) {
            @$query['StudioName'] = $request->studioName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveAIStudio',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveAIStudioResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the virtual studio templates within your Alibaba Cloud account.
     *
     * @param request - DescribeLiveAIStudioRequest
     *
     * @returns DescribeLiveAIStudioResponse
     *
     * @param DescribeLiveAIStudioRequest $request
     *
     * @return DescribeLiveAIStudioResponse
     */
    public function describeLiveAIStudio($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveAIStudioWithOptions($request, $runtime);
    }

    /**
     * Queries subtitle templates.
     *
     * @remarks
     * This interface supports querying the list of subtitle template information with specified pagination parameters. Ensure that the parameter settings meet the requirements when calling.
     * >Notice: The real-time subtitle function is currently in the beta testing phase, and each user can add up to 300 subtitle templates.
     * ## QPS Limit
     * The QPS limit for this interface per user is 60 times/second. Exceeding this limit will result in API calls being throttled, which may impact your business operations. Please use it reasonably. For more information, refer to [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveAISubtitleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveAISubtitleResponse
     *
     * @param DescribeLiveAISubtitleRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DescribeLiveAISubtitleResponse
     */
    public function describeLiveAISubtitleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->isDefault) {
            @$query['IsDefault'] = $request->isDefault;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->subtitleId) {
            @$query['SubtitleId'] = $request->subtitleId;
        }

        if (null !== $request->subtitleName) {
            @$query['SubtitleName'] = $request->subtitleName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveAISubtitle',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveAISubtitleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries subtitle templates.
     *
     * @remarks
     * This interface supports querying the list of subtitle template information with specified pagination parameters. Ensure that the parameter settings meet the requirements when calling.
     * >Notice: The real-time subtitle function is currently in the beta testing phase, and each user can add up to 300 subtitle templates.
     * ## QPS Limit
     * The QPS limit for this interface per user is 60 times/second. Exceeding this limit will result in API calls being throttled, which may impact your business operations. Please use it reasonably. For more information, refer to [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveAISubtitleRequest
     *
     * @returns DescribeLiveAISubtitleResponse
     *
     * @param DescribeLiveAISubtitleRequest $request
     *
     * @return DescribeLiveAISubtitleResponse
     */
    public function describeLiveAISubtitle($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveAISubtitleWithOptions($request, $runtime);
    }

    /**
     * Queries audio moderation configurations.
     *
     * @remarks
     *   Obtain the main streaming domain, and then call this operation to query audio moderation configurations.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveAudioAuditConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveAudioAuditConfigResponse
     *
     * @param DescribeLiveAudioAuditConfigRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribeLiveAudioAuditConfigResponse
     */
    public function describeLiveAudioAuditConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveAudioAuditConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveAudioAuditConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries audio moderation configurations.
     *
     * @remarks
     *   Obtain the main streaming domain, and then call this operation to query audio moderation configurations.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveAudioAuditConfigRequest
     *
     * @returns DescribeLiveAudioAuditConfigResponse
     *
     * @param DescribeLiveAudioAuditConfigRequest $request
     *
     * @return DescribeLiveAudioAuditConfigResponse
     */
    public function describeLiveAudioAuditConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveAudioAuditConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the configuration of callbacks for audio moderation results.
     *
     * @remarks
     *   Obtain the main streaming domain, and then call this operation to query the configuration of callbacks for audio moderation results.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveAudioAuditNotifyConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveAudioAuditNotifyConfigResponse
     *
     * @param DescribeLiveAudioAuditNotifyConfigRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return DescribeLiveAudioAuditNotifyConfigResponse
     */
    public function describeLiveAudioAuditNotifyConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveAudioAuditNotifyConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveAudioAuditNotifyConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configuration of callbacks for audio moderation results.
     *
     * @remarks
     *   Obtain the main streaming domain, and then call this operation to query the configuration of callbacks for audio moderation results.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveAudioAuditNotifyConfigRequest
     *
     * @returns DescribeLiveAudioAuditNotifyConfigResponse
     *
     * @param DescribeLiveAudioAuditNotifyConfigRequest $request
     *
     * @return DescribeLiveAudioAuditNotifyConfigResponse
     */
    public function describeLiveAudioAuditNotifyConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveAudioAuditNotifyConfigWithOptions($request, $runtime);
    }

    /**
     * @param request - DescribeLiveCdnDiagnoseInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveCdnDiagnoseInfoResponse
     *
     * @param DescribeLiveCdnDiagnoseInfoRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeLiveCdnDiagnoseInfoResponse
     */
    public function describeLiveCdnDiagnoseInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        if (null !== $request->app) {
            @$query['app'] = $request->app;
        }

        if (null !== $request->domain) {
            @$query['domain'] = $request->domain;
        }

        if (null !== $request->endTime) {
            @$query['endTime'] = $request->endTime;
        }

        if (null !== $request->intervalType) {
            @$query['intervalType'] = $request->intervalType;
        }

        if (null !== $request->phase) {
            @$query['phase'] = $request->phase;
        }

        if (null !== $request->requestType) {
            @$query['requestType'] = $request->requestType;
        }

        if (null !== $request->startTime) {
            @$query['startTime'] = $request->startTime;
        }

        if (null !== $request->streamName) {
            @$query['streamName'] = $request->streamName;
        }

        if (null !== $request->streamSuffix) {
            @$query['streamSuffix'] = $request->streamSuffix;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveCdnDiagnoseInfo',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveCdnDiagnoseInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param request - DescribeLiveCdnDiagnoseInfoRequest
     *
     * @returns DescribeLiveCdnDiagnoseInfoResponse
     *
     * @param DescribeLiveCdnDiagnoseInfoRequest $request
     *
     * @return DescribeLiveCdnDiagnoseInfoResponse
     */
    public function describeLiveCdnDiagnoseInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveCdnDiagnoseInfoWithOptions($request, $runtime);
    }

    /**
     * Queries the audio and video frame rates and bitrates of a stream in a live center.
     *
     * @remarks
     * The time granularity for the returned data is 5 seconds. The maximum time range to query is 3 hours. You can query data in the last 30 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveCenterStreamRateDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveCenterStreamRateDataResponse
     *
     * @param DescribeLiveCenterStreamRateDataRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return DescribeLiveCenterStreamRateDataResponse
     */
    public function describeLiveCenterStreamRateDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveCenterStreamRateData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveCenterStreamRateDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the audio and video frame rates and bitrates of a stream in a live center.
     *
     * @remarks
     * The time granularity for the returned data is 5 seconds. The maximum time range to query is 3 hours. You can query data in the last 30 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveCenterStreamRateDataRequest
     *
     * @returns DescribeLiveCenterStreamRateDataResponse
     *
     * @param DescribeLiveCenterStreamRateDataRequest $request
     *
     * @return DescribeLiveCenterStreamRateDataResponse
     */
    public function describeLiveCenterStreamRateData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveCenterStreamRateDataWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a configuration of live center stream relay.
     *
     * @remarks
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveCenterTransferRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveCenterTransferResponse
     *
     * @param DescribeLiveCenterTransferRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeLiveCenterTransferResponse
     */
    public function describeLiveCenterTransferWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->dstUrl) {
            @$query['DstUrl'] = $request->dstUrl;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveCenterTransfer',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveCenterTransferResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a configuration of live center stream relay.
     *
     * @remarks
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveCenterTransferRequest
     *
     * @returns DescribeLiveCenterTransferResponse
     *
     * @param DescribeLiveCenterTransferRequest $request
     *
     * @return DescribeLiveCenterTransferResponse
     */
    public function describeLiveCenterTransfer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveCenterTransferWithOptions($request, $runtime);
    }

    /**
     * Queries the details of a certificate.
     *
     * @remarks
     * You can obtain the certificate name on the [Certificates](https://help.aliyun.com/document_detail/2584962.html) page of the ApsaraVideo Live console and then call this operation to query the certificate details.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveCertificateDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveCertificateDetailResponse
     *
     * @param DescribeLiveCertificateDetailRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DescribeLiveCertificateDetailResponse
     */
    public function describeLiveCertificateDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->certName) {
            @$query['CertName'] = $request->certName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveCertificateDetail',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveCertificateDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of a certificate.
     *
     * @remarks
     * You can obtain the certificate name on the [Certificates](https://help.aliyun.com/document_detail/2584962.html) page of the ApsaraVideo Live console and then call this operation to query the certificate details.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveCertificateDetailRequest
     *
     * @returns DescribeLiveCertificateDetailResponse
     *
     * @param DescribeLiveCertificateDetailRequest $request
     *
     * @return DescribeLiveCertificateDetailResponse
     */
    public function describeLiveCertificateDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveCertificateDetailWithOptions($request, $runtime);
    }

    /**
     * Queries the certificates of one or more specified domain names or all certificates within your Alibaba Cloud account.
     *
     * @remarks
     * If you specify one or more domain names in the request, the certificates of the domain names are returned. If you do not specify a domain name in the request, all certificates within your Alibaba Cloud account are returned.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveCertificateListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveCertificateListResponse
     *
     * @param DescribeLiveCertificateListRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeLiveCertificateListResponse
     */
    public function describeLiveCertificateListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveCertificateList',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveCertificateListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the certificates of one or more specified domain names or all certificates within your Alibaba Cloud account.
     *
     * @remarks
     * If you specify one or more domain names in the request, the certificates of the domain names are returned. If you do not specify a domain name in the request, all certificates within your Alibaba Cloud account are returned.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveCertificateListRequest
     *
     * @returns DescribeLiveCertificateListResponse
     *
     * @param DescribeLiveCertificateListRequest $request
     *
     * @return DescribeLiveCertificateListResponse
     */
    public function describeLiveCertificateList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveCertificateListWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a stream delay configuration.
     *
     * @remarks
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveDelayConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDelayConfigResponse
     *
     * @param DescribeLiveDelayConfigRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeLiveDelayConfigResponse
     */
    public function describeLiveDelayConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->app) {
            @$query['App'] = $request->app;
        }

        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->stream) {
            @$query['Stream'] = $request->stream;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDelayConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDelayConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a stream delay configuration.
     *
     * @remarks
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveDelayConfigRequest
     *
     * @returns DescribeLiveDelayConfigResponse
     *
     * @param DescribeLiveDelayConfigRequest $request
     *
     * @return DescribeLiveDelayConfigResponse
     */
    public function describeLiveDelayConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDelayConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the stream delay usage data.
     *
     * @remarks
     *   You can call this operation to query your stream delay usage data. The default time granularity is 1 hour.
     * *   The maximum time range for a query is 31 days.
     * *   The minimum time granularity for a query is 1 hour.
     * *   You can query the data in the last 31 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDelayedStreamingUsageRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDelayedStreamingUsageResponse
     *
     * @param DescribeLiveDelayedStreamingUsageRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return DescribeLiveDelayedStreamingUsageResponse
     */
    public function describeLiveDelayedStreamingUsageWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->interval) {
            @$query['Interval'] = $request->interval;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->region) {
            @$query['Region'] = $request->region;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->splitBy) {
            @$query['SplitBy'] = $request->splitBy;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDelayedStreamingUsage',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDelayedStreamingUsageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the stream delay usage data.
     *
     * @remarks
     *   You can call this operation to query your stream delay usage data. The default time granularity is 1 hour.
     * *   The maximum time range for a query is 31 days.
     * *   The minimum time granularity for a query is 1 hour.
     * *   You can query the data in the last 31 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDelayedStreamingUsageRequest
     *
     * @returns DescribeLiveDelayedStreamingUsageResponse
     *
     * @param DescribeLiveDelayedStreamingUsageRequest $request
     *
     * @return DescribeLiveDelayedStreamingUsageResponse
     */
    public function describeLiveDelayedStreamingUsage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDelayedStreamingUsageWithOptions($request, $runtime);
    }

    /**
     * Queries the configuration of callbacks for video moderation results.
     *
     * @remarks
     *   Obtain the main streaming domain, and then call this operation to query the configuration of callbacks for video moderation results.
     * *   Only some live centers support the automated review feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
     *
     * @param request - DescribeLiveDetectNotifyConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDetectNotifyConfigResponse
     *
     * @param DescribeLiveDetectNotifyConfigRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DescribeLiveDetectNotifyConfigResponse
     */
    public function describeLiveDetectNotifyConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDetectNotifyConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDetectNotifyConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configuration of callbacks for video moderation results.
     *
     * @remarks
     *   Obtain the main streaming domain, and then call this operation to query the configuration of callbacks for video moderation results.
     * *   Only some live centers support the automated review feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
     *
     * @param request - DescribeLiveDetectNotifyConfigRequest
     *
     * @returns DescribeLiveDetectNotifyConfigResponse
     *
     * @param DescribeLiveDetectNotifyConfigRequest $request
     *
     * @return DescribeLiveDetectNotifyConfigResponse
     */
    public function describeLiveDetectNotifyConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDetectNotifyConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the usage data of content moderation.
     *
     * @remarks
     *   The minimum data granularity is 5 minutes. If you do not specify the `StartTime` parameter, data in the last 24 hours is queried.
     * *   You can query data in the last 90 days.
     * *   You can call this operation to query the bandwidth at each interval.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDetectPornDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDetectPornDataResponse
     *
     * @param DescribeLiveDetectPornDataRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeLiveDetectPornDataResponse
     */
    public function describeLiveDetectPornDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->app) {
            @$query['App'] = $request->app;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->fee) {
            @$query['Fee'] = $request->fee;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->region) {
            @$query['Region'] = $request->region;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->scene) {
            @$query['Scene'] = $request->scene;
        }

        if (null !== $request->splitBy) {
            @$query['SplitBy'] = $request->splitBy;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->stream) {
            @$query['Stream'] = $request->stream;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDetectPornData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDetectPornDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the usage data of content moderation.
     *
     * @remarks
     *   The minimum data granularity is 5 minutes. If you do not specify the `StartTime` parameter, data in the last 24 hours is queried.
     * *   You can query data in the last 90 days.
     * *   You can call this operation to query the bandwidth at each interval.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDetectPornDataRequest
     *
     * @returns DescribeLiveDetectPornDataResponse
     *
     * @param DescribeLiveDetectPornDataRequest $request
     *
     * @return DescribeLiveDetectPornDataResponse
     */
    public function describeLiveDetectPornData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDetectPornDataWithOptions($request, $runtime);
    }

    /**
     * Queries the bandwidth data for one or more streaming domains.
     *
     * @remarks
     *   You can specify both the StartTime and EndTime parameters to query the data in the specified period of time. If you do not specify the StartTime and EndTime parameters, the data of the last hour is queried by default.
     * *   If you specify only the StartTime parameter but not the EndTime parameter, the data of the hour following the specified start time is queried.
     * *   If you specify only the EndTime parameter but not the StartTime parameter, the data of the hour preceding the specified end time is queried.
     * *   You can query the data in the last 90 days.
     * *   This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainBpsDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDomainBpsDataResponse
     *
     * @param DescribeLiveDomainBpsDataRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeLiveDomainBpsDataResponse
     */
    public function describeLiveDomainBpsDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->interval) {
            @$query['Interval'] = $request->interval;
        }

        if (null !== $request->ispNameEn) {
            @$query['IspNameEn'] = $request->ispNameEn;
        }

        if (null !== $request->locationNameEn) {
            @$query['LocationNameEn'] = $request->locationNameEn;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainBpsData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainBpsDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the bandwidth data for one or more streaming domains.
     *
     * @remarks
     *   You can specify both the StartTime and EndTime parameters to query the data in the specified period of time. If you do not specify the StartTime and EndTime parameters, the data of the last hour is queried by default.
     * *   If you specify only the StartTime parameter but not the EndTime parameter, the data of the hour following the specified start time is queried.
     * *   If you specify only the EndTime parameter but not the StartTime parameter, the data of the hour preceding the specified end time is queried.
     * *   You can query the data in the last 90 days.
     * *   This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainBpsDataRequest
     *
     * @returns DescribeLiveDomainBpsDataResponse
     *
     * @param DescribeLiveDomainBpsDataRequest $request
     *
     * @return DescribeLiveDomainBpsDataResponse
     */
    public function describeLiveDomainBpsData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainBpsDataWithOptions($request, $runtime);
    }

    /**
     * Queries the bandwidth and traffic data by protocol for one or more domain names.
     *
     * @remarks
     * You can query data in the last 90 days. You can specify up to 500 domain names. Separate multiple domain names with commas (,). The data of multiple domain names is aggregated and returned. The following section describes the time granularities of the data entries returned depending on the time range specified by the **StartTime** and **EndTime** parameters:
     * *   If the time range is smaller than or equal to 3 days, the time granularity is 5 minutes.
     * *   If the time range is larger than 3 days but smaller than or equal to 31 days, the time granularity is 1 hour.
     * *   If the time range is larger than 31 days, the time granularity is 1 day.
     * >  If neither the **StartTime** nor the **EndTime** parameter is specified, the data of the last 24 hours is returned.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainBpsDataByLayerRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDomainBpsDataByLayerResponse
     *
     * @param DescribeLiveDomainBpsDataByLayerRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return DescribeLiveDomainBpsDataByLayerResponse
     */
    public function describeLiveDomainBpsDataByLayerWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->interval) {
            @$query['Interval'] = $request->interval;
        }

        if (null !== $request->ispNameEn) {
            @$query['IspNameEn'] = $request->ispNameEn;
        }

        if (null !== $request->layer) {
            @$query['Layer'] = $request->layer;
        }

        if (null !== $request->locationNameEn) {
            @$query['LocationNameEn'] = $request->locationNameEn;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainBpsDataByLayer',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainBpsDataByLayerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the bandwidth and traffic data by protocol for one or more domain names.
     *
     * @remarks
     * You can query data in the last 90 days. You can specify up to 500 domain names. Separate multiple domain names with commas (,). The data of multiple domain names is aggregated and returned. The following section describes the time granularities of the data entries returned depending on the time range specified by the **StartTime** and **EndTime** parameters:
     * *   If the time range is smaller than or equal to 3 days, the time granularity is 5 minutes.
     * *   If the time range is larger than 3 days but smaller than or equal to 31 days, the time granularity is 1 hour.
     * *   If the time range is larger than 31 days, the time granularity is 1 day.
     * >  If neither the **StartTime** nor the **EndTime** parameter is specified, the data of the last 24 hours is returned.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainBpsDataByLayerRequest
     *
     * @returns DescribeLiveDomainBpsDataByLayerResponse
     *
     * @param DescribeLiveDomainBpsDataByLayerRequest $request
     *
     * @return DescribeLiveDomainBpsDataByLayerResponse
     */
    public function describeLiveDomainBpsDataByLayer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainBpsDataByLayerWithOptions($request, $runtime);
    }

    /**
     * Queries the accelerated domain names that match a certificate.
     *
     * @remarks
     * You can call this operation to query the accelerated domain names that match a certificate.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainByCertificateRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDomainByCertificateResponse
     *
     * @param DescribeLiveDomainByCertificateRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return DescribeLiveDomainByCertificateResponse
     */
    public function describeLiveDomainByCertificateWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->SSLPub) {
            @$query['SSLPub'] = $request->SSLPub;
        }

        if (null !== $request->SSLStatus) {
            @$query['SSLStatus'] = $request->SSLStatus;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainByCertificate',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainByCertificateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the accelerated domain names that match a certificate.
     *
     * @remarks
     * You can call this operation to query the accelerated domain names that match a certificate.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainByCertificateRequest
     *
     * @returns DescribeLiveDomainByCertificateResponse
     *
     * @param DescribeLiveDomainByCertificateRequest $request
     *
     * @return DescribeLiveDomainByCertificateResponse
     */
    public function describeLiveDomainByCertificate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainByCertificateWithOptions($request, $runtime);
    }

    /**
     * Queries certificate information about a domain name.
     *
     * @remarks
     * Obtain a domain name, and then call this operation to query certificate information about the domain name.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainCertificateInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDomainCertificateInfoResponse
     *
     * @param DescribeLiveDomainCertificateInfoRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return DescribeLiveDomainCertificateInfoResponse
     */
    public function describeLiveDomainCertificateInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainCertificateInfo',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainCertificateInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries certificate information about a domain name.
     *
     * @remarks
     * Obtain a domain name, and then call this operation to query certificate information about the domain name.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainCertificateInfoRequest
     *
     * @returns DescribeLiveDomainCertificateInfoResponse
     *
     * @param DescribeLiveDomainCertificateInfoRequest $request
     *
     * @return DescribeLiveDomainCertificateInfoResponse
     */
    public function describeLiveDomainCertificateInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainCertificateInfoWithOptions($request, $runtime);
    }

    /**
     * Queries one or more configurations of a domain name.
     *
     * @remarks
     * You can call this operation to query multiple configurations at a time.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainConfigsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDomainConfigsResponse
     *
     * @param DescribeLiveDomainConfigsRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeLiveDomainConfigsResponse
     */
    public function describeLiveDomainConfigsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->functionNames) {
            @$query['FunctionNames'] = $request->functionNames;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainConfigs',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainConfigsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries one or more configurations of a domain name.
     *
     * @remarks
     * You can call this operation to query multiple configurations at a time.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainConfigsRequest
     *
     * @returns DescribeLiveDomainConfigsResponse
     *
     * @param DescribeLiveDomainConfigsRequest $request
     *
     * @return DescribeLiveDomainConfigsResponse
     */
    public function describeLiveDomainConfigs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainConfigsWithOptions($request, $runtime);
    }

    /**
     * Queries the basic information about a domain name.
     *
     * @remarks
     * ## [](#)Usage notes
     * You can call this operation to query the basic information about an ingest domain or a streaming domain. If you want to query a newly added domain name, wait a few minutes until the configuration of the domain name is completed in ApsaraVideo Live.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveDomainDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDomainDetailResponse
     *
     * @param DescribeLiveDomainDetailRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeLiveDomainDetailResponse
     */
    public function describeLiveDomainDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainDetail',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the basic information about a domain name.
     *
     * @remarks
     * ## [](#)Usage notes
     * You can call this operation to query the basic information about an ingest domain or a streaming domain. If you want to query a newly added domain name, wait a few minutes until the configuration of the domain name is completed in ApsaraVideo Live.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveDomainDetailRequest
     *
     * @returns DescribeLiveDomainDetailResponse
     *
     * @param DescribeLiveDomainDetailRequest $request
     *
     * @return DescribeLiveDomainDetailResponse
     */
    public function describeLiveDomainDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainDetailWithOptions($request, $runtime);
    }

    /**
     * 直播离线日志查询地址
     *
     * @param request - DescribeLiveDomainEdgeLogRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDomainEdgeLogResponse
     *
     * @param DescribeLiveDomainEdgeLogRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeLiveDomainEdgeLogResponse
     */
    public function describeLiveDomainEdgeLogWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainEdgeLog',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainEdgeLogResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 直播离线日志查询地址
     *
     * @param request - DescribeLiveDomainEdgeLogRequest
     *
     * @returns DescribeLiveDomainEdgeLogResponse
     *
     * @param DescribeLiveDomainEdgeLogRequest $request
     *
     * @return DescribeLiveDomainEdgeLogResponse
     */
    public function describeLiveDomainEdgeLog($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainEdgeLogWithOptions($request, $runtime);
    }

    /**
     * Queries the frame rates and bitrates of all live streams under an ingest domain.
     *
     * @remarks
     * You can call this operation to query the real-time bitrates and frame rates of live streams, which helps you evaluate the stream ingest quality. A delay exists in data collection and statistics. We recommend that you query the data of more than 5 minutes ago.
     * >  Use this operation to replace the deprecated DescribeLiveStreamsFrameRateAndBitRateData operation.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainFrameRateAndBitRateDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDomainFrameRateAndBitRateDataResponse
     *
     * @param DescribeLiveDomainFrameRateAndBitRateDataRequest $request
     * @param RuntimeOptions                                   $runtime
     *
     * @return DescribeLiveDomainFrameRateAndBitRateDataResponse
     */
    public function describeLiveDomainFrameRateAndBitRateDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->queryTime) {
            @$query['QueryTime'] = $request->queryTime;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainFrameRateAndBitRateData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainFrameRateAndBitRateDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the frame rates and bitrates of all live streams under an ingest domain.
     *
     * @remarks
     * You can call this operation to query the real-time bitrates and frame rates of live streams, which helps you evaluate the stream ingest quality. A delay exists in data collection and statistics. We recommend that you query the data of more than 5 minutes ago.
     * >  Use this operation to replace the deprecated DescribeLiveStreamsFrameRateAndBitRateData operation.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainFrameRateAndBitRateDataRequest
     *
     * @returns DescribeLiveDomainFrameRateAndBitRateDataResponse
     *
     * @param DescribeLiveDomainFrameRateAndBitRateDataRequest $request
     *
     * @return DescribeLiveDomainFrameRateAndBitRateDataResponse
     */
    public function describeLiveDomainFrameRateAndBitRateData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainFrameRateAndBitRateDataWithOptions($request, $runtime);
    }

    /**
     * Queries the maximum numbers of ingested and transcoded streams for a streaming domain.
     *
     * @remarks
     * This operation applies only to main streaming domains.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveDomainLimitRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDomainLimitResponse
     *
     * @param DescribeLiveDomainLimitRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeLiveDomainLimitResponse
     */
    public function describeLiveDomainLimitWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainLimit',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainLimitResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the maximum numbers of ingested and transcoded streams for a streaming domain.
     *
     * @remarks
     * This operation applies only to main streaming domains.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveDomainLimitRequest
     *
     * @returns DescribeLiveDomainLimitResponse
     *
     * @param DescribeLiveDomainLimitRequest $request
     *
     * @return DescribeLiveDomainLimitResponse
     */
    public function describeLiveDomainLimit($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainLimitWithOptions($request, $runtime);
    }

    /**
     * Queries the address from which you can download the raw access logs of a domain name.
     *
     * @remarks
     *   You can call this operation to query the offline logs of a single domain name.
     * *   The StartTime and EndTime parameters are optional. You can specify both the parameters to query logs that are generated within the specified time period.
     * *   If you do not specify the StartTime and EndTime parameters, logs that are generated in the last 24 hours are queried by default.
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveDomainLogRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDomainLogResponse
     *
     * @param DescribeLiveDomainLogRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DescribeLiveDomainLogResponse
     */
    public function describeLiveDomainLogWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainLog',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainLogResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the address from which you can download the raw access logs of a domain name.
     *
     * @remarks
     *   You can call this operation to query the offline logs of a single domain name.
     * *   The StartTime and EndTime parameters are optional. You can specify both the parameters to query logs that are generated within the specified time period.
     * *   If you do not specify the StartTime and EndTime parameters, logs that are generated in the last 24 hours are queried by default.
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveDomainLogRequest
     *
     * @returns DescribeLiveDomainLogResponse
     *
     * @param DescribeLiveDomainLogRequest $request
     *
     * @return DescribeLiveDomainLogResponse
     */
    public function describeLiveDomainLog($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainLogWithOptions($request, $runtime);
    }

    /**
     * 直播离线日志扩展接口(大客定制).
     *
     * @param request - DescribeLiveDomainLogExTtlRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDomainLogExTtlResponse
     *
     * @param DescribeLiveDomainLogExTtlRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeLiveDomainLogExTtlResponse
     */
    public function describeLiveDomainLogExTtlWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainLogExTtl',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainLogExTtlResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 直播离线日志扩展接口(大客定制).
     *
     * @param request - DescribeLiveDomainLogExTtlRequest
     *
     * @returns DescribeLiveDomainLogExTtlResponse
     *
     * @param DescribeLiveDomainLogExTtlRequest $request
     *
     * @return DescribeLiveDomainLogExTtlResponse
     */
    public function describeLiveDomainLogExTtl($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainLogExTtlWithOptions($request, $runtime);
    }

    /**
     * Queries the mappings of an ingest domain, a main streaming domain, or a sub-streaming domain.
     *
     * @remarks
     * Obtain the ingest domain, main streaming domain, or sub-streaming domain, and then call this operation to query the mappings of the domain name.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 500 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveDomainMappingRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDomainMappingResponse
     *
     * @param DescribeLiveDomainMappingRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeLiveDomainMappingResponse
     */
    public function describeLiveDomainMappingWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainMapping',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainMappingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the mappings of an ingest domain, a main streaming domain, or a sub-streaming domain.
     *
     * @remarks
     * Obtain the ingest domain, main streaming domain, or sub-streaming domain, and then call this operation to query the mappings of the domain name.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 500 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveDomainMappingRequest
     *
     * @returns DescribeLiveDomainMappingResponse
     *
     * @param DescribeLiveDomainMappingRequest $request
     *
     * @return DescribeLiveDomainMappingResponse
     */
    public function describeLiveDomainMapping($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainMappingWithOptions($request, $runtime);
    }

    /**
     * Queries the live monitoring usage data for one or more domain names.
     *
     * @remarks
     *   You can specify one or more domain names. Separate multiple domain names with commas (,).
     * *   You can query data in the last 90 days.
     * *   The data is queried by hour or day.
     * *   The maximum time range for a query is 31 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainMonitoringUsageDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDomainMonitoringUsageDataResponse
     *
     * @param DescribeLiveDomainMonitoringUsageDataRequest $request
     * @param RuntimeOptions                               $runtime
     *
     * @return DescribeLiveDomainMonitoringUsageDataResponse
     */
    public function describeLiveDomainMonitoringUsageDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->interval) {
            @$query['Interval'] = $request->interval;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->region) {
            @$query['Region'] = $request->region;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->splitBy) {
            @$query['SplitBy'] = $request->splitBy;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainMonitoringUsageData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainMonitoringUsageDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the live monitoring usage data for one or more domain names.
     *
     * @remarks
     *   You can specify one or more domain names. Separate multiple domain names with commas (,).
     * *   You can query data in the last 90 days.
     * *   The data is queried by hour or day.
     * *   The maximum time range for a query is 31 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainMonitoringUsageDataRequest
     *
     * @returns DescribeLiveDomainMonitoringUsageDataResponse
     *
     * @param DescribeLiveDomainMonitoringUsageDataRequest $request
     *
     * @return DescribeLiveDomainMonitoringUsageDataResponse
     */
    public function describeLiveDomainMonitoringUsageData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainMonitoringUsageDataWithOptions($request, $runtime);
    }

    /**
     * Queries the configuration status of dual-stream disaster recovery.
     *
     * @param request - DescribeLiveDomainMultiStreamConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDomainMultiStreamConfigResponse
     *
     * @param DescribeLiveDomainMultiStreamConfigRequest $request
     * @param RuntimeOptions                             $runtime
     *
     * @return DescribeLiveDomainMultiStreamConfigResponse
     */
    public function describeLiveDomainMultiStreamConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainMultiStreamConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainMultiStreamConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configuration status of dual-stream disaster recovery.
     *
     * @param request - DescribeLiveDomainMultiStreamConfigRequest
     *
     * @returns DescribeLiveDomainMultiStreamConfigResponse
     *
     * @param DescribeLiveDomainMultiStreamConfigRequest $request
     *
     * @return DescribeLiveDomainMultiStreamConfigResponse
     */
    public function describeLiveDomainMultiStreamConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainMultiStreamConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the number of online users at a specified point in time for all live streams under a specified domain name.
     *
     * @remarks
     * You can call this operation to collect statistics on the number of online users for only Flash Video (FLV), Real-Time Streaming (RTS), and Real-Time Messaging Protocol (RTMP) streams, but not HTTP Live Streaming (HLS) streams. A delay exists in data collection and statistics. We recommend that you query the data of more than 5 minutes ago.
     * >  Use this operation to replace the deprecated DescribeLiveStreamOnlineUserNum operation.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 200 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainOnlineUserNumRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDomainOnlineUserNumResponse
     *
     * @param DescribeLiveDomainOnlineUserNumRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return DescribeLiveDomainOnlineUserNumResponse
     */
    public function describeLiveDomainOnlineUserNumWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->queryTime) {
            @$query['QueryTime'] = $request->queryTime;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainOnlineUserNum',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainOnlineUserNumResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the number of online users at a specified point in time for all live streams under a specified domain name.
     *
     * @remarks
     * You can call this operation to collect statistics on the number of online users for only Flash Video (FLV), Real-Time Streaming (RTS), and Real-Time Messaging Protocol (RTMP) streams, but not HTTP Live Streaming (HLS) streams. A delay exists in data collection and statistics. We recommend that you query the data of more than 5 minutes ago.
     * >  Use this operation to replace the deprecated DescribeLiveStreamOnlineUserNum operation.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 200 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainOnlineUserNumRequest
     *
     * @returns DescribeLiveDomainOnlineUserNumResponse
     *
     * @param DescribeLiveDomainOnlineUserNumRequest $request
     *
     * @return DescribeLiveDomainOnlineUserNumResponse
     */
    public function describeLiveDomainOnlineUserNum($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainOnlineUserNumWithOptions($request, $runtime);
    }

    /**
     * Queries the HTTP status codes that are returned within a specified period of time under an ingest domain.
     *
     * @remarks
     *   This operation is used to monitor data. The returned data cannot be used as a reference to calculate resource usage for billing.
     * *   You can query data within the previous 90 days.
     * *   The data is delayed for 3 to 5 minutes.
     * ## [](#qps-)QPS limits
     * You can call this API operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainPublishErrorCodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDomainPublishErrorCodeResponse
     *
     * @param DescribeLiveDomainPublishErrorCodeRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return DescribeLiveDomainPublishErrorCodeResponse
     */
    public function describeLiveDomainPublishErrorCodeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainPublishErrorCode',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainPublishErrorCodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the HTTP status codes that are returned within a specified period of time under an ingest domain.
     *
     * @remarks
     *   This operation is used to monitor data. The returned data cannot be used as a reference to calculate resource usage for billing.
     * *   You can query data within the previous 90 days.
     * *   The data is delayed for 3 to 5 minutes.
     * ## [](#qps-)QPS limits
     * You can call this API operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainPublishErrorCodeRequest
     *
     * @returns DescribeLiveDomainPublishErrorCodeResponse
     *
     * @param DescribeLiveDomainPublishErrorCodeRequest $request
     *
     * @return DescribeLiveDomainPublishErrorCodeResponse
     */
    public function describeLiveDomainPublishErrorCode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainPublishErrorCodeWithOptions($request, $runtime);
    }

    /**
     * Queries the bandwidth data for one or more ingest domains.
     *
     * @remarks
     *   The bandwidth unit is bit/s.
     * *   You can specify multiple domain names by separating them with commas (,).
     * *   If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
     * *   You can query the data in the last 90 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainPushBpsDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDomainPushBpsDataResponse
     *
     * @param DescribeLiveDomainPushBpsDataRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DescribeLiveDomainPushBpsDataResponse
     */
    public function describeLiveDomainPushBpsDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->interval) {
            @$query['Interval'] = $request->interval;
        }

        if (null !== $request->ispNameEn) {
            @$query['IspNameEn'] = $request->ispNameEn;
        }

        if (null !== $request->locationNameEn) {
            @$query['LocationNameEn'] = $request->locationNameEn;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainPushBpsData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainPushBpsDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the bandwidth data for one or more ingest domains.
     *
     * @remarks
     *   The bandwidth unit is bit/s.
     * *   You can specify multiple domain names by separating them with commas (,).
     * *   If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
     * *   You can query the data in the last 90 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainPushBpsDataRequest
     *
     * @returns DescribeLiveDomainPushBpsDataResponse
     *
     * @param DescribeLiveDomainPushBpsDataRequest $request
     *
     * @return DescribeLiveDomainPushBpsDataResponse
     */
    public function describeLiveDomainPushBpsData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainPushBpsDataWithOptions($request, $runtime);
    }

    /**
     * Queries the network traffic data for one or more ingest domains.
     *
     * @remarks
     *   The traffic unit is bytes.
     * *   You can specify multiple domain names by separating them with commas (,).
     * *   If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
     * *   You can query the data in the last 90 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainPushTrafficDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDomainPushTrafficDataResponse
     *
     * @param DescribeLiveDomainPushTrafficDataRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return DescribeLiveDomainPushTrafficDataResponse
     */
    public function describeLiveDomainPushTrafficDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->interval) {
            @$query['Interval'] = $request->interval;
        }

        if (null !== $request->ispNameEn) {
            @$query['IspNameEn'] = $request->ispNameEn;
        }

        if (null !== $request->locationNameEn) {
            @$query['LocationNameEn'] = $request->locationNameEn;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainPushTrafficData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainPushTrafficDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the network traffic data for one or more ingest domains.
     *
     * @remarks
     *   The traffic unit is bytes.
     * *   You can specify multiple domain names by separating them with commas (,).
     * *   If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
     * *   You can query the data in the last 90 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainPushTrafficDataRequest
     *
     * @returns DescribeLiveDomainPushTrafficDataResponse
     *
     * @param DescribeLiveDomainPushTrafficDataRequest $request
     *
     * @return DescribeLiveDomainPushTrafficDataResponse
     */
    public function describeLiveDomainPushTrafficData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainPushTrafficDataWithOptions($request, $runtime);
    }

    /**
     * Queries the data of page views (PVs) and unique visitors (UVs) of a streaming domain.
     *
     * @remarks
     *   You can call this operation to query the geographical distribution of viewers, the visitor ranking of a streaming domain, and the number of independent requests from IP addresses under a streaming domain within a specified time period.
     * *   If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
     * *   You can specify only one streaming domain in each request.
     * *   You can query the data in the last 90 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainPvUvDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDomainPvUvDataResponse
     *
     * @param DescribeLiveDomainPvUvDataRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeLiveDomainPvUvDataResponse
     */
    public function describeLiveDomainPvUvDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainPvUvData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainPvUvDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the data of page views (PVs) and unique visitors (UVs) of a streaming domain.
     *
     * @remarks
     *   You can call this operation to query the geographical distribution of viewers, the visitor ranking of a streaming domain, and the number of independent requests from IP addresses under a streaming domain within a specified time period.
     * *   If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
     * *   You can specify only one streaming domain in each request.
     * *   You can query the data in the last 90 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainPvUvDataRequest
     *
     * @returns DescribeLiveDomainPvUvDataResponse
     *
     * @param DescribeLiveDomainPvUvDataRequest $request
     *
     * @return DescribeLiveDomainPvUvDataResponse
     */
    public function describeLiveDomainPvUvData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainPvUvDataWithOptions($request, $runtime);
    }

    /**
     * Queries the bandwidth data that is collected every minute for one or more domain names.
     *
     * @remarks
     *   You can call this operation to query the bandwidth usage of one or more specified domain names.
     * *   You can query data in the last seven days. The time range that is specified by the StartTime and EndTime parameters cannot exceed 24 hours for a query.
     * *   If you specify neither the StartTime parameter nor the EndTime parameter, the data of the last hour is returned.
     * *   This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainRealTimeBpsDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDomainRealTimeBpsDataResponse
     *
     * @param DescribeLiveDomainRealTimeBpsDataRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return DescribeLiveDomainRealTimeBpsDataResponse
     */
    public function describeLiveDomainRealTimeBpsDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainRealTimeBpsData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainRealTimeBpsDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the bandwidth data that is collected every minute for one or more domain names.
     *
     * @remarks
     *   You can call this operation to query the bandwidth usage of one or more specified domain names.
     * *   You can query data in the last seven days. The time range that is specified by the StartTime and EndTime parameters cannot exceed 24 hours for a query.
     * *   If you specify neither the StartTime parameter nor the EndTime parameter, the data of the last hour is returned.
     * *   This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainRealTimeBpsDataRequest
     *
     * @returns DescribeLiveDomainRealTimeBpsDataResponse
     *
     * @param DescribeLiveDomainRealTimeBpsDataRequest $request
     *
     * @return DescribeLiveDomainRealTimeBpsDataResponse
     */
    public function describeLiveDomainRealTimeBpsData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainRealTimeBpsDataWithOptions($request, $runtime);
    }

    /**
     * Queries the proportions of HTTP status codes returned for one or more domain names. Data is collected every minute.
     *
     * @remarks
     * The following table describes the time granularities supported by this operation.
     * |Time granularity|Maximum time range per query|Historical data available|Data delay|
     * |---|---|---|---|
     * |1 minute|1 hour|7 days|5 minutes|
     * |5 minutes|3 days|93 days|15 minutes|
     * |1 hour|31 days|186 days|Usually 4 hours|
     * |1 day|Unlimited|366 days|After 04:00 on the next day|
     * ## QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainRealTimeHttpCodeDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDomainRealTimeHttpCodeDataResponse
     *
     * @param DescribeLiveDomainRealTimeHttpCodeDataRequest $request
     * @param RuntimeOptions                                $runtime
     *
     * @return DescribeLiveDomainRealTimeHttpCodeDataResponse
     */
    public function describeLiveDomainRealTimeHttpCodeDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ispNameEn) {
            @$query['IspNameEn'] = $request->ispNameEn;
        }

        if (null !== $request->locationNameEn) {
            @$query['LocationNameEn'] = $request->locationNameEn;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainRealTimeHttpCodeData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainRealTimeHttpCodeDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the proportions of HTTP status codes returned for one or more domain names. Data is collected every minute.
     *
     * @remarks
     * The following table describes the time granularities supported by this operation.
     * |Time granularity|Maximum time range per query|Historical data available|Data delay|
     * |---|---|---|---|
     * |1 minute|1 hour|7 days|5 minutes|
     * |5 minutes|3 days|93 days|15 minutes|
     * |1 hour|31 days|186 days|Usually 4 hours|
     * |1 day|Unlimited|366 days|After 04:00 on the next day|
     * ## QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainRealTimeHttpCodeDataRequest
     *
     * @returns DescribeLiveDomainRealTimeHttpCodeDataResponse
     *
     * @param DescribeLiveDomainRealTimeHttpCodeDataRequest $request
     *
     * @return DescribeLiveDomainRealTimeHttpCodeDataResponse
     */
    public function describeLiveDomainRealTimeHttpCodeData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainRealTimeHttpCodeDataWithOptions($request, $runtime);
    }

    /**
     * Queries the network traffic data that is collected in real time for one or more domain names.
     *
     * @remarks
     *   You can call this operation to query the real-time traffic in a region for an Internet service provider (ISP) within a specified period of time under one or more streaming domains.
     * *   If you do not specify the StartTime parameter or the EndTime parameter, the data of the last hour is returned. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
     * *   This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
     * *   You can query the data in the last 90 days.
     * ## [](#qps-)QPS limit
     * This operation does not have a queries per second (QPS) limit on a single user. You can call this operation based on your business requirements.
     *
     * @param request - DescribeLiveDomainRealTimeTrafficDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDomainRealTimeTrafficDataResponse
     *
     * @param DescribeLiveDomainRealTimeTrafficDataRequest $request
     * @param RuntimeOptions                               $runtime
     *
     * @return DescribeLiveDomainRealTimeTrafficDataResponse
     */
    public function describeLiveDomainRealTimeTrafficDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ispNameEn) {
            @$query['IspNameEn'] = $request->ispNameEn;
        }

        if (null !== $request->locationNameEn) {
            @$query['LocationNameEn'] = $request->locationNameEn;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainRealTimeTrafficData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainRealTimeTrafficDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the network traffic data that is collected in real time for one or more domain names.
     *
     * @remarks
     *   You can call this operation to query the real-time traffic in a region for an Internet service provider (ISP) within a specified period of time under one or more streaming domains.
     * *   If you do not specify the StartTime parameter or the EndTime parameter, the data of the last hour is returned. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
     * *   This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
     * *   You can query the data in the last 90 days.
     * ## [](#qps-)QPS limit
     * This operation does not have a queries per second (QPS) limit on a single user. You can call this operation based on your business requirements.
     *
     * @param request - DescribeLiveDomainRealTimeTrafficDataRequest
     *
     * @returns DescribeLiveDomainRealTimeTrafficDataResponse
     *
     * @param DescribeLiveDomainRealTimeTrafficDataRequest $request
     *
     * @return DescribeLiveDomainRealTimeTrafficDataResponse
     */
    public function describeLiveDomainRealTimeTrafficData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainRealTimeTrafficDataWithOptions($request, $runtime);
    }

    /**
     * Queries the information about real-time log delivery for a domain name.
     *
     * @remarks
     * You can call this operation to query the status of real-time log delivery for a domain name. Make sure that the parameter settings meet the requirements.
     * ## QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveDomainRealtimeLogDeliveryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDomainRealtimeLogDeliveryResponse
     *
     * @param DescribeLiveDomainRealtimeLogDeliveryRequest $request
     * @param RuntimeOptions                               $runtime
     *
     * @return DescribeLiveDomainRealtimeLogDeliveryResponse
     */
    public function describeLiveDomainRealtimeLogDeliveryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainRealtimeLogDelivery',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainRealtimeLogDeliveryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about real-time log delivery for a domain name.
     *
     * @remarks
     * You can call this operation to query the status of real-time log delivery for a domain name. Make sure that the parameter settings meet the requirements.
     * ## QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveDomainRealtimeLogDeliveryRequest
     *
     * @returns DescribeLiveDomainRealtimeLogDeliveryResponse
     *
     * @param DescribeLiveDomainRealtimeLogDeliveryRequest $request
     *
     * @return DescribeLiveDomainRealtimeLogDeliveryResponse
     */
    public function describeLiveDomainRealtimeLogDelivery($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainRealtimeLogDeliveryWithOptions($request, $runtime);
    }

    /**
     * Queries the numbers of live recording channels and container format conversions.
     *
     * @remarks
     *   You can call this operation to query the number of concurrent recording channels on each day and event tracking data at different time intervals. This way, you can measure the peak number of concurrent recording channels on each day or month.
     * *   The number of time shifting channels is not included in the number of recording channels.
     * *   You can query data by domain name or query data for multiple domain names at a time. If you specify multiple domain names, separate them with commas (,).
     * *   If you set the data granularity to 1 minute, the maximum time range to query is 24 hours. You can query data in the last 60 days.
     * *   If you set the data granularity to 1 hour, the maximum time range to query is 31 days. You can query data in the last 180 days.
     * *   If you set the data granularity to 1 day, the maximum time range to query is 90 days. You can query data in the last 366 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainRecordUsageDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDomainRecordUsageDataResponse
     *
     * @param DescribeLiveDomainRecordUsageDataRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return DescribeLiveDomainRecordUsageDataResponse
     */
    public function describeLiveDomainRecordUsageDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->interval) {
            @$query['Interval'] = $request->interval;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->region) {
            @$query['Region'] = $request->region;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->splitBy) {
            @$query['SplitBy'] = $request->splitBy;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainRecordUsageData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainRecordUsageDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the numbers of live recording channels and container format conversions.
     *
     * @remarks
     *   You can call this operation to query the number of concurrent recording channels on each day and event tracking data at different time intervals. This way, you can measure the peak number of concurrent recording channels on each day or month.
     * *   The number of time shifting channels is not included in the number of recording channels.
     * *   You can query data by domain name or query data for multiple domain names at a time. If you specify multiple domain names, separate them with commas (,).
     * *   If you set the data granularity to 1 minute, the maximum time range to query is 24 hours. You can query data in the last 60 days.
     * *   If you set the data granularity to 1 hour, the maximum time range to query is 31 days. You can query data in the last 180 days.
     * *   If you set the data granularity to 1 day, the maximum time range to query is 90 days. You can query data in the last 366 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainRecordUsageDataRequest
     *
     * @returns DescribeLiveDomainRecordUsageDataResponse
     *
     * @param DescribeLiveDomainRecordUsageDataRequest $request
     *
     * @return DescribeLiveDomainRecordUsageDataResponse
     */
    public function describeLiveDomainRecordUsageData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainRecordUsageDataWithOptions($request, $runtime);
    }

    /**
     * Queries the number of snapshots for one or more streaming domains.
     *
     * @remarks
     *   You can call this operation to collect statistics on the total number of snapshots on a day.
     * *   You can query data in the last 90 days.
     * ## [](#qps-)QPS limit
     * This operation does not have a queries per second (QPS) limit on a single user. You can call this operation based on your business requirements.
     *
     * @param request - DescribeLiveDomainSnapshotDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDomainSnapshotDataResponse
     *
     * @param DescribeLiveDomainSnapshotDataRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DescribeLiveDomainSnapshotDataResponse
     */
    public function describeLiveDomainSnapshotDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainSnapshotData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainSnapshotDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the number of snapshots for one or more streaming domains.
     *
     * @remarks
     *   You can call this operation to collect statistics on the total number of snapshots on a day.
     * *   You can query data in the last 90 days.
     * ## [](#qps-)QPS limit
     * This operation does not have a queries per second (QPS) limit on a single user. You can call this operation based on your business requirements.
     *
     * @param request - DescribeLiveDomainSnapshotDataRequest
     *
     * @returns DescribeLiveDomainSnapshotDataResponse
     *
     * @param DescribeLiveDomainSnapshotDataRequest $request
     *
     * @return DescribeLiveDomainSnapshotDataResponse
     */
    public function describeLiveDomainSnapshotData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainSnapshotDataWithOptions($request, $runtime);
    }

    /**
     * Queries the feature configurations of an accelerated domain name in the canary release environment.
     *
     * @remarks
     * ## [](#)Usage notes
     * You can call this operation to query the feature configurations of an accelerated domain name in the canary release environment.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveDomainStagingConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDomainStagingConfigResponse
     *
     * @param DescribeLiveDomainStagingConfigRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return DescribeLiveDomainStagingConfigResponse
     */
    public function describeLiveDomainStagingConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->functionNames) {
            @$query['FunctionNames'] = $request->functionNames;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainStagingConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainStagingConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the feature configurations of an accelerated domain name in the canary release environment.
     *
     * @remarks
     * ## [](#)Usage notes
     * You can call this operation to query the feature configurations of an accelerated domain name in the canary release environment.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveDomainStagingConfigRequest
     *
     * @returns DescribeLiveDomainStagingConfigResponse
     *
     * @param DescribeLiveDomainStagingConfigRequest $request
     *
     * @return DescribeLiveDomainStagingConfigResponse
     */
    public function describeLiveDomainStagingConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainStagingConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the transcoding length for one or more domain names.
     *
     * @remarks
     *   You can call this operation to collect the transcoding usage data at each time interval.
     * *   You can specify multiple domain names by separating them with commas (,).
     * *   You can query data in the last 90 days.
     * *   The time granularity of data is 1 hour or 1 day.
     * *   For information about the billing of different transcoding types and transcoding resolutions, see the description about billing of different transcoding specifications in transcoding bills in the [Billing of live stream transcoding](https://help.aliyun.com/document_detail/90424.html) section of the ApsaraVideo Live pricing page.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainStreamTranscodeDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDomainStreamTranscodeDataResponse
     *
     * @param DescribeLiveDomainStreamTranscodeDataRequest $request
     * @param RuntimeOptions                               $runtime
     *
     * @return DescribeLiveDomainStreamTranscodeDataResponse
     */
    public function describeLiveDomainStreamTranscodeDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->interval) {
            @$query['Interval'] = $request->interval;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->precision) {
            @$query['Precision'] = $request->precision;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->split) {
            @$query['Split'] = $request->split;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainStreamTranscodeData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainStreamTranscodeDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the transcoding length for one or more domain names.
     *
     * @remarks
     *   You can call this operation to collect the transcoding usage data at each time interval.
     * *   You can specify multiple domain names by separating them with commas (,).
     * *   You can query data in the last 90 days.
     * *   The time granularity of data is 1 hour or 1 day.
     * *   For information about the billing of different transcoding types and transcoding resolutions, see the description about billing of different transcoding specifications in transcoding bills in the [Billing of live stream transcoding](https://help.aliyun.com/document_detail/90424.html) section of the ApsaraVideo Live pricing page.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainStreamTranscodeDataRequest
     *
     * @returns DescribeLiveDomainStreamTranscodeDataResponse
     *
     * @param DescribeLiveDomainStreamTranscodeDataRequest $request
     *
     * @return DescribeLiveDomainStreamTranscodeDataResponse
     */
    public function describeLiveDomainStreamTranscodeData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainStreamTranscodeDataWithOptions($request, $runtime);
    }

    /**
     * Queries the resource usage data of time shifting for one or more domain names.
     *
     * @remarks
     *   You can call this operation to query the time shifting usage data at each time interval.
     * *   You can query data in the last 90 days.
     * *   The time interval is 1 hour.
     * *   The maximum time range for a query is 31 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainTimeShiftDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDomainTimeShiftDataResponse
     *
     * @param DescribeLiveDomainTimeShiftDataRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return DescribeLiveDomainTimeShiftDataResponse
     */
    public function describeLiveDomainTimeShiftDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->interval) {
            @$query['Interval'] = $request->interval;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainTimeShiftData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainTimeShiftDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the resource usage data of time shifting for one or more domain names.
     *
     * @remarks
     *   You can call this operation to query the time shifting usage data at each time interval.
     * *   You can query data in the last 90 days.
     * *   The time interval is 1 hour.
     * *   The maximum time range for a query is 31 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainTimeShiftDataRequest
     *
     * @returns DescribeLiveDomainTimeShiftDataResponse
     *
     * @param DescribeLiveDomainTimeShiftDataRequest $request
     *
     * @return DescribeLiveDomainTimeShiftDataResponse
     */
    public function describeLiveDomainTimeShiftData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainTimeShiftDataWithOptions($request, $runtime);
    }

    /**
     * Queries the network traffic data for one or more domain names.
     *
     * @remarks
     *   If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is returned.
     * *   This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainTrafficDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDomainTrafficDataResponse
     *
     * @param DescribeLiveDomainTrafficDataRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DescribeLiveDomainTrafficDataResponse
     */
    public function describeLiveDomainTrafficDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->interval) {
            @$query['Interval'] = $request->interval;
        }

        if (null !== $request->ispNameEn) {
            @$query['IspNameEn'] = $request->ispNameEn;
        }

        if (null !== $request->locationNameEn) {
            @$query['LocationNameEn'] = $request->locationNameEn;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainTrafficData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainTrafficDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the network traffic data for one or more domain names.
     *
     * @remarks
     *   If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is returned.
     * *   This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveDomainTrafficDataRequest
     *
     * @returns DescribeLiveDomainTrafficDataResponse
     *
     * @param DescribeLiveDomainTrafficDataRequest $request
     *
     * @return DescribeLiveDomainTrafficDataResponse
     */
    public function describeLiveDomainTrafficData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainTrafficDataWithOptions($request, $runtime);
    }

    /**
     * @param request - DescribeLiveDomainTranscodeParamsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDomainTranscodeParamsResponse
     *
     * @param DescribeLiveDomainTranscodeParamsRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return DescribeLiveDomainTranscodeParamsResponse
     */
    public function describeLiveDomainTranscodeParamsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        if (null !== $request->app) {
            @$query['app'] = $request->app;
        }

        if (null !== $request->pushdomain) {
            @$query['pushdomain'] = $request->pushdomain;
        }

        if (null !== $request->templateName) {
            @$query['template_name'] = $request->templateName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDomainTranscodeParams',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDomainTranscodeParamsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param request - DescribeLiveDomainTranscodeParamsRequest
     *
     * @returns DescribeLiveDomainTranscodeParamsResponse
     *
     * @param DescribeLiveDomainTranscodeParamsRequest $request
     *
     * @return DescribeLiveDomainTranscodeParamsResponse
     */
    public function describeLiveDomainTranscodeParams($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDomainTranscodeParamsWithOptions($request, $runtime);
    }

    /**
     * @remarks
     * ### [](#)Usage notes
     * *   You can query data in the previous 90 days.
     * *   The maximum time range to query is 31 days.
     * ### [](#qps-)QPS limit
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveDrmUsageDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveDrmUsageDataResponse
     *
     * @param DescribeLiveDrmUsageDataRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeLiveDrmUsageDataResponse
     */
    public function describeLiveDrmUsageDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->interval) {
            @$query['Interval'] = $request->interval;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->splitBy) {
            @$query['SplitBy'] = $request->splitBy;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveDrmUsageData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveDrmUsageDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @remarks
     * ### [](#)Usage notes
     * *   You can query data in the previous 90 days.
     * *   The maximum time range to query is 31 days.
     * ### [](#qps-)QPS limit
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveDrmUsageDataRequest
     *
     * @returns DescribeLiveDrmUsageDataResponse
     *
     * @param DescribeLiveDrmUsageDataRequest $request
     *
     * @return DescribeLiveDrmUsageDataResponse
     */
    public function describeLiveDrmUsageData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveDrmUsageDataWithOptions($request, $runtime);
    }

    /**
     * Queries the configuration of edge stream relay.
     *
     * @remarks
     * Obtain the ingest domain, and then call this operation to query the configuration of edge stream relay.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveEdgeTransferRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveEdgeTransferResponse
     *
     * @param DescribeLiveEdgeTransferRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeLiveEdgeTransferResponse
     */
    public function describeLiveEdgeTransferWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveEdgeTransfer',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveEdgeTransferResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configuration of edge stream relay.
     *
     * @remarks
     * Obtain the ingest domain, and then call this operation to query the configuration of edge stream relay.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveEdgeTransferRequest
     *
     * @returns DescribeLiveEdgeTransferResponse
     *
     * @param DescribeLiveEdgeTransferRequest $request
     *
     * @return DescribeLiveEdgeTransferResponse
     */
    public function describeLiveEdgeTransfer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveEdgeTransferWithOptions($request, $runtime);
    }

    /**
     * Queries the co-streaming usage data.
     *
     * @remarks
     *   The maximum time range for a query is 31 days.
     * *   The minimum time granularity for a query is 5 minutes.
     * *   You can query the data in the last 90 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveGrtnDurationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveGrtnDurationResponse
     *
     * @param DescribeLiveGrtnDurationRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeLiveGrtnDurationResponse
     */
    public function describeLiveGrtnDurationWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->area) {
            @$query['Area'] = $request->area;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->interval) {
            @$query['Interval'] = $request->interval;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveGrtnDuration',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveGrtnDurationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the co-streaming usage data.
     *
     * @remarks
     *   The maximum time range for a query is 31 days.
     * *   The minimum time granularity for a query is 5 minutes.
     * *   You can query the data in the last 90 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveGrtnDurationRequest
     *
     * @returns DescribeLiveGrtnDurationResponse
     *
     * @param DescribeLiveGrtnDurationRequest $request
     *
     * @return DescribeLiveGrtnDurationResponse
     */
    public function describeLiveGrtnDuration($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveGrtnDurationWithOptions($request, $runtime);
    }

    /**
     * Queries the information about all certificates that you have configured.
     *
     * @remarks
     * You can call this operation to query the information about all certificates that you have configured.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveHttpsDomainListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveHttpsDomainListResponse
     *
     * @param DescribeLiveHttpsDomainListRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeLiveHttpsDomainListResponse
     */
    public function describeLiveHttpsDomainListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->keyword) {
            @$query['Keyword'] = $request->keyword;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveHttpsDomainList',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveHttpsDomainListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about all certificates that you have configured.
     *
     * @remarks
     * You can call this operation to query the information about all certificates that you have configured.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveHttpsDomainListRequest
     *
     * @returns DescribeLiveHttpsDomainListResponse
     *
     * @param DescribeLiveHttpsDomainListRequest $request
     *
     * @return DescribeLiveHttpsDomainListResponse
     */
    public function describeLiveHttpsDomainList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveHttpsDomainListWithOptions($request, $runtime);
    }

    /**
     * Queries the metric data of ApsaraVideo Real-time Communication (ARTC).
     *
     * @remarks
     *   You can query data in the last 30 days. The time range for a query cannot exceed 24 hours.
     * *   The time granularity for a query is 5 minutes.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveInteractionMetricDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveInteractionMetricDataResponse
     *
     * @param DescribeLiveInteractionMetricDataRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return DescribeLiveInteractionMetricDataResponse
     */
    public function describeLiveInteractionMetricDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->beginTs) {
            @$query['BeginTs'] = $request->beginTs;
        }

        if (null !== $request->endTs) {
            @$query['EndTs'] = $request->endTs;
        }

        if (null !== $request->metricType) {
            @$query['MetricType'] = $request->metricType;
        }

        if (null !== $request->os) {
            @$query['Os'] = $request->os;
        }

        if (null !== $request->terminalType) {
            @$query['TerminalType'] = $request->terminalType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveInteractionMetricData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveInteractionMetricDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the metric data of ApsaraVideo Real-time Communication (ARTC).
     *
     * @remarks
     *   You can query data in the last 30 days. The time range for a query cannot exceed 24 hours.
     * *   The time granularity for a query is 5 minutes.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveInteractionMetricDataRequest
     *
     * @returns DescribeLiveInteractionMetricDataResponse
     *
     * @param DescribeLiveInteractionMetricDataRequest $request
     *
     * @return DescribeLiveInteractionMetricDataResponse
     */
    public function describeLiveInteractionMetricData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveInteractionMetricDataWithOptions($request, $runtime);
    }

    /**
     * Checks whether a specified IP address belongs to an Alibaba Cloud point of presence (POP).
     *
     * @remarks
     * ### [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveIpInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveIpInfoResponse
     *
     * @param DescribeLiveIpInfoRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return DescribeLiveIpInfoResponse
     */
    public function describeLiveIpInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->IP) {
            @$query['IP'] = $request->IP;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveIpInfo',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveIpInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Checks whether a specified IP address belongs to an Alibaba Cloud point of presence (POP).
     *
     * @remarks
     * ### [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveIpInfoRequest
     *
     * @returns DescribeLiveIpInfoResponse
     *
     * @param DescribeLiveIpInfoRequest $request
     *
     * @return DescribeLiveIpInfoResponse
     */
    public function describeLiveIpInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveIpInfoWithOptions($request, $runtime);
    }

    /**
     * Queries the configurations of triggered stream pulling for a streaming domain.
     *
     * @remarks
     * ##
     * This operation is applicable to regular stream pulling. You can call this operation to query the configurations of regular stream pulling for a domain name.
     * ## QPS limit
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveLazyPullStreamConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveLazyPullStreamConfigResponse
     *
     * @param DescribeLiveLazyPullStreamConfigRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return DescribeLiveLazyPullStreamConfigResponse
     */
    public function describeLiveLazyPullStreamConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveLazyPullStreamConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveLazyPullStreamConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configurations of triggered stream pulling for a streaming domain.
     *
     * @remarks
     * ##
     * This operation is applicable to regular stream pulling. You can call this operation to query the configurations of regular stream pulling for a domain name.
     * ## QPS limit
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveLazyPullStreamConfigRequest
     *
     * @returns DescribeLiveLazyPullStreamConfigResponse
     *
     * @param DescribeLiveLazyPullStreamConfigRequest $request
     *
     * @return DescribeLiveLazyPullStreamConfigResponse
     */
    public function describeLiveLazyPullStreamConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveLazyPullStreamConfigWithOptions($request, $runtime);
    }

    /**
     * Query Interactive Message App.
     *
     * @remarks
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveMessageAppRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveMessageAppResponse
     *
     * @param DescribeLiveMessageAppRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DescribeLiveMessageAppResponse
     */
    public function describeLiveMessageAppWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->dataCenter) {
            @$query['DataCenter'] = $request->dataCenter;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveMessageApp',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveMessageAppResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Query Interactive Message App.
     *
     * @remarks
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveMessageAppRequest
     *
     * @returns DescribeLiveMessageAppResponse
     *
     * @param DescribeLiveMessageAppRequest $request
     *
     * @return DescribeLiveMessageAppResponse
     */
    public function describeLiveMessageApp($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveMessageAppWithOptions($request, $runtime);
    }

    /**
     * Queries the information about an interactive messaging group.
     *
     * @remarks
     * Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848162.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveMessageGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveMessageGroupResponse
     *
     * @param DescribeLiveMessageGroupRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeLiveMessageGroupResponse
     */
    public function describeLiveMessageGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->dataCenter) {
            @$query['DataCenter'] = $request->dataCenter;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveMessageGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveMessageGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about an interactive messaging group.
     *
     * @remarks
     * Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848162.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveMessageGroupRequest
     *
     * @returns DescribeLiveMessageGroupResponse
     *
     * @param DescribeLiveMessageGroupRequest $request
     *
     * @return DescribeLiveMessageGroupResponse
     */
    public function describeLiveMessageGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveMessageGroupWithOptions($request, $runtime);
    }

    /**
     * Queries the mute status of users.
     *
     * @remarks
     * Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveMessageGroupBandRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveMessageGroupBandResponse
     *
     * @param DescribeLiveMessageGroupBandRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribeLiveMessageGroupBandResponse
     */
    public function describeLiveMessageGroupBandWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->dataCenter) {
            @$query['DataCenter'] = $request->dataCenter;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveMessageGroupBand',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveMessageGroupBandResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the mute status of users.
     *
     * @remarks
     * Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveMessageGroupBandRequest
     *
     * @returns DescribeLiveMessageGroupBandResponse
     *
     * @param DescribeLiveMessageGroupBandRequest $request
     *
     * @return DescribeLiveMessageGroupBandResponse
     */
    public function describeLiveMessageGroupBand($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveMessageGroupBandWithOptions($request, $runtime);
    }

    /**
     * @remarks
     * Obtain the main streaming domain, and then call this operation to query live stream encapsulation configurations.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLivePackageConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLivePackageConfigResponse
     *
     * @param DescribeLivePackageConfigRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeLivePackageConfigResponse
     */
    public function describeLivePackageConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->order) {
            @$query['Order'] = $request->order;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNum) {
            @$query['PageNum'] = $request->pageNum;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLivePackageConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLivePackageConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @remarks
     * Obtain the main streaming domain, and then call this operation to query live stream encapsulation configurations.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLivePackageConfigRequest
     *
     * @returns DescribeLivePackageConfigResponse
     *
     * @param DescribeLivePackageConfigRequest $request
     *
     * @return DescribeLivePackageConfigResponse
     */
    public function describeLivePackageConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLivePackageConfigWithOptions($request, $runtime);
    }

    /**
     * Queries available access points where acceleration circuits start.
     *
     * @remarks
     * Before you call the CreateLivePrivateLine operation, you can call this operation to query available acceleration regions, which are access points where acceleration circuits start.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLivePrivateLineAreasRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLivePrivateLineAreasResponse
     *
     * @param DescribeLivePrivateLineAreasRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribeLivePrivateLineAreasResponse
     */
    public function describeLivePrivateLineAreasWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLivePrivateLineAreas',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLivePrivateLineAreasResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries available access points where acceleration circuits start.
     *
     * @remarks
     * Before you call the CreateLivePrivateLine operation, you can call this operation to query available acceleration regions, which are access points where acceleration circuits start.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLivePrivateLineAreasRequest
     *
     * @returns DescribeLivePrivateLineAreasResponse
     *
     * @param DescribeLivePrivateLineAreasRequest $request
     *
     * @return DescribeLivePrivateLineAreasResponse
     */
    public function describeLivePrivateLineAreas($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLivePrivateLineAreasWithOptions($request, $runtime);
    }

    /**
     * Queries the binding information between Global Accelerator (GA) instances and acceleration circuits.
     *
     * @remarks
     * If you set the IsGaInstance parameter to yes, the status of GA instances is queried. If you set the IsGaInstance parameter to no, the binding information between GA instances and acceleration circuits is queried.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLivePrivateLineAvailGARequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLivePrivateLineAvailGAResponse
     *
     * @param DescribeLivePrivateLineAvailGARequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DescribeLivePrivateLineAvailGAResponse
     */
    public function describeLivePrivateLineAvailGAWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accelerationArea) {
            @$query['AccelerationArea'] = $request->accelerationArea;
        }

        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->isGaInstance) {
            @$query['IsGaInstance'] = $request->isGaInstance;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        if (null !== $request->videoCenter) {
            @$query['VideoCenter'] = $request->videoCenter;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLivePrivateLineAvailGA',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLivePrivateLineAvailGAResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the binding information between Global Accelerator (GA) instances and acceleration circuits.
     *
     * @remarks
     * If you set the IsGaInstance parameter to yes, the status of GA instances is queried. If you set the IsGaInstance parameter to no, the binding information between GA instances and acceleration circuits is queried.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLivePrivateLineAvailGARequest
     *
     * @returns DescribeLivePrivateLineAvailGAResponse
     *
     * @param DescribeLivePrivateLineAvailGARequest $request
     *
     * @return DescribeLivePrivateLineAvailGAResponse
     */
    public function describeLivePrivateLineAvailGA($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLivePrivateLineAvailGAWithOptions($request, $runtime);
    }

    /**
     * Queries the production studio usage data.
     *
     * @remarks
     * The minimum time granularity for a query is 1 hour. The maximum time range for a query is 31 days. You can query the production studio usage data in the last 90 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveProducerUsageDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveProducerUsageDataResponse
     *
     * @param DescribeLiveProducerUsageDataRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DescribeLiveProducerUsageDataResponse
     */
    public function describeLiveProducerUsageDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->instance) {
            @$query['Instance'] = $request->instance;
        }

        if (null !== $request->interval) {
            @$query['Interval'] = $request->interval;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->region) {
            @$query['Region'] = $request->region;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->splitBy) {
            @$query['SplitBy'] = $request->splitBy;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        if (null !== $request->app) {
            @$query['app'] = $request->app;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveProducerUsageData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveProducerUsageDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the production studio usage data.
     *
     * @remarks
     * The minimum time granularity for a query is 1 hour. The maximum time range for a query is 31 days. You can query the production studio usage data in the last 90 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveProducerUsageDataRequest
     *
     * @returns DescribeLiveProducerUsageDataResponse
     *
     * @param DescribeLiveProducerUsageDataRequest $request
     *
     * @return DescribeLiveProducerUsageDataResponse
     */
    public function describeLiveProducerUsageData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveProducerUsageDataWithOptions($request, $runtime);
    }

    /**
     * Queries the stream pulling configurations for a domain name.
     *
     * @remarks
     * ##
     * This operation is applicable to regular stream pulling. You can call this operation to query the regular stream pulling configurations for a domain name.
     * ## QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLivePullStreamConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLivePullStreamConfigResponse
     *
     * @param DescribeLivePullStreamConfigRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribeLivePullStreamConfigResponse
     */
    public function describeLivePullStreamConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLivePullStreamConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLivePullStreamConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the stream pulling configurations for a domain name.
     *
     * @remarks
     * ##
     * This operation is applicable to regular stream pulling. You can call this operation to query the regular stream pulling configurations for a domain name.
     * ## QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLivePullStreamConfigRequest
     *
     * @returns DescribeLivePullStreamConfigResponse
     *
     * @param DescribeLivePullStreamConfigRequest $request
     *
     * @return DescribeLivePullStreamConfigResponse
     */
    public function describeLivePullStreamConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLivePullStreamConfigWithOptions($request, $runtime);
    }

    /**
     * Queries pulled-stream relay tasks.
     *
     * @remarks
     *   You can call this operation to query the information about a pulled-stream relay task.
     * *   This operation allows you to query the configurations and status of a task with a specified ID.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLivePullToPushRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLivePullToPushResponse
     *
     * @param DescribeLivePullToPushRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DescribeLivePullToPushResponse
     */
    public function describeLivePullToPushWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLivePullToPush',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLivePullToPushResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries pulled-stream relay tasks.
     *
     * @remarks
     *   You can call this operation to query the information about a pulled-stream relay task.
     * *   This operation allows you to query the configurations and status of a task with a specified ID.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLivePullToPushRequest
     *
     * @returns DescribeLivePullToPushResponse
     *
     * @param DescribeLivePullToPushRequest $request
     *
     * @return DescribeLivePullToPushResponse
     */
    public function describeLivePullToPush($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLivePullToPushWithOptions($request, $runtime);
    }

    /**
     * Queries pulled-stream relay tasks. Fuzzy match is supported.
     *
     * @remarks
     *   You can call this operation to query pulled-stream relay tasks.
     * *   You can query tasks by page. Fuzzy search is supported based on task IDs, task names, and destination URLs.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLivePullToPushListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLivePullToPushListResponse
     *
     * @param DescribeLivePullToPushListRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeLivePullToPushListResponse
     */
    public function describeLivePullToPushListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLivePullToPushList',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLivePullToPushListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries pulled-stream relay tasks. Fuzzy match is supported.
     *
     * @remarks
     *   You can call this operation to query pulled-stream relay tasks.
     * *   You can query tasks by page. Fuzzy search is supported based on task IDs, task names, and destination URLs.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLivePullToPushListRequest
     *
     * @returns DescribeLivePullToPushListResponse
     *
     * @param DescribeLivePullToPushListRequest $request
     *
     * @return DescribeLivePullToPushListResponse
     */
    public function describeLivePullToPushList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLivePullToPushListWithOptions($request, $runtime);
    }

    /**
     * Queries the stream relay logs, which are available for download.
     *
     * @remarks
     *   The time granularity of the data is 1 hour.
     * *   You can query data in the last 31 days.
     * *   If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLivePushProxyLogRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLivePushProxyLogResponse
     *
     * @param DescribeLivePushProxyLogRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeLivePushProxyLogResponse
     */
    public function describeLivePushProxyLogWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLivePushProxyLog',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLivePushProxyLogResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the stream relay logs, which are available for download.
     *
     * @remarks
     *   The time granularity of the data is 1 hour.
     * *   You can query data in the last 31 days.
     * *   If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLivePushProxyLogRequest
     *
     * @returns DescribeLivePushProxyLogResponse
     *
     * @param DescribeLivePushProxyLogRequest $request
     *
     * @return DescribeLivePushProxyLogResponse
     */
    public function describeLivePushProxyLog($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLivePushProxyLogWithOptions($request, $runtime);
    }

    /**
     * Queries the usage data of live center stream relay.
     *
     * @remarks
     *   You can call this operation to query the usage data of live center stream relay.
     * *   The maximum time range for a query is 31 days.
     * *   The minimum time granularity for a query is 1 day.
     * *   You can query the data in the last 90 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLivePushProxyUsageDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLivePushProxyUsageDataResponse
     *
     * @param DescribeLivePushProxyUsageDataRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DescribeLivePushProxyUsageDataResponse
     */
    public function describeLivePushProxyUsageDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->region) {
            @$query['Region'] = $request->region;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->splitBy) {
            @$query['SplitBy'] = $request->splitBy;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLivePushProxyUsageData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLivePushProxyUsageDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the usage data of live center stream relay.
     *
     * @remarks
     *   You can call this operation to query the usage data of live center stream relay.
     * *   The maximum time range for a query is 31 days.
     * *   The minimum time granularity for a query is 1 day.
     * *   You can query the data in the last 90 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLivePushProxyUsageDataRequest
     *
     * @returns DescribeLivePushProxyUsageDataResponse
     *
     * @param DescribeLivePushProxyUsageDataRequest $request
     *
     * @return DescribeLivePushProxyUsageDataResponse
     */
    public function describeLivePushProxyUsageData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLivePushProxyUsageDataWithOptions($request, $runtime);
    }

    /**
     * Queries the number of real-time log deliveries.
     *
     * @remarks
     *   You can collect statistics on the number of real-time log deliveries. The number of failed real-time log deliveries and the number of successful real-time log deliveries are counted.
     * *   You can query the data by UID.
     * *   You are charged for both successful and failed real-time log deliveries.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveRealtimeDeliveryAccRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveRealtimeDeliveryAccResponse
     *
     * @param DescribeLiveRealtimeDeliveryAccRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return DescribeLiveRealtimeDeliveryAccResponse
     */
    public function describeLiveRealtimeDeliveryAccWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->interval) {
            @$query['Interval'] = $request->interval;
        }

        if (null !== $request->logStore) {
            @$query['LogStore'] = $request->logStore;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->project) {
            @$query['Project'] = $request->project;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveRealtimeDeliveryAcc',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveRealtimeDeliveryAccResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the number of real-time log deliveries.
     *
     * @remarks
     *   You can collect statistics on the number of real-time log deliveries. The number of failed real-time log deliveries and the number of successful real-time log deliveries are counted.
     * *   You can query the data by UID.
     * *   You are charged for both successful and failed real-time log deliveries.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveRealtimeDeliveryAccRequest
     *
     * @returns DescribeLiveRealtimeDeliveryAccResponse
     *
     * @param DescribeLiveRealtimeDeliveryAccRequest $request
     *
     * @return DescribeLiveRealtimeDeliveryAccResponse
     */
    public function describeLiveRealtimeDeliveryAcc($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveRealtimeDeliveryAccWithOptions($request, $runtime);
    }

    /**
     * Queries the status of authorization for real-time log delivery.
     *
     * @remarks
     * You can call this operation to query the status of authorization for real-time log delivery.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveRealtimeLogAuthorizedRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveRealtimeLogAuthorizedResponse
     *
     * @param DescribeLiveRealtimeLogAuthorizedRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return DescribeLiveRealtimeLogAuthorizedResponse
     */
    public function describeLiveRealtimeLogAuthorizedWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveRealtimeLogAuthorized',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveRealtimeLogAuthorizedResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the status of authorization for real-time log delivery.
     *
     * @remarks
     * You can call this operation to query the status of authorization for real-time log delivery.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveRealtimeLogAuthorizedRequest
     *
     * @returns DescribeLiveRealtimeLogAuthorizedResponse
     *
     * @param DescribeLiveRealtimeLogAuthorizedRequest $request
     *
     * @return DescribeLiveRealtimeLogAuthorizedResponse
     */
    public function describeLiveRealtimeLogAuthorized($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveRealtimeLogAuthorizedWithOptions($request, $runtime);
    }

    /**
     * Queries all recording configurations of an application for a streaming domain.
     *
     * @remarks
     * Obtain the main streaming domain, and then call this operation to query the recording configurations of all applications under the main streaming domain.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveRecordConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveRecordConfigResponse
     *
     * @param DescribeLiveRecordConfigRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeLiveRecordConfigResponse
     */
    public function describeLiveRecordConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->order) {
            @$query['Order'] = $request->order;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNum) {
            @$query['PageNum'] = $request->pageNum;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveRecordConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveRecordConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries all recording configurations of an application for a streaming domain.
     *
     * @remarks
     * Obtain the main streaming domain, and then call this operation to query the recording configurations of all applications under the main streaming domain.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveRecordConfigRequest
     *
     * @returns DescribeLiveRecordConfigResponse
     *
     * @param DescribeLiveRecordConfigRequest $request
     *
     * @return DescribeLiveRecordConfigResponse
     */
    public function describeLiveRecordConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveRecordConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the configuration of callbacks for live stream recording under a domain name.
     *
     * @remarks
     * Obtain the main streaming domain, and then call this operation to query the configuration of callbacks for live stream recording under the domain name.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveRecordNotifyConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveRecordNotifyConfigResponse
     *
     * @param DescribeLiveRecordNotifyConfigRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DescribeLiveRecordNotifyConfigResponse
     */
    public function describeLiveRecordNotifyConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveRecordNotifyConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveRecordNotifyConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configuration of callbacks for live stream recording under a domain name.
     *
     * @remarks
     * Obtain the main streaming domain, and then call this operation to query the configuration of callbacks for live stream recording under the domain name.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveRecordNotifyConfigRequest
     *
     * @returns DescribeLiveRecordNotifyConfigResponse
     *
     * @param DescribeLiveRecordNotifyConfigRequest $request
     *
     * @return DescribeLiveRecordNotifyConfigResponse
     */
    public function describeLiveRecordNotifyConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveRecordNotifyConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the recording callback records that are stored in Object Storage Service (OSS).
     *
     * @remarks
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveRecordNotifyRecordsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveRecordNotifyRecordsResponse
     *
     * @param DescribeLiveRecordNotifyRecordsRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return DescribeLiveRecordNotifyRecordsResponse
     */
    public function describeLiveRecordNotifyRecordsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveRecordNotifyRecords',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveRecordNotifyRecordsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the recording callback records that are stored in Object Storage Service (OSS).
     *
     * @remarks
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveRecordNotifyRecordsRequest
     *
     * @returns DescribeLiveRecordNotifyRecordsResponse
     *
     * @param DescribeLiveRecordNotifyRecordsRequest $request
     *
     * @return DescribeLiveRecordNotifyRecordsResponse
     */
    public function describeLiveRecordNotifyRecords($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveRecordNotifyRecordsWithOptions($request, $runtime);
    }

    /**
     * Queries Live-to-VOD configurations.
     *
     * @remarks
     * ## [](#)Usage notes
     * Obtain the streaming domain, and then call this operation to query the Live-to-VOD configurations.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveRecordVodConfigsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveRecordVodConfigsResponse
     *
     * @param DescribeLiveRecordVodConfigsRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribeLiveRecordVodConfigsResponse
     */
    public function describeLiveRecordVodConfigsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNum) {
            @$query['PageNum'] = $request->pageNum;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveRecordVodConfigs',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveRecordVodConfigsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries Live-to-VOD configurations.
     *
     * @remarks
     * ## [](#)Usage notes
     * Obtain the streaming domain, and then call this operation to query the Live-to-VOD configurations.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveRecordVodConfigsRequest
     *
     * @returns DescribeLiveRecordVodConfigsResponse
     *
     * @param DescribeLiveRecordVodConfigsRequest $request
     *
     * @return DescribeLiveRecordVodConfigsResponse
     */
    public function describeLiveRecordVodConfigs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveRecordVodConfigsWithOptions($request, $runtime);
    }

    /**
     * Queries the time shifting configurations under a domain name.
     *
     * @remarks
     * This operation is applicable to the streaming domains.
     * ## QPS limit
     * A single user can perform a maximum of 10 queries per second (QPS). Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
     *
     * @param request - DescribeLiveShiftConfigsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveShiftConfigsResponse
     *
     * @param DescribeLiveShiftConfigsRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeLiveShiftConfigsResponse
     */
    public function describeLiveShiftConfigsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveShiftConfigs',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveShiftConfigsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the time shifting configurations under a domain name.
     *
     * @remarks
     * This operation is applicable to the streaming domains.
     * ## QPS limit
     * A single user can perform a maximum of 10 queries per second (QPS). Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
     *
     * @param request - DescribeLiveShiftConfigsRequest
     *
     * @returns DescribeLiveShiftConfigsResponse
     *
     * @param DescribeLiveShiftConfigsRequest $request
     *
     * @return DescribeLiveShiftConfigsResponse
     */
    public function describeLiveShiftConfigs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveShiftConfigsWithOptions($request, $runtime);
    }

    /**
     * Queries the snapshot configurations of a streaming domain.
     *
     * @remarks
     * Obtain the main streaming domain, and then call this operation to query the snapshot configurations.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveSnapshotConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveSnapshotConfigResponse
     *
     * @param DescribeLiveSnapshotConfigRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeLiveSnapshotConfigResponse
     */
    public function describeLiveSnapshotConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->order) {
            @$query['Order'] = $request->order;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNum) {
            @$query['PageNum'] = $request->pageNum;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveSnapshotConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveSnapshotConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the snapshot configurations of a streaming domain.
     *
     * @remarks
     * Obtain the main streaming domain, and then call this operation to query the snapshot configurations.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveSnapshotConfigRequest
     *
     * @returns DescribeLiveSnapshotConfigResponse
     *
     * @param DescribeLiveSnapshotConfigRequest $request
     *
     * @return DescribeLiveSnapshotConfigResponse
     */
    public function describeLiveSnapshotConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveSnapshotConfigWithOptions($request, $runtime);
    }

    /**
     * Queries video moderation configurations.
     *
     * @remarks
     *   Obtain the main streaming domain, and then call this operation to query video moderation configurations. The configurations can be sorted in ascending or descending order.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveSnapshotDetectPornConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveSnapshotDetectPornConfigResponse
     *
     * @param DescribeLiveSnapshotDetectPornConfigRequest $request
     * @param RuntimeOptions                              $runtime
     *
     * @return DescribeLiveSnapshotDetectPornConfigResponse
     */
    public function describeLiveSnapshotDetectPornConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->order) {
            @$query['Order'] = $request->order;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNum) {
            @$query['PageNum'] = $request->pageNum;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveSnapshotDetectPornConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveSnapshotDetectPornConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries video moderation configurations.
     *
     * @remarks
     *   Obtain the main streaming domain, and then call this operation to query video moderation configurations. The configurations can be sorted in ascending or descending order.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveSnapshotDetectPornConfigRequest
     *
     * @returns DescribeLiveSnapshotDetectPornConfigResponse
     *
     * @param DescribeLiveSnapshotDetectPornConfigRequest $request
     *
     * @return DescribeLiveSnapshotDetectPornConfigResponse
     */
    public function describeLiveSnapshotDetectPornConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveSnapshotDetectPornConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the configuration of snapshot callbacks.
     *
     * @remarks
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveSnapshotNotifyConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveSnapshotNotifyConfigResponse
     *
     * @param DescribeLiveSnapshotNotifyConfigRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return DescribeLiveSnapshotNotifyConfigResponse
     */
    public function describeLiveSnapshotNotifyConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveSnapshotNotifyConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveSnapshotNotifyConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configuration of snapshot callbacks.
     *
     * @remarks
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveSnapshotNotifyConfigRequest
     *
     * @returns DescribeLiveSnapshotNotifyConfigResponse
     *
     * @param DescribeLiveSnapshotNotifyConfigRequest $request
     *
     * @return DescribeLiveSnapshotNotifyConfigResponse
     */
    public function describeLiveSnapshotNotifyConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveSnapshotNotifyConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the authentication status of an active stream.
     *
     * @remarks
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamAuthCheckingRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveStreamAuthCheckingResponse
     *
     * @param DescribeLiveStreamAuthCheckingRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DescribeLiveStreamAuthCheckingResponse
     */
    public function describeLiveStreamAuthCheckingWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->url) {
            @$query['Url'] = $request->url;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamAuthChecking',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamAuthCheckingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the authentication status of an active stream.
     *
     * @remarks
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamAuthCheckingRequest
     *
     * @returns DescribeLiveStreamAuthCheckingResponse
     *
     * @param DescribeLiveStreamAuthCheckingRequest $request
     *
     * @return DescribeLiveStreamAuthCheckingResponse
     */
    public function describeLiveStreamAuthChecking($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamAuthCheckingWithOptions($request, $runtime);
    }

    /**
     * Queries the frame rates and bitrates of a Real-Time Messaging Protocol (RTMP) stream within a specified time period. You can call this operation to query historical data.
     *
     * @remarks
     * This operation allows you to query the frame rates and bitrates of an RTMP stream within a specified time period. You can call this operation to query historical data.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamBitRateDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveStreamBitRateDataResponse
     *
     * @param DescribeLiveStreamBitRateDataRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DescribeLiveStreamBitRateDataResponse
     */
    public function describeLiveStreamBitRateDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamBitRateData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamBitRateDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the frame rates and bitrates of a Real-Time Messaging Protocol (RTMP) stream within a specified time period. You can call this operation to query historical data.
     *
     * @remarks
     * This operation allows you to query the frame rates and bitrates of an RTMP stream within a specified time period. You can call this operation to query historical data.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamBitRateDataRequest
     *
     * @returns DescribeLiveStreamBitRateDataResponse
     *
     * @param DescribeLiveStreamBitRateDataRequest $request
     *
     * @return DescribeLiveStreamBitRateDataResponse
     */
    public function describeLiveStreamBitRateData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamBitRateDataWithOptions($request, $runtime);
    }

    /**
     * Queries the numbers of online source streams and transcoded streams.
     *
     * @remarks
     * Obtain the main streaming domain, and then call this operation to query the numbers of online source streams and transcoded streams. The streams that are returned by calling this operation are encoded in H.264 or H.265.
     * ## [](#qps-)QPS limit
     * You can call this operation once per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamCountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveStreamCountResponse
     *
     * @param DescribeLiveStreamCountRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeLiveStreamCountResponse
     */
    public function describeLiveStreamCountWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamCount',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the numbers of online source streams and transcoded streams.
     *
     * @remarks
     * Obtain the main streaming domain, and then call this operation to query the numbers of online source streams and transcoded streams. The streams that are returned by calling this operation are encoded in H.264 or H.265.
     * ## [](#qps-)QPS limit
     * You can call this operation once per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamCountRequest
     *
     * @returns DescribeLiveStreamCountResponse
     *
     * @param DescribeLiveStreamCountRequest $request
     *
     * @return DescribeLiveStreamCountResponse
     */
    public function describeLiveStreamCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamCountWithOptions($request, $runtime);
    }

    /**
     * Queries the live streaming latency.
     *
     * @remarks
     * Obtain the streaming domain, and then call this operation to query the live streaming latency.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamDelayConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveStreamDelayConfigResponse
     *
     * @param DescribeLiveStreamDelayConfigRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DescribeLiveStreamDelayConfigResponse
     */
    public function describeLiveStreamDelayConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamDelayConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamDelayConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the live streaming latency.
     *
     * @remarks
     * Obtain the streaming domain, and then call this operation to query the live streaming latency.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamDelayConfigRequest
     *
     * @returns DescribeLiveStreamDelayConfigResponse
     *
     * @param DescribeLiveStreamDelayConfigRequest $request
     *
     * @return DescribeLiveStreamDelayConfigResponse
     */
    public function describeLiveStreamDelayConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamDelayConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the audio and video frame rates and bitrates of a Real-Time Messaging Protocol (RTMP) stream.
     *
     * @remarks
     *   You can call this operation to query a set of audio and video frame rates and bitrates of an RTMP stream within a specified time range.
     * *   This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
     * *   You can query data in the last 90 days.
     * *   The data is delayed for 3 to 5 minutes.
     * *   The maximum time range that you can specify is 1 hour.
     *
     * @param request - DescribeLiveStreamDetailFrameRateAndBitRateDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveStreamDetailFrameRateAndBitRateDataResponse
     *
     * @param DescribeLiveStreamDetailFrameRateAndBitRateDataRequest $request
     * @param RuntimeOptions                                         $runtime
     *
     * @return DescribeLiveStreamDetailFrameRateAndBitRateDataResponse
     */
    public function describeLiveStreamDetailFrameRateAndBitRateDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamDetailFrameRateAndBitRateData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamDetailFrameRateAndBitRateDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the audio and video frame rates and bitrates of a Real-Time Messaging Protocol (RTMP) stream.
     *
     * @remarks
     *   You can call this operation to query a set of audio and video frame rates and bitrates of an RTMP stream within a specified time range.
     * *   This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
     * *   You can query data in the last 90 days.
     * *   The data is delayed for 3 to 5 minutes.
     * *   The maximum time range that you can specify is 1 hour.
     *
     * @param request - DescribeLiveStreamDetailFrameRateAndBitRateDataRequest
     *
     * @returns DescribeLiveStreamDetailFrameRateAndBitRateDataResponse
     *
     * @param DescribeLiveStreamDetailFrameRateAndBitRateDataRequest $request
     *
     * @return DescribeLiveStreamDetailFrameRateAndBitRateDataResponse
     */
    public function describeLiveStreamDetailFrameRateAndBitRateData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamDetailFrameRateAndBitRateDataWithOptions($request, $runtime);
    }

    /**
     * Queries the number of historical online users for a live stream.
     *
     * @remarks
     *   The data returned by this operation is delayed for an average of 2 to 5 minutes.
     * *   This operation queries the number of historical online users for only Flash Video (FLV) and Real-Time Messaging Protocol (RTMP) streams.
     * *   This operation does not query the number of viewers that are watching transcoded streams.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamHistoryUserNumRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveStreamHistoryUserNumResponse
     *
     * @param DescribeLiveStreamHistoryUserNumRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return DescribeLiveStreamHistoryUserNumResponse
     */
    public function describeLiveStreamHistoryUserNumWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamHistoryUserNum',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamHistoryUserNumResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the number of historical online users for a live stream.
     *
     * @remarks
     *   The data returned by this operation is delayed for an average of 2 to 5 minutes.
     * *   This operation queries the number of historical online users for only Flash Video (FLV) and Real-Time Messaging Protocol (RTMP) streams.
     * *   This operation does not query the number of viewers that are watching transcoded streams.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamHistoryUserNumRequest
     *
     * @returns DescribeLiveStreamHistoryUserNumResponse
     *
     * @param DescribeLiveStreamHistoryUserNumRequest $request
     *
     * @return DescribeLiveStreamHistoryUserNumResponse
     */
    public function describeLiveStreamHistoryUserNum($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamHistoryUserNumWithOptions($request, $runtime);
    }

    /**
     * Invoke DescribeLiveStreamMerge to query the primary-standby stream merging configuration.
     *
     * @remarks
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamMergeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveStreamMergeResponse
     *
     * @param DescribeLiveStreamMergeRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeLiveStreamMergeResponse
     */
    public function describeLiveStreamMergeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->protocol) {
            @$query['Protocol'] = $request->protocol;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamMerge',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamMergeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Invoke DescribeLiveStreamMerge to query the primary-standby stream merging configuration.
     *
     * @remarks
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamMergeRequest
     *
     * @returns DescribeLiveStreamMergeResponse
     *
     * @param DescribeLiveStreamMergeRequest $request
     *
     * @return DescribeLiveStreamMergeResponse
     */
    public function describeLiveStreamMerge($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamMergeWithOptions($request, $runtime);
    }

    /**
     * Queries the monitoring data of streams for a specified domain name. Up to 5,000 rows of data can be returned per call.
     *
     * @remarks
     * If you call this operation to query the monitoring data of streams under a domain name for the first time, you must [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex) for backend configuration. Provide the following information in the ticket:
     * *   The domain name that you want to query
     * *   The maximum number of concurrent streams under the domain name
     * *   The maximum number of concurrent online users in each stream
     * *   The protocols used for the client requests
     * >  The review is expected to be completed within one business day after you submit the ticket.
     * ## [](#)Usage limits
     * *   By default, statistics on the number of viewers who watch streams over the HTTP Live Streaming (HLS) protocol cannot be collected.
     * *   You can specify only one domain name in each call.
     * *   The maximum time range to query is 24 hours.
     * *   The minimum data granularity to query is 1 minute.
     * *   You can query data in the last 31 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamMetricDetailDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveStreamMetricDetailDataResponse
     *
     * @param DescribeLiveStreamMetricDetailDataRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return DescribeLiveStreamMetricDetailDataResponse
     */
    public function describeLiveStreamMetricDetailDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->nextPageToken) {
            @$query['NextPageToken'] = $request->nextPageToken;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->protocol) {
            @$query['Protocol'] = $request->protocol;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamMetricDetailData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamMetricDetailDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the monitoring data of streams for a specified domain name. Up to 5,000 rows of data can be returned per call.
     *
     * @remarks
     * If you call this operation to query the monitoring data of streams under a domain name for the first time, you must [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex) for backend configuration. Provide the following information in the ticket:
     * *   The domain name that you want to query
     * *   The maximum number of concurrent streams under the domain name
     * *   The maximum number of concurrent online users in each stream
     * *   The protocols used for the client requests
     * >  The review is expected to be completed within one business day after you submit the ticket.
     * ## [](#)Usage limits
     * *   By default, statistics on the number of viewers who watch streams over the HTTP Live Streaming (HLS) protocol cannot be collected.
     * *   You can specify only one domain name in each call.
     * *   The maximum time range to query is 24 hours.
     * *   The minimum data granularity to query is 1 minute.
     * *   You can query data in the last 31 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamMetricDetailDataRequest
     *
     * @returns DescribeLiveStreamMetricDetailDataResponse
     *
     * @param DescribeLiveStreamMetricDetailDataRequest $request
     *
     * @return DescribeLiveStreamMetricDetailDataResponse
     */
    public function describeLiveStreamMetricDetailData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamMetricDetailDataWithOptions($request, $runtime);
    }

    /**
     * Queries the list of created monitoring sessions.
     *
     * @remarks
     * [Create monitoring sessions](https://help.aliyun.com/document_detail/2848129.html) before you call this operation to query the monitoring session list. Make sure that the parameter settings meet the requirements.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamMonitorListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveStreamMonitorListResponse
     *
     * @param DescribeLiveStreamMonitorListRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DescribeLiveStreamMonitorListResponse
     */
    public function describeLiveStreamMonitorListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->monitorId) {
            @$query['MonitorId'] = $request->monitorId;
        }

        if (null !== $request->orderRule) {
            @$query['OrderRule'] = $request->orderRule;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNum) {
            @$query['PageNum'] = $request->pageNum;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamMonitorList',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamMonitorListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the list of created monitoring sessions.
     *
     * @remarks
     * [Create monitoring sessions](https://help.aliyun.com/document_detail/2848129.html) before you call this operation to query the monitoring session list. Make sure that the parameter settings meet the requirements.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamMonitorListRequest
     *
     * @returns DescribeLiveStreamMonitorListResponse
     *
     * @param DescribeLiveStreamMonitorListRequest $request
     *
     * @return DescribeLiveStreamMonitorListResponse
     */
    public function describeLiveStreamMonitorList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamMonitorListWithOptions($request, $runtime);
    }

    /**
     * Queries prefetch tasks in the last three days.
     *
     * @remarks
     * You can call this operation to query prefetch tasks in the last three days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamPreloadTasksRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveStreamPreloadTasksResponse
     *
     * @param DescribeLiveStreamPreloadTasksRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DescribeLiveStreamPreloadTasksResponse
     */
    public function describeLiveStreamPreloadTasksWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNum) {
            @$query['PageNum'] = $request->pageNum;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->playUrl) {
            @$query['PlayUrl'] = $request->playUrl;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamPreloadTasks',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamPreloadTasksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries prefetch tasks in the last three days.
     *
     * @remarks
     * You can call this operation to query prefetch tasks in the last three days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamPreloadTasksRequest
     *
     * @returns DescribeLiveStreamPreloadTasksResponse
     *
     * @param DescribeLiveStreamPreloadTasksRequest $request
     *
     * @return DescribeLiveStreamPreloadTasksResponse
     */
    public function describeLiveStreamPreloadTasks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamPreloadTasksWithOptions($request, $runtime);
    }

    /**
     * Queries the stream ingest data of a specified domain name at the application level and the stream level.
     *
     * @remarks
     *   You can query data of a single domain name in each request. If you specify multiple domain names, an error is returned.
     * *   The maximum time range to query is 24 hours.
     * *   The minimum data granularity to query is 1 minute.
     * *   You can query data in the last 31 days.
     * *   This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamPushMetricDetailDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveStreamPushMetricDetailDataResponse
     *
     * @param DescribeLiveStreamPushMetricDetailDataRequest $request
     * @param RuntimeOptions                                $runtime
     *
     * @return DescribeLiveStreamPushMetricDetailDataResponse
     */
    public function describeLiveStreamPushMetricDetailDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->nextPageToken) {
            @$query['NextPageToken'] = $request->nextPageToken;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamPushMetricDetailData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamPushMetricDetailDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the stream ingest data of a specified domain name at the application level and the stream level.
     *
     * @remarks
     *   You can query data of a single domain name in each request. If you specify multiple domain names, an error is returned.
     * *   The maximum time range to query is 24 hours.
     * *   The minimum data granularity to query is 1 minute.
     * *   You can query data in the last 31 days.
     * *   This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamPushMetricDetailDataRequest
     *
     * @returns DescribeLiveStreamPushMetricDetailDataResponse
     *
     * @param DescribeLiveStreamPushMetricDetailDataRequest $request
     *
     * @return DescribeLiveStreamPushMetricDetailDataResponse
     */
    public function describeLiveStreamPushMetricDetailData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamPushMetricDetailDataWithOptions($request, $runtime);
    }

    /**
     * Queries the recordings of a live stream.
     *
     * @remarks
     * Obtain the main streaming domain, and then call this operation to query the recordings of the live stream.
     * ## QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
     *
     * @param request - DescribeLiveStreamRecordContentRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveStreamRecordContentResponse
     *
     * @param DescribeLiveStreamRecordContentRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return DescribeLiveStreamRecordContentResponse
     */
    public function describeLiveStreamRecordContentWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamRecordContent',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamRecordContentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the recordings of a live stream.
     *
     * @remarks
     * Obtain the main streaming domain, and then call this operation to query the recordings of the live stream.
     * ## QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
     *
     * @param request - DescribeLiveStreamRecordContentRequest
     *
     * @returns DescribeLiveStreamRecordContentResponse
     *
     * @param DescribeLiveStreamRecordContentRequest $request
     *
     * @return DescribeLiveStreamRecordContentResponse
     */
    public function describeLiveStreamRecordContent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamRecordContentWithOptions($request, $runtime);
    }

    /**
     * Queries the information about an index file.
     *
     * @remarks
     * ApsaraVideo Live stores the information about M3U8 index files for six months. You can query the information about only the M3U8 index files that were created in the last six months. OSS stores M3U8 index files for a time period that is specified by the storage configuration in OSS.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamRecordIndexFileRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveStreamRecordIndexFileResponse
     *
     * @param DescribeLiveStreamRecordIndexFileRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return DescribeLiveStreamRecordIndexFileResponse
     */
    public function describeLiveStreamRecordIndexFileWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->recordId) {
            @$query['RecordId'] = $request->recordId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamRecordIndexFile',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamRecordIndexFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about an index file.
     *
     * @remarks
     * ApsaraVideo Live stores the information about M3U8 index files for six months. You can query the information about only the M3U8 index files that were created in the last six months. OSS stores M3U8 index files for a time period that is specified by the storage configuration in OSS.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamRecordIndexFileRequest
     *
     * @returns DescribeLiveStreamRecordIndexFileResponse
     *
     * @param DescribeLiveStreamRecordIndexFileRequest $request
     *
     * @return DescribeLiveStreamRecordIndexFileResponse
     */
    public function describeLiveStreamRecordIndexFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamRecordIndexFileWithOptions($request, $runtime);
    }

    /**
     * Queries all index files within a specific time period.
     *
     * @remarks
     *   ApsaraVideo Live stores the information about M3U8 index files for six months. You can query the information about only the M3U8 index files that were created in the last six months.
     * *   OSS stores M3U8 index files for a time period that is specified by the storage configuration in OSS.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamRecordIndexFilesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveStreamRecordIndexFilesResponse
     *
     * @param DescribeLiveStreamRecordIndexFilesRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return DescribeLiveStreamRecordIndexFilesResponse
     */
    public function describeLiveStreamRecordIndexFilesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->order) {
            @$query['Order'] = $request->order;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNum) {
            @$query['PageNum'] = $request->pageNum;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamRecordIndexFiles',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamRecordIndexFilesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries all index files within a specific time period.
     *
     * @remarks
     *   ApsaraVideo Live stores the information about M3U8 index files for six months. You can query the information about only the M3U8 index files that were created in the last six months.
     * *   OSS stores M3U8 index files for a time period that is specified by the storage configuration in OSS.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamRecordIndexFilesRequest
     *
     * @returns DescribeLiveStreamRecordIndexFilesResponse
     *
     * @param DescribeLiveStreamRecordIndexFilesRequest $request
     *
     * @return DescribeLiveStreamRecordIndexFilesResponse
     */
    public function describeLiveStreamRecordIndexFiles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamRecordIndexFilesWithOptions($request, $runtime);
    }

    /**
     * Queries the snapshots that were captured within a specific time period.
     *
     * @remarks
     * You can query only snapshots that were captured in the last year.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamSnapshotInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveStreamSnapshotInfoResponse
     *
     * @param DescribeLiveStreamSnapshotInfoRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DescribeLiveStreamSnapshotInfoResponse
     */
    public function describeLiveStreamSnapshotInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->limit) {
            @$query['Limit'] = $request->limit;
        }

        if (null !== $request->order) {
            @$query['Order'] = $request->order;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamSnapshotInfo',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamSnapshotInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the snapshots that were captured within a specific time period.
     *
     * @remarks
     * You can query only snapshots that were captured in the last year.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamSnapshotInfoRequest
     *
     * @returns DescribeLiveStreamSnapshotInfoResponse
     *
     * @param DescribeLiveStreamSnapshotInfoRequest $request
     *
     * @return DescribeLiveStreamSnapshotInfoResponse
     */
    public function describeLiveStreamSnapshotInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamSnapshotInfoWithOptions($request, $runtime);
    }

    /**
     * Queries the status of a stream in real time.
     *
     * @remarks
     * Obtain the streaming domain, and then call this operation to query the status of a stream in real time. If the stream is in the offline status, you can check the stream ingest callback to learn about the reason that causes the offline status. This operation does not provide detailed information.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamStateRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveStreamStateResponse
     *
     * @param DescribeLiveStreamStateRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeLiveStreamStateResponse
     */
    public function describeLiveStreamStateWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamState',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamStateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the status of a stream in real time.
     *
     * @remarks
     * Obtain the streaming domain, and then call this operation to query the status of a stream in real time. If the stream is in the offline status, you can check the stream ingest callback to learn about the reason that causes the offline status. This operation does not provide detailed information.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamStateRequest
     *
     * @returns DescribeLiveStreamStateResponse
     *
     * @param DescribeLiveStreamStateRequest $request
     *
     * @return DescribeLiveStreamStateResponse
     */
    public function describeLiveStreamState($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamStateWithOptions($request, $runtime);
    }

    /**
     * Queries the transcoding configurations of a streaming domain.
     *
     * @remarks
     * Obtain the main streaming domain, and then call this operation to query the transcoding configurations.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamTranscodeInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveStreamTranscodeInfoResponse
     *
     * @param DescribeLiveStreamTranscodeInfoRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return DescribeLiveStreamTranscodeInfoResponse
     */
    public function describeLiveStreamTranscodeInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainTranscodeName) {
            @$query['DomainTranscodeName'] = $request->domainTranscodeName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamTranscodeInfo',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamTranscodeInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the transcoding configurations of a streaming domain.
     *
     * @remarks
     * Obtain the main streaming domain, and then call this operation to query the transcoding configurations.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamTranscodeInfoRequest
     *
     * @returns DescribeLiveStreamTranscodeInfoResponse
     *
     * @param DescribeLiveStreamTranscodeInfoRequest $request
     *
     * @return DescribeLiveStreamTranscodeInfoResponse
     */
    public function describeLiveStreamTranscodeInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamTranscodeInfoWithOptions($request, $runtime);
    }

    /**
     * Queries the transcoding data of a specified domain name at the application level and the stream level.
     *
     * @remarks
     *   The maximum time range for a query is 24 hours.
     * *   The minimum time granularity for a query is 5 minutes.
     * *   You can query data in the last 31 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamTranscodeMetricDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveStreamTranscodeMetricDataResponse
     *
     * @param DescribeLiveStreamTranscodeMetricDataRequest $request
     * @param RuntimeOptions                               $runtime
     *
     * @return DescribeLiveStreamTranscodeMetricDataResponse
     */
    public function describeLiveStreamTranscodeMetricDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->nextPageToken) {
            @$query['NextPageToken'] = $request->nextPageToken;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamTranscodeMetricData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamTranscodeMetricDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the transcoding data of a specified domain name at the application level and the stream level.
     *
     * @remarks
     *   The maximum time range for a query is 24 hours.
     * *   The minimum time granularity for a query is 5 minutes.
     * *   You can query data in the last 31 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamTranscodeMetricDataRequest
     *
     * @returns DescribeLiveStreamTranscodeMetricDataResponse
     *
     * @param DescribeLiveStreamTranscodeMetricDataRequest $request
     *
     * @return DescribeLiveStreamTranscodeMetricDataResponse
     */
    public function describeLiveStreamTranscodeMetricData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamTranscodeMetricDataWithOptions($request, $runtime);
    }

    /**
     * Queries the number of transcoded streams in real time.
     *
     * @remarks
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamTranscodeStreamNumRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveStreamTranscodeStreamNumResponse
     *
     * @param DescribeLiveStreamTranscodeStreamNumRequest $request
     * @param RuntimeOptions                              $runtime
     *
     * @return DescribeLiveStreamTranscodeStreamNumResponse
     */
    public function describeLiveStreamTranscodeStreamNumWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->splitType) {
            @$query['SplitType'] = $request->splitType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamTranscodeStreamNum',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamTranscodeStreamNumResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the number of transcoded streams in real time.
     *
     * @remarks
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamTranscodeStreamNumRequest
     *
     * @returns DescribeLiveStreamTranscodeStreamNumResponse
     *
     * @param DescribeLiveStreamTranscodeStreamNumRequest $request
     *
     * @return DescribeLiveStreamTranscodeStreamNumResponse
     */
    public function describeLiveStreamTranscodeStreamNum($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamTranscodeStreamNumWithOptions($request, $runtime);
    }

    /**
     * Queries watermark rules.
     *
     * @remarks
     * When you call this operation, you can specify the PageNumber and PageSize parameters to view watermark rules on separate pages. Make sure that the parameter settings meet the requirements.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamWatermarkRulesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveStreamWatermarkRulesResponse
     *
     * @param DescribeLiveStreamWatermarkRulesRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return DescribeLiveStreamWatermarkRulesResponse
     */
    public function describeLiveStreamWatermarkRulesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamWatermarkRules',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamWatermarkRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries watermark rules.
     *
     * @remarks
     * When you call this operation, you can specify the PageNumber and PageSize parameters to view watermark rules on separate pages. Make sure that the parameter settings meet the requirements.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamWatermarkRulesRequest
     *
     * @returns DescribeLiveStreamWatermarkRulesResponse
     *
     * @param DescribeLiveStreamWatermarkRulesRequest $request
     *
     * @return DescribeLiveStreamWatermarkRulesResponse
     */
    public function describeLiveStreamWatermarkRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamWatermarkRulesWithOptions($request, $runtime);
    }

    /**
     * Queries watermark templates.
     *
     * @remarks
     * You can call this operation to query watermark templates. You can use the PageNumber parameter to view results on separate pages. Make sure that you configure parameters properly when you call this operation.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamWatermarksRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveStreamWatermarksResponse
     *
     * @param DescribeLiveStreamWatermarksRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribeLiveStreamWatermarksResponse
     */
    public function describeLiveStreamWatermarksWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->keyWord) {
            @$query['KeyWord'] = $request->keyWord;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamWatermarks',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamWatermarksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries watermark templates.
     *
     * @remarks
     * You can call this operation to query watermark templates. You can use the PageNumber parameter to view results on separate pages. Make sure that you configure parameters properly when you call this operation.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamWatermarksRequest
     *
     * @returns DescribeLiveStreamWatermarksResponse
     *
     * @param DescribeLiveStreamWatermarksRequest $request
     *
     * @return DescribeLiveStreamWatermarksResponse
     */
    public function describeLiveStreamWatermarks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamWatermarksWithOptions($request, $runtime);
    }

    /**
     * Queries the blacklist of live stream URLs under a main streaming domain.
     *
     * @remarks
     * The stream URLs refer to the URLs for playing in particular.
     * ## QPS limit
     * A single user can perform a maximum of 50 queries per second (QPS). Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
     *
     * @param request - DescribeLiveStreamsBlockListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveStreamsBlockListResponse
     *
     * @param DescribeLiveStreamsBlockListRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribeLiveStreamsBlockListResponse
     */
    public function describeLiveStreamsBlockListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNum) {
            @$query['PageNum'] = $request->pageNum;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamsBlockList',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamsBlockListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the blacklist of live stream URLs under a main streaming domain.
     *
     * @remarks
     * The stream URLs refer to the URLs for playing in particular.
     * ## QPS limit
     * A single user can perform a maximum of 50 queries per second (QPS). Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
     *
     * @param request - DescribeLiveStreamsBlockListRequest
     *
     * @returns DescribeLiveStreamsBlockListResponse
     *
     * @param DescribeLiveStreamsBlockListRequest $request
     *
     * @return DescribeLiveStreamsBlockListResponse
     */
    public function describeLiveStreamsBlockList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamsBlockListWithOptions($request, $runtime);
    }

    /**
     * Queries the operation history of live streams under a domain name or in an application.
     *
     * @remarks
     * You can call this operation to query the operation history of live streams under a domain name or in an application. The operations include all API operations that were called on live streams.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamsControlHistoryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveStreamsControlHistoryResponse
     *
     * @param DescribeLiveStreamsControlHistoryRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return DescribeLiveStreamsControlHistoryResponse
     */
    public function describeLiveStreamsControlHistoryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamsControlHistory',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamsControlHistoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the operation history of live streams under a domain name or in an application.
     *
     * @remarks
     * You can call this operation to query the operation history of live streams under a domain name or in an application. The operations include all API operations that were called on live streams.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamsControlHistoryRequest
     *
     * @returns DescribeLiveStreamsControlHistoryResponse
     *
     * @param DescribeLiveStreamsControlHistoryRequest $request
     *
     * @return DescribeLiveStreamsControlHistoryResponse
     */
    public function describeLiveStreamsControlHistory($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamsControlHistoryWithOptions($request, $runtime);
    }

    /**
     * Queries stream ingest callback records.
     *
     * @remarks
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamsNotifyRecordsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveStreamsNotifyRecordsResponse
     *
     * @param DescribeLiveStreamsNotifyRecordsRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return DescribeLiveStreamsNotifyRecordsResponse
     */
    public function describeLiveStreamsNotifyRecordsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamsNotifyRecords',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamsNotifyRecordsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries stream ingest callback records.
     *
     * @remarks
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamsNotifyRecordsRequest
     *
     * @returns DescribeLiveStreamsNotifyRecordsResponse
     *
     * @param DescribeLiveStreamsNotifyRecordsRequest $request
     *
     * @return DescribeLiveStreamsNotifyRecordsResponse
     */
    public function describeLiveStreamsNotifyRecords($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamsNotifyRecordsWithOptions($request, $runtime);
    }

    /**
     * Queries the callback configuration for stream ingest under an ingest domain.
     *
     * @param request - DescribeLiveStreamsNotifyUrlConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveStreamsNotifyUrlConfigResponse
     *
     * @param DescribeLiveStreamsNotifyUrlConfigRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return DescribeLiveStreamsNotifyUrlConfigResponse
     */
    public function describeLiveStreamsNotifyUrlConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamsNotifyUrlConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamsNotifyUrlConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the callback configuration for stream ingest under an ingest domain.
     *
     * @param request - DescribeLiveStreamsNotifyUrlConfigRequest
     *
     * @returns DescribeLiveStreamsNotifyUrlConfigResponse
     *
     * @param DescribeLiveStreamsNotifyUrlConfigRequest $request
     *
     * @return DescribeLiveStreamsNotifyUrlConfigResponse
     */
    public function describeLiveStreamsNotifyUrlConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamsNotifyUrlConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the information about all active streams under a specified domain name or the active streams of an application under a specified domain name.
     *
     * @remarks
     * You can call this operation to query the following types of streams.
     * *   all: all streams.
     * *   raw: source streams.
     * *   trans: transcoded streams.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamsOnlineListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveStreamsOnlineListResponse
     *
     * @param DescribeLiveStreamsOnlineListRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DescribeLiveStreamsOnlineListResponse
     */
    public function describeLiveStreamsOnlineListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->onlyStream) {
            @$query['OnlyStream'] = $request->onlyStream;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNum) {
            @$query['PageNum'] = $request->pageNum;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->queryType) {
            @$query['QueryType'] = $request->queryType;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        if (null !== $request->streamType) {
            @$query['StreamType'] = $request->streamType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamsOnlineList',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamsOnlineListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about all active streams under a specified domain name or the active streams of an application under a specified domain name.
     *
     * @remarks
     * You can call this operation to query the following types of streams.
     * *   all: all streams.
     * *   raw: source streams.
     * *   trans: transcoded streams.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamsOnlineListRequest
     *
     * @returns DescribeLiveStreamsOnlineListResponse
     *
     * @param DescribeLiveStreamsOnlineListRequest $request
     *
     * @return DescribeLiveStreamsOnlineListResponse
     */
    public function describeLiveStreamsOnlineList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamsOnlineListWithOptions($request, $runtime);
    }

    /**
     * Queries the stream ingest records of a domain name or an application or stream under a domain name.
     *
     * @remarks
     * ## [](#)Usage notes
     * This operation allows you to query streams in the last 30 days. The information of active streams during the queried period is returned. This operation supports the following sorting methods.
     * *   stream_name_desc: sorts the entries in descending order by stream name.
     * *   stream_name_asc: sorts the entries in ascending order by stream name.
     * *   publish_time_desc: sorts the entries in descending order by stream ingest time.
     * *   publish_time_asc: sorts the entries in ascending order by stream ingest time.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 3 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveStreamsPublishListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveStreamsPublishListResponse
     *
     * @param DescribeLiveStreamsPublishListRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DescribeLiveStreamsPublishListResponse
     */
    public function describeLiveStreamsPublishListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->orderBy) {
            @$query['OrderBy'] = $request->orderBy;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->queryType) {
            @$query['QueryType'] = $request->queryType;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        if (null !== $request->streamType) {
            @$query['StreamType'] = $request->streamType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamsPublishList',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamsPublishListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the stream ingest records of a domain name or an application or stream under a domain name.
     *
     * @remarks
     * ## [](#)Usage notes
     * This operation allows you to query streams in the last 30 days. The information of active streams during the queried period is returned. This operation supports the following sorting methods.
     * *   stream_name_desc: sorts the entries in descending order by stream name.
     * *   stream_name_asc: sorts the entries in ascending order by stream name.
     * *   publish_time_desc: sorts the entries in descending order by stream ingest time.
     * *   publish_time_asc: sorts the entries in ascending order by stream ingest time.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 3 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveStreamsPublishListRequest
     *
     * @returns DescribeLiveStreamsPublishListResponse
     *
     * @param DescribeLiveStreamsPublishListRequest $request
     *
     * @return DescribeLiveStreamsPublishListResponse
     */
    public function describeLiveStreamsPublishList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamsPublishListWithOptions($request, $runtime);
    }

    /**
     * Queries the total number of live streams within a specified time range. Data is collected on a daily basis.
     *
     * @remarks
     *   The maximum time range for a query is 15 days.
     * *   You can query data in the last 18 months.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamsTotalCountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveStreamsTotalCountResponse
     *
     * @param DescribeLiveStreamsTotalCountRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DescribeLiveStreamsTotalCountResponse
     */
    public function describeLiveStreamsTotalCountWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->typ) {
            @$query['Typ'] = $request->typ;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveStreamsTotalCount',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveStreamsTotalCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the total number of live streams within a specified time range. Data is collected on a daily basis.
     *
     * @remarks
     *   The maximum time range for a query is 15 days.
     * *   You can query data in the last 18 months.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveStreamsTotalCountRequest
     *
     * @returns DescribeLiveStreamsTotalCountResponse
     *
     * @param DescribeLiveStreamsTotalCountRequest $request
     *
     * @return DescribeLiveStreamsTotalCountResponse
     */
    public function describeLiveStreamsTotalCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveStreamsTotalCountWithOptions($request, $runtime);
    }

    /**
     * Queries the top domain names ranked by traffic.
     *
     * @remarks
     *   If you do not specify the StartTime or EndTime parameter, data of the current month is queried by default. To query data within a specific time range, you must specify both the StartTime and EndTime parameters.
     * *   You can query data in the last 90 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveTopDomainsByFlowRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveTopDomainsByFlowResponse
     *
     * @param DescribeLiveTopDomainsByFlowRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribeLiveTopDomainsByFlowResponse
     */
    public function describeLiveTopDomainsByFlowWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->limit) {
            @$query['Limit'] = $request->limit;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveTopDomainsByFlow',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveTopDomainsByFlowResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the top domain names ranked by traffic.
     *
     * @remarks
     *   If you do not specify the StartTime or EndTime parameter, data of the current month is queried by default. To query data within a specific time range, you must specify both the StartTime and EndTime parameters.
     * *   You can query data in the last 90 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeLiveTopDomainsByFlowRequest
     *
     * @returns DescribeLiveTopDomainsByFlowResponse
     *
     * @param DescribeLiveTopDomainsByFlowRequest $request
     *
     * @return DescribeLiveTopDomainsByFlowResponse
     */
    public function describeLiveTopDomainsByFlow($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveTopDomainsByFlowWithOptions($request, $runtime);
    }

    /**
     * 获取直播指定域名的原始访问日志的下载地址
     *
     * @param request - DescribeLiveTrafficDomainLogRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveTrafficDomainLogResponse
     *
     * @param DescribeLiveTrafficDomainLogRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribeLiveTrafficDomainLogResponse
     */
    public function describeLiveTrafficDomainLogWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveTrafficDomainLog',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveTrafficDomainLogResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 获取直播指定域名的原始访问日志的下载地址
     *
     * @param request - DescribeLiveTrafficDomainLogRequest
     *
     * @returns DescribeLiveTrafficDomainLogResponse
     *
     * @param DescribeLiveTrafficDomainLogRequest $request
     *
     * @return DescribeLiveTrafficDomainLogResponse
     */
    public function describeLiveTrafficDomainLog($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveTrafficDomainLogWithOptions($request, $runtime);
    }

    /**
     * Queries the audio and video data of an ingested stream within a specific period of time.
     *
     * @remarks
     * ### Usage notes
     * - The maximum time range for a query is 24 hours.
     * - The minimum time range for a query is 1 hour.
     * - You can query data in the last 31 days.
     * ### QPS limit
     * You can call this operation up to 10 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveUpVideoAudioInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveUpVideoAudioInfoResponse
     *
     * @param DescribeLiveUpVideoAudioInfoRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribeLiveUpVideoAudioInfoResponse
     */
    public function describeLiveUpVideoAudioInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->stream) {
            @$query['Stream'] = $request->stream;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveUpVideoAudioInfo',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveUpVideoAudioInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the audio and video data of an ingested stream within a specific period of time.
     *
     * @remarks
     * ### Usage notes
     * - The maximum time range for a query is 24 hours.
     * - The minimum time range for a query is 1 hour.
     * - You can query data in the last 31 days.
     * ### QPS limit
     * You can call this operation up to 10 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveUpVideoAudioInfoRequest
     *
     * @returns DescribeLiveUpVideoAudioInfoResponse
     *
     * @param DescribeLiveUpVideoAudioInfoRequest $request
     *
     * @return DescribeLiveUpVideoAudioInfoResponse
     */
    public function describeLiveUpVideoAudioInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveUpVideoAudioInfoWithOptions($request, $runtime);
    }

    /**
     * Queries the estimated bills of ApsaraVideo Live in your Alibaba Cloud account.
     *
     * @remarks
     * You can call this operation to estimate resource usage of the current month based on the metering method that is specified on the first day of the month. You can call this operation to estimate resource usage of only the current month within your Alibaba Cloud account. The time range used for the estimation starts at 00:00 on the first day of the month and ends 2 hours earlier than the current time.
     * *   Pay by monthly 95th percentile bandwidth: The top 5% values between the start time and end time are excluded. The highest value among the remaining values is the estimated value.
     * *   Pay by average daily peak bandwidth per month: Estimated value = Sum of daily peak bandwidth values/Number of days. The current day is excluded.
     * *   Pay by 4th peak bandwidth per month: The estimated value is the 4th peak bandwidth value between the start time and end time. If the time range is less than four days, the estimated value is 0.
     * *   Pay by average daily 95th percentile bandwidth per month: Estimated value = Sum of daily 95th percentile bandwidth values/Number of days. The current day is excluded.
     * *   Pay by 95th percentile bandwidth with 50% off from 00:00 to 08:00: The top 5% values between the start time and end time are excluded. The highest value among the remaining values is the estimated value.
     * ## [](#qps-)QPS limit
     * You can call this operation once per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveUserBillPredictionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveUserBillPredictionResponse
     *
     * @param DescribeLiveUserBillPredictionRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DescribeLiveUserBillPredictionResponse
     */
    public function describeLiveUserBillPredictionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveUserBillPrediction',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveUserBillPredictionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the estimated bills of ApsaraVideo Live in your Alibaba Cloud account.
     *
     * @remarks
     * You can call this operation to estimate resource usage of the current month based on the metering method that is specified on the first day of the month. You can call this operation to estimate resource usage of only the current month within your Alibaba Cloud account. The time range used for the estimation starts at 00:00 on the first day of the month and ends 2 hours earlier than the current time.
     * *   Pay by monthly 95th percentile bandwidth: The top 5% values between the start time and end time are excluded. The highest value among the remaining values is the estimated value.
     * *   Pay by average daily peak bandwidth per month: Estimated value = Sum of daily peak bandwidth values/Number of days. The current day is excluded.
     * *   Pay by 4th peak bandwidth per month: The estimated value is the 4th peak bandwidth value between the start time and end time. If the time range is less than four days, the estimated value is 0.
     * *   Pay by average daily 95th percentile bandwidth per month: Estimated value = Sum of daily 95th percentile bandwidth values/Number of days. The current day is excluded.
     * *   Pay by 95th percentile bandwidth with 50% off from 00:00 to 08:00: The top 5% values between the start time and end time are excluded. The highest value among the remaining values is the estimated value.
     * ## [](#qps-)QPS limit
     * You can call this operation once per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveUserBillPredictionRequest
     *
     * @returns DescribeLiveUserBillPredictionResponse
     *
     * @param DescribeLiveUserBillPredictionRequest $request
     *
     * @return DescribeLiveUserBillPredictionResponse
     */
    public function describeLiveUserBillPrediction($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveUserBillPredictionWithOptions($request, $runtime);
    }

    /**
     * Queries domain names of ApsaraVideo Live in your Alibaba Cloud account.
     *
     * @remarks
     * ## [](#)Usage notes
     * You can call this operation to query all domain names of ApsaraVideo Live within your Alibaba Cloud account. The supported types of domain names are streaming domains and edge ingest domains.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveUserDomainsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveUserDomainsResponse
     *
     * @param DescribeLiveUserDomainsRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeLiveUserDomainsResponse
     */
    public function describeLiveUserDomainsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->domainSearchType) {
            @$query['DomainSearchType'] = $request->domainSearchType;
        }

        if (null !== $request->domainStatus) {
            @$query['DomainStatus'] = $request->domainStatus;
        }

        if (null !== $request->liveDomainType) {
            @$query['LiveDomainType'] = $request->liveDomainType;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionName) {
            @$query['RegionName'] = $request->regionName;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveUserDomains',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveUserDomainsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries domain names of ApsaraVideo Live in your Alibaba Cloud account.
     *
     * @remarks
     * ## [](#)Usage notes
     * You can call this operation to query all domain names of ApsaraVideo Live within your Alibaba Cloud account. The supported types of domain names are streaming domains and edge ingest domains.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeLiveUserDomainsRequest
     *
     * @returns DescribeLiveUserDomainsResponse
     *
     * @param DescribeLiveUserDomainsRequest $request
     *
     * @return DescribeLiveUserDomainsResponse
     */
    public function describeLiveUserDomains($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveUserDomainsWithOptions($request, $runtime);
    }

    /**
     * 查询指定域名流粒度批量数据.
     *
     * @param request - DescribeLiveUserStreamMetricDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveUserStreamMetricDataResponse
     *
     * @param DescribeLiveUserStreamMetricDataRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return DescribeLiveUserStreamMetricDataResponse
     */
    public function describeLiveUserStreamMetricDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->protocol) {
            @$query['Protocol'] = $request->protocol;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveUserStreamMetricData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveUserStreamMetricDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 查询指定域名流粒度批量数据.
     *
     * @param request - DescribeLiveUserStreamMetricDataRequest
     *
     * @returns DescribeLiveUserStreamMetricDataResponse
     *
     * @param DescribeLiveUserStreamMetricDataRequest $request
     *
     * @return DescribeLiveUserStreamMetricDataResponse
     */
    public function describeLiveUserStreamMetricData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveUserStreamMetricDataWithOptions($request, $runtime);
    }

    /**
     * @param request - DescribeLiveUserTagsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveUserTagsResponse
     *
     * @param DescribeLiveUserTagsRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DescribeLiveUserTagsResponse
     */
    public function describeLiveUserTagsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveUserTags',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveUserTagsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param request - DescribeLiveUserTagsRequest
     *
     * @returns DescribeLiveUserTagsResponse
     *
     * @param DescribeLiveUserTagsRequest $request
     *
     * @return DescribeLiveUserTagsResponse
     */
    public function describeLiveUserTags($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveUserTagsWithOptions($request, $runtime);
    }

    /**
     * 获取直播指定域名的原始访问日志的下载地址
     *
     * @param request - DescribeLiveUserTrafficLogRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveUserTrafficLogResponse
     *
     * @param DescribeLiveUserTrafficLogRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeLiveUserTrafficLogResponse
     */
    public function describeLiveUserTrafficLogWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveUserTrafficLog',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveUserTrafficLogResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 获取直播指定域名的原始访问日志的下载地址
     *
     * @param request - DescribeLiveUserTrafficLogRequest
     *
     * @returns DescribeLiveUserTrafficLogResponse
     *
     * @param DescribeLiveUserTrafficLogRequest $request
     *
     * @return DescribeLiveUserTrafficLogResponse
     */
    public function describeLiveUserTrafficLog($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveUserTrafficLogWithOptions($request, $runtime);
    }

    /**
     * Queries the ownership verification content of a domain name.
     *
     * @remarks
     * ## [](#)Usage notes
     * *   You can call this operation to query the ownership verification content of a single domain name.
     * *   You can call this operation up to 30 times per second per account.
     * *   When you call this operation, you need to specify a domain name as a request parameter.
     * *   After a successful call, the verification content and request ID are returned, which can be used for subsequent operations.
     *
     * @param request - DescribeLiveVerifyContentRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLiveVerifyContentResponse
     *
     * @param DescribeLiveVerifyContentRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeLiveVerifyContentResponse
     */
    public function describeLiveVerifyContentWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLiveVerifyContent',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLiveVerifyContentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the ownership verification content of a domain name.
     *
     * @remarks
     * ## [](#)Usage notes
     * *   You can call this operation to query the ownership verification content of a single domain name.
     * *   You can call this operation up to 30 times per second per account.
     * *   When you call this operation, you need to specify a domain name as a request parameter.
     * *   After a successful call, the verification content and request ID are returned, which can be used for subsequent operations.
     *
     * @param request - DescribeLiveVerifyContentRequest
     *
     * @returns DescribeLiveVerifyContentResponse
     *
     * @param DescribeLiveVerifyContentRequest $request
     *
     * @return DescribeLiveVerifyContentResponse
     */
    public function describeLiveVerifyContent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLiveVerifyContentWithOptions($request, $runtime);
    }

    /**
     * DescribeMeterLiveBypassDuration.
     *
     * @remarks
     * ## [](#)Usage notes
     * *   The maximum time range for a query is 31 days.
     * *   The minimum time granularity for a query is 5 minutes.
     * *   You can query the data in the last 90 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeMeterLiveBypassDurationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeMeterLiveBypassDurationResponse
     *
     * @param DescribeMeterLiveBypassDurationRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return DescribeMeterLiveBypassDurationResponse
     */
    public function describeMeterLiveBypassDurationWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->interval) {
            @$query['Interval'] = $request->interval;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeMeterLiveBypassDuration',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeMeterLiveBypassDurationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * DescribeMeterLiveBypassDuration.
     *
     * @remarks
     * ## [](#)Usage notes
     * *   The maximum time range for a query is 31 days.
     * *   The minimum time granularity for a query is 5 minutes.
     * *   You can query the data in the last 90 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeMeterLiveBypassDurationRequest
     *
     * @returns DescribeMeterLiveBypassDurationResponse
     *
     * @param DescribeMeterLiveBypassDurationRequest $request
     *
     * @return DescribeMeterLiveBypassDurationResponse
     */
    public function describeMeterLiveBypassDuration($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeMeterLiveBypassDurationWithOptions($request, $runtime);
    }

    /**
     * Queries stream mixing tasks.
     *
     * @remarks
     * You can call the [CreateMixStream](https://help.aliyun.com/document_detail/2848087.html) operation to create stream mixing tasks and then call this operation to query the list of stream mixing tasks.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeMixStreamListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeMixStreamListResponse
     *
     * @param DescribeMixStreamListRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DescribeMixStreamListResponse
     */
    public function describeMixStreamListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->mixStreamId) {
            @$query['MixStreamId'] = $request->mixStreamId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNo) {
            @$query['PageNo'] = $request->pageNo;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeMixStreamList',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeMixStreamListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries stream mixing tasks.
     *
     * @remarks
     * You can call the [CreateMixStream](https://help.aliyun.com/document_detail/2848087.html) operation to create stream mixing tasks and then call this operation to query the list of stream mixing tasks.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeMixStreamListRequest
     *
     * @returns DescribeMixStreamListResponse
     *
     * @param DescribeMixStreamListRequest $request
     *
     * @return DescribeMixStreamListResponse
     */
    public function describeMixStreamList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeMixStreamListWithOptions($request, $runtime);
    }

    /**
     * Queries the information about the factors that cause latency of first frames within a specified period of time.
     *
     * @remarks
     * You can call this operation to query the information about the factors that cause latency of first frames within a specified period of time. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
     *
     * @param tmpReq - DescribeRTSNativeSDKFirstFrameCostRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRTSNativeSDKFirstFrameCostResponse
     *
     * @param DescribeRTSNativeSDKFirstFrameCostRequest $tmpReq
     * @param RuntimeOptions                            $runtime
     *
     * @return DescribeRTSNativeSDKFirstFrameCostResponse
     */
    public function describeRTSNativeSDKFirstFrameCostWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new DescribeRTSNativeSDKFirstFrameCostShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->domainNameList) {
            $request->domainNameListShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->domainNameList, 'DomainNameList', 'json');
        }

        $query = [];
        if (null !== $request->dataInterval) {
            @$query['DataInterval'] = $request->dataInterval;
        }

        if (null !== $request->domainNameListShrink) {
            @$query['DomainNameList'] = $request->domainNameListShrink;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRTSNativeSDKFirstFrameCost',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRTSNativeSDKFirstFrameCostResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about the factors that cause latency of first frames within a specified period of time.
     *
     * @remarks
     * You can call this operation to query the information about the factors that cause latency of first frames within a specified period of time. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
     *
     * @param request - DescribeRTSNativeSDKFirstFrameCostRequest
     *
     * @returns DescribeRTSNativeSDKFirstFrameCostResponse
     *
     * @param DescribeRTSNativeSDKFirstFrameCostRequest $request
     *
     * @return DescribeRTSNativeSDKFirstFrameCostResponse
     */
    public function describeRTSNativeSDKFirstFrameCost($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRTSNativeSDKFirstFrameCostWithOptions($request, $runtime);
    }

    /**
     * Queries the average latency of first frames within a specified period of time.
     *
     * @remarks
     * You can call this operation to query the average latency of first frames within a specified period of time. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
     *
     * @param tmpReq - DescribeRTSNativeSDKFirstFrameDelayRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRTSNativeSDKFirstFrameDelayResponse
     *
     * @param DescribeRTSNativeSDKFirstFrameDelayRequest $tmpReq
     * @param RuntimeOptions                             $runtime
     *
     * @return DescribeRTSNativeSDKFirstFrameDelayResponse
     */
    public function describeRTSNativeSDKFirstFrameDelayWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new DescribeRTSNativeSDKFirstFrameDelayShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->domainNameList) {
            $request->domainNameListShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->domainNameList, 'DomainNameList', 'json');
        }

        $query = [];
        if (null !== $request->dataInterval) {
            @$query['DataInterval'] = $request->dataInterval;
        }

        if (null !== $request->domainNameListShrink) {
            @$query['DomainNameList'] = $request->domainNameListShrink;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRTSNativeSDKFirstFrameDelay',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRTSNativeSDKFirstFrameDelayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the average latency of first frames within a specified period of time.
     *
     * @remarks
     * You can call this operation to query the average latency of first frames within a specified period of time. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
     *
     * @param request - DescribeRTSNativeSDKFirstFrameDelayRequest
     *
     * @returns DescribeRTSNativeSDKFirstFrameDelayResponse
     *
     * @param DescribeRTSNativeSDKFirstFrameDelayRequest $request
     *
     * @return DescribeRTSNativeSDKFirstFrameDelayResponse
     */
    public function describeRTSNativeSDKFirstFrameDelay($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRTSNativeSDKFirstFrameDelayWithOptions($request, $runtime);
    }

    /**
     * Queries the causes of playback failures that occurred within a specified period of time. The causes are returned in the form of status codes.
     *
     * @remarks
     * You can call this operation to query the causes of playback failures that occurred within a specified period of time. The causes are returned in the form of status codes. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
     *
     * @param tmpReq - DescribeRTSNativeSDKPlayFailStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRTSNativeSDKPlayFailStatusResponse
     *
     * @param DescribeRTSNativeSDKPlayFailStatusRequest $tmpReq
     * @param RuntimeOptions                            $runtime
     *
     * @return DescribeRTSNativeSDKPlayFailStatusResponse
     */
    public function describeRTSNativeSDKPlayFailStatusWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new DescribeRTSNativeSDKPlayFailStatusShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->domainNameList) {
            $request->domainNameListShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->domainNameList, 'DomainNameList', 'json');
        }

        $query = [];
        if (null !== $request->dataInterval) {
            @$query['DataInterval'] = $request->dataInterval;
        }

        if (null !== $request->domainNameListShrink) {
            @$query['DomainNameList'] = $request->domainNameListShrink;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRTSNativeSDKPlayFailStatus',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRTSNativeSDKPlayFailStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the causes of playback failures that occurred within a specified period of time. The causes are returned in the form of status codes.
     *
     * @remarks
     * You can call this operation to query the causes of playback failures that occurred within a specified period of time. The causes are returned in the form of status codes. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
     *
     * @param request - DescribeRTSNativeSDKPlayFailStatusRequest
     *
     * @returns DescribeRTSNativeSDKPlayFailStatusResponse
     *
     * @param DescribeRTSNativeSDKPlayFailStatusRequest $request
     *
     * @return DescribeRTSNativeSDKPlayFailStatusResponse
     */
    public function describeRTSNativeSDKPlayFailStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRTSNativeSDKPlayFailStatusWithOptions($request, $runtime);
    }

    /**
     * Queries the playback duration within a specified period of time.
     *
     * @remarks
     * You can query the playback duration within a specified period of time. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
     *
     * @param tmpReq - DescribeRTSNativeSDKPlayTimeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRTSNativeSDKPlayTimeResponse
     *
     * @param DescribeRTSNativeSDKPlayTimeRequest $tmpReq
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribeRTSNativeSDKPlayTimeResponse
     */
    public function describeRTSNativeSDKPlayTimeWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new DescribeRTSNativeSDKPlayTimeShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->domainNameList) {
            $request->domainNameListShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->domainNameList, 'DomainNameList', 'json');
        }

        $query = [];
        if (null !== $request->dataInterval) {
            @$query['DataInterval'] = $request->dataInterval;
        }

        if (null !== $request->domainNameListShrink) {
            @$query['DomainNameList'] = $request->domainNameListShrink;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRTSNativeSDKPlayTime',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRTSNativeSDKPlayTimeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the playback duration within a specified period of time.
     *
     * @remarks
     * You can query the playback duration within a specified period of time. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
     *
     * @param request - DescribeRTSNativeSDKPlayTimeRequest
     *
     * @returns DescribeRTSNativeSDKPlayTimeResponse
     *
     * @param DescribeRTSNativeSDKPlayTimeRequest $request
     *
     * @return DescribeRTSNativeSDKPlayTimeResponse
     */
    public function describeRTSNativeSDKPlayTime($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRTSNativeSDKPlayTimeWithOptions($request, $runtime);
    }

    /**
     * Queries the total number of playbacks and the number of successful playbacks within a specified period of time.
     *
     * @remarks
     * QPS limit You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
     *
     * @param tmpReq - DescribeRTSNativeSDKVvDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRTSNativeSDKVvDataResponse
     *
     * @param DescribeRTSNativeSDKVvDataRequest $tmpReq
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeRTSNativeSDKVvDataResponse
     */
    public function describeRTSNativeSDKVvDataWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new DescribeRTSNativeSDKVvDataShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->domainNameList) {
            $request->domainNameListShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->domainNameList, 'DomainNameList', 'json');
        }

        $query = [];
        if (null !== $request->dataInterval) {
            @$query['DataInterval'] = $request->dataInterval;
        }

        if (null !== $request->domainNameListShrink) {
            @$query['DomainNameList'] = $request->domainNameListShrink;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRTSNativeSDKVvData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRTSNativeSDKVvDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the total number of playbacks and the number of successful playbacks within a specified period of time.
     *
     * @remarks
     * QPS limit You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
     *
     * @param request - DescribeRTSNativeSDKVvDataRequest
     *
     * @returns DescribeRTSNativeSDKVvDataResponse
     *
     * @param DescribeRTSNativeSDKVvDataRequest $request
     *
     * @return DescribeRTSNativeSDKVvDataResponse
     */
    public function describeRTSNativeSDKVvData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRTSNativeSDKVvDataWithOptions($request, $runtime);
    }

    /**
     * 查询rtc云端录制文件与任务信息.
     *
     * @param request - DescribeRtcCloudRecordingFilesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRtcCloudRecordingFilesResponse
     *
     * @param DescribeRtcCloudRecordingFilesRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DescribeRtcCloudRecordingFilesResponse
     */
    public function describeRtcCloudRecordingFilesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRtcCloudRecordingFiles',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRtcCloudRecordingFilesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 查询rtc云端录制文件与任务信息.
     *
     * @param request - DescribeRtcCloudRecordingFilesRequest
     *
     * @returns DescribeRtcCloudRecordingFilesResponse
     *
     * @param DescribeRtcCloudRecordingFilesRequest $request
     *
     * @return DescribeRtcCloudRecordingFilesResponse
     */
    public function describeRtcCloudRecordingFiles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRtcCloudRecordingFilesWithOptions($request, $runtime);
    }

    /**
     * Queries information about a subscription to mixed-stream relay events.
     *
     * @remarks
     * ### Usage notes
     * - You can call this operation to query information about a subscription to mixed-stream relay events.
     * - Before you call this operation, make sure that you have called the CreateRtcMPUEventSub operation to create the subscription.
     * ### QPS limit
     * - You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeRtcMPUEventSubRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRtcMPUEventSubResponse
     *
     * @param DescribeRtcMPUEventSubRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DescribeRtcMPUEventSubResponse
     */
    public function describeRtcMPUEventSubWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRtcMPUEventSub',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRtcMPUEventSubResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries information about a subscription to mixed-stream relay events.
     *
     * @remarks
     * ### Usage notes
     * - You can call this operation to query information about a subscription to mixed-stream relay events.
     * - Before you call this operation, make sure that you have called the CreateRtcMPUEventSub operation to create the subscription.
     * ### QPS limit
     * - You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeRtcMPUEventSubRequest
     *
     * @returns DescribeRtcMPUEventSubResponse
     *
     * @param DescribeRtcMPUEventSubRequest $request
     *
     * @return DescribeRtcMPUEventSubResponse
     */
    public function describeRtcMPUEventSub($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRtcMPUEventSubWithOptions($request, $runtime);
    }

    /**
     * Queries the details of the episode list.
     *
     * @remarks
     * You cannot call this operation if the episode list is empty. For information about how to add episodes to the episode list, see [AddShowIntoShowList](https://help.aliyun.com/document_detail/2848051.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeShowListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeShowListResponse
     *
     * @param DescribeShowListRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DescribeShowListResponse
     */
    public function describeShowListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeShowList',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeShowListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of the episode list.
     *
     * @remarks
     * You cannot call this operation if the episode list is empty. For information about how to add episodes to the episode list, see [AddShowIntoShowList](https://help.aliyun.com/document_detail/2848051.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeShowListRequest
     *
     * @returns DescribeShowListResponse
     *
     * @param DescribeShowListRequest $request
     *
     * @return DescribeShowListResponse
     */
    public function describeShowList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeShowListWithOptions($request, $runtime);
    }

    /**
     * Queries configurations of stream-level region blocking.
     *
     * @remarks
     * Queries configurations of stream-level region blocking.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeStreamLocationBlockRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeStreamLocationBlockResponse
     *
     * @param DescribeStreamLocationBlockRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeStreamLocationBlockResponse
     */
    public function describeStreamLocationBlockWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->blockType) {
            @$query['BlockType'] = $request->blockType;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNum) {
            @$query['PageNum'] = $request->pageNum;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeStreamLocationBlock',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeStreamLocationBlockResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries configurations of stream-level region blocking.
     *
     * @remarks
     * Queries configurations of stream-level region blocking.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeStreamLocationBlockRequest
     *
     * @returns DescribeStreamLocationBlockResponse
     *
     * @param DescribeStreamLocationBlockRequest $request
     *
     * @return DescribeStreamLocationBlockResponse
     */
    public function describeStreamLocationBlock($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeStreamLocationBlockWithOptions($request, $runtime);
    }

    /**
     * Queries one or more layouts of a virtual studio.
     *
     * @remarks
     * You must call the [AddStudioLayout](https://help.aliyun.com/document_detail/215388.html) operation to configure layouts for a virtual studio before you call this operation to query layouts.
     * ## QPS limits
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
     *
     * @param request - DescribeStudioLayoutsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeStudioLayoutsResponse
     *
     * @param DescribeStudioLayoutsRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DescribeStudioLayoutsResponse
     */
    public function describeStudioLayoutsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->layoutId) {
            @$query['LayoutId'] = $request->layoutId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeStudioLayouts',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeStudioLayoutsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries one or more layouts of a virtual studio.
     *
     * @remarks
     * You must call the [AddStudioLayout](https://help.aliyun.com/document_detail/215388.html) operation to configure layouts for a virtual studio before you call this operation to query layouts.
     * ## QPS limits
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
     *
     * @param request - DescribeStudioLayoutsRequest
     *
     * @returns DescribeStudioLayoutsResponse
     *
     * @param DescribeStudioLayoutsRequest $request
     *
     * @return DescribeStudioLayoutsResponse
     */
    public function describeStudioLayouts($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeStudioLayoutsWithOptions($request, $runtime);
    }

    /**
     * Queries the stream pulling information about a live stream of a headline.
     *
     * @remarks
     * You can call this operation to query the stream pulling information about a live stream of a headline.
     * ## [](#qps-)QPS limits
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeToutiaoLivePlayRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeToutiaoLivePlayResponse
     *
     * @param DescribeToutiaoLivePlayRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeToutiaoLivePlayResponse
     */
    public function describeToutiaoLivePlayWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->app) {
            @$query['App'] = $request->app;
        }

        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->stream) {
            @$query['Stream'] = $request->stream;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeToutiaoLivePlay',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeToutiaoLivePlayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the stream pulling information about a live stream of a headline.
     *
     * @remarks
     * You can call this operation to query the stream pulling information about a live stream of a headline.
     * ## [](#qps-)QPS limits
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeToutiaoLivePlayRequest
     *
     * @returns DescribeToutiaoLivePlayResponse
     *
     * @param DescribeToutiaoLivePlayRequest $request
     *
     * @return DescribeToutiaoLivePlayResponse
     */
    public function describeToutiaoLivePlay($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeToutiaoLivePlayWithOptions($request, $runtime);
    }

    /**
     * Queries the ingest information of a specified live stream that is ingested to Toutiao.
     *
     * @remarks
     * You can call this operation to query the ingest information of a specified live stream that is ingested to Toutiao.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeToutiaoLivePublishRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeToutiaoLivePublishResponse
     *
     * @param DescribeToutiaoLivePublishRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeToutiaoLivePublishResponse
     */
    public function describeToutiaoLivePublishWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->app) {
            @$query['App'] = $request->app;
        }

        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->stream) {
            @$query['Stream'] = $request->stream;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeToutiaoLivePublish',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeToutiaoLivePublishResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the ingest information of a specified live stream that is ingested to Toutiao.
     *
     * @remarks
     * You can call this operation to query the ingest information of a specified live stream that is ingested to Toutiao.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeToutiaoLivePublishRequest
     *
     * @returns DescribeToutiaoLivePublishResponse
     *
     * @param DescribeToutiaoLivePublishRequest $request
     *
     * @return DescribeToutiaoLivePublishResponse
     */
    public function describeToutiaoLivePublish($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeToutiaoLivePublishWithOptions($request, $runtime);
    }

    /**
     * 新增查询 uid 级别或域名app级别在线流
     *
     * @param request - DescribeUidOnlineStreamsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeUidOnlineStreamsResponse
     *
     * @param DescribeUidOnlineStreamsRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeUidOnlineStreamsResponse
     */
    public function describeUidOnlineStreamsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeUidOnlineStreams',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeUidOnlineStreamsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 新增查询 uid 级别或域名app级别在线流
     *
     * @param request - DescribeUidOnlineStreamsRequest
     *
     * @returns DescribeUidOnlineStreamsResponse
     *
     * @param DescribeUidOnlineStreamsRequest $request
     *
     * @return DescribeUidOnlineStreamsResponse
     */
    public function describeUidOnlineStreams($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUidOnlineStreamsWithOptions($request, $runtime);
    }

    /**
     * Queries the daily peak inbound bandwidth.
     *
     * @remarks
     * You can call this operation to query the daily peak inbound bandwidth.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeUpBpsPeakDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeUpBpsPeakDataResponse
     *
     * @param DescribeUpBpsPeakDataRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DescribeUpBpsPeakDataResponse
     */
    public function describeUpBpsPeakDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->domainSwitch) {
            @$query['DomainSwitch'] = $request->domainSwitch;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeUpBpsPeakData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeUpBpsPeakDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the daily peak inbound bandwidth.
     *
     * @remarks
     * You can call this operation to query the daily peak inbound bandwidth.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeUpBpsPeakDataRequest
     *
     * @returns DescribeUpBpsPeakDataResponse
     *
     * @param DescribeUpBpsPeakDataRequest $request
     *
     * @return DescribeUpBpsPeakDataResponse
     */
    public function describeUpBpsPeakData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUpBpsPeakDataWithOptions($request, $runtime);
    }

    /**
     * Queries the daily peak inbound bandwidth of a leased line.
     *
     * @remarks
     * You can call this operation to query the daily peak inbound bandwidth of a leased line.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeUpBpsPeakOfLineRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeUpBpsPeakOfLineResponse
     *
     * @param DescribeUpBpsPeakOfLineRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeUpBpsPeakOfLineResponse
     */
    public function describeUpBpsPeakOfLineWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->domainSwitch) {
            @$query['DomainSwitch'] = $request->domainSwitch;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->line) {
            @$query['Line'] = $request->line;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeUpBpsPeakOfLine',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeUpBpsPeakOfLineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the daily peak inbound bandwidth of a leased line.
     *
     * @remarks
     * You can call this operation to query the daily peak inbound bandwidth of a leased line.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeUpBpsPeakOfLineRequest
     *
     * @returns DescribeUpBpsPeakOfLineResponse
     *
     * @param DescribeUpBpsPeakOfLineRequest $request
     *
     * @return DescribeUpBpsPeakOfLineResponse
     */
    public function describeUpBpsPeakOfLine($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUpBpsPeakOfLineWithOptions($request, $runtime);
    }

    /**
     * Queries the daily peak number of concurrently ingested streams.
     *
     * @remarks
     * You can call this operation to query the daily peak number of concurrently ingested streams.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeUpPeakPublishStreamDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeUpPeakPublishStreamDataResponse
     *
     * @param DescribeUpPeakPublishStreamDataRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return DescribeUpPeakPublishStreamDataResponse
     */
    public function describeUpPeakPublishStreamDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->domainSwitch) {
            @$query['DomainSwitch'] = $request->domainSwitch;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeUpPeakPublishStreamData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeUpPeakPublishStreamDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the daily peak number of concurrently ingested streams.
     *
     * @remarks
     * You can call this operation to query the daily peak number of concurrently ingested streams.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - DescribeUpPeakPublishStreamDataRequest
     *
     * @returns DescribeUpPeakPublishStreamDataResponse
     *
     * @param DescribeUpPeakPublishStreamDataRequest $request
     *
     * @return DescribeUpPeakPublishStreamDataResponse
     */
    public function describeUpPeakPublishStreamData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUpPeakPublishStreamDataWithOptions($request, $runtime);
    }

    /**
     * Suspends real-time log delivery for one or more domain names.
     *
     * @remarks
     * Obtain a domain name for which real-time log delivery is enabled, and then call this operation to suspend real-time log delivery for the domain name.
     * This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DisableLiveRealtimeLogDeliveryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DisableLiveRealtimeLogDeliveryResponse
     *
     * @param DisableLiveRealtimeLogDeliveryRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DisableLiveRealtimeLogDeliveryResponse
     */
    public function disableLiveRealtimeLogDeliveryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DisableLiveRealtimeLogDelivery',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DisableLiveRealtimeLogDeliveryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Suspends real-time log delivery for one or more domain names.
     *
     * @remarks
     * Obtain a domain name for which real-time log delivery is enabled, and then call this operation to suspend real-time log delivery for the domain name.
     * This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DisableLiveRealtimeLogDeliveryRequest
     *
     * @returns DisableLiveRealtimeLogDeliveryResponse
     *
     * @param DisableLiveRealtimeLogDeliveryRequest $request
     *
     * @return DisableLiveRealtimeLogDeliveryResponse
     */
    public function disableLiveRealtimeLogDelivery($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->disableLiveRealtimeLogDeliveryWithOptions($request, $runtime);
    }

    /**
     * Dynamically updates a watermark.
     *
     * @remarks
     * Dynamically updating a watermark means replacing the watermark template ID during live streaming. Before you call this operation to update a watermark, you must prepare the watermark template ID that is used for replacement. The watermark template ID is specified by the **TemplateId** parameter of this operation. You can call the [DescribeLiveStreamWatermarks](https://help.aliyun.com/document_detail/2848102.html) operation to obtain available watermark template IDs.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DynamicUpdateWaterMarkStreamRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DynamicUpdateWaterMarkStreamRuleResponse
     *
     * @param DynamicUpdateWaterMarkStreamRuleRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return DynamicUpdateWaterMarkStreamRuleResponse
     */
    public function dynamicUpdateWaterMarkStreamRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->app) {
            @$query['App'] = $request->app;
        }

        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->stream) {
            @$query['Stream'] = $request->stream;
        }

        if (null !== $request->templateId) {
            @$query['TemplateId'] = $request->templateId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DynamicUpdateWaterMarkStreamRule',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DynamicUpdateWaterMarkStreamRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Dynamically updates a watermark.
     *
     * @remarks
     * Dynamically updating a watermark means replacing the watermark template ID during live streaming. Before you call this operation to update a watermark, you must prepare the watermark template ID that is used for replacement. The watermark template ID is specified by the **TemplateId** parameter of this operation. You can call the [DescribeLiveStreamWatermarks](https://help.aliyun.com/document_detail/2848102.html) operation to obtain available watermark template IDs.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DynamicUpdateWaterMarkStreamRuleRequest
     *
     * @returns DynamicUpdateWaterMarkStreamRuleResponse
     *
     * @param DynamicUpdateWaterMarkStreamRuleRequest $request
     *
     * @return DynamicUpdateWaterMarkStreamRuleResponse
     */
    public function dynamicUpdateWaterMarkStreamRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dynamicUpdateWaterMarkStreamRuleWithOptions($request, $runtime);
    }

    /**
     * Edits an episode list.
     *
     * @remarks
     * You can call this operation to update all configurations of episodes in an episode list or replace the episodes.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - EditPlaylistRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns EditPlaylistResponse
     *
     * @param EditPlaylistRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return EditPlaylistResponse
     */
    public function editPlaylistWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->programConfig) {
            @$query['ProgramConfig'] = $request->programConfig;
        }

        if (null !== $request->programId) {
            @$query['ProgramId'] = $request->programId;
        }

        if (null !== $request->programItems) {
            @$query['ProgramItems'] = $request->programItems;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'EditPlaylist',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return EditPlaylistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Edits an episode list.
     *
     * @remarks
     * You can call this operation to update all configurations of episodes in an episode list or replace the episodes.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - EditPlaylistRequest
     *
     * @returns EditPlaylistResponse
     *
     * @param EditPlaylistRequest $request
     *
     * @return EditPlaylistResponse
     */
    public function editPlaylist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->editPlaylistWithOptions($request, $runtime);
    }

    /**
     * Creates an editing task.
     *
     * @remarks
     * You can call this operation to create an editing task by specifying the production studio ID and the episode ID. You will not receive a notification after the editing task is created. You can call the [GetEditingJobInfo](https://help.aliyun.com/document_detail/2848059.html) operation to query the status of the editing task.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - EditShowAndReplaceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns EditShowAndReplaceResponse
     *
     * @param EditShowAndReplaceRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return EditShowAndReplaceResponse
     */
    public function editShowAndReplaceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->showId) {
            @$query['ShowId'] = $request->showId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->storageInfo) {
            @$query['StorageInfo'] = $request->storageInfo;
        }

        if (null !== $request->userData) {
            @$query['UserData'] = $request->userData;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'EditShowAndReplace',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return EditShowAndReplaceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an editing task.
     *
     * @remarks
     * You can call this operation to create an editing task by specifying the production studio ID and the episode ID. You will not receive a notification after the editing task is created. You can call the [GetEditingJobInfo](https://help.aliyun.com/document_detail/2848059.html) operation to query the status of the editing task.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - EditShowAndReplaceRequest
     *
     * @returns EditShowAndReplaceResponse
     *
     * @param EditShowAndReplaceRequest $request
     *
     * @return EditShowAndReplaceResponse
     */
    public function editShowAndReplace($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->editShowAndReplaceWithOptions($request, $runtime);
    }

    /**
     * Switches a scene to the standby resource in a production studio.
     *
     * @remarks
     * You can call this operation to switch a specified scene to the standby resource. Only a PGM scene is supported.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - EffectCasterUrgentRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns EffectCasterUrgentResponse
     *
     * @param EffectCasterUrgentRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return EffectCasterUrgentResponse
     */
    public function effectCasterUrgentWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->sceneId) {
            @$query['SceneId'] = $request->sceneId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'EffectCasterUrgent',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return EffectCasterUrgentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Switches a scene to the standby resource in a production studio.
     *
     * @remarks
     * You can call this operation to switch a specified scene to the standby resource. Only a PGM scene is supported.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - EffectCasterUrgentRequest
     *
     * @returns EffectCasterUrgentResponse
     *
     * @param EffectCasterUrgentRequest $request
     *
     * @return EffectCasterUrgentResponse
     */
    public function effectCasterUrgent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->effectCasterUrgentWithOptions($request, $runtime);
    }

    /**
     * Updates the standby resource in a specified scene.
     *
     * @remarks
     * Make sure that the resource is referenced by the scene.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - EffectCasterVideoResourceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns EffectCasterVideoResourceResponse
     *
     * @param EffectCasterVideoResourceRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return EffectCasterVideoResourceResponse
     */
    public function effectCasterVideoResourceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->sceneId) {
            @$query['SceneId'] = $request->sceneId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'EffectCasterVideoResource',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return EffectCasterVideoResourceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates the standby resource in a specified scene.
     *
     * @remarks
     * Make sure that the resource is referenced by the scene.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - EffectCasterVideoResourceRequest
     *
     * @returns EffectCasterVideoResourceResponse
     *
     * @param EffectCasterVideoResourceRequest $request
     *
     * @return EffectCasterVideoResourceResponse
     */
    public function effectCasterVideoResource($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->effectCasterVideoResourceWithOptions($request, $runtime);
    }

    /**
     * Enables real-time log delivery for one or more domain names.
     *
     * @remarks
     * ##
     * This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
     * ## QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - EnableLiveRealtimeLogDeliveryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns EnableLiveRealtimeLogDeliveryResponse
     *
     * @param EnableLiveRealtimeLogDeliveryRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return EnableLiveRealtimeLogDeliveryResponse
     */
    public function enableLiveRealtimeLogDeliveryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'EnableLiveRealtimeLogDelivery',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return EnableLiveRealtimeLogDeliveryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables real-time log delivery for one or more domain names.
     *
     * @remarks
     * ##
     * This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
     * ## QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - EnableLiveRealtimeLogDeliveryRequest
     *
     * @returns EnableLiveRealtimeLogDeliveryResponse
     *
     * @param EnableLiveRealtimeLogDeliveryRequest $request
     *
     * @return EnableLiveRealtimeLogDeliveryResponse
     */
    public function enableLiveRealtimeLogDelivery($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->enableLiveRealtimeLogDeliveryWithOptions($request, $runtime);
    }

    /**
     * Disables a live stream. You can specify the time when the live stream is resumed.
     *
     * @remarks
     * You can call this operation to disable a live stream and specify the time when the live stream is resumed. If the time is not specified, you can call the [ResumeLiveStream](https://help.aliyun.com/document_detail/2847831.html) operation to resume the live stream. This operation supports only the live streams ingested by streamers.
     * >
     * *   This operation disables a live stream by adding the stream to the blacklist. You can disable up to 10,000 live streams. If the limit is reached, you cannot disable any more live streams. Pay attention to the number of live streams that are disabled. You can call the [DescribeLiveStreamsBlockList](https://help.aliyun.com/document_detail/2847825.html) operation to query the number of live streams that are disabled.
     * *   An interrupted live stream is not added to the blacklist and does not occupy the quota.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ForbidLiveStreamRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ForbidLiveStreamResponse
     *
     * @param ForbidLiveStreamRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return ForbidLiveStreamResponse
     */
    public function forbidLiveStreamWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->liveStreamType) {
            @$query['LiveStreamType'] = $request->liveStreamType;
        }

        if (null !== $request->oneshot) {
            @$query['Oneshot'] = $request->oneshot;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resumeTime) {
            @$query['ResumeTime'] = $request->resumeTime;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ForbidLiveStream',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ForbidLiveStreamResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Disables a live stream. You can specify the time when the live stream is resumed.
     *
     * @remarks
     * You can call this operation to disable a live stream and specify the time when the live stream is resumed. If the time is not specified, you can call the [ResumeLiveStream](https://help.aliyun.com/document_detail/2847831.html) operation to resume the live stream. This operation supports only the live streams ingested by streamers.
     * >
     * *   This operation disables a live stream by adding the stream to the blacklist. You can disable up to 10,000 live streams. If the limit is reached, you cannot disable any more live streams. Pay attention to the number of live streams that are disabled. You can call the [DescribeLiveStreamsBlockList](https://help.aliyun.com/document_detail/2847825.html) operation to query the number of live streams that are disabled.
     * *   An interrupted live stream is not added to the blacklist and does not occupy the quota.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ForbidLiveStreamRequest
     *
     * @returns ForbidLiveStreamResponse
     *
     * @param ForbidLiveStreamRequest $request
     *
     * @return ForbidLiveStreamResponse
     */
    public function forbidLiveStream($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->forbidLiveStreamWithOptions($request, $runtime);
    }

    /**
     * Queries all custom stream mixing templates.
     *
     * @remarks
     * You can call this operation to query all custom stream mixing templates. A list of template names and template configurations is returned.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - GetAllCustomTemplatesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetAllCustomTemplatesResponse
     *
     * @param GetAllCustomTemplatesRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return GetAllCustomTemplatesResponse
     */
    public function getAllCustomTemplatesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userId) {
            @$query['UserId'] = $request->userId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetAllCustomTemplates',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetAllCustomTemplatesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries all custom stream mixing templates.
     *
     * @remarks
     * You can call this operation to query all custom stream mixing templates. A list of template names and template configurations is returned.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - GetAllCustomTemplatesRequest
     *
     * @returns GetAllCustomTemplatesResponse
     *
     * @param GetAllCustomTemplatesRequest $request
     *
     * @return GetAllCustomTemplatesResponse
     */
    public function getAllCustomTemplates($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAllCustomTemplatesWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a custom stream mixing template.
     *
     * @remarks
     * Obtain the name of the custom stream mixing template, and then call this operation to query the information about the template.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - GetCustomTemplateRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetCustomTemplateResponse
     *
     * @param GetCustomTemplateRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return GetCustomTemplateResponse
     */
    public function getCustomTemplateWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->template) {
            @$query['Template'] = $request->template;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetCustomTemplate',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetCustomTemplateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a custom stream mixing template.
     *
     * @remarks
     * Obtain the name of the custom stream mixing template, and then call this operation to query the information about the template.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - GetCustomTemplateRequest
     *
     * @returns GetCustomTemplateResponse
     *
     * @param GetCustomTemplateRequest $request
     *
     * @return GetCustomTemplateResponse
     */
    public function getCustomTemplate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCustomTemplateWithOptions($request, $runtime);
    }

    /**
     * Queries the details of an edge transcoding task.
     *
     * @remarks
     * To call this operation, make sure that you have the permissions to access the edge transcoding feature.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - GetEdgeTranscodeJobRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetEdgeTranscodeJobResponse
     *
     * @param GetEdgeTranscodeJobRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return GetEdgeTranscodeJobResponse
     */
    public function getEdgeTranscodeJobWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->jobId) {
            @$query['JobId'] = $request->jobId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetEdgeTranscodeJob',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetEdgeTranscodeJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of an edge transcoding task.
     *
     * @remarks
     * To call this operation, make sure that you have the permissions to access the edge transcoding feature.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - GetEdgeTranscodeJobRequest
     *
     * @returns GetEdgeTranscodeJobResponse
     *
     * @param GetEdgeTranscodeJobRequest $request
     *
     * @return GetEdgeTranscodeJobResponse
     */
    public function getEdgeTranscodeJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getEdgeTranscodeJobWithOptions($request, $runtime);
    }

    /**
     * Queries the details of an edge transcoding template.
     *
     * @remarks
     *   You can call this operation to query the details of an edge transcoding template.
     * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - GetEdgeTranscodeTemplateRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetEdgeTranscodeTemplateResponse
     *
     * @param GetEdgeTranscodeTemplateRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return GetEdgeTranscodeTemplateResponse
     */
    public function getEdgeTranscodeTemplateWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->templateId) {
            @$query['TemplateId'] = $request->templateId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetEdgeTranscodeTemplate',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetEdgeTranscodeTemplateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of an edge transcoding template.
     *
     * @remarks
     *   You can call this operation to query the details of an edge transcoding template.
     * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - GetEdgeTranscodeTemplateRequest
     *
     * @returns GetEdgeTranscodeTemplateResponse
     *
     * @param GetEdgeTranscodeTemplateRequest $request
     *
     * @return GetEdgeTranscodeTemplateResponse
     */
    public function getEdgeTranscodeTemplate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getEdgeTranscodeTemplateWithOptions($request, $runtime);
    }

    /**
     * Queries the information about editing tasks.
     *
     * @remarks
     *   When you call this operation, you can specify the CasterId and ShowId parameters to query the information about specific editing tasks. Make sure that the parameter settings meet the requirements.
     * *   If you specify the ShowId parameter in the request, the information about the editing tasks for the specified episode is returned.
     * *   If you do not specify the ShowId parameter in the request, the information about the editing tasks for the entire episode list is returned.
     * ### [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - GetEditingJobInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetEditingJobInfoResponse
     *
     * @param GetEditingJobInfoRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return GetEditingJobInfoResponse
     */
    public function getEditingJobInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->showId) {
            @$query['ShowId'] = $request->showId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetEditingJobInfo',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetEditingJobInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about editing tasks.
     *
     * @remarks
     *   When you call this operation, you can specify the CasterId and ShowId parameters to query the information about specific editing tasks. Make sure that the parameter settings meet the requirements.
     * *   If you specify the ShowId parameter in the request, the information about the editing tasks for the specified episode is returned.
     * *   If you do not specify the ShowId parameter in the request, the information about the editing tasks for the entire episode list is returned.
     * ### [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - GetEditingJobInfoRequest
     *
     * @returns GetEditingJobInfoResponse
     *
     * @param GetEditingJobInfoRequest $request
     *
     * @return GetEditingJobInfoResponse
     */
    public function getEditingJobInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getEditingJobInfoWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a specified interactive messaging application.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - GetMessageAppRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetMessageAppResponse
     *
     * @param GetMessageAppRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return GetMessageAppResponse
     */
    public function getMessageAppWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->appId) {
            @$body['AppId'] = $request->appId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetMessageApp',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetMessageAppResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a specified interactive messaging application.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - GetMessageAppRequest
     *
     * @returns GetMessageAppResponse
     *
     * @param GetMessageAppRequest $request
     *
     * @return GetMessageAppResponse
     */
    public function getMessageApp($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMessageAppWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a message group.
     *
     * @remarks
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - GetMessageGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetMessageGroupResponse
     *
     * @param GetMessageGroupRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return GetMessageGroupResponse
     */
    public function getMessageGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->appId) {
            @$body['AppId'] = $request->appId;
        }

        if (null !== $request->groupId) {
            @$body['GroupId'] = $request->groupId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetMessageGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetMessageGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a message group.
     *
     * @remarks
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - GetMessageGroupRequest
     *
     * @returns GetMessageGroupResponse
     *
     * @param GetMessageGroupRequest $request
     *
     * @return GetMessageGroupResponse
     */
    public function getMessageGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMessageGroupWithOptions($request, $runtime);
    }

    /**
     * Obtains a token that the client can use to establish a persistent connection over the LWP protocol and based on atomic capabilities.
     *
     * @remarks
     * ##
     * Obtain the user ID, device ID, and device type of the client, and then pass the information to the server. When you call this operation, the server obtains a token and returns the token to the client. Different users have different user IDs, and different devices have different device IDs.
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - GetMessageTokenRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetMessageTokenResponse
     *
     * @param GetMessageTokenRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return GetMessageTokenResponse
     */
    public function getMessageTokenWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->appId) {
            @$body['AppId'] = $request->appId;
        }

        if (null !== $request->deviceId) {
            @$body['DeviceId'] = $request->deviceId;
        }

        if (null !== $request->deviceType) {
            @$body['DeviceType'] = $request->deviceType;
        }

        if (null !== $request->userId) {
            @$body['UserId'] = $request->userId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetMessageToken',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetMessageTokenResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Obtains a token that the client can use to establish a persistent connection over the LWP protocol and based on atomic capabilities.
     *
     * @remarks
     * ##
     * Obtain the user ID, device ID, and device type of the client, and then pass the information to the server. When you call this operation, the server obtains a token and returns the token to the client. Different users have different user IDs, and different devices have different device IDs.
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - GetMessageTokenRequest
     *
     * @returns GetMessageTokenResponse
     *
     * @param GetMessageTokenRequest $request
     *
     * @return GetMessageTokenResponse
     */
    public function getMessageToken($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMessageTokenWithOptions($request, $runtime);
    }

    /**
     * @param request - GetTranscodeTaskStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetTranscodeTaskStatusResponse
     *
     * @param GetTranscodeTaskStatusRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return GetTranscodeTaskStatusResponse
     */
    public function getTranscodeTaskStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->app) {
            @$query['App'] = $request->app;
        }

        if (null !== $request->pushDomain) {
            @$query['PushDomain'] = $request->pushDomain;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        if (null !== $request->transcodingTemplate) {
            @$query['TranscodingTemplate'] = $request->transcodingTemplate;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetTranscodeTaskStatus',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetTranscodeTaskStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param request - GetTranscodeTaskStatusRequest
     *
     * @returns GetTranscodeTaskStatusResponse
     *
     * @param GetTranscodeTaskStatusRequest $request
     *
     * @return GetTranscodeTaskStatusResponse
     */
    public function getTranscodeTaskStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getTranscodeTaskStatusWithOptions($request, $runtime);
    }

    /**
     * Configures prefetch for a live stream that is ingested based on Real-Time Communication (RTC).
     *
     * @remarks
     * ### [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - HotLiveRtcStreamRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns HotLiveRtcStreamResponse
     *
     * @param HotLiveRtcStreamRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return HotLiveRtcStreamResponse
     */
    public function hotLiveRtcStreamWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->audioMsid) {
            @$query['AudioMsid'] = $request->audioMsid;
        }

        if (null !== $request->connectionTimeout) {
            @$query['ConnectionTimeout'] = $request->connectionTimeout;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->mediaTimeout) {
            @$query['MediaTimeout'] = $request->mediaTimeout;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionCode) {
            @$query['RegionCode'] = $request->regionCode;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        if (null !== $request->videoMsid) {
            @$query['VideoMsid'] = $request->videoMsid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'HotLiveRtcStream',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return HotLiveRtcStreamResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures prefetch for a live stream that is ingested based on Real-Time Communication (RTC).
     *
     * @remarks
     * ### [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - HotLiveRtcStreamRequest
     *
     * @returns HotLiveRtcStreamResponse
     *
     * @param HotLiveRtcStreamRequest $request
     *
     * @return HotLiveRtcStreamResponse
     */
    public function hotLiveRtcStream($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->hotLiveRtcStreamWithOptions($request, $runtime);
    }

    /**
     * Creates a scheduled task to start and stop the playback of a playlist at specified points in time.
     *
     * @remarks
     * You can call this operation to create a scheduled task to start and stop the playback of an episode list at specified points in time. Make sure that the parameter settings meet the requirements.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - InitializeAutoShowListTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns InitializeAutoShowListTaskResponse
     *
     * @param InitializeAutoShowListTaskRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return InitializeAutoShowListTaskResponse
     */
    public function initializeAutoShowListTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->callBackUrl) {
            @$query['CallBackUrl'] = $request->callBackUrl;
        }

        if (null !== $request->casterConfig) {
            @$query['CasterConfig'] = $request->casterConfig;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceIds) {
            @$query['ResourceIds'] = $request->resourceIds;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'InitializeAutoShowListTask',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return InitializeAutoShowListTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a scheduled task to start and stop the playback of a playlist at specified points in time.
     *
     * @remarks
     * You can call this operation to create a scheduled task to start and stop the playback of an episode list at specified points in time. Make sure that the parameter settings meet the requirements.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - InitializeAutoShowListTaskRequest
     *
     * @returns InitializeAutoShowListTaskResponse
     *
     * @param InitializeAutoShowListTaskRequest $request
     *
     * @return InitializeAutoShowListTaskResponse
     */
    public function initializeAutoShowListTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->initializeAutoShowListTaskWithOptions($request, $runtime);
    }

    /**
     * Joins a message group.
     *
     * @remarks
     * You can call this operation up to 200 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - JoinMessageGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns JoinMessageGroupResponse
     *
     * @param JoinMessageGroupRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return JoinMessageGroupResponse
     */
    public function joinMessageGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->appId) {
            @$body['AppId'] = $request->appId;
        }

        if (null !== $request->broadCastStatistics) {
            @$body['BroadCastStatistics'] = $request->broadCastStatistics;
        }

        if (null !== $request->broadCastType) {
            @$body['BroadCastType'] = $request->broadCastType;
        }

        if (null !== $request->groupId) {
            @$body['GroupId'] = $request->groupId;
        }

        if (null !== $request->userId) {
            @$body['UserId'] = $request->userId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'JoinMessageGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return JoinMessageGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Joins a message group.
     *
     * @remarks
     * You can call this operation up to 200 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - JoinMessageGroupRequest
     *
     * @returns JoinMessageGroupResponse
     *
     * @param JoinMessageGroupRequest $request
     *
     * @return JoinMessageGroupResponse
     */
    public function joinMessageGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->joinMessageGroupWithOptions($request, $runtime);
    }

    /**
     * Removes a user from an interactive messaging group.
     *
     * @remarks
     * Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - KickLiveMessageGroupUserRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns KickLiveMessageGroupUserResponse
     *
     * @param KickLiveMessageGroupUserRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return KickLiveMessageGroupUserResponse
     */
    public function kickLiveMessageGroupUserWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->dataCenter) {
            @$query['DataCenter'] = $request->dataCenter;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        if (null !== $request->kickoffUser) {
            @$query['KickoffUser'] = $request->kickoffUser;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'KickLiveMessageGroupUser',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return KickLiveMessageGroupUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Removes a user from an interactive messaging group.
     *
     * @remarks
     * Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - KickLiveMessageGroupUserRequest
     *
     * @returns KickLiveMessageGroupUserResponse
     *
     * @param KickLiveMessageGroupUserRequest $request
     *
     * @return KickLiveMessageGroupUserResponse
     */
    public function kickLiveMessageGroupUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->kickLiveMessageGroupUserWithOptions($request, $runtime);
    }

    /**
     * Leaves a message group.
     *
     * @remarks
     * ##
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - LeaveMessageGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns LeaveMessageGroupResponse
     *
     * @param LeaveMessageGroupRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return LeaveMessageGroupResponse
     */
    public function leaveMessageGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->appId) {
            @$body['AppId'] = $request->appId;
        }

        if (null !== $request->broadCastStatistics) {
            @$body['BroadCastStatistics'] = $request->broadCastStatistics;
        }

        if (null !== $request->broadCastType) {
            @$body['BroadCastType'] = $request->broadCastType;
        }

        if (null !== $request->groupId) {
            @$body['GroupId'] = $request->groupId;
        }

        if (null !== $request->userId) {
            @$body['UserId'] = $request->userId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'LeaveMessageGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return LeaveMessageGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Leaves a message group.
     *
     * @remarks
     * ##
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - LeaveMessageGroupRequest
     *
     * @returns LeaveMessageGroupResponse
     *
     * @param LeaveMessageGroupRequest $request
     *
     * @return LeaveMessageGroupResponse
     */
    public function leaveMessageGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->leaveMessageGroupWithOptions($request, $runtime);
    }

    /**
     * Queries edge transcoding tasks.
     *
     * @remarks
     *   You can call this operation to query edge transcoding tasks.
     * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature.
     * *   You can query only tasks created or modified in the last 180 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListEdgeTranscodeJobRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListEdgeTranscodeJobResponse
     *
     * @param ListEdgeTranscodeJobRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return ListEdgeTranscodeJobResponse
     */
    public function listEdgeTranscodeJobWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->keyword) {
            @$query['Keyword'] = $request->keyword;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNo) {
            @$query['PageNo'] = $request->pageNo;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->sortBy) {
            @$query['SortBy'] = $request->sortBy;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListEdgeTranscodeJob',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListEdgeTranscodeJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries edge transcoding tasks.
     *
     * @remarks
     *   You can call this operation to query edge transcoding tasks.
     * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature.
     * *   You can query only tasks created or modified in the last 180 days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListEdgeTranscodeJobRequest
     *
     * @returns ListEdgeTranscodeJobResponse
     *
     * @param ListEdgeTranscodeJobRequest $request
     *
     * @return ListEdgeTranscodeJobResponse
     */
    public function listEdgeTranscodeJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listEdgeTranscodeJobWithOptions($request, $runtime);
    }

    /**
     * Queries the list of edge transcoding templates.
     *
     * @remarks
     *   You can call this operation to query the list of edge transcoding templates.
     * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListEdgeTranscodeTemplateRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListEdgeTranscodeTemplateResponse
     *
     * @param ListEdgeTranscodeTemplateRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return ListEdgeTranscodeTemplateResponse
     */
    public function listEdgeTranscodeTemplateWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->keyword) {
            @$query['Keyword'] = $request->keyword;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNo) {
            @$query['PageNo'] = $request->pageNo;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->sortBy) {
            @$query['SortBy'] = $request->sortBy;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        if (null !== $request->videoCodec) {
            @$query['VideoCodec'] = $request->videoCodec;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListEdgeTranscodeTemplate',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListEdgeTranscodeTemplateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the list of edge transcoding templates.
     *
     * @remarks
     *   You can call this operation to query the list of edge transcoding templates.
     * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListEdgeTranscodeTemplateRequest
     *
     * @returns ListEdgeTranscodeTemplateResponse
     *
     * @param ListEdgeTranscodeTemplateRequest $request
     *
     * @return ListEdgeTranscodeTemplateResponse
     */
    public function listEdgeTranscodeTemplate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listEdgeTranscodeTemplateWithOptions($request, $runtime);
    }

    /**
     * Queries the events generated in channels to which you subscribe.
     *
     * @remarks
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListEventSubRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListEventSubResponse
     *
     * @param ListEventSubRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return ListEventSubResponse
     */
    public function listEventSubWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListEventSub',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListEventSubResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the events generated in channels to which you subscribe.
     *
     * @remarks
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListEventSubRequest
     *
     * @returns ListEventSubResponse
     *
     * @param ListEventSubRequest $request
     *
     * @return ListEventSubResponse
     */
    public function listEventSub($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listEventSubWithOptions($request, $runtime);
    }

    /**
     * Queries callback records.
     *
     * @remarks
     *   The maximum time range to query is seven days.
     * *   The minimum time granularity to query is 1 minute.
     * *   You can query data in the last seven days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListEventSubEventRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListEventSubEventResponse
     *
     * @param ListEventSubEventRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return ListEventSubEventResponse
     */
    public function listEventSubEventWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListEventSubEvent',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListEventSubEventResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries callback records.
     *
     * @remarks
     *   The maximum time range to query is seven days.
     * *   The minimum time granularity to query is 1 minute.
     * *   You can query data in the last seven days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListEventSubEventRequest
     *
     * @returns ListEventSubEventResponse
     *
     * @param ListEventSubEventRequest $request
     *
     * @return ListEventSubEventResponse
     */
    public function listEventSubEvent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listEventSubEventWithOptions($request, $runtime);
    }

    /**
     * Queries stream delay configurations.
     *
     * @remarks
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListLiveDelayConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListLiveDelayConfigResponse
     *
     * @param ListLiveDelayConfigRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ListLiveDelayConfigResponse
     */
    public function listLiveDelayConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNum) {
            @$query['PageNum'] = $request->pageNum;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListLiveDelayConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListLiveDelayConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries stream delay configurations.
     *
     * @remarks
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListLiveDelayConfigRequest
     *
     * @returns ListLiveDelayConfigResponse
     *
     * @param ListLiveDelayConfigRequest $request
     *
     * @return ListLiveDelayConfigResponse
     */
    public function listLiveDelayConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listLiveDelayConfigWithOptions($request, $runtime);
    }

    /**
     * Queries interactive messaging applications.
     *
     * @remarks
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListLiveMessageAppsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListLiveMessageAppsResponse
     *
     * @param ListLiveMessageAppsRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ListLiveMessageAppsResponse
     */
    public function listLiveMessageAppsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dataCenter) {
            @$query['DataCenter'] = $request->dataCenter;
        }

        if (null !== $request->nextPageToken) {
            @$query['NextPageToken'] = $request->nextPageToken;
        }

        if (null !== $request->sortType) {
            @$query['SortType'] = $request->sortType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListLiveMessageApps',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListLiveMessageAppsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries interactive messaging applications.
     *
     * @remarks
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListLiveMessageAppsRequest
     *
     * @returns ListLiveMessageAppsResponse
     *
     * @param ListLiveMessageAppsRequest $request
     *
     * @return ListLiveMessageAppsResponse
     */
    public function listLiveMessageApps($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listLiveMessageAppsWithOptions($request, $runtime);
    }

    /**
     * Queries interactive messaging groups by page.
     *
     * @remarks
     * Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListLiveMessageGroupByPageRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListLiveMessageGroupByPageResponse
     *
     * @param ListLiveMessageGroupByPageRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return ListLiveMessageGroupByPageResponse
     */
    public function listLiveMessageGroupByPageWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListLiveMessageGroupByPage',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListLiveMessageGroupByPageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries interactive messaging groups by page.
     *
     * @remarks
     * Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListLiveMessageGroupByPageRequest
     *
     * @returns ListLiveMessageGroupByPageResponse
     *
     * @param ListLiveMessageGroupByPageRequest $request
     *
     * @return ListLiveMessageGroupByPageResponse
     */
    public function listLiveMessageGroupByPage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listLiveMessageGroupByPageWithOptions($request, $runtime);
    }

    /**
     * Queries the messages sent in a group.
     *
     * @remarks
     * Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListLiveMessageGroupMessagesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListLiveMessageGroupMessagesResponse
     *
     * @param ListLiveMessageGroupMessagesRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return ListLiveMessageGroupMessagesResponse
     */
    public function listLiveMessageGroupMessagesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->beginTime) {
            @$query['BeginTime'] = $request->beginTime;
        }

        if (null !== $request->dataCenter) {
            @$query['DataCenter'] = $request->dataCenter;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        if (null !== $request->msgType) {
            @$query['MsgType'] = $request->msgType;
        }

        if (null !== $request->nextPageToken) {
            @$query['NextPageToken'] = $request->nextPageToken;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->sortType) {
            @$query['SortType'] = $request->sortType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListLiveMessageGroupMessages',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListLiveMessageGroupMessagesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the messages sent in a group.
     *
     * @remarks
     * Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListLiveMessageGroupMessagesRequest
     *
     * @returns ListLiveMessageGroupMessagesResponse
     *
     * @param ListLiveMessageGroupMessagesRequest $request
     *
     * @return ListLiveMessageGroupMessagesResponse
     */
    public function listLiveMessageGroupMessages($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listLiveMessageGroupMessagesWithOptions($request, $runtime);
    }

    /**
     * Queries the users in an interactive messaging group.
     *
     * @remarks
     *   Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * *   For a super group, which has more than 2,000 users, the user list cannot be queried. In addition, the notifications about users entering or leaving the group are sent at an interval of at least of 5 seconds. These notifications display the accurate number of users in the group for the time being, but do not display the list of all users entering or leaving the group. Once a group is upgraded to a super group, the user list of the group is immediately cleared. The super group cannot be restored to a normal group until all users in the group leave the group (that is, the group is closed). After you reopen the group, it is restored to a normal group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListLiveMessageGroupUsersRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListLiveMessageGroupUsersResponse
     *
     * @param ListLiveMessageGroupUsersRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return ListLiveMessageGroupUsersResponse
     */
    public function listLiveMessageGroupUsersWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->dataCenter) {
            @$query['DataCenter'] = $request->dataCenter;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        if (null !== $request->nextPageToken) {
            @$query['NextPageToken'] = $request->nextPageToken;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->sortType) {
            @$query['SortType'] = $request->sortType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListLiveMessageGroupUsers',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListLiveMessageGroupUsersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the users in an interactive messaging group.
     *
     * @remarks
     *   Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * *   For a super group, which has more than 2,000 users, the user list cannot be queried. In addition, the notifications about users entering or leaving the group are sent at an interval of at least of 5 seconds. These notifications display the accurate number of users in the group for the time being, but do not display the list of all users entering or leaving the group. Once a group is upgraded to a super group, the user list of the group is immediately cleared. The super group cannot be restored to a normal group until all users in the group leave the group (that is, the group is closed). After you reopen the group, it is restored to a normal group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListLiveMessageGroupUsersRequest
     *
     * @returns ListLiveMessageGroupUsersResponse
     *
     * @param ListLiveMessageGroupUsersRequest $request
     *
     * @return ListLiveMessageGroupUsersResponse
     */
    public function listLiveMessageGroupUsers($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listLiveMessageGroupUsersWithOptions($request, $runtime);
    }

    /**
     * Queries the interactive messaging groups in an interactive messaging application.
     *
     * @remarks
     * Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListLiveMessageGroupsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListLiveMessageGroupsResponse
     *
     * @param ListLiveMessageGroupsRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return ListLiveMessageGroupsResponse
     */
    public function listLiveMessageGroupsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->dataCenter) {
            @$query['DataCenter'] = $request->dataCenter;
        }

        if (null !== $request->groupStatus) {
            @$query['GroupStatus'] = $request->groupStatus;
        }

        if (null !== $request->nextPageToken) {
            @$query['NextPageToken'] = $request->nextPageToken;
        }

        if (null !== $request->sortType) {
            @$query['SortType'] = $request->sortType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListLiveMessageGroups',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListLiveMessageGroupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the interactive messaging groups in an interactive messaging application.
     *
     * @remarks
     * Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListLiveMessageGroupsRequest
     *
     * @returns ListLiveMessageGroupsResponse
     *
     * @param ListLiveMessageGroupsRequest $request
     *
     * @return ListLiveMessageGroupsResponse
     */
    public function listLiveMessageGroups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listLiveMessageGroupsWithOptions($request, $runtime);
    }

    /**
     * Queries all configurations of real-time log delivery under an Alibaba Cloud account.
     *
     * @remarks
     * You can call this operation to query all configurations of real-time log delivery under an account. Make sure that the parameter settings meet the requirements.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListLiveRealtimeLogDeliveryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListLiveRealtimeLogDeliveryResponse
     *
     * @param ListLiveRealtimeLogDeliveryRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return ListLiveRealtimeLogDeliveryResponse
     */
    public function listLiveRealtimeLogDeliveryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListLiveRealtimeLogDelivery',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListLiveRealtimeLogDeliveryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries all configurations of real-time log delivery under an Alibaba Cloud account.
     *
     * @remarks
     * You can call this operation to query all configurations of real-time log delivery under an account. Make sure that the parameter settings meet the requirements.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListLiveRealtimeLogDeliveryRequest
     *
     * @returns ListLiveRealtimeLogDeliveryResponse
     *
     * @param ListLiveRealtimeLogDeliveryRequest $request
     *
     * @return ListLiveRealtimeLogDeliveryResponse
     */
    public function listLiveRealtimeLogDelivery($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listLiveRealtimeLogDeliveryWithOptions($request, $runtime);
    }

    /**
     * Queries all domain names that are associated with a specific configuration of real-time log delivery.
     *
     * @remarks
     *   You can call this operation to query all domain names that are associated with a specific configuration of real-time log delivery. The returned results indicate whether real-time log delivery is enabled or disabled for the domain names.
     * *   You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) to query the Project, Logstore, and Region parameters.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListLiveRealtimeLogDeliveryDomainsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListLiveRealtimeLogDeliveryDomainsResponse
     *
     * @param ListLiveRealtimeLogDeliveryDomainsRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return ListLiveRealtimeLogDeliveryDomainsResponse
     */
    public function listLiveRealtimeLogDeliveryDomainsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListLiveRealtimeLogDeliveryDomains',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListLiveRealtimeLogDeliveryDomainsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries all domain names that are associated with a specific configuration of real-time log delivery.
     *
     * @remarks
     *   You can call this operation to query all domain names that are associated with a specific configuration of real-time log delivery. The returned results indicate whether real-time log delivery is enabled or disabled for the domain names.
     * *   You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) to query the Project, Logstore, and Region parameters.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListLiveRealtimeLogDeliveryDomainsRequest
     *
     * @returns ListLiveRealtimeLogDeliveryDomainsResponse
     *
     * @param ListLiveRealtimeLogDeliveryDomainsRequest $request
     *
     * @return ListLiveRealtimeLogDeliveryDomainsResponse
     */
    public function listLiveRealtimeLogDeliveryDomains($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listLiveRealtimeLogDeliveryDomainsWithOptions($request, $runtime);
    }

    /**
     * Queries all configurations of real-time log delivery.
     *
     * @remarks
     * You can call this operation to query all configurations of real-time log delivery. Make sure that the parameter settings meet the requirements.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListLiveRealtimeLogDeliveryInfosRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListLiveRealtimeLogDeliveryInfosResponse
     *
     * @param ListLiveRealtimeLogDeliveryInfosRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return ListLiveRealtimeLogDeliveryInfosResponse
     */
    public function listLiveRealtimeLogDeliveryInfosWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListLiveRealtimeLogDeliveryInfos',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListLiveRealtimeLogDeliveryInfosResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries all configurations of real-time log delivery.
     *
     * @remarks
     * You can call this operation to query all configurations of real-time log delivery. Make sure that the parameter settings meet the requirements.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListLiveRealtimeLogDeliveryInfosRequest
     *
     * @returns ListLiveRealtimeLogDeliveryInfosResponse
     *
     * @param ListLiveRealtimeLogDeliveryInfosRequest $request
     *
     * @return ListLiveRealtimeLogDeliveryInfosResponse
     */
    public function listLiveRealtimeLogDeliveryInfos($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listLiveRealtimeLogDeliveryInfosWithOptions($request, $runtime);
    }

    /**
     * Queries messages.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - ListMessageRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListMessageResponse
     *
     * @param ListMessageRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return ListMessageResponse
     */
    public function listMessageWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->appId) {
            @$body['AppId'] = $request->appId;
        }

        if (null !== $request->groupId) {
            @$body['GroupId'] = $request->groupId;
        }

        if (null !== $request->pageNum) {
            @$body['PageNum'] = $request->pageNum;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->sortType) {
            @$body['SortType'] = $request->sortType;
        }

        if (null !== $request->type) {
            @$body['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListMessage',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListMessageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries messages.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - ListMessageRequest
     *
     * @returns ListMessageResponse
     *
     * @param ListMessageRequest $request
     *
     * @return ListMessageResponse
     */
    public function listMessage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listMessageWithOptions($request, $runtime);
    }

    /**
     * Queries interactive messaging applications.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - ListMessageAppRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListMessageAppResponse
     *
     * @param ListMessageAppRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return ListMessageAppResponse
     */
    public function listMessageAppWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->pageNum) {
            @$body['PageNum'] = $request->pageNum;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->sortType) {
            @$body['SortType'] = $request->sortType;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListMessageApp',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListMessageAppResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries interactive messaging applications.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - ListMessageAppRequest
     *
     * @returns ListMessageAppResponse
     *
     * @param ListMessageAppRequest $request
     *
     * @return ListMessageAppResponse
     */
    public function listMessageApp($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listMessageAppWithOptions($request, $runtime);
    }

    /**
     * Queries the message groups of a specified user.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - ListMessageGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListMessageGroupResponse
     *
     * @param ListMessageGroupRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return ListMessageGroupResponse
     */
    public function listMessageGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->appId) {
            @$body['AppId'] = $request->appId;
        }

        if (null !== $request->pageNum) {
            @$body['PageNum'] = $request->pageNum;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->sortType) {
            @$body['SortType'] = $request->sortType;
        }

        if (null !== $request->userId) {
            @$body['UserId'] = $request->userId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListMessageGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListMessageGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the message groups of a specified user.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - ListMessageGroupRequest
     *
     * @returns ListMessageGroupResponse
     *
     * @param ListMessageGroupRequest $request
     *
     * @return ListMessageGroupResponse
     */
    public function listMessageGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listMessageGroupWithOptions($request, $runtime);
    }

    /**
     * Queries the members of a message group.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - ListMessageGroupUserRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListMessageGroupUserResponse
     *
     * @param ListMessageGroupUserRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return ListMessageGroupUserResponse
     */
    public function listMessageGroupUserWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->appId) {
            @$body['AppId'] = $request->appId;
        }

        if (null !== $request->groupId) {
            @$body['GroupId'] = $request->groupId;
        }

        if (null !== $request->pageNum) {
            @$body['PageNum'] = $request->pageNum;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->sortType) {
            @$body['SortType'] = $request->sortType;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListMessageGroupUser',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListMessageGroupUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the members of a message group.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - ListMessageGroupUserRequest
     *
     * @returns ListMessageGroupUserResponse
     *
     * @param ListMessageGroupUserRequest $request
     *
     * @return ListMessageGroupUserResponse
     */
    public function listMessageGroupUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listMessageGroupUserWithOptions($request, $runtime);
    }

    /**
     * Queries user information by user ID.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param tmpReq - ListMessageGroupUserByIdRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListMessageGroupUserByIdResponse
     *
     * @param ListMessageGroupUserByIdRequest $tmpReq
     * @param RuntimeOptions                  $runtime
     *
     * @return ListMessageGroupUserByIdResponse
     */
    public function listMessageGroupUserByIdWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new ListMessageGroupUserByIdShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->userIdList) {
            $request->userIdListShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->userIdList, 'UserIdList', 'simple');
        }

        $body = [];
        if (null !== $request->appId) {
            @$body['AppId'] = $request->appId;
        }

        if (null !== $request->groupId) {
            @$body['GroupId'] = $request->groupId;
        }

        if (null !== $request->userIdListShrink) {
            @$body['UserIdList'] = $request->userIdListShrink;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListMessageGroupUserById',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListMessageGroupUserByIdResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries user information by user ID.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - ListMessageGroupUserByIdRequest
     *
     * @returns ListMessageGroupUserByIdResponse
     *
     * @param ListMessageGroupUserByIdRequest $request
     *
     * @return ListMessageGroupUserByIdResponse
     */
    public function listMessageGroupUserById($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listMessageGroupUserByIdWithOptions($request, $runtime);
    }

    /**
     * Queries muted members in a messaging group.
     *
     * @remarks
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - ListMuteGroupUserRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListMuteGroupUserResponse
     *
     * @param ListMuteGroupUserRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return ListMuteGroupUserResponse
     */
    public function listMuteGroupUserWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->appId) {
            @$body['AppId'] = $request->appId;
        }

        if (null !== $request->groupId) {
            @$body['GroupId'] = $request->groupId;
        }

        if (null !== $request->operatorUserId) {
            @$body['OperatorUserId'] = $request->operatorUserId;
        }

        if (null !== $request->pageNum) {
            @$body['PageNum'] = $request->pageNum;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListMuteGroupUser',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListMuteGroupUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries muted members in a messaging group.
     *
     * @remarks
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - ListMuteGroupUserRequest
     *
     * @returns ListMuteGroupUserResponse
     *
     * @param ListMuteGroupUserRequest $request
     *
     * @return ListMuteGroupUserResponse
     */
    public function listMuteGroupUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listMuteGroupUserWithOptions($request, $runtime);
    }

    /**
     * Queries the information about one or more episode lists.
     *
     * @remarks
     * You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episode lists and then call this operation to query the episode lists.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListPlaylistRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListPlaylistResponse
     *
     * @param ListPlaylistRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return ListPlaylistResponse
     */
    public function listPlaylistWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->page) {
            @$query['Page'] = $request->page;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->programId) {
            @$query['ProgramId'] = $request->programId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListPlaylist',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListPlaylistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about one or more episode lists.
     *
     * @remarks
     * You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episode lists and then call this operation to query the episode lists.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListPlaylistRequest
     *
     * @returns ListPlaylistResponse
     *
     * @param ListPlaylistRequest $request
     *
     * @return ListPlaylistResponse
     */
    public function listPlaylist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listPlaylistWithOptions($request, $runtime);
    }

    /**
     * Queries the information about episodes in an episode list.
     *
     * @remarks
     * You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episodes to an episode list and then call this operation to query the episodes in the episode list
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListPlaylistItemsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListPlaylistItemsResponse
     *
     * @param ListPlaylistItemsRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return ListPlaylistItemsResponse
     */
    public function listPlaylistItemsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->programId) {
            @$query['ProgramId'] = $request->programId;
        }

        if (null !== $request->programItemIds) {
            @$query['ProgramItemIds'] = $request->programItemIds;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListPlaylistItems',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListPlaylistItemsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about episodes in an episode list.
     *
     * @remarks
     * You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episodes to an episode list and then call this operation to query the episodes in the episode list
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListPlaylistItemsRequest
     *
     * @returns ListPlaylistItemsResponse
     *
     * @param ListPlaylistItemsRequest $request
     *
     * @return ListPlaylistItemsResponse
     */
    public function listPlaylistItems($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listPlaylistItemsWithOptions($request, $runtime);
    }

    /**
     * Queries the callback records of a subscription to mixed-stream relay events.
     *
     * @remarks
     * You can call this operation to query the callback records of a subscription to mixed-stream relay events in the last seven days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListRtcMPUEventSubRecordRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListRtcMPUEventSubRecordResponse
     *
     * @param ListRtcMPUEventSubRecordRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return ListRtcMPUEventSubRecordResponse
     */
    public function listRtcMPUEventSubRecordWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->pageNo) {
            @$query['PageNo'] = $request->pageNo;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->subId) {
            @$query['SubId'] = $request->subId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListRtcMPUEventSubRecord',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListRtcMPUEventSubRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the callback records of a subscription to mixed-stream relay events.
     *
     * @remarks
     * You can call this operation to query the callback records of a subscription to mixed-stream relay events in the last seven days.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListRtcMPUEventSubRecordRequest
     *
     * @returns ListRtcMPUEventSubRecordResponse
     *
     * @param ListRtcMPUEventSubRecordRequest $request
     *
     * @return ListRtcMPUEventSubRecordResponse
     */
    public function listRtcMPUEventSubRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listRtcMPUEventSubRecordWithOptions($request, $runtime);
    }

    /**
     * Queries the parameters of mixed-stream relay tasks.
     *
     * @remarks
     *   You can call the ListRtcMPUTaskDetail operation to query the parameters of mixed-stream relay tasks that were created by calling the StartLiveMPUTask operation.
     * *   By default, the query results are sorted in reverse chronological order based on the task update time.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListRtcMPUTaskDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListRtcMPUTaskDetailResponse
     *
     * @param ListRtcMPUTaskDetailRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return ListRtcMPUTaskDetailResponse
     */
    public function listRtcMPUTaskDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->pageNo) {
            @$query['PageNo'] = $request->pageNo;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListRtcMPUTaskDetail',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListRtcMPUTaskDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the parameters of mixed-stream relay tasks.
     *
     * @remarks
     *   You can call the ListRtcMPUTaskDetail operation to query the parameters of mixed-stream relay tasks that were created by calling the StartLiveMPUTask operation.
     * *   By default, the query results are sorted in reverse chronological order based on the task update time.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ListRtcMPUTaskDetailRequest
     *
     * @returns ListRtcMPUTaskDetailResponse
     *
     * @param ListRtcMPUTaskDetailRequest $request
     *
     * @return ListRtcMPUTaskDetailResponse
     */
    public function listRtcMPUTaskDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listRtcMPUTaskDetailWithOptions($request, $runtime);
    }

    /**
     * 直播回源监控数据.
     *
     * @param tmpReq - LiveUpstreamQosDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns LiveUpstreamQosDataResponse
     *
     * @param LiveUpstreamQosDataRequest $tmpReq
     * @param RuntimeOptions             $runtime
     *
     * @return LiveUpstreamQosDataResponse
     */
    public function liveUpstreamQosDataWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new LiveUpstreamQosDataShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->cdnDomains) {
            $request->cdnDomainsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->cdnDomains, 'CdnDomains', 'json');
        }

        if (null !== $tmpReq->cdnIsps) {
            $request->cdnIspsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->cdnIsps, 'CdnIsps', 'json');
        }

        if (null !== $tmpReq->cdnProvinces) {
            $request->cdnProvincesShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->cdnProvinces, 'CdnProvinces', 'json');
        }

        if (null !== $tmpReq->kwaiSidcs) {
            $request->kwaiSidcsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->kwaiSidcs, 'KwaiSidcs', 'json');
        }

        if (null !== $tmpReq->kwaiTsc) {
            $request->kwaiTscShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->kwaiTsc, 'KwaiTsc', 'json');
        }

        if (null !== $tmpReq->upstreamDomains) {
            $request->upstreamDomainsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->upstreamDomains, 'UpstreamDomains', 'json');
        }

        $query = [];
        if (null !== $request->cdnDomainsShrink) {
            @$query['CdnDomains'] = $request->cdnDomainsShrink;
        }

        if (null !== $request->cdnIspsShrink) {
            @$query['CdnIsps'] = $request->cdnIspsShrink;
        }

        if (null !== $request->cdnProvincesShrink) {
            @$query['CdnProvinces'] = $request->cdnProvincesShrink;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->kwaiSidcsShrink) {
            @$query['KwaiSidcs'] = $request->kwaiSidcsShrink;
        }

        if (null !== $request->kwaiTscShrink) {
            @$query['KwaiTsc'] = $request->kwaiTscShrink;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->region) {
            @$query['Region'] = $request->region;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->upstreamDomainsShrink) {
            @$query['UpstreamDomains'] = $request->upstreamDomainsShrink;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'LiveUpstreamQosData',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return LiveUpstreamQosDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 直播回源监控数据.
     *
     * @param request - LiveUpstreamQosDataRequest
     *
     * @returns LiveUpstreamQosDataResponse
     *
     * @param LiveUpstreamQosDataRequest $request
     *
     * @return LiveUpstreamQosDataResponse
     */
    public function liveUpstreamQosData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->liveUpstreamQosDataWithOptions($request, $runtime);
    }

    /**
     * 咪咕定制直播拉转推启动接口.
     *
     * @param request - MiguLivePullToPushStartRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns MiguLivePullToPushStartResponse
     *
     * @param MiguLivePullToPushStartRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return MiguLivePullToPushStartResponse
     */
    public function miguLivePullToPushStartWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->miguData) {
            @$query['MiguData'] = $request->miguData;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'MiguLivePullToPushStart',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return MiguLivePullToPushStartResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 咪咕定制直播拉转推启动接口.
     *
     * @param request - MiguLivePullToPushStartRequest
     *
     * @returns MiguLivePullToPushStartResponse
     *
     * @param MiguLivePullToPushStartRequest $request
     *
     * @return MiguLivePullToPushStartResponse
     */
    public function miguLivePullToPushStart($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->miguLivePullToPushStartWithOptions($request, $runtime);
    }

    /**
     * 咪咕定制直播拉转推启动接口.
     *
     * @param request - MiguLivePullToPushStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns MiguLivePullToPushStatusResponse
     *
     * @param MiguLivePullToPushStatusRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return MiguLivePullToPushStatusResponse
     */
    public function miguLivePullToPushStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->miguData) {
            @$query['MiguData'] = $request->miguData;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'MiguLivePullToPushStatus',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return MiguLivePullToPushStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 咪咕定制直播拉转推启动接口.
     *
     * @param request - MiguLivePullToPushStatusRequest
     *
     * @returns MiguLivePullToPushStatusResponse
     *
     * @param MiguLivePullToPushStatusRequest $request
     *
     * @return MiguLivePullToPushStatusResponse
     */
    public function miguLivePullToPushStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->miguLivePullToPushStatusWithOptions($request, $runtime);
    }

    /**
     * Modifies a component of a production studio.
     *
     * @remarks
     * You can call this operation to modify a text, image, or subtitle component.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ModifyCasterComponentRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyCasterComponentResponse
     *
     * @param ModifyCasterComponentRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return ModifyCasterComponentResponse
     */
    public function modifyCasterComponentWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->captionLayerContent) {
            @$query['CaptionLayerContent'] = $request->captionLayerContent;
        }

        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->componentId) {
            @$query['ComponentId'] = $request->componentId;
        }

        if (null !== $request->componentLayer) {
            @$query['ComponentLayer'] = $request->componentLayer;
        }

        if (null !== $request->componentName) {
            @$query['ComponentName'] = $request->componentName;
        }

        if (null !== $request->componentType) {
            @$query['ComponentType'] = $request->componentType;
        }

        if (null !== $request->effect) {
            @$query['Effect'] = $request->effect;
        }

        if (null !== $request->imageLayerContent) {
            @$query['ImageLayerContent'] = $request->imageLayerContent;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->textLayerContent) {
            @$query['TextLayerContent'] = $request->textLayerContent;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyCasterComponent',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyCasterComponentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies a component of a production studio.
     *
     * @remarks
     * You can call this operation to modify a text, image, or subtitle component.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ModifyCasterComponentRequest
     *
     * @returns ModifyCasterComponentResponse
     *
     * @param ModifyCasterComponentRequest $request
     *
     * @return ModifyCasterComponentResponse
     */
    public function modifyCasterComponent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyCasterComponentWithOptions($request, $runtime);
    }

    /**
     * Modifies the configurations of an episode in a production studio. You cannot change the episode type.
     *
     * @remarks
     * You can call this operation to modify the configurations of an episode in a production studio. You cannot change the episode type.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ModifyCasterEpisodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyCasterEpisodeResponse
     *
     * @param ModifyCasterEpisodeRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ModifyCasterEpisodeResponse
     */
    public function modifyCasterEpisodeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->componentId) {
            @$query['ComponentId'] = $request->componentId;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->episodeId) {
            @$query['EpisodeId'] = $request->episodeId;
        }

        if (null !== $request->episodeName) {
            @$query['EpisodeName'] = $request->episodeName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->switchType) {
            @$query['SwitchType'] = $request->switchType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyCasterEpisode',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyCasterEpisodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configurations of an episode in a production studio. You cannot change the episode type.
     *
     * @remarks
     * You can call this operation to modify the configurations of an episode in a production studio. You cannot change the episode type.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ModifyCasterEpisodeRequest
     *
     * @returns ModifyCasterEpisodeResponse
     *
     * @param ModifyCasterEpisodeRequest $request
     *
     * @return ModifyCasterEpisodeResponse
     */
    public function modifyCasterEpisode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyCasterEpisodeWithOptions($request, $runtime);
    }

    /**
     * Modifies the layout configurations pf a production studio. You need to pass only parameters that you want to modify.
     *
     * @remarks
     * You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to modify a layout of the production studio. This operation supports the default and adaptive scaling modes.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ModifyCasterLayoutRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyCasterLayoutResponse
     *
     * @param ModifyCasterLayoutRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return ModifyCasterLayoutResponse
     */
    public function modifyCasterLayoutWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->audioLayer) {
            @$query['AudioLayer'] = $request->audioLayer;
        }

        if (null !== $request->blendList) {
            @$query['BlendList'] = $request->blendList;
        }

        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->layoutId) {
            @$query['LayoutId'] = $request->layoutId;
        }

        if (null !== $request->mixList) {
            @$query['MixList'] = $request->mixList;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->videoLayer) {
            @$query['VideoLayer'] = $request->videoLayer;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyCasterLayout',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyCasterLayoutResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the layout configurations pf a production studio. You need to pass only parameters that you want to modify.
     *
     * @remarks
     * You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to modify a layout of the production studio. This operation supports the default and adaptive scaling modes.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ModifyCasterLayoutRequest
     *
     * @returns ModifyCasterLayoutResponse
     *
     * @param ModifyCasterLayoutRequest $request
     *
     * @return ModifyCasterLayoutResponse
     */
    public function modifyCasterLayout($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyCasterLayoutWithOptions($request, $runtime);
    }

    /**
     * Modifies the episode list for carousel playback in a production studio.
     *
     * @remarks
     * You can call the [AddCasterProgram](https://help.aliyun.com/document_detail/2848074.html) operation to add the episode list for carousel playback in a production studio and then call this operation to modify the episode list. The supported types of episodes include video resource and component.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ModifyCasterProgramRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyCasterProgramResponse
     *
     * @param ModifyCasterProgramRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ModifyCasterProgramResponse
     */
    public function modifyCasterProgramWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->episode) {
            @$query['Episode'] = $request->episode;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyCasterProgram',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyCasterProgramResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the episode list for carousel playback in a production studio.
     *
     * @remarks
     * You can call the [AddCasterProgram](https://help.aliyun.com/document_detail/2848074.html) operation to add the episode list for carousel playback in a production studio and then call this operation to modify the episode list. The supported types of episodes include video resource and component.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ModifyCasterProgramRequest
     *
     * @returns ModifyCasterProgramResponse
     *
     * @param ModifyCasterProgramRequest $request
     *
     * @return ModifyCasterProgramResponse
     */
    public function modifyCasterProgram($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyCasterProgramWithOptions($request, $runtime);
    }

    /**
     * Changes the video source for a production studio.
     *
     * @remarks
     * ## Usage notes
     * You must call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio before you call this operation to modify input sources of the production studio.
     * ## QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - ModifyCasterVideoResourceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyCasterVideoResourceResponse
     *
     * @param ModifyCasterVideoResourceRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return ModifyCasterVideoResourceResponse
     */
    public function modifyCasterVideoResourceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->beginOffset) {
            @$query['BeginOffset'] = $request->beginOffset;
        }

        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->endOffset) {
            @$query['EndOffset'] = $request->endOffset;
        }

        if (null !== $request->imageId) {
            @$query['ImageId'] = $request->imageId;
        }

        if (null !== $request->imageUrl) {
            @$query['ImageUrl'] = $request->imageUrl;
        }

        if (null !== $request->liveStreamUrl) {
            @$query['LiveStreamUrl'] = $request->liveStreamUrl;
        }

        if (null !== $request->materialId) {
            @$query['MaterialId'] = $request->materialId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->ptsCallbackInterval) {
            @$query['PtsCallbackInterval'] = $request->ptsCallbackInterval;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->repeatNum) {
            @$query['RepeatNum'] = $request->repeatNum;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceName) {
            @$query['ResourceName'] = $request->resourceName;
        }

        if (null !== $request->vodUrl) {
            @$query['VodUrl'] = $request->vodUrl;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyCasterVideoResource',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyCasterVideoResourceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the video source for a production studio.
     *
     * @remarks
     * ## Usage notes
     * You must call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio before you call this operation to modify input sources of the production studio.
     * ## QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - ModifyCasterVideoResourceRequest
     *
     * @returns ModifyCasterVideoResourceResponse
     *
     * @param ModifyCasterVideoResourceRequest $request
     *
     * @return ModifyCasterVideoResourceResponse
     */
    public function modifyCasterVideoResource($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyCasterVideoResourceWithOptions($request, $runtime);
    }

    /**
     * Modifies a virtual studio template.
     *
     * @param tmpReq - ModifyLiveAIStudioRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyLiveAIStudioResponse
     *
     * @param ModifyLiveAIStudioRequest $tmpReq
     * @param RuntimeOptions            $runtime
     *
     * @return ModifyLiveAIStudioResponse
     */
    public function modifyLiveAIStudioWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new ModifyLiveAIStudioShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->mattingLayout) {
            $request->mattingLayoutShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->mattingLayout, 'MattingLayout', 'json');
        }

        if (null !== $tmpReq->mediaLayout) {
            $request->mediaLayoutShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->mediaLayout, 'MediaLayout', 'json');
        }

        $query = [];
        if (null !== $request->backgroundResourceId) {
            @$query['BackgroundResourceId'] = $request->backgroundResourceId;
        }

        if (null !== $request->backgroundResourceUrl) {
            @$query['BackgroundResourceUrl'] = $request->backgroundResourceUrl;
        }

        if (null !== $request->backgroundType) {
            @$query['BackgroundType'] = $request->backgroundType;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->height) {
            @$query['Height'] = $request->height;
        }

        if (null !== $request->mattingLayoutShrink) {
            @$query['MattingLayout'] = $request->mattingLayoutShrink;
        }

        if (null !== $request->mattingType) {
            @$query['MattingType'] = $request->mattingType;
        }

        if (null !== $request->mediaLayoutShrink) {
            @$query['MediaLayout'] = $request->mediaLayoutShrink;
        }

        if (null !== $request->mediaResourceId) {
            @$query['MediaResourceId'] = $request->mediaResourceId;
        }

        if (null !== $request->mediaResourceUrl) {
            @$query['MediaResourceUrl'] = $request->mediaResourceUrl;
        }

        if (null !== $request->mediaType) {
            @$query['MediaType'] = $request->mediaType;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->studioName) {
            @$query['StudioName'] = $request->studioName;
        }

        if (null !== $request->width) {
            @$query['Width'] = $request->width;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyLiveAIStudio',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyLiveAIStudioResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies a virtual studio template.
     *
     * @param request - ModifyLiveAIStudioRequest
     *
     * @returns ModifyLiveAIStudioResponse
     *
     * @param ModifyLiveAIStudioRequest $request
     *
     * @return ModifyLiveAIStudioResponse
     */
    public function modifyLiveAIStudio($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyLiveAIStudioWithOptions($request, $runtime);
    }

    /**
     * Modifies the acceleration region of a domain name.
     *
     * @remarks
     * ### [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ModifyLiveDomainSchdmByPropertyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyLiveDomainSchdmByPropertyResponse
     *
     * @param ModifyLiveDomainSchdmByPropertyRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return ModifyLiveDomainSchdmByPropertyResponse
     */
    public function modifyLiveDomainSchdmByPropertyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->property) {
            @$query['Property'] = $request->property;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyLiveDomainSchdmByProperty',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyLiveDomainSchdmByPropertyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the acceleration region of a domain name.
     *
     * @remarks
     * ### [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ModifyLiveDomainSchdmByPropertyRequest
     *
     * @returns ModifyLiveDomainSchdmByPropertyResponse
     *
     * @param ModifyLiveDomainSchdmByPropertyRequest $request
     *
     * @return ModifyLiveDomainSchdmByPropertyResponse
     */
    public function modifyLiveDomainSchdmByProperty($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyLiveDomainSchdmByPropertyWithOptions($request, $runtime);
    }

    /**
     * Modifies the content moderation settings of an interactive messaging application.
     *
     * @remarks
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ModifyLiveMessageAppAuditRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyLiveMessageAppAuditResponse
     *
     * @param ModifyLiveMessageAppAuditRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return ModifyLiveMessageAppAuditResponse
     */
    public function modifyLiveMessageAppAuditWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->auditType) {
            @$query['AuditType'] = $request->auditType;
        }

        if (null !== $request->auditUrl) {
            @$query['AuditUrl'] = $request->auditUrl;
        }

        if (null !== $request->dataCenter) {
            @$query['DataCenter'] = $request->dataCenter;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyLiveMessageAppAudit',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyLiveMessageAppAuditResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the content moderation settings of an interactive messaging application.
     *
     * @remarks
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ModifyLiveMessageAppAuditRequest
     *
     * @returns ModifyLiveMessageAppAuditResponse
     *
     * @param ModifyLiveMessageAppAuditRequest $request
     *
     * @return ModifyLiveMessageAppAuditResponse
     */
    public function modifyLiveMessageAppAudit($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyLiveMessageAppAuditWithOptions($request, $runtime);
    }

    /**
     * Modifies the callback settings of an interactive messaging application.
     *
     * @remarks
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ModifyLiveMessageAppCallbackRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyLiveMessageAppCallbackResponse
     *
     * @param ModifyLiveMessageAppCallbackRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return ModifyLiveMessageAppCallbackResponse
     */
    public function modifyLiveMessageAppCallbackWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->dataCenter) {
            @$query['DataCenter'] = $request->dataCenter;
        }

        if (null !== $request->eventCallbackUrl) {
            @$query['EventCallbackUrl'] = $request->eventCallbackUrl;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyLiveMessageAppCallback',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyLiveMessageAppCallbackResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the callback settings of an interactive messaging application.
     *
     * @remarks
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ModifyLiveMessageAppCallbackRequest
     *
     * @returns ModifyLiveMessageAppCallbackResponse
     *
     * @param ModifyLiveMessageAppCallbackRequest $request
     *
     * @return ModifyLiveMessageAppCallbackResponse
     */
    public function modifyLiveMessageAppCallback($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyLiveMessageAppCallbackWithOptions($request, $runtime);
    }

    /**
     * Disables or enables an interactive messaging application.
     *
     * @remarks
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ModifyLiveMessageAppDisableRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyLiveMessageAppDisableResponse
     *
     * @param ModifyLiveMessageAppDisableRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return ModifyLiveMessageAppDisableResponse
     */
    public function modifyLiveMessageAppDisableWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->dataCenter) {
            @$query['DataCenter'] = $request->dataCenter;
        }

        if (null !== $request->disable) {
            @$query['Disable'] = $request->disable;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyLiveMessageAppDisable',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyLiveMessageAppDisableResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Disables or enables an interactive messaging application.
     *
     * @remarks
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ModifyLiveMessageAppDisableRequest
     *
     * @returns ModifyLiveMessageAppDisableResponse
     *
     * @param ModifyLiveMessageAppDisableRequest $request
     *
     * @return ModifyLiveMessageAppDisableResponse
     */
    public function modifyLiveMessageAppDisable($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyLiveMessageAppDisableWithOptions($request, $runtime);
    }

    /**
     * Modifies the information about an interactive messaging group.
     *
     * @remarks
     * Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param tmpReq - ModifyLiveMessageGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyLiveMessageGroupResponse
     *
     * @param ModifyLiveMessageGroupRequest $tmpReq
     * @param RuntimeOptions                $runtime
     *
     * @return ModifyLiveMessageGroupResponse
     */
    public function modifyLiveMessageGroupWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new ModifyLiveMessageGroupShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->adminList) {
            $request->adminListShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->adminList, 'AdminList', 'simple');
        }

        $query = [];
        if (null !== $request->adminListShrink) {
            @$query['AdminList'] = $request->adminListShrink;
        }

        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->dataCenter) {
            @$query['DataCenter'] = $request->dataCenter;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        if (null !== $request->groupInfo) {
            @$query['GroupInfo'] = $request->groupInfo;
        }

        if (null !== $request->modifyAdmin) {
            @$query['ModifyAdmin'] = $request->modifyAdmin;
        }

        if (null !== $request->modifyInfo) {
            @$query['ModifyInfo'] = $request->modifyInfo;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyLiveMessageGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyLiveMessageGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the information about an interactive messaging group.
     *
     * @remarks
     * Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ModifyLiveMessageGroupRequest
     *
     * @returns ModifyLiveMessageGroupResponse
     *
     * @param ModifyLiveMessageGroupRequest $request
     *
     * @return ModifyLiveMessageGroupResponse
     */
    public function modifyLiveMessageGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyLiveMessageGroupWithOptions($request, $runtime);
    }

    /**
     * Modifies the mute status of users.
     *
     * @remarks
     * Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param tmpReq - ModifyLiveMessageGroupBandRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyLiveMessageGroupBandResponse
     *
     * @param ModifyLiveMessageGroupBandRequest $tmpReq
     * @param RuntimeOptions                    $runtime
     *
     * @return ModifyLiveMessageGroupBandResponse
     */
    public function modifyLiveMessageGroupBandWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new ModifyLiveMessageGroupBandShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->bannnedUsers) {
            $request->bannnedUsersShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->bannnedUsers, 'BannnedUsers', 'simple');
        }

        if (null !== $tmpReq->exceptUsers) {
            $request->exceptUsersShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->exceptUsers, 'ExceptUsers', 'simple');
        }

        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->bannedAll) {
            @$query['BannedAll'] = $request->bannedAll;
        }

        if (null !== $request->bannnedUsersShrink) {
            @$query['BannnedUsers'] = $request->bannnedUsersShrink;
        }

        if (null !== $request->dataCenter) {
            @$query['DataCenter'] = $request->dataCenter;
        }

        if (null !== $request->exceptUsersShrink) {
            @$query['ExceptUsers'] = $request->exceptUsersShrink;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyLiveMessageGroupBand',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyLiveMessageGroupBandResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the mute status of users.
     *
     * @remarks
     * Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ModifyLiveMessageGroupBandRequest
     *
     * @returns ModifyLiveMessageGroupBandResponse
     *
     * @param ModifyLiveMessageGroupBandRequest $request
     *
     * @return ModifyLiveMessageGroupBandResponse
     */
    public function modifyLiveMessageGroupBand($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyLiveMessageGroupBandWithOptions($request, $runtime);
    }

    /**
     * Modifies the information about a user.
     *
     * @param request - ModifyLiveMessageUserInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyLiveMessageUserInfoResponse
     *
     * @param ModifyLiveMessageUserInfoRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return ModifyLiveMessageUserInfoResponse
     */
    public function modifyLiveMessageUserInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->dataCenter) {
            @$query['DataCenter'] = $request->dataCenter;
        }

        if (null !== $request->userId) {
            @$query['UserId'] = $request->userId;
        }

        if (null !== $request->userMetaInfo) {
            @$query['UserMetaInfo'] = $request->userMetaInfo;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyLiveMessageUserInfo',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyLiveMessageUserInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the information about a user.
     *
     * @param request - ModifyLiveMessageUserInfoRequest
     *
     * @returns ModifyLiveMessageUserInfoResponse
     *
     * @param ModifyLiveMessageUserInfoRequest $request
     *
     * @return ModifyLiveMessageUserInfoResponse
     */
    public function modifyLiveMessageUserInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyLiveMessageUserInfoWithOptions($request, $runtime);
    }

    /**
     * Modifies the configuration of real-time log delivery for a domain name.
     *
     * @remarks
     *   You can call this operation to modify the configuration of real-time log delivery for a domain name. Logs for a domain name can be delivered to only one Logstore.
     * This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
     * *   You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) operation to query the Project, Logstore, and Region parameters.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ModifyLiveRealtimeLogDeliveryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyLiveRealtimeLogDeliveryResponse
     *
     * @param ModifyLiveRealtimeLogDeliveryRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return ModifyLiveRealtimeLogDeliveryResponse
     */
    public function modifyLiveRealtimeLogDeliveryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyLiveRealtimeLogDelivery',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyLiveRealtimeLogDeliveryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configuration of real-time log delivery for a domain name.
     *
     * @remarks
     *   You can call this operation to modify the configuration of real-time log delivery for a domain name. Logs for a domain name can be delivered to only one Logstore.
     * This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
     * *   You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) operation to query the Project, Logstore, and Region parameters.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ModifyLiveRealtimeLogDeliveryRequest
     *
     * @returns ModifyLiveRealtimeLogDeliveryResponse
     *
     * @param ModifyLiveRealtimeLogDeliveryRequest $request
     *
     * @return ModifyLiveRealtimeLogDeliveryResponse
     */
    public function modifyLiveRealtimeLogDelivery($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyLiveRealtimeLogDeliveryWithOptions($request, $runtime);
    }

    /**
     * Modifies the attributes of an episode list.
     *
     * @remarks
     * This operation allows you to change the position of an episode in an episode list, how many times an episode list is played, and the specific point in time at which the episode of the highest priority in an episode list is played.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ModifyShowListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyShowListResponse
     *
     * @param ModifyShowListRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return ModifyShowListResponse
     */
    public function modifyShowListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->highPriorityShowId) {
            @$query['HighPriorityShowId'] = $request->highPriorityShowId;
        }

        if (null !== $request->highPriorityShowStartTime) {
            @$query['HighPriorityShowStartTime'] = $request->highPriorityShowStartTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->repeatTimes) {
            @$query['RepeatTimes'] = $request->repeatTimes;
        }

        if (null !== $request->showId) {
            @$query['ShowId'] = $request->showId;
        }

        if (null !== $request->spot) {
            @$query['Spot'] = $request->spot;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyShowList',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyShowListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the attributes of an episode list.
     *
     * @remarks
     * This operation allows you to change the position of an episode in an episode list, how many times an episode list is played, and the specific point in time at which the episode of the highest priority in an episode list is played.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ModifyShowListRequest
     *
     * @returns ModifyShowListResponse
     *
     * @param ModifyShowListRequest $request
     *
     * @return ModifyShowListResponse
     */
    public function modifyShowList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyShowListWithOptions($request, $runtime);
    }

    /**
     * Modifies a layout of a virtual studio.
     *
     * @remarks
     * You can call this operation to modify a layout of a virtual studio. When you call this operation, specify only the parameters that you want to modify.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ModifyStudioLayoutRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyStudioLayoutResponse
     *
     * @param ModifyStudioLayoutRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return ModifyStudioLayoutResponse
     */
    public function modifyStudioLayoutWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bgImageConfig) {
            @$query['BgImageConfig'] = $request->bgImageConfig;
        }

        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->commonConfig) {
            @$query['CommonConfig'] = $request->commonConfig;
        }

        if (null !== $request->layerOrderConfigList) {
            @$query['LayerOrderConfigList'] = $request->layerOrderConfigList;
        }

        if (null !== $request->layoutId) {
            @$query['LayoutId'] = $request->layoutId;
        }

        if (null !== $request->layoutName) {
            @$query['LayoutName'] = $request->layoutName;
        }

        if (null !== $request->mediaInputConfigList) {
            @$query['MediaInputConfigList'] = $request->mediaInputConfigList;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->screenInputConfigList) {
            @$query['ScreenInputConfigList'] = $request->screenInputConfigList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyStudioLayout',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyStudioLayoutResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies a layout of a virtual studio.
     *
     * @remarks
     * You can call this operation to modify a layout of a virtual studio. When you call this operation, specify only the parameters that you want to modify.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ModifyStudioLayoutRequest
     *
     * @returns ModifyStudioLayoutResponse
     *
     * @param ModifyStudioLayoutRequest $request
     *
     * @return ModifyStudioLayoutResponse
     */
    public function modifyStudioLayout($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyStudioLayoutWithOptions($request, $runtime);
    }

    /**
     * Mutes a message group. In this case, all members of the message group are muted.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - MuteAllGroupUserRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns MuteAllGroupUserResponse
     *
     * @param MuteAllGroupUserRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return MuteAllGroupUserResponse
     */
    public function muteAllGroupUserWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->appId) {
            @$body['AppId'] = $request->appId;
        }

        if (null !== $request->broadCastType) {
            @$body['BroadCastType'] = $request->broadCastType;
        }

        if (null !== $request->groupId) {
            @$body['GroupId'] = $request->groupId;
        }

        if (null !== $request->operatorUserId) {
            @$body['OperatorUserId'] = $request->operatorUserId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'MuteAllGroupUser',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return MuteAllGroupUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Mutes a message group. In this case, all members of the message group are muted.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - MuteAllGroupUserRequest
     *
     * @returns MuteAllGroupUserResponse
     *
     * @param MuteAllGroupUserRequest $request
     *
     * @return MuteAllGroupUserResponse
     */
    public function muteAllGroupUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->muteAllGroupUserWithOptions($request, $runtime);
    }

    /**
     * Mutes members in a message group.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param tmpReq - MuteGroupUserRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns MuteGroupUserResponse
     *
     * @param MuteGroupUserRequest $tmpReq
     * @param RuntimeOptions       $runtime
     *
     * @return MuteGroupUserResponse
     */
    public function muteGroupUserWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new MuteGroupUserShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->muteUserList) {
            $request->muteUserListShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->muteUserList, 'MuteUserList', 'simple');
        }

        $body = [];
        if (null !== $request->appId) {
            @$body['AppId'] = $request->appId;
        }

        if (null !== $request->broadCastType) {
            @$body['BroadCastType'] = $request->broadCastType;
        }

        if (null !== $request->groupId) {
            @$body['GroupId'] = $request->groupId;
        }

        if (null !== $request->muteTime) {
            @$body['MuteTime'] = $request->muteTime;
        }

        if (null !== $request->muteUserListShrink) {
            @$body['MuteUserList'] = $request->muteUserListShrink;
        }

        if (null !== $request->operatorUserId) {
            @$body['OperatorUserId'] = $request->operatorUserId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'MuteGroupUser',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return MuteGroupUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Mutes members in a message group.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - MuteGroupUserRequest
     *
     * @returns MuteGroupUserResponse
     *
     * @param MuteGroupUserRequest $request
     *
     * @return MuteGroupUserResponse
     */
    public function muteGroupUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->muteGroupUserWithOptions($request, $runtime);
    }

    /**
     * Enables time shifting for a domain name, or an application or a live stream under the domain name.
     *
     * @remarks
     * You cannot configure time shifting and delayed transcoding at the same time.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - OpenLiveShiftRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns OpenLiveShiftResponse
     *
     * @param OpenLiveShiftRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return OpenLiveShiftResponse
     */
    public function openLiveShiftWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->duration) {
            @$query['Duration'] = $request->duration;
        }

        if (null !== $request->ignoreTranscode) {
            @$query['IgnoreTranscode'] = $request->ignoreTranscode;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        if (null !== $request->vision) {
            @$query['Vision'] = $request->vision;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'OpenLiveShift',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return OpenLiveShiftResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables time shifting for a domain name, or an application or a live stream under the domain name.
     *
     * @remarks
     * You cannot configure time shifting and delayed transcoding at the same time.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - OpenLiveShiftRequest
     *
     * @returns OpenLiveShiftResponse
     *
     * @param OpenLiveShiftRequest $request
     *
     * @return OpenLiveShiftResponse
     */
    public function openLiveShift($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->openLiveShiftWithOptions($request, $runtime);
    }

    /**
     * Switches to a specified episode.
     *
     * @remarks
     * After you add episodes to an episode list and start live streaming, you can call this operation to switch among episodes. For information about how to add episodes to an episode list, see [AddShowIntoShowList](https://help.aliyun.com/document_detail/2848051.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - PlayChoosenShowRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns PlayChoosenShowResponse
     *
     * @param PlayChoosenShowRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return PlayChoosenShowResponse
     */
    public function playChoosenShowWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->showId) {
            @$query['ShowId'] = $request->showId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'PlayChoosenShow',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return PlayChoosenShowResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Switches to a specified episode.
     *
     * @remarks
     * After you add episodes to an episode list and start live streaming, you can call this operation to switch among episodes. For information about how to add episodes to an episode list, see [AddShowIntoShowList](https://help.aliyun.com/document_detail/2848051.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - PlayChoosenShowRequest
     *
     * @returns PlayChoosenShowResponse
     *
     * @param PlayChoosenShowRequest $request
     *
     * @return PlayChoosenShowResponse
     */
    public function playChoosenShow($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->playChoosenShowWithOptions($request, $runtime);
    }

    /**
     * Publishes the configurations of an accelerated domain name from the canary release environment to the production environment.
     *
     * @remarks
     * Function name is required for calling this operation. You can get the function name by calling the [DescribeLiveDomainStagingConfig](~~297374#doc-api-live-DescribeLiveDomainStagingConfig~~ "Queries the configurations in the canary release environment.") operation.
     * ## QPS limit
     * A single user can perform a maximum of 30 queries per minute. Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
     *
     * @param request - PublishLiveStagingConfigToProductionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns PublishLiveStagingConfigToProductionResponse
     *
     * @param PublishLiveStagingConfigToProductionRequest $request
     * @param RuntimeOptions                              $runtime
     *
     * @return PublishLiveStagingConfigToProductionResponse
     */
    public function publishLiveStagingConfigToProductionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->functionName) {
            @$query['FunctionName'] = $request->functionName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'PublishLiveStagingConfigToProduction',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return PublishLiveStagingConfigToProductionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Publishes the configurations of an accelerated domain name from the canary release environment to the production environment.
     *
     * @remarks
     * Function name is required for calling this operation. You can get the function name by calling the [DescribeLiveDomainStagingConfig](~~297374#doc-api-live-DescribeLiveDomainStagingConfig~~ "Queries the configurations in the canary release environment.") operation.
     * ## QPS limit
     * A single user can perform a maximum of 30 queries per minute. Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
     *
     * @param request - PublishLiveStagingConfigToProductionRequest
     *
     * @returns PublishLiveStagingConfigToProductionResponse
     *
     * @param PublishLiveStagingConfigToProductionRequest $request
     *
     * @return PublishLiveStagingConfigToProductionResponse
     */
    public function publishLiveStagingConfigToProduction($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->publishLiveStagingConfigToProductionWithOptions($request, $runtime);
    }

    /**
     * Queries the dual-stream disaster recovery records of online streams.
     *
     * @param request - QueryLiveDomainMultiStreamListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns QueryLiveDomainMultiStreamListResponse
     *
     * @param QueryLiveDomainMultiStreamListRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return QueryLiveDomainMultiStreamListResponse
     */
    public function queryLiveDomainMultiStreamListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'QueryLiveDomainMultiStreamList',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return QueryLiveDomainMultiStreamListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the dual-stream disaster recovery records of online streams.
     *
     * @param request - QueryLiveDomainMultiStreamListRequest
     *
     * @returns QueryLiveDomainMultiStreamListResponse
     *
     * @param QueryLiveDomainMultiStreamListRequest $request
     *
     * @return QueryLiveDomainMultiStreamListResponse
     */
    public function queryLiveDomainMultiStreamList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryLiveDomainMultiStreamListWithOptions($request, $runtime);
    }

    /**
     * Queries interactive messaging applications based on specified conditions.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - QueryMessageAppRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns QueryMessageAppResponse
     *
     * @param QueryMessageAppRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return QueryMessageAppResponse
     */
    public function queryMessageAppWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->appId) {
            @$body['AppId'] = $request->appId;
        }

        if (null !== $request->appName) {
            @$body['AppName'] = $request->appName;
        }

        if (null !== $request->pageNum) {
            @$body['PageNum'] = $request->pageNum;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->sortType) {
            @$body['SortType'] = $request->sortType;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'QueryMessageApp',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return QueryMessageAppResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries interactive messaging applications based on specified conditions.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - QueryMessageAppRequest
     *
     * @returns QueryMessageAppResponse
     *
     * @param QueryMessageAppRequest $request
     *
     * @return QueryMessageAppResponse
     */
    public function queryMessageApp($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryMessageAppWithOptions($request, $runtime);
    }

    /**
     * Queries the status of a speech-to-text or translation task.
     *
     * @remarks
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - QueryRtcAsrTasksRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns QueryRtcAsrTasksResponse
     *
     * @param QueryRtcAsrTasksRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return QueryRtcAsrTasksResponse
     */
    public function queryRtcAsrTasksWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'QueryRtcAsrTasks',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return QueryRtcAsrTasksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the status of a speech-to-text or translation task.
     *
     * @remarks
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - QueryRtcAsrTasksRequest
     *
     * @returns QueryRtcAsrTasksResponse
     *
     * @param QueryRtcAsrTasksRequest $request
     *
     * @return QueryRtcAsrTasksResponse
     */
    public function queryRtcAsrTasks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryRtcAsrTasksWithOptions($request, $runtime);
    }

    /**
     * Queries the configuration of authentication for snapshot callbacks.
     *
     * @remarks
     * Before you call this operation, make sure that you have configured authentication for snapshot callbacks. For more information, see [SetSnapshotCallbackAuth](https://help.aliyun.com/document_detail/2847907.html). You can call this operation to query the configuration of authentication for snapshot callbacks for a main streaming domain. Make sure that the parameter settings meet the requirements.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - QuerySnapshotCallbackAuthRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns QuerySnapshotCallbackAuthResponse
     *
     * @param QuerySnapshotCallbackAuthRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return QuerySnapshotCallbackAuthResponse
     */
    public function querySnapshotCallbackAuthWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'QuerySnapshotCallbackAuth',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return QuerySnapshotCallbackAuthResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configuration of authentication for snapshot callbacks.
     *
     * @remarks
     * Before you call this operation, make sure that you have configured authentication for snapshot callbacks. For more information, see [SetSnapshotCallbackAuth](https://help.aliyun.com/document_detail/2847907.html). You can call this operation to query the configuration of authentication for snapshot callbacks for a main streaming domain. Make sure that the parameter settings meet the requirements.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - QuerySnapshotCallbackAuthRequest
     *
     * @returns QuerySnapshotCallbackAuthResponse
     *
     * @param QuerySnapshotCallbackAuthRequest $request
     *
     * @return QuerySnapshotCallbackAuthResponse
     */
    public function querySnapshotCallbackAuth($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->querySnapshotCallbackAuthWithOptions($request, $runtime);
    }

    /**
     * Controls recordings manually on demand. For example, you can call this operation to start or stop recording at a specific point in time.
     *
     * @remarks
     *   Before you call this operation, make sure that you fully understand the billing method and pricing of live stream recording in ApsaraVideo Live. For more information, see [Billing of live stream recording](https://help.aliyun.com/document_detail/195287.html).
     * *   If a live stream is being automatically or manually recorded, you can call this operation to stop recording the live stream.
     * *   If you call this operation to start recording a live stream while it is being recorded, a TaskAlreadyStarted error is returned, indicating that the task has been started.
     * *   If a live stream that you manually record is interrupted, the recording stops.
     * *   If automatic recording is not configured for the live stream, ApsaraVideo Live does not automatically record the live stream after it is resumed.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - RealTimeRecordCommandRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RealTimeRecordCommandResponse
     *
     * @param RealTimeRecordCommandRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return RealTimeRecordCommandResponse
     */
    public function realTimeRecordCommandWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->command) {
            @$query['Command'] = $request->command;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RealTimeRecordCommand',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RealTimeRecordCommandResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Controls recordings manually on demand. For example, you can call this operation to start or stop recording at a specific point in time.
     *
     * @remarks
     *   Before you call this operation, make sure that you fully understand the billing method and pricing of live stream recording in ApsaraVideo Live. For more information, see [Billing of live stream recording](https://help.aliyun.com/document_detail/195287.html).
     * *   If a live stream is being automatically or manually recorded, you can call this operation to stop recording the live stream.
     * *   If you call this operation to start recording a live stream while it is being recorded, a TaskAlreadyStarted error is returned, indicating that the task has been started.
     * *   If a live stream that you manually record is interrupted, the recording stops.
     * *   If automatic recording is not configured for the live stream, ApsaraVideo Live does not automatically record the live stream after it is resumed.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - RealTimeRecordCommandRequest
     *
     * @returns RealTimeRecordCommandResponse
     *
     * @param RealTimeRecordCommandRequest $request
     *
     * @return RealTimeRecordCommandResponse
     */
    public function realTimeRecordCommand($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->realTimeRecordCommandWithOptions($request, $runtime);
    }

    /**
     * Restores a deleted interactive messaging group.
     *
     * @remarks
     *   You can call this operation to restore a deleted interactive messaging group within 30 days after you call the [DeleteLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) to delete the group.
     * *   After you restore a group, the messages that were stored in the group before it was deleted can still be queried.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - RecoverLiveMessageDeletedGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RecoverLiveMessageDeletedGroupResponse
     *
     * @param RecoverLiveMessageDeletedGroupRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return RecoverLiveMessageDeletedGroupResponse
     */
    public function recoverLiveMessageDeletedGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->dataCenter) {
            @$query['DataCenter'] = $request->dataCenter;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RecoverLiveMessageDeletedGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RecoverLiveMessageDeletedGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Restores a deleted interactive messaging group.
     *
     * @remarks
     *   You can call this operation to restore a deleted interactive messaging group within 30 days after you call the [DeleteLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) to delete the group.
     * *   After you restore a group, the messages that were stored in the group before it was deleted can still be queried.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - RecoverLiveMessageDeletedGroupRequest
     *
     * @returns RecoverLiveMessageDeletedGroupResponse
     *
     * @param RecoverLiveMessageDeletedGroupRequest $request
     *
     * @return RecoverLiveMessageDeletedGroupResponse
     */
    public function recoverLiveMessageDeletedGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->recoverLiveMessageDeletedGroupWithOptions($request, $runtime);
    }

    /**
     * Unmutes one or more users.
     *
     * @remarks
     * Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param tmpReq - RemoveLiveMessageGroupBandRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RemoveLiveMessageGroupBandResponse
     *
     * @param RemoveLiveMessageGroupBandRequest $tmpReq
     * @param RuntimeOptions                    $runtime
     *
     * @return RemoveLiveMessageGroupBandResponse
     */
    public function removeLiveMessageGroupBandWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new RemoveLiveMessageGroupBandShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->unbannedUsers) {
            $request->unbannedUsersShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->unbannedUsers, 'UnbannedUsers', 'simple');
        }

        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->dataCenter) {
            @$query['DataCenter'] = $request->dataCenter;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        if (null !== $request->unbannedUsersShrink) {
            @$query['UnbannedUsers'] = $request->unbannedUsersShrink;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RemoveLiveMessageGroupBand',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RemoveLiveMessageGroupBandResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Unmutes one or more users.
     *
     * @remarks
     * Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - RemoveLiveMessageGroupBandRequest
     *
     * @returns RemoveLiveMessageGroupBandResponse
     *
     * @param RemoveLiveMessageGroupBandRequest $request
     *
     * @return RemoveLiveMessageGroupBandResponse
     */
    public function removeLiveMessageGroupBand($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->removeLiveMessageGroupBandWithOptions($request, $runtime);
    }

    /**
     * Removes a specified episode from an episode list.
     *
     * @remarks
     * ## [](#)Usage notes
     * You cannot use this operation on empty episode lists. For information about how to add episodes to an episode list, see [AddShowIntoShowList](https://help.aliyun.com/document_detail/370861.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - RemoveShowFromShowListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RemoveShowFromShowListResponse
     *
     * @param RemoveShowFromShowListRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return RemoveShowFromShowListResponse
     */
    public function removeShowFromShowListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->showId) {
            @$query['ShowId'] = $request->showId;
        }

        if (null !== $request->isBatchMode) {
            @$query['isBatchMode'] = $request->isBatchMode;
        }

        if (null !== $request->showIdList) {
            @$query['showIdList'] = $request->showIdList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RemoveShowFromShowList',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RemoveShowFromShowListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Removes a specified episode from an episode list.
     *
     * @remarks
     * ## [](#)Usage notes
     * You cannot use this operation on empty episode lists. For information about how to add episodes to an episode list, see [AddShowIntoShowList](https://help.aliyun.com/document_detail/370861.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - RemoveShowFromShowListRequest
     *
     * @returns RemoveShowFromShowListResponse
     *
     * @param RemoveShowFromShowListRequest $request
     *
     * @return RemoveShowFromShowListResponse
     */
    public function removeShowFromShowList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->removeShowFromShowListWithOptions($request, $runtime);
    }

    /**
     * Removes users from a channel.
     *
     * @remarks
     * You can call this operation to remove one or more users from a channel.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - RemoveTerminalsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RemoveTerminalsResponse
     *
     * @param RemoveTerminalsRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return RemoveTerminalsResponse
     */
    public function removeTerminalsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->channelId) {
            @$query['ChannelId'] = $request->channelId;
        }

        if (null !== $request->terminalIds) {
            @$query['TerminalIds'] = $request->terminalIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RemoveTerminals',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RemoveTerminalsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Removes users from a channel.
     *
     * @remarks
     * You can call this operation to remove one or more users from a channel.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - RemoveTerminalsRequest
     *
     * @returns RemoveTerminalsResponse
     *
     * @param RemoveTerminalsRequest $request
     *
     * @return RemoveTerminalsResponse
     */
    public function removeTerminals($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->removeTerminalsWithOptions($request, $runtime);
    }

    /**
     * Restarts a production studio.
     *
     * @remarks
     *   Only product studios in playlist mode and general mode are supported. Virtual studios are not supported.
     * *   After you restart a production studio, the current settings such as the resolution and screen orientation are reloaded to restore the previous playback status.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - RestartCasterRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RestartCasterResponse
     *
     * @param RestartCasterRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return RestartCasterResponse
     */
    public function restartCasterWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RestartCaster',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RestartCasterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Restarts a production studio.
     *
     * @remarks
     *   Only product studios in playlist mode and general mode are supported. Virtual studios are not supported.
     * *   After you restart a production studio, the current settings such as the resolution and screen orientation are reloaded to restore the previous playback status.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - RestartCasterRequest
     *
     * @returns RestartCasterResponse
     *
     * @param RestartCasterRequest $request
     *
     * @return RestartCasterResponse
     */
    public function restartCaster($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->restartCasterWithOptions($request, $runtime);
    }

    /**
     * Restarts a pulled-stream relay task.
     *
     * @remarks
     *   You can call this operation to restart a pulled-stream relay task.
     * *   You can restart a task that is running (even if the task is in an abnormal retry state) or a task that is stopped. For a task that is running, this operation stops and then restarts it. For a task that is stopped, this operation directly starts it.
     * *   You cannot restart a task if the start time specified for the task has not been reached.
     * *   If a task is restarted, the task runs based on the latest configuration of the task. This interrupts stream ingest.
     * *   If a task for a list of ApsaraVideo VOD resources is restarted, the list plays from the beginning based on the latest configuration. You can call an operation to update the video index and playback progress to achieve successive playback.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - RestartLivePullToPushRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RestartLivePullToPushResponse
     *
     * @param RestartLivePullToPushRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return RestartLivePullToPushResponse
     */
    public function restartLivePullToPushWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RestartLivePullToPush',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RestartLivePullToPushResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Restarts a pulled-stream relay task.
     *
     * @remarks
     *   You can call this operation to restart a pulled-stream relay task.
     * *   You can restart a task that is running (even if the task is in an abnormal retry state) or a task that is stopped. For a task that is running, this operation stops and then restarts it. For a task that is stopped, this operation directly starts it.
     * *   You cannot restart a task if the start time specified for the task has not been reached.
     * *   If a task is restarted, the task runs based on the latest configuration of the task. This interrupts stream ingest.
     * *   If a task for a list of ApsaraVideo VOD resources is restarted, the list plays from the beginning based on the latest configuration. You can call an operation to update the video index and playback progress to achieve successive playback.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - RestartLivePullToPushRequest
     *
     * @returns RestartLivePullToPushResponse
     *
     * @param RestartLivePullToPushRequest $request
     *
     * @return RestartLivePullToPushResponse
     */
    public function restartLivePullToPush($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->restartLivePullToPushWithOptions($request, $runtime);
    }

    /**
     * @param request - RestartTranscodeTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RestartTranscodeTaskResponse
     *
     * @param RestartTranscodeTaskRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return RestartTranscodeTaskResponse
     */
    public function restartTranscodeTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->app) {
            @$query['App'] = $request->app;
        }

        if (null !== $request->pushDomain) {
            @$query['PushDomain'] = $request->pushDomain;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        if (null !== $request->transcodingTemplate) {
            @$query['TranscodingTemplate'] = $request->transcodingTemplate;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RestartTranscodeTask',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RestartTranscodeTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param request - RestartTranscodeTaskRequest
     *
     * @returns RestartTranscodeTaskResponse
     *
     * @param RestartTranscodeTaskRequest $request
     *
     * @return RestartTranscodeTaskResponse
     */
    public function restartTranscodeTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->restartTranscodeTaskWithOptions($request, $runtime);
    }

    /**
     * Resumes the ingest of a live stream.
     *
     * @remarks
     * You can call this operation to resume the ingest of a stream. This operation supports only the live streams ingested by streamers.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ResumeLiveStreamRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ResumeLiveStreamResponse
     *
     * @param ResumeLiveStreamRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return ResumeLiveStreamResponse
     */
    public function resumeLiveStreamWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->liveStreamType) {
            @$query['LiveStreamType'] = $request->liveStreamType;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ResumeLiveStream',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ResumeLiveStreamResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Resumes the ingest of a live stream.
     *
     * @remarks
     * You can call this operation to resume the ingest of a stream. This operation supports only the live streams ingested by streamers.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - ResumeLiveStreamRequest
     *
     * @returns ResumeLiveStreamResponse
     *
     * @param ResumeLiveStreamRequest $request
     *
     * @return ResumeLiveStreamResponse
     */
    public function resumeLiveStream($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->resumeLiveStreamWithOptions($request, $runtime);
    }

    /**
     * Rolls back the configurations of an accelerated domain name in the canary release environment.
     *
     * @remarks
     * Function name is required for calling this operation. You can get the function name by calling the [DescribeLiveDomainStagingConfig](~~297374#doc-api-live-DescribeLiveDomainStagingConfig~~ "Queries the configurations in the canary release environment.") operation.
     * ## QPS limit
     * A single user can perform a maximum of 30 queries per minute. Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
     *
     * @param request - RollbackLiveStagingConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RollbackLiveStagingConfigResponse
     *
     * @param RollbackLiveStagingConfigRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return RollbackLiveStagingConfigResponse
     */
    public function rollbackLiveStagingConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->functionName) {
            @$query['FunctionName'] = $request->functionName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RollbackLiveStagingConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RollbackLiveStagingConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Rolls back the configurations of an accelerated domain name in the canary release environment.
     *
     * @remarks
     * Function name is required for calling this operation. You can get the function name by calling the [DescribeLiveDomainStagingConfig](~~297374#doc-api-live-DescribeLiveDomainStagingConfig~~ "Queries the configurations in the canary release environment.") operation.
     * ## QPS limit
     * A single user can perform a maximum of 30 queries per minute. Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
     *
     * @param request - RollbackLiveStagingConfigRequest
     *
     * @returns RollbackLiveStagingConfigResponse
     *
     * @param RollbackLiveStagingConfigRequest $request
     *
     * @return RollbackLiveStagingConfigResponse
     */
    public function rollbackLiveStagingConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->rollbackLiveStagingConfigWithOptions($request, $runtime);
    }

    /**
     * Configures likes in a message group.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - SendLikeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SendLikeResponse
     *
     * @param SendLikeRequest $request
     * @param RuntimeOptions  $runtime
     *
     * @return SendLikeResponse
     */
    public function sendLikeWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->appId) {
            @$body['AppId'] = $request->appId;
        }

        if (null !== $request->broadCastType) {
            @$body['BroadCastType'] = $request->broadCastType;
        }

        if (null !== $request->count) {
            @$body['Count'] = $request->count;
        }

        if (null !== $request->groupId) {
            @$body['GroupId'] = $request->groupId;
        }

        if (null !== $request->operatorUserId) {
            @$body['OperatorUserId'] = $request->operatorUserId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'SendLike',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SendLikeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures likes in a message group.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - SendLikeRequest
     *
     * @returns SendLikeResponse
     *
     * @param SendLikeRequest $request
     *
     * @return SendLikeResponse
     */
    public function sendLike($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->sendLikeWithOptions($request, $runtime);
    }

    /**
     * Sends a message to a group.
     *
     * @remarks
     * Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group. You can send messages to a group only if the group is active, which requires that one or more users have joined the group. Offline messages are not supported. If you fail to send a message, check whether users exist in the group. If you want to send a message when all users are offline, we recommend that you store the message locally and send it after users get online.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - SendLiveMessageGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SendLiveMessageGroupResponse
     *
     * @param SendLiveMessageGroupRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return SendLiveMessageGroupResponse
     */
    public function sendLiveMessageGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->body) {
            @$query['Body'] = $request->body;
        }

        if (null !== $request->dataCenter) {
            @$query['DataCenter'] = $request->dataCenter;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        if (null !== $request->msgTid) {
            @$query['MsgTid'] = $request->msgTid;
        }

        if (null !== $request->msgType) {
            @$query['MsgType'] = $request->msgType;
        }

        if (null !== $request->noCache) {
            @$query['NoCache'] = $request->noCache;
        }

        if (null !== $request->noStorage) {
            @$query['NoStorage'] = $request->noStorage;
        }

        if (null !== $request->senderId) {
            @$query['SenderId'] = $request->senderId;
        }

        if (null !== $request->senderMetaInfo) {
            @$query['SenderMetaInfo'] = $request->senderMetaInfo;
        }

        if (null !== $request->staticsIncrease) {
            @$query['StaticsIncrease'] = $request->staticsIncrease;
        }

        if (null !== $request->weight) {
            @$query['Weight'] = $request->weight;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SendLiveMessageGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SendLiveMessageGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Sends a message to a group.
     *
     * @remarks
     * Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group. You can send messages to a group only if the group is active, which requires that one or more users have joined the group. Offline messages are not supported. If you fail to send a message, check whether users exist in the group. If you want to send a message when all users are offline, we recommend that you store the message locally and send it after users get online.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - SendLiveMessageGroupRequest
     *
     * @returns SendLiveMessageGroupResponse
     *
     * @param SendLiveMessageGroupRequest $request
     *
     * @return SendLiveMessageGroupResponse
     */
    public function sendLiveMessageGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->sendLiveMessageGroupWithOptions($request, $runtime);
    }

    /**
     * Sends a message to a specified user. The user is identified by ReceiverId.
     *
     * @remarks
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - SendLiveMessageUserRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SendLiveMessageUserResponse
     *
     * @param SendLiveMessageUserRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return SendLiveMessageUserResponse
     */
    public function sendLiveMessageUserWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->body) {
            @$query['Body'] = $request->body;
        }

        if (null !== $request->dataCenter) {
            @$query['DataCenter'] = $request->dataCenter;
        }

        if (null !== $request->highReliability) {
            @$query['HighReliability'] = $request->highReliability;
        }

        if (null !== $request->msgTid) {
            @$query['MsgTid'] = $request->msgTid;
        }

        if (null !== $request->msgType) {
            @$query['MsgType'] = $request->msgType;
        }

        if (null !== $request->receiverId) {
            @$query['ReceiverId'] = $request->receiverId;
        }

        if (null !== $request->senderId) {
            @$query['SenderId'] = $request->senderId;
        }

        if (null !== $request->senderInfo) {
            @$query['SenderInfo'] = $request->senderInfo;
        }

        if (null !== $request->storage) {
            @$query['Storage'] = $request->storage;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SendLiveMessageUser',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SendLiveMessageUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Sends a message to a specified user. The user is identified by ReceiverId.
     *
     * @remarks
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - SendLiveMessageUserRequest
     *
     * @returns SendLiveMessageUserResponse
     *
     * @param SendLiveMessageUserRequest $request
     *
     * @return SendLiveMessageUserResponse
     */
    public function sendLiveMessageUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->sendLiveMessageUserWithOptions($request, $runtime);
    }

    /**
     * Sends a message to all members in a message group.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - SendMessageToGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SendMessageToGroupResponse
     *
     * @param SendMessageToGroupRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return SendMessageToGroupResponse
     */
    public function sendMessageToGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->skipAudit) {
            @$query['SkipAudit'] = $request->skipAudit;
        }

        $body = [];
        if (null !== $request->appId) {
            @$body['AppId'] = $request->appId;
        }

        if (null !== $request->data) {
            @$body['Data'] = $request->data;
        }

        if (null !== $request->groupId) {
            @$body['GroupId'] = $request->groupId;
        }

        if (null !== $request->operatorUserId) {
            @$body['OperatorUserId'] = $request->operatorUserId;
        }

        if (null !== $request->type) {
            @$body['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'SendMessageToGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SendMessageToGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Sends a message to all members in a message group.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - SendMessageToGroupRequest
     *
     * @returns SendMessageToGroupResponse
     *
     * @param SendMessageToGroupRequest $request
     *
     * @return SendMessageToGroupResponse
     */
    public function sendMessageToGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->sendMessageToGroupWithOptions($request, $runtime);
    }

    /**
     * Sends a message to specified users in a message group.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param tmpReq - SendMessageToGroupUsersRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SendMessageToGroupUsersResponse
     *
     * @param SendMessageToGroupUsersRequest $tmpReq
     * @param RuntimeOptions                 $runtime
     *
     * @return SendMessageToGroupUsersResponse
     */
    public function sendMessageToGroupUsersWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new SendMessageToGroupUsersShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->receiverIdList) {
            $request->receiverIdListShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->receiverIdList, 'ReceiverIdList', 'simple');
        }

        $query = [];
        if (null !== $request->skipAudit) {
            @$query['SkipAudit'] = $request->skipAudit;
        }

        $body = [];
        if (null !== $request->appId) {
            @$body['AppId'] = $request->appId;
        }

        if (null !== $request->data) {
            @$body['Data'] = $request->data;
        }

        if (null !== $request->groupId) {
            @$body['GroupId'] = $request->groupId;
        }

        if (null !== $request->operatorUserId) {
            @$body['OperatorUserId'] = $request->operatorUserId;
        }

        if (null !== $request->receiverIdListShrink) {
            @$body['ReceiverIdList'] = $request->receiverIdListShrink;
        }

        if (null !== $request->type) {
            @$body['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'SendMessageToGroupUsers',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SendMessageToGroupUsersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Sends a message to specified users in a message group.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - SendMessageToGroupUsersRequest
     *
     * @returns SendMessageToGroupUsersResponse
     *
     * @param SendMessageToGroupUsersRequest $request
     *
     * @return SendMessageToGroupUsersResponse
     */
    public function sendMessageToGroupUsers($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->sendMessageToGroupUsersWithOptions($request, $runtime);
    }

    /**
     * Configures a channel of a production studio.
     *
     * @remarks
     * You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to configure a channel for the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - SetCasterChannelRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetCasterChannelResponse
     *
     * @param SetCasterChannelRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return SetCasterChannelResponse
     */
    public function setCasterChannelWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->channelId) {
            @$query['ChannelId'] = $request->channelId;
        }

        if (null !== $request->faceBeauty) {
            @$query['FaceBeauty'] = $request->faceBeauty;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->playStatus) {
            @$query['PlayStatus'] = $request->playStatus;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->seekOffset) {
            @$query['SeekOffset'] = $request->seekOffset;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SetCasterChannel',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetCasterChannelResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures a channel of a production studio.
     *
     * @remarks
     * You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to configure a channel for the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - SetCasterChannelRequest
     *
     * @returns SetCasterChannelResponse
     *
     * @param SetCasterChannelRequest $request
     *
     * @return SetCasterChannelResponse
     */
    public function setCasterChannel($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setCasterChannelWithOptions($request, $runtime);
    }

    /**
     * Configures a production studio. For example, you can specify the name of the production studio, configure the transcoding settings, and configure the recording settings.
     *
     * @remarks
     * You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to configure the production studio. This operation completely replaces existing configurations. If you leave a parameter empty, the corresponding configuration is cleared for the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - SetCasterConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetCasterConfigResponse
     *
     * @param SetCasterConfigRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return SetCasterConfigResponse
     */
    public function setCasterConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->autoSwitchUrgentConfig) {
            @$query['AutoSwitchUrgentConfig'] = $request->autoSwitchUrgentConfig;
        }

        if (null !== $request->autoSwitchUrgentOn) {
            @$query['AutoSwitchUrgentOn'] = $request->autoSwitchUrgentOn;
        }

        if (null !== $request->callbackUrl) {
            @$query['CallbackUrl'] = $request->callbackUrl;
        }

        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->casterName) {
            @$query['CasterName'] = $request->casterName;
        }

        if (null !== $request->channelEnable) {
            @$query['ChannelEnable'] = $request->channelEnable;
        }

        if (null !== $request->delay) {
            @$query['Delay'] = $request->delay;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->programEffect) {
            @$query['ProgramEffect'] = $request->programEffect;
        }

        if (null !== $request->programName) {
            @$query['ProgramName'] = $request->programName;
        }

        if (null !== $request->recordConfig) {
            @$query['RecordConfig'] = $request->recordConfig;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->sideOutputUrl) {
            @$query['SideOutputUrl'] = $request->sideOutputUrl;
        }

        if (null !== $request->sideOutputUrlList) {
            @$query['SideOutputUrlList'] = $request->sideOutputUrlList;
        }

        if (null !== $request->syncGroupsConfig) {
            @$query['SyncGroupsConfig'] = $request->syncGroupsConfig;
        }

        if (null !== $request->transcodeConfig) {
            @$query['TranscodeConfig'] = $request->transcodeConfig;
        }

        if (null !== $request->urgentImageId) {
            @$query['UrgentImageId'] = $request->urgentImageId;
        }

        if (null !== $request->urgentImageUrl) {
            @$query['UrgentImageUrl'] = $request->urgentImageUrl;
        }

        if (null !== $request->urgentLiveStreamUrl) {
            @$query['UrgentLiveStreamUrl'] = $request->urgentLiveStreamUrl;
        }

        if (null !== $request->urgentMaterialId) {
            @$query['UrgentMaterialId'] = $request->urgentMaterialId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SetCasterConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetCasterConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures a production studio. For example, you can specify the name of the production studio, configure the transcoding settings, and configure the recording settings.
     *
     * @remarks
     * You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to configure the production studio. This operation completely replaces existing configurations. If you leave a parameter empty, the corresponding configuration is cleared for the production studio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - SetCasterConfigRequest
     *
     * @returns SetCasterConfigResponse
     *
     * @param SetCasterConfigRequest $request
     *
     * @return SetCasterConfigResponse
     */
    public function setCasterConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setCasterConfigWithOptions($request, $runtime);
    }

    /**
     * Configures all settings of a scene. This is done by clearing all previous settings of the scene and applying new settings, including the layout setting, to the scene.
     *
     * @remarks
     * ## [](#)Usage notes
     * This operation configures a scene by clearing all previous settings of the scene and applying new settings, including the layout setting, to the scene.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - SetCasterSceneConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetCasterSceneConfigResponse
     *
     * @param SetCasterSceneConfigRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return SetCasterSceneConfigResponse
     */
    public function setCasterSceneConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->componentId) {
            @$query['ComponentId'] = $request->componentId;
        }

        if (null !== $request->layoutId) {
            @$query['LayoutId'] = $request->layoutId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->sceneId) {
            @$query['SceneId'] = $request->sceneId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SetCasterSceneConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetCasterSceneConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures all settings of a scene. This is done by clearing all previous settings of the scene and applying new settings, including the layout setting, to the scene.
     *
     * @remarks
     * ## [](#)Usage notes
     * This operation configures a scene by clearing all previous settings of the scene and applying new settings, including the layout setting, to the scene.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - SetCasterSceneConfigRequest
     *
     * @returns SetCasterSceneConfigResponse
     *
     * @param SetCasterSceneConfigRequest $request
     *
     * @return SetCasterSceneConfigResponse
     */
    public function setCasterSceneConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setCasterSceneConfigWithOptions($request, $runtime);
    }

    /**
     * Enables or disables the certificate of a domain name, and modifies the certificate information.
     *
     * @remarks
     * Obtain the domain name, and then call this operation to enable or disable the certificate of a domain name and modify the certificate information.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - SetLiveDomainCertificateRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetLiveDomainCertificateResponse
     *
     * @param SetLiveDomainCertificateRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return SetLiveDomainCertificateResponse
     */
    public function setLiveDomainCertificateWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->certName) {
            @$query['CertName'] = $request->certName;
        }

        if (null !== $request->certType) {
            @$query['CertType'] = $request->certType;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->forceSet) {
            @$query['ForceSet'] = $request->forceSet;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->SSLPri) {
            @$query['SSLPri'] = $request->SSLPri;
        }

        if (null !== $request->SSLProtocol) {
            @$query['SSLProtocol'] = $request->SSLProtocol;
        }

        if (null !== $request->SSLPub) {
            @$query['SSLPub'] = $request->SSLPub;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SetLiveDomainCertificate',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetLiveDomainCertificateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables or disables the certificate of a domain name, and modifies the certificate information.
     *
     * @remarks
     * Obtain the domain name, and then call this operation to enable or disable the certificate of a domain name and modify the certificate information.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - SetLiveDomainCertificateRequest
     *
     * @returns SetLiveDomainCertificateResponse
     *
     * @param SetLiveDomainCertificateRequest $request
     *
     * @return SetLiveDomainCertificateResponse
     */
    public function setLiveDomainCertificate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setLiveDomainCertificateWithOptions($request, $runtime);
    }

    /**
     * Configures dual-stream disaster recovery for a streaming domain.
     *
     * @remarks
     * You can call this operation to configure dual-stream disaster recovery for a streaming domain, which allows you to ingest two streams that have the same name.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - SetLiveDomainMultiStreamConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetLiveDomainMultiStreamConfigResponse
     *
     * @param SetLiveDomainMultiStreamConfigRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return SetLiveDomainMultiStreamConfigResponse
     */
    public function setLiveDomainMultiStreamConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SetLiveDomainMultiStreamConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetLiveDomainMultiStreamConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures dual-stream disaster recovery for a streaming domain.
     *
     * @remarks
     * You can call this operation to configure dual-stream disaster recovery for a streaming domain, which allows you to ingest two streams that have the same name.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - SetLiveDomainMultiStreamConfigRequest
     *
     * @returns SetLiveDomainMultiStreamConfigResponse
     *
     * @param SetLiveDomainMultiStreamConfigRequest $request
     *
     * @return SetLiveDomainMultiStreamConfigResponse
     */
    public function setLiveDomainMultiStreamConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setLiveDomainMultiStreamConfigWithOptions($request, $runtime);
    }

    /**
     * Manually switches between the active stream and standby stream.
     *
     * @param request - SetLiveDomainMultiStreamMasterRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetLiveDomainMultiStreamMasterResponse
     *
     * @param SetLiveDomainMultiStreamMasterRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return SetLiveDomainMultiStreamMasterResponse
     */
    public function setLiveDomainMultiStreamMasterWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SetLiveDomainMultiStreamMaster',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetLiveDomainMultiStreamMasterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Manually switches between the active stream and standby stream.
     *
     * @param request - SetLiveDomainMultiStreamMasterRequest
     *
     * @returns SetLiveDomainMultiStreamMasterResponse
     *
     * @param SetLiveDomainMultiStreamMasterRequest $request
     *
     * @return SetLiveDomainMultiStreamMasterResponse
     */
    public function setLiveDomainMultiStreamMaster($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setLiveDomainMultiStreamMasterWithOptions($request, $runtime);
    }

    /**
     * Configures the auto mode of dual-stream disaster recovery.
     *
     * @param request - SetLiveDomainMultiStreamOptimalModeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetLiveDomainMultiStreamOptimalModeResponse
     *
     * @param SetLiveDomainMultiStreamOptimalModeRequest $request
     * @param RuntimeOptions                             $runtime
     *
     * @return SetLiveDomainMultiStreamOptimalModeResponse
     */
    public function setLiveDomainMultiStreamOptimalModeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SetLiveDomainMultiStreamOptimalMode',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetLiveDomainMultiStreamOptimalModeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures the auto mode of dual-stream disaster recovery.
     *
     * @param request - SetLiveDomainMultiStreamOptimalModeRequest
     *
     * @returns SetLiveDomainMultiStreamOptimalModeResponse
     *
     * @param SetLiveDomainMultiStreamOptimalModeRequest $request
     *
     * @return SetLiveDomainMultiStreamOptimalModeResponse
     */
    public function setLiveDomainMultiStreamOptimalMode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setLiveDomainMultiStreamOptimalModeWithOptions($request, $runtime);
    }

    /**
     * Sets or modifies domain name configurations in the canary release environment.
     *
     * @remarks
     * ## [](#)Usage notes
     * Obtain the accelerated domain name, and then call this operation to set or modify the domain name configurations in the canary release environment. For more information, see **Format of the Functions parameter**.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - SetLiveDomainStagingConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetLiveDomainStagingConfigResponse
     *
     * @param SetLiveDomainStagingConfigRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return SetLiveDomainStagingConfigResponse
     */
    public function setLiveDomainStagingConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->functions) {
            @$query['Functions'] = $request->functions;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SetLiveDomainStagingConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetLiveDomainStagingConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Sets or modifies domain name configurations in the canary release environment.
     *
     * @remarks
     * ## [](#)Usage notes
     * Obtain the accelerated domain name, and then call this operation to set or modify the domain name configurations in the canary release environment. For more information, see **Format of the Functions parameter**.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - SetLiveDomainStagingConfigRequest
     *
     * @returns SetLiveDomainStagingConfigResponse
     *
     * @param SetLiveDomainStagingConfigRequest $request
     *
     * @return SetLiveDomainStagingConfigResponse
     */
    public function setLiveDomainStagingConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setLiveDomainStagingConfigWithOptions($request, $runtime);
    }

    /**
     * Sets the configuration of edge stream relay.
     *
     * @remarks
     * You can call the SetLiveEdgeTransfer operation to configure edge stream relay. The configuration takes effect for ingested streams that start after edge stream relay is configured. The following table describes the scenarios in which edge stream relay takes effect or not.
     * |Scenario|Analysis|Result|
     * |---|---|---|
     * |1\\. You ingest a stream before you call the SetLiveEdgeTransfer operation.|The configuration of edge stream relay is not available.|The ingested stream is not affected by your call of the SetLiveEdgeTransfer operation. Edge stream relay does not take effect.|
     * |2\\. You disconnect an ingested stream that started before you called the SetLiveEdgeTransfer operation, and then resume the ingested stream.|The configuration of edge stream relay is available.|Edge stream relay takes effect for the resumed ingested stream based on the configuration.|
     * |3\\. You ingest a stream after you call the SetLiveEdgeTransfer operation.|The configuration of edge stream relay is available.|Edge stream relay takes effect for the ingested stream based on the configuration.|
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - SetLiveEdgeTransferRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetLiveEdgeTransferResponse
     *
     * @param SetLiveEdgeTransferRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return SetLiveEdgeTransferResponse
     */
    public function setLiveEdgeTransferWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->httpDns) {
            @$query['HttpDns'] = $request->httpDns;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        if (null !== $request->targetDomainList) {
            @$query['TargetDomainList'] = $request->targetDomainList;
        }

        if (null !== $request->transferArgs) {
            @$query['TransferArgs'] = $request->transferArgs;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SetLiveEdgeTransfer',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetLiveEdgeTransferResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Sets the configuration of edge stream relay.
     *
     * @remarks
     * You can call the SetLiveEdgeTransfer operation to configure edge stream relay. The configuration takes effect for ingested streams that start after edge stream relay is configured. The following table describes the scenarios in which edge stream relay takes effect or not.
     * |Scenario|Analysis|Result|
     * |---|---|---|
     * |1\\. You ingest a stream before you call the SetLiveEdgeTransfer operation.|The configuration of edge stream relay is not available.|The ingested stream is not affected by your call of the SetLiveEdgeTransfer operation. Edge stream relay does not take effect.|
     * |2\\. You disconnect an ingested stream that started before you called the SetLiveEdgeTransfer operation, and then resume the ingested stream.|The configuration of edge stream relay is available.|Edge stream relay takes effect for the resumed ingested stream based on the configuration.|
     * |3\\. You ingest a stream after you call the SetLiveEdgeTransfer operation.|The configuration of edge stream relay is available.|Edge stream relay takes effect for the ingested stream based on the configuration.|
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - SetLiveEdgeTransferRequest
     *
     * @returns SetLiveEdgeTransferResponse
     *
     * @param SetLiveEdgeTransferRequest $request
     *
     * @return SetLiveEdgeTransferResponse
     */
    public function setLiveEdgeTransfer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setLiveEdgeTransferWithOptions($request, $runtime);
    }

    /**
     * Creates a configuration of triggered stream pulling.
     *
     * @remarks
     * You can call this operation to configure triggered stream pulling. The configuration lets ApsaraVideo Live automatically pull live streams from the origin server when the origin server starts to play live streams.
     * >  The IPv6 protocol is not supported.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - SetLiveLazyPullStreamInfoConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetLiveLazyPullStreamInfoConfigResponse
     *
     * @param SetLiveLazyPullStreamInfoConfigRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return SetLiveLazyPullStreamInfoConfigResponse
     */
    public function setLiveLazyPullStreamInfoConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pullAppName) {
            @$query['PullAppName'] = $request->pullAppName;
        }

        if (null !== $request->pullDomainName) {
            @$query['PullDomainName'] = $request->pullDomainName;
        }

        if (null !== $request->pullProtocol) {
            @$query['PullProtocol'] = $request->pullProtocol;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->transcodeLazy) {
            @$query['TranscodeLazy'] = $request->transcodeLazy;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SetLiveLazyPullStreamInfoConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetLiveLazyPullStreamInfoConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a configuration of triggered stream pulling.
     *
     * @remarks
     * You can call this operation to configure triggered stream pulling. The configuration lets ApsaraVideo Live automatically pull live streams from the origin server when the origin server starts to play live streams.
     * >  The IPv6 protocol is not supported.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - SetLiveLazyPullStreamInfoConfigRequest
     *
     * @returns SetLiveLazyPullStreamInfoConfigResponse
     *
     * @param SetLiveLazyPullStreamInfoConfigRequest $request
     *
     * @return SetLiveLazyPullStreamInfoConfigResponse
     */
    public function setLiveLazyPullStreamInfoConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setLiveLazyPullStreamInfoConfigWithOptions($request, $runtime);
    }

    /**
     * Configures custom supplemental enhancement information (SEI) for co-streaming.
     *
     * @remarks
     * ## [](#)Usage notes
     * You can call this operation to configure custom SEI for a mixed-stream relay task.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - SetLiveMpuTaskSeiRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetLiveMpuTaskSeiResponse
     *
     * @param SetLiveMpuTaskSeiRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return SetLiveMpuTaskSeiResponse
     */
    public function setLiveMpuTaskSeiWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->customSei) {
            @$query['CustomSei'] = $request->customSei;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SetLiveMpuTaskSei',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetLiveMpuTaskSeiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures custom supplemental enhancement information (SEI) for co-streaming.
     *
     * @remarks
     * ## [](#)Usage notes
     * You can call this operation to configure custom SEI for a mixed-stream relay task.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - SetLiveMpuTaskSeiRequest
     *
     * @returns SetLiveMpuTaskSeiResponse
     *
     * @param SetLiveMpuTaskSeiRequest $request
     *
     * @return SetLiveMpuTaskSeiResponse
     */
    public function setLiveMpuTaskSei($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setLiveMpuTaskSeiWithOptions($request, $runtime);
    }

    /**
     * Configures stream-level region blocking.
     *
     * @remarks
     * You can configure up to 200 stream-level region blocking rules for a domain name. If there are rules in which the same application name and the same stream name are specified, the rule that is updated the most recently takes effect.
     * ### [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - SetLiveStreamBlockRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetLiveStreamBlockResponse
     *
     * @param SetLiveStreamBlockRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return SetLiveStreamBlockResponse
     */
    public function setLiveStreamBlockWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->blockType) {
            @$query['BlockType'] = $request->blockType;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->locationList) {
            @$query['LocationList'] = $request->locationList;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->releaseTime) {
            @$query['ReleaseTime'] = $request->releaseTime;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SetLiveStreamBlock',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetLiveStreamBlockResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures stream-level region blocking.
     *
     * @remarks
     * You can configure up to 200 stream-level region blocking rules for a domain name. If there are rules in which the same application name and the same stream name are specified, the rule that is updated the most recently takes effect.
     * ### [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - SetLiveStreamBlockRequest
     *
     * @returns SetLiveStreamBlockResponse
     *
     * @param SetLiveStreamBlockRequest $request
     *
     * @return SetLiveStreamBlockResponse
     */
    public function setLiveStreamBlock($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setLiveStreamBlockWithOptions($request, $runtime);
    }

    /**
     * Configures the live streaming latency.
     *
     * @remarks
     *   You can call this operation to configure the latency of a streaming domain.
     * *   Because an integer number of groups of pictures (GOPs) are cached, the latency is not less than the GOP size. The actual latency is calculated based on the GOP size. For example, if RtmpDelay is set to 4 seconds and the GOP size is 2 seconds, the minimum latency is 2 seconds (4 seconds minus 2 seconds) and the maximum latency is 6 seconds (4 seconds plus 2 seconds). If the GOP size is greater than the value of RtmpDelay, for example, the GOP size is 5 seconds and RtmpDelay is set to 4 seconds, the latency ranges from 0 to 9 seconds.
     * *   Configuration for the latency of an audio-only stream is invalid. By default, the latency is close to 0.
     * *   For HTTP Live Streaming (HLS)-based playback, the segment size equals the latency divided by 3. Round the value down to the nearest integer. The value cannot be less than 1 second. Then, calculate the maximum number of segments. If the segment size is greater than or equal to 3 seconds, the maximum number of segments is 4. Otherwise, the maximum number of segments is 6.
     * *   The actual HLS segment size is not smaller than the GOP size.
     * *   The latency of HLS-based playback equals the configured segment size times 3.
     * *   If you do not call this operation, the default latency is 2 seconds for Real-Time Messaging Protocol (RTMP)-based playback and 4 seconds for Flash Video (FLV)-based playback. By default, the size of an HLS segment is 5 seconds. In this case, the latency is 15 seconds and the maximum number of segments is 6.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - SetLiveStreamDelayConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetLiveStreamDelayConfigResponse
     *
     * @param SetLiveStreamDelayConfigRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return SetLiveStreamDelayConfigResponse
     */
    public function setLiveStreamDelayConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->flvDelay) {
            @$query['FlvDelay'] = $request->flvDelay;
        }

        if (null !== $request->flvLevel) {
            @$query['FlvLevel'] = $request->flvLevel;
        }

        if (null !== $request->hlsDelay) {
            @$query['HlsDelay'] = $request->hlsDelay;
        }

        if (null !== $request->hlsLevel) {
            @$query['HlsLevel'] = $request->hlsLevel;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->rtmpDelay) {
            @$query['RtmpDelay'] = $request->rtmpDelay;
        }

        if (null !== $request->rtmpLevel) {
            @$query['RtmpLevel'] = $request->rtmpLevel;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SetLiveStreamDelayConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetLiveStreamDelayConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures the live streaming latency.
     *
     * @remarks
     *   You can call this operation to configure the latency of a streaming domain.
     * *   Because an integer number of groups of pictures (GOPs) are cached, the latency is not less than the GOP size. The actual latency is calculated based on the GOP size. For example, if RtmpDelay is set to 4 seconds and the GOP size is 2 seconds, the minimum latency is 2 seconds (4 seconds minus 2 seconds) and the maximum latency is 6 seconds (4 seconds plus 2 seconds). If the GOP size is greater than the value of RtmpDelay, for example, the GOP size is 5 seconds and RtmpDelay is set to 4 seconds, the latency ranges from 0 to 9 seconds.
     * *   Configuration for the latency of an audio-only stream is invalid. By default, the latency is close to 0.
     * *   For HTTP Live Streaming (HLS)-based playback, the segment size equals the latency divided by 3. Round the value down to the nearest integer. The value cannot be less than 1 second. Then, calculate the maximum number of segments. If the segment size is greater than or equal to 3 seconds, the maximum number of segments is 4. Otherwise, the maximum number of segments is 6.
     * *   The actual HLS segment size is not smaller than the GOP size.
     * *   The latency of HLS-based playback equals the configured segment size times 3.
     * *   If you do not call this operation, the default latency is 2 seconds for Real-Time Messaging Protocol (RTMP)-based playback and 4 seconds for Flash Video (FLV)-based playback. By default, the size of an HLS segment is 5 seconds. In this case, the latency is 15 seconds and the maximum number of segments is 6.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - SetLiveStreamDelayConfigRequest
     *
     * @returns SetLiveStreamDelayConfigResponse
     *
     * @param SetLiveStreamDelayConfigRequest $request
     *
     * @return SetLiveStreamDelayConfigResponse
     */
    public function setLiveStreamDelayConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setLiveStreamDelayConfigWithOptions($request, $runtime);
    }

    /**
     * Configures a prefetch task. You can specify multiple URLs to prefetch at a time.
     *
     * @remarks
     *   You can call this operation to specify multiple URLs to prefetch at a time. You can specify up to 100 URLs in a request.
     * *   URLs in the HTTP Live Steaming (HLS) format are not supported.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - SetLiveStreamPreloadTasksRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetLiveStreamPreloadTasksResponse
     *
     * @param SetLiveStreamPreloadTasksRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return SetLiveStreamPreloadTasksResponse
     */
    public function setLiveStreamPreloadTasksWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->area) {
            @$query['Area'] = $request->area;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->playUrl) {
            @$query['PlayUrl'] = $request->playUrl;
        }

        if (null !== $request->preloadedEndTime) {
            @$query['PreloadedEndTime'] = $request->preloadedEndTime;
        }

        if (null !== $request->preloadedStartTime) {
            @$query['PreloadedStartTime'] = $request->preloadedStartTime;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SetLiveStreamPreloadTasks',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetLiveStreamPreloadTasksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures a prefetch task. You can specify multiple URLs to prefetch at a time.
     *
     * @remarks
     *   You can call this operation to specify multiple URLs to prefetch at a time. You can specify up to 100 URLs in a request.
     * *   URLs in the HTTP Live Steaming (HLS) format are not supported.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - SetLiveStreamPreloadTasksRequest
     *
     * @returns SetLiveStreamPreloadTasksResponse
     *
     * @param SetLiveStreamPreloadTasksRequest $request
     *
     * @return SetLiveStreamPreloadTasksResponse
     */
    public function setLiveStreamPreloadTasks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setLiveStreamPreloadTasksWithOptions($request, $runtime);
    }

    /**
     * Configures stream ingest callbacks under an ingest domain.
     *
     * @remarks
     *   You can call this operation to configure the callback URL and authentication information of an ingest domain.
     * *   If you configure callbacks for stream ingest status, you can receive callback notifications about successful or interrupted stream ingest in a timely manner. For more information, see [Format of stream ingest callbacks](https://help.aliyun.com/document_detail/54787.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - SetLiveStreamsNotifyUrlConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetLiveStreamsNotifyUrlConfigResponse
     *
     * @param SetLiveStreamsNotifyUrlConfigRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return SetLiveStreamsNotifyUrlConfigResponse
     */
    public function setLiveStreamsNotifyUrlConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->exceptionNotifyUrl) {
            @$query['ExceptionNotifyUrl'] = $request->exceptionNotifyUrl;
        }

        if (null !== $request->notifyAuthKey) {
            @$query['NotifyAuthKey'] = $request->notifyAuthKey;
        }

        if (null !== $request->notifyReqAuth) {
            @$query['NotifyReqAuth'] = $request->notifyReqAuth;
        }

        if (null !== $request->notifyUrl) {
            @$query['NotifyUrl'] = $request->notifyUrl;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->switchNotifyUrl) {
            @$query['SwitchNotifyUrl'] = $request->switchNotifyUrl;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SetLiveStreamsNotifyUrlConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetLiveStreamsNotifyUrlConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures stream ingest callbacks under an ingest domain.
     *
     * @remarks
     *   You can call this operation to configure the callback URL and authentication information of an ingest domain.
     * *   If you configure callbacks for stream ingest status, you can receive callback notifications about successful or interrupted stream ingest in a timely manner. For more information, see [Format of stream ingest callbacks](https://help.aliyun.com/document_detail/54787.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - SetLiveStreamsNotifyUrlConfigRequest
     *
     * @returns SetLiveStreamsNotifyUrlConfigResponse
     *
     * @param SetLiveStreamsNotifyUrlConfigRequest $request
     *
     * @return SetLiveStreamsNotifyUrlConfigResponse
     */
    public function setLiveStreamsNotifyUrlConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setLiveStreamsNotifyUrlConfigWithOptions($request, $runtime);
    }

    /**
     * Configures the background of the episode list.
     *
     * @remarks
     *   Create a production studio in playlist mode, and then call this operation to add the background material. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
     * *   You can call this operation to create, update, or delete the background of the episode list. To delete the background, leave the ResourceType, ResourceUrl, and MaterialId parameters empty.
     * >
     * *   When you select media resources from ApsaraVideo VOD, we recommend that you select resources that are stored in hosted OSS buckets. Resources stored in non-hosted OSS buckets have a validity period. Pay attention to the validity if you select resources that are stored in non-hosted OSS buckets.
     * *   When you add media resources to a production studio, we recommend that you select resources from ApsaraVideo Live and ApsaraVideo VOD. If you add a third-party stream by specifying a streaming URL, there is a possibility that the stream fails to be played. You must pay attention to the quality and validity of the third-party stream.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - SetShowListBackgroundRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetShowListBackgroundResponse
     *
     * @param SetShowListBackgroundRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return SetShowListBackgroundResponse
     */
    public function setShowListBackgroundWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->materialId) {
            @$query['MaterialId'] = $request->materialId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        if (null !== $request->resourceUrl) {
            @$query['ResourceUrl'] = $request->resourceUrl;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SetShowListBackground',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetShowListBackgroundResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures the background of the episode list.
     *
     * @remarks
     *   Create a production studio in playlist mode, and then call this operation to add the background material. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
     * *   You can call this operation to create, update, or delete the background of the episode list. To delete the background, leave the ResourceType, ResourceUrl, and MaterialId parameters empty.
     * >
     * *   When you select media resources from ApsaraVideo VOD, we recommend that you select resources that are stored in hosted OSS buckets. Resources stored in non-hosted OSS buckets have a validity period. Pay attention to the validity if you select resources that are stored in non-hosted OSS buckets.
     * *   When you add media resources to a production studio, we recommend that you select resources from ApsaraVideo Live and ApsaraVideo VOD. If you add a third-party stream by specifying a streaming URL, there is a possibility that the stream fails to be played. You must pay attention to the quality and validity of the third-party stream.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - SetShowListBackgroundRequest
     *
     * @returns SetShowListBackgroundResponse
     *
     * @param SetShowListBackgroundRequest $request
     *
     * @return SetShowListBackgroundResponse
     */
    public function setShowListBackground($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setShowListBackgroundWithOptions($request, $runtime);
    }

    /**
     * Configures authentication for snapshot callbacks.
     *
     * @remarks
     *   Before you configure authentication for snapshot callbacks, you need to specify the callback URL. For more information, see [AddLiveAppSnapshotConfig](https://help.aliyun.com/document_detail/2847897.html).
     * *   You can call this operation to configure authentication for snapshot callbacks for a main streaming domain. Make sure that the parameter settings meet the requirements.
     * *   ApsaraVideo Live allows you to add a specific signature header to each HTTP or HTTPS callback request. This way, the server that receives callback messages can authenticate the signature to prevent illegal or invalid requests. For more information, see [Usage notes for callback authentication](https://help.aliyun.com/document_detail/417349.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - SetSnapshotCallbackAuthRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetSnapshotCallbackAuthResponse
     *
     * @param SetSnapshotCallbackAuthRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return SetSnapshotCallbackAuthResponse
     */
    public function setSnapshotCallbackAuthWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->callbackAuthKey) {
            @$query['CallbackAuthKey'] = $request->callbackAuthKey;
        }

        if (null !== $request->callbackReqAuth) {
            @$query['CallbackReqAuth'] = $request->callbackReqAuth;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SetSnapshotCallbackAuth',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetSnapshotCallbackAuthResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures authentication for snapshot callbacks.
     *
     * @remarks
     *   Before you configure authentication for snapshot callbacks, you need to specify the callback URL. For more information, see [AddLiveAppSnapshotConfig](https://help.aliyun.com/document_detail/2847897.html).
     * *   You can call this operation to configure authentication for snapshot callbacks for a main streaming domain. Make sure that the parameter settings meet the requirements.
     * *   ApsaraVideo Live allows you to add a specific signature header to each HTTP or HTTPS callback request. This way, the server that receives callback messages can authenticate the signature to prevent illegal or invalid requests. For more information, see [Usage notes for callback authentication](https://help.aliyun.com/document_detail/417349.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - SetSnapshotCallbackAuthRequest
     *
     * @returns SetSnapshotCallbackAuthResponse
     *
     * @param SetSnapshotCallbackAuthRequest $request
     *
     * @return SetSnapshotCallbackAuthResponse
     */
    public function setSnapshotCallbackAuth($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setSnapshotCallbackAuthWithOptions($request, $runtime);
    }

    /**
     * Starts a production studio. If the production studio does not have a PVW scene or a PGM scene, this operation creates and starts such scenes and starts audio and video processing tasks.
     *
     * @remarks
     * You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to start the production studio. If the production studio does not have a PVW scene or a PGM scene, this operation creates and starts such scenes and starts audio and video processing tasks.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - StartCasterRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StartCasterResponse
     *
     * @param StartCasterRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return StartCasterResponse
     */
    public function startCasterWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StartCaster',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StartCasterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Starts a production studio. If the production studio does not have a PVW scene or a PGM scene, this operation creates and starts such scenes and starts audio and video processing tasks.
     *
     * @remarks
     * You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to start the production studio. If the production studio does not have a PVW scene or a PGM scene, this operation creates and starts such scenes and starts audio and video processing tasks.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - StartCasterRequest
     *
     * @returns StartCasterResponse
     *
     * @param StartCasterRequest $request
     *
     * @return StartCasterResponse
     */
    public function startCaster($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startCasterWithOptions($request, $runtime);
    }

    /**
     * Starts a specified preview (PVW) scene.
     *
     * @remarks
     * You can call this operation to start a specified PVW scene.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - StartCasterSceneRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StartCasterSceneResponse
     *
     * @param StartCasterSceneRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return StartCasterSceneResponse
     */
    public function startCasterSceneWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->sceneId) {
            @$query['SceneId'] = $request->sceneId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StartCasterScene',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StartCasterSceneResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Starts a specified preview (PVW) scene.
     *
     * @remarks
     * You can call this operation to start a specified PVW scene.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - StartCasterSceneRequest
     *
     * @returns StartCasterSceneResponse
     *
     * @param StartCasterSceneRequest $request
     *
     * @return StartCasterSceneResponse
     */
    public function startCasterScene($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startCasterSceneWithOptions($request, $runtime);
    }

    /**
     * Starts an edge transcoding task.
     *
     * @remarks
     *   You can call this operation to start an edge transcoding task.
     * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature and the edge transcoding task that you specify is not started.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - StartEdgeTranscodeJobRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StartEdgeTranscodeJobResponse
     *
     * @param StartEdgeTranscodeJobRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return StartEdgeTranscodeJobResponse
     */
    public function startEdgeTranscodeJobWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->jobId) {
            @$query['JobId'] = $request->jobId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StartEdgeTranscodeJob',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StartEdgeTranscodeJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Starts an edge transcoding task.
     *
     * @remarks
     *   You can call this operation to start an edge transcoding task.
     * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature and the edge transcoding task that you specify is not started.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - StartEdgeTranscodeJobRequest
     *
     * @returns StartEdgeTranscodeJobResponse
     *
     * @param StartEdgeTranscodeJobRequest $request
     *
     * @return StartEdgeTranscodeJobResponse
     */
    public function startEdgeTranscodeJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startEdgeTranscodeJobWithOptions($request, $runtime);
    }

    /**
     * Enables a disabled domain name. After the domain name is enabled, its status changes to online.
     *
     * @remarks
     * This operation does not work if the Alibaba Cloud account to which the domain name belongs has overdue payments or the domain name is invalid.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - StartLiveDomainRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StartLiveDomainResponse
     *
     * @param StartLiveDomainRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return StartLiveDomainResponse
     */
    public function startLiveDomainWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StartLiveDomain',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StartLiveDomainResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables a disabled domain name. After the domain name is enabled, its status changes to online.
     *
     * @remarks
     * This operation does not work if the Alibaba Cloud account to which the domain name belongs has overdue payments or the domain name is invalid.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - StartLiveDomainRequest
     *
     * @returns StartLiveDomainResponse
     *
     * @param StartLiveDomainRequest $request
     *
     * @return StartLiveDomainResponse
     */
    public function startLiveDomain($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startLiveDomainWithOptions($request, $runtime);
    }

    /**
     * Creates a mixed-stream relay task.
     *
     * @remarks
     * By default, you can create up to 200 single-stream relay tasks and up to 40 mixed-stream relay tasks for an application. To increase the quota, [submit a ticket](https://smartservice.console.aliyun.com/service/create-ticket).
     * ### [](#)Lifecycle of a stream relay task
     * **Start**
     * *   Call the StartLiveMPUTask operation to create a task.
     *     *   If no user joins the channel, an error indicating that the channel does not exist is returned.
     *     *   Stream relay is not performed if no stream is ingested. In this case, no relayed stream is available for playback.
     *     *   If the task is in the mixed-stream relay mode, make sure that at least one user is ingesting a stream, which can be relayed for playback. A black screen is displayed in the pane of a user who is not ingesting a stream.
     * *   We recommend that you record the task status, task mode, and task parameters on your business server.
     *     *   Task status: started or stopped.
     *     *   Task mode: single-stream relay or mixed-stream relay.
     *     *   Task parameters: the latest input parameters. For example, after your call of the UpdateLiveMPUTask operation is successful, record the task parameters, which are the latest.
     * *   In co-streaming or battle scenarios, the task is in the mixed-stream relay mode. If the streamer leaves the channel due to exceptions and re-joins the channel, you can directly call the StartLiveMPUTask operation on your business server to start stream relay based on the recorded task parameters.
     *     *   If the task has not been automatically cleared by the system, the task is directly started.
     *     *   If the task has not been automatically cleared by the system, a message indicating that **the task already exists** is returned.
     * **End**
     * *   After the streamer leaves the channel, you need to call the [StopLiveMPUTask](https://help.aliyun.com/document_detail/2362742.html) operation to stop the task.
     * *   If all users specified in the task have left the channel, but you do not call the StopLiveMPUTask operation, the system stops the task in 2 minutes.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 500 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param tmpReq - StartLiveMPUTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StartLiveMPUTaskResponse
     *
     * @param StartLiveMPUTaskRequest $tmpReq
     * @param RuntimeOptions          $runtime
     *
     * @return StartLiveMPUTaskResponse
     */
    public function startLiveMPUTaskWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new StartLiveMPUTaskShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->multiStreamURL) {
            $request->multiStreamURLShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->multiStreamURL, 'MultiStreamURL', 'json');
        }

        if (null !== $tmpReq->seiParams) {
            $request->seiParamsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->seiParams, 'SeiParams', 'json');
        }

        if (null !== $tmpReq->singleSubParams) {
            $request->singleSubParamsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->singleSubParams, 'SingleSubParams', 'json');
        }

        if (null !== $tmpReq->transcodeParams) {
            $request->transcodeParamsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->transcodeParams, 'TranscodeParams', 'json');
        }

        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->channelId) {
            @$query['ChannelId'] = $request->channelId;
        }

        if (null !== $request->maxIdleTime) {
            @$query['MaxIdleTime'] = $request->maxIdleTime;
        }

        if (null !== $request->mixMode) {
            @$query['MixMode'] = $request->mixMode;
        }

        if (null !== $request->multiStreamURLShrink) {
            @$query['MultiStreamURL'] = $request->multiStreamURLShrink;
        }

        if (null !== $request->region) {
            @$query['Region'] = $request->region;
        }

        if (null !== $request->seiParamsShrink) {
            @$query['SeiParams'] = $request->seiParamsShrink;
        }

        if (null !== $request->singleSubParamsShrink) {
            @$query['SingleSubParams'] = $request->singleSubParamsShrink;
        }

        if (null !== $request->streamURL) {
            @$query['StreamURL'] = $request->streamURL;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        if (null !== $request->transcodeParamsShrink) {
            @$query['TranscodeParams'] = $request->transcodeParamsShrink;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StartLiveMPUTask',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StartLiveMPUTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a mixed-stream relay task.
     *
     * @remarks
     * By default, you can create up to 200 single-stream relay tasks and up to 40 mixed-stream relay tasks for an application. To increase the quota, [submit a ticket](https://smartservice.console.aliyun.com/service/create-ticket).
     * ### [](#)Lifecycle of a stream relay task
     * **Start**
     * *   Call the StartLiveMPUTask operation to create a task.
     *     *   If no user joins the channel, an error indicating that the channel does not exist is returned.
     *     *   Stream relay is not performed if no stream is ingested. In this case, no relayed stream is available for playback.
     *     *   If the task is in the mixed-stream relay mode, make sure that at least one user is ingesting a stream, which can be relayed for playback. A black screen is displayed in the pane of a user who is not ingesting a stream.
     * *   We recommend that you record the task status, task mode, and task parameters on your business server.
     *     *   Task status: started or stopped.
     *     *   Task mode: single-stream relay or mixed-stream relay.
     *     *   Task parameters: the latest input parameters. For example, after your call of the UpdateLiveMPUTask operation is successful, record the task parameters, which are the latest.
     * *   In co-streaming or battle scenarios, the task is in the mixed-stream relay mode. If the streamer leaves the channel due to exceptions and re-joins the channel, you can directly call the StartLiveMPUTask operation on your business server to start stream relay based on the recorded task parameters.
     *     *   If the task has not been automatically cleared by the system, the task is directly started.
     *     *   If the task has not been automatically cleared by the system, a message indicating that **the task already exists** is returned.
     * **End**
     * *   After the streamer leaves the channel, you need to call the [StopLiveMPUTask](https://help.aliyun.com/document_detail/2362742.html) operation to stop the task.
     * *   If all users specified in the task have left the channel, but you do not call the StopLiveMPUTask operation, the system stops the task in 2 minutes.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 500 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - StartLiveMPUTaskRequest
     *
     * @returns StartLiveMPUTaskResponse
     *
     * @param StartLiveMPUTaskRequest $request
     *
     * @return StartLiveMPUTaskResponse
     */
    public function startLiveMPUTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startLiveMPUTaskWithOptions($request, $runtime);
    }

    /**
     * Starts live monitoring.
     *
     * @remarks
     * You can call the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation to create a monitoring session, obtain the value of the response parameter **MonitorId**, and then start live monitoring.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - StartLiveStreamMonitorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StartLiveStreamMonitorResponse
     *
     * @param StartLiveStreamMonitorRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return StartLiveStreamMonitorResponse
     */
    public function startLiveStreamMonitorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->monitorId) {
            @$query['MonitorId'] = $request->monitorId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StartLiveStreamMonitor',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StartLiveStreamMonitorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Starts live monitoring.
     *
     * @remarks
     * You can call the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation to create a monitoring session, obtain the value of the response parameter **MonitorId**, and then start live monitoring.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - StartLiveStreamMonitorRequest
     *
     * @returns StartLiveStreamMonitorResponse
     *
     * @param StartLiveStreamMonitorRequest $request
     *
     * @return StartLiveStreamMonitorResponse
     */
    public function startLiveStreamMonitor($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startLiveStreamMonitorWithOptions($request, $runtime);
    }

    /**
     * Starts playing an episode list.
     *
     * @remarks
     * You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episodes to an episode list and then call this operation to start playing the episode list.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - StartPlaylistRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StartPlaylistResponse
     *
     * @param StartPlaylistRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return StartPlaylistResponse
     */
    public function startPlaylistWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->offset) {
            @$query['Offset'] = $request->offset;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->programId) {
            @$query['ProgramId'] = $request->programId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resumeMode) {
            @$query['ResumeMode'] = $request->resumeMode;
        }

        if (null !== $request->startItemId) {
            @$query['StartItemId'] = $request->startItemId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StartPlaylist',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StartPlaylistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Starts playing an episode list.
     *
     * @remarks
     * You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episodes to an episode list and then call this operation to start playing the episode list.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - StartPlaylistRequest
     *
     * @returns StartPlaylistResponse
     *
     * @param StartPlaylistRequest $request
     *
     * @return StartPlaylistResponse
     */
    public function startPlaylist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startPlaylistWithOptions($request, $runtime);
    }

    /**
     * 启动rtc云端录制任务
     *
     * @param tmpReq - StartRtcCloudRecordingRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StartRtcCloudRecordingResponse
     *
     * @param StartRtcCloudRecordingRequest $tmpReq
     * @param RuntimeOptions                $runtime
     *
     * @return StartRtcCloudRecordingResponse
     */
    public function startRtcCloudRecordingWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new StartRtcCloudRecordingShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->mixLayoutParams) {
            $request->mixLayoutParamsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->mixLayoutParams, 'MixLayoutParams', 'json');
        }

        if (null !== $tmpReq->mixTranscodeParams) {
            $request->mixTranscodeParamsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->mixTranscodeParams, 'MixTranscodeParams', 'json');
        }

        if (null !== $tmpReq->recordParams) {
            $request->recordParamsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->recordParams, 'RecordParams', 'json');
        }

        if (null !== $tmpReq->storageParams) {
            $request->storageParamsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->storageParams, 'StorageParams', 'json');
        }

        if (null !== $tmpReq->subscribeParams) {
            $request->subscribeParamsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->subscribeParams, 'SubscribeParams', 'json');
        }

        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->channelId) {
            @$query['ChannelId'] = $request->channelId;
        }

        if (null !== $request->maxIdleTime) {
            @$query['MaxIdleTime'] = $request->maxIdleTime;
        }

        if (null !== $request->mixLayoutParamsShrink) {
            @$query['MixLayoutParams'] = $request->mixLayoutParamsShrink;
        }

        if (null !== $request->mixTranscodeParamsShrink) {
            @$query['MixTranscodeParams'] = $request->mixTranscodeParamsShrink;
        }

        if (null !== $request->notifyAuthKey) {
            @$query['NotifyAuthKey'] = $request->notifyAuthKey;
        }

        if (null !== $request->notifyUrl) {
            @$query['NotifyUrl'] = $request->notifyUrl;
        }

        if (null !== $request->recordParamsShrink) {
            @$query['RecordParams'] = $request->recordParamsShrink;
        }

        if (null !== $request->storageParamsShrink) {
            @$query['StorageParams'] = $request->storageParamsShrink;
        }

        if (null !== $request->subscribeParamsShrink) {
            @$query['SubscribeParams'] = $request->subscribeParamsShrink;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StartRtcCloudRecording',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StartRtcCloudRecordingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 启动rtc云端录制任务
     *
     * @param request - StartRtcCloudRecordingRequest
     *
     * @returns StartRtcCloudRecordingResponse
     *
     * @param StartRtcCloudRecordingRequest $request
     *
     * @return StartRtcCloudRecordingResponse
     */
    public function startRtcCloudRecording($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startRtcCloudRecordingWithOptions($request, $runtime);
    }

    /**
     * Stops a production studio. This stops the PVW and PGM scenes of the production studio.
     *
     * @remarks
     * You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and call this operation to stop the production studio. When a production studio is stopped, its PVW and PGM scenes are stopped.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - StopCasterRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StopCasterResponse
     *
     * @param StopCasterRequest $request
     * @param RuntimeOptions    $runtime
     *
     * @return StopCasterResponse
     */
    public function stopCasterWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StopCaster',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StopCasterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Stops a production studio. This stops the PVW and PGM scenes of the production studio.
     *
     * @remarks
     * You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and call this operation to stop the production studio. When a production studio is stopped, its PVW and PGM scenes are stopped.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - StopCasterRequest
     *
     * @returns StopCasterResponse
     *
     * @param StopCasterRequest $request
     *
     * @return StopCasterResponse
     */
    public function stopCaster($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopCasterWithOptions($request, $runtime);
    }

    /**
     * Stops a specified preview scene.
     *
     * @remarks
     * ## Usage note
     * This operation is only applicable to the PVW scenes.
     *
     * @param request - StopCasterSceneRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StopCasterSceneResponse
     *
     * @param StopCasterSceneRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return StopCasterSceneResponse
     */
    public function stopCasterSceneWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->sceneId) {
            @$query['SceneId'] = $request->sceneId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StopCasterScene',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StopCasterSceneResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Stops a specified preview scene.
     *
     * @remarks
     * ## Usage note
     * This operation is only applicable to the PVW scenes.
     *
     * @param request - StopCasterSceneRequest
     *
     * @returns StopCasterSceneResponse
     *
     * @param StopCasterSceneRequest $request
     *
     * @return StopCasterSceneResponse
     */
    public function stopCasterScene($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopCasterSceneWithOptions($request, $runtime);
    }

    /**
     * Stops an edge transcoding task.
     *
     * @remarks
     *   You can call this operation to stop an edge transcoding task.
     * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature and the edge transcoding task that you specify is running.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - StopEdgeTranscodeJobRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StopEdgeTranscodeJobResponse
     *
     * @param StopEdgeTranscodeJobRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return StopEdgeTranscodeJobResponse
     */
    public function stopEdgeTranscodeJobWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->jobId) {
            @$query['JobId'] = $request->jobId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StopEdgeTranscodeJob',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StopEdgeTranscodeJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Stops an edge transcoding task.
     *
     * @remarks
     *   You can call this operation to stop an edge transcoding task.
     * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature and the edge transcoding task that you specify is running.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - StopEdgeTranscodeJobRequest
     *
     * @returns StopEdgeTranscodeJobResponse
     *
     * @param StopEdgeTranscodeJobRequest $request
     *
     * @return StopEdgeTranscodeJobResponse
     */
    public function stopEdgeTranscodeJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopEdgeTranscodeJobWithOptions($request, $runtime);
    }

    /**
     * Disables an enabled domain name. After the domain name is disabled, its status changes to offline.
     *
     * @remarks
     * After you disable a domain name, the information about the domain name is retained. ApsaraVideo Live automatically reroutes all requests that are destined for the domain name to the origin.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - StopLiveDomainRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StopLiveDomainResponse
     *
     * @param StopLiveDomainRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return StopLiveDomainResponse
     */
    public function stopLiveDomainWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StopLiveDomain',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StopLiveDomainResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Disables an enabled domain name. After the domain name is disabled, its status changes to offline.
     *
     * @remarks
     * After you disable a domain name, the information about the domain name is retained. ApsaraVideo Live automatically reroutes all requests that are destined for the domain name to the origin.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - StopLiveDomainRequest
     *
     * @returns StopLiveDomainResponse
     *
     * @param StopLiveDomainRequest $request
     *
     * @return StopLiveDomainResponse
     */
    public function stopLiveDomain($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopLiveDomainWithOptions($request, $runtime);
    }

    /**
     * Stops a mixed-stream relay task.
     *
     * @remarks
     *   Make sure that a mixed-stream relay task is started before you call this operation. You can call the [StartLiveMPUTask](https://help.aliyun.com/document_detail/2848199.html) operation to start a mixed-stream relay task.
     * *   If a mixed-stream relay task becomes abnormal, the task is automatically stopped 2 minutes after the last person leaves the channel. In this case, you do not need to call the StopLiveMPUTask operation. If you need to resume a mixed-stream relay task that is stopped, call the [StartLiveMPUTask](https://help.aliyun.com/document_detail/2848199.html) operation again.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 500 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - StopLiveMPUTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StopLiveMPUTaskResponse
     *
     * @param StopLiveMPUTaskRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return StopLiveMPUTaskResponse
     */
    public function stopLiveMPUTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StopLiveMPUTask',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StopLiveMPUTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Stops a mixed-stream relay task.
     *
     * @remarks
     *   Make sure that a mixed-stream relay task is started before you call this operation. You can call the [StartLiveMPUTask](https://help.aliyun.com/document_detail/2848199.html) operation to start a mixed-stream relay task.
     * *   If a mixed-stream relay task becomes abnormal, the task is automatically stopped 2 minutes after the last person leaves the channel. In this case, you do not need to call the StopLiveMPUTask operation. If you need to resume a mixed-stream relay task that is stopped, call the [StartLiveMPUTask](https://help.aliyun.com/document_detail/2848199.html) operation again.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 500 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - StopLiveMPUTaskRequest
     *
     * @returns StopLiveMPUTaskResponse
     *
     * @param StopLiveMPUTaskRequest $request
     *
     * @return StopLiveMPUTaskResponse
     */
    public function stopLiveMPUTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopLiveMPUTaskWithOptions($request, $runtime);
    }

    /**
     * Stops a pulled-stream relay task.
     *
     * @remarks
     *   You can call this operation to stop a pulled-stream relay task.
     * *   You can stop a task that is running (even if the task is in an abnormal retry state). You cannot stop a task that is not running.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - StopLivePullToPushRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StopLivePullToPushResponse
     *
     * @param StopLivePullToPushRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return StopLivePullToPushResponse
     */
    public function stopLivePullToPushWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StopLivePullToPush',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StopLivePullToPushResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Stops a pulled-stream relay task.
     *
     * @remarks
     *   You can call this operation to stop a pulled-stream relay task.
     * *   You can stop a task that is running (even if the task is in an abnormal retry state). You cannot stop a task that is not running.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - StopLivePullToPushRequest
     *
     * @returns StopLivePullToPushResponse
     *
     * @param StopLivePullToPushRequest $request
     *
     * @return StopLivePullToPushResponse
     */
    public function stopLivePullToPush($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopLivePullToPushWithOptions($request, $runtime);
    }

    /**
     * Stops live monitoring.
     *
     * @remarks
     * Before you call this operation to stop live monitoring, make sure that live monitoring is started. You can call the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation to create a monitoring session, obtain the value of the response parameter **MonitorId**, and then start live monitoring.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - StopLiveStreamMonitorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StopLiveStreamMonitorResponse
     *
     * @param StopLiveStreamMonitorRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return StopLiveStreamMonitorResponse
     */
    public function stopLiveStreamMonitorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->monitorId) {
            @$query['MonitorId'] = $request->monitorId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StopLiveStreamMonitor',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StopLiveStreamMonitorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Stops live monitoring.
     *
     * @remarks
     * Before you call this operation to stop live monitoring, make sure that live monitoring is started. You can call the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation to create a monitoring session, obtain the value of the response parameter **MonitorId**, and then start live monitoring.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - StopLiveStreamMonitorRequest
     *
     * @returns StopLiveStreamMonitorResponse
     *
     * @param StopLiveStreamMonitorRequest $request
     *
     * @return StopLiveStreamMonitorResponse
     */
    public function stopLiveStreamMonitor($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopLiveStreamMonitorWithOptions($request, $runtime);
    }

    /**
     * Stops playing an episode list.
     *
     * @remarks
     * You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episodes to an episode list and then call this operation to stop playing the episode list.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - StopPlaylistRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StopPlaylistResponse
     *
     * @param StopPlaylistRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return StopPlaylistResponse
     */
    public function stopPlaylistWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->programId) {
            @$query['ProgramId'] = $request->programId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StopPlaylist',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StopPlaylistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Stops playing an episode list.
     *
     * @remarks
     * You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episodes to an episode list and then call this operation to stop playing the episode list.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - StopPlaylistRequest
     *
     * @returns StopPlaylistResponse
     *
     * @param StopPlaylistRequest $request
     *
     * @return StopPlaylistResponse
     */
    public function stopPlaylist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopPlaylistWithOptions($request, $runtime);
    }

    /**
     * Stops a live subtitle task.
     *
     * @remarks
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - StopRtcAsrTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StopRtcAsrTaskResponse
     *
     * @param StopRtcAsrTaskRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return StopRtcAsrTaskResponse
     */
    public function stopRtcAsrTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StopRtcAsrTask',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StopRtcAsrTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Stops a live subtitle task.
     *
     * @remarks
     * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - StopRtcAsrTaskRequest
     *
     * @returns StopRtcAsrTaskResponse
     *
     * @param StopRtcAsrTaskRequest $request
     *
     * @return StopRtcAsrTaskResponse
     */
    public function stopRtcAsrTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopRtcAsrTaskWithOptions($request, $runtime);
    }

    /**
     * 停止rtc云端录制任务
     *
     * @param request - StopRtcCloudRecordingRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StopRtcCloudRecordingResponse
     *
     * @param StopRtcCloudRecordingRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return StopRtcCloudRecordingResponse
     */
    public function stopRtcCloudRecordingWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StopRtcCloudRecording',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StopRtcCloudRecordingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 停止rtc云端录制任务
     *
     * @param request - StopRtcCloudRecordingRequest
     *
     * @returns StopRtcCloudRecordingResponse
     *
     * @param StopRtcCloudRecordingRequest $request
     *
     * @return StopRtcCloudRecordingResponse
     */
    public function stopRtcCloudRecording($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopRtcCloudRecordingWithOptions($request, $runtime);
    }

    /**
     * The N tags that you want to add for the resource.
     *
     * @remarks
     * The key of the tag. Valid values of N: **1 to 20**.
     *
     * @param request - TagLiveResourcesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns TagLiveResourcesResponse
     *
     * @param TagLiveResourcesRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return TagLiveResourcesResponse
     */
    public function tagLiveResourcesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'TagLiveResources',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return TagLiveResourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * The N tags that you want to add for the resource.
     *
     * @remarks
     * The key of the tag. Valid values of N: **1 to 20**.
     *
     * @param request - TagLiveResourcesRequest
     *
     * @returns TagLiveResourcesResponse
     *
     * @param TagLiveResourcesRequest $request
     *
     * @return TagLiveResourcesResponse
     */
    public function tagLiveResources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->tagLiveResourcesWithOptions($request, $runtime);
    }

    /**
     * @param request - UnTagLiveResourcesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UnTagLiveResourcesResponse
     *
     * @param UnTagLiveResourcesRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return UnTagLiveResourcesResponse
     */
    public function unTagLiveResourcesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->all) {
            @$query['All'] = $request->all;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        if (null !== $request->tagKey) {
            @$query['TagKey'] = $request->tagKey;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UnTagLiveResources',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UnTagLiveResourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param request - UnTagLiveResourcesRequest
     *
     * @returns UnTagLiveResourcesResponse
     *
     * @param UnTagLiveResourcesRequest $request
     *
     * @return UnTagLiveResourcesResponse
     */
    public function unTagLiveResources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->unTagLiveResourcesWithOptions($request, $runtime);
    }

    /**
     * Unmutes a group.
     *
     * @remarks
     *   Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * *   If a user was muted by calling the AddLiveMessageGroupBand operation, the user remains muted even after you call the UnbanLiveMessageGroup operation.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UnbanLiveMessageGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UnbanLiveMessageGroupResponse
     *
     * @param UnbanLiveMessageGroupRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return UnbanLiveMessageGroupResponse
     */
    public function unbanLiveMessageGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->dataCenter) {
            @$query['DataCenter'] = $request->dataCenter;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UnbanLiveMessageGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UnbanLiveMessageGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Unmutes a group.
     *
     * @remarks
     *   Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
     * *   If a user was muted by calling the AddLiveMessageGroupBand operation, the user remains muted even after you call the UnbanLiveMessageGroup operation.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UnbanLiveMessageGroupRequest
     *
     * @returns UnbanLiveMessageGroupResponse
     *
     * @param UnbanLiveMessageGroupRequest $request
     *
     * @return UnbanLiveMessageGroupResponse
     */
    public function unbanLiveMessageGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->unbanLiveMessageGroupWithOptions($request, $runtime);
    }

    /**
     * Changes the resource group to which a production studio belongs.
     *
     * @remarks
     * ## [](#)Usage notes
     * To call this operation to change the resource group to which a production studio belongs, you must have access permissions on the original resource group and the destination resource group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - UpdateCasterResourceGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateCasterResourceGroupResponse
     *
     * @param UpdateCasterResourceGroupRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return UpdateCasterResourceGroupResponse
     */
    public function updateCasterResourceGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->newResourceGroupId) {
            @$query['NewResourceGroupId'] = $request->newResourceGroupId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateCasterResourceGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateCasterResourceGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the resource group to which a production studio belongs.
     *
     * @remarks
     * ## [](#)Usage notes
     * To call this operation to change the resource group to which a production studio belongs, you must have access permissions on the original resource group and the destination resource group.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - UpdateCasterResourceGroupRequest
     *
     * @returns UpdateCasterResourceGroupResponse
     *
     * @param UpdateCasterResourceGroupRequest $request
     *
     * @return UpdateCasterResourceGroupResponse
     */
    public function updateCasterResourceGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateCasterResourceGroupWithOptions($request, $runtime);
    }

    /**
     * Modifies the audio configurations of a scene. This operation also allows you to add an audio configuration or apply an existing audio configuration to a new scene.
     *
     * @remarks
     * You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to modify the audio configurations of a scene in the production studio. This operation supports the audio mixing mode and the audio follows video (AFV) mode.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateCasterSceneAudioRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateCasterSceneAudioResponse
     *
     * @param UpdateCasterSceneAudioRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return UpdateCasterSceneAudioResponse
     */
    public function updateCasterSceneAudioWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->audioLayer) {
            @$query['AudioLayer'] = $request->audioLayer;
        }

        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->followEnable) {
            @$query['FollowEnable'] = $request->followEnable;
        }

        if (null !== $request->mixList) {
            @$query['MixList'] = $request->mixList;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->sceneId) {
            @$query['SceneId'] = $request->sceneId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateCasterSceneAudio',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateCasterSceneAudioResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the audio configurations of a scene. This operation also allows you to add an audio configuration or apply an existing audio configuration to a new scene.
     *
     * @remarks
     * You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to modify the audio configurations of a scene in the production studio. This operation supports the audio mixing mode and the audio follows video (AFV) mode.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateCasterSceneAudioRequest
     *
     * @returns UpdateCasterSceneAudioResponse
     *
     * @param UpdateCasterSceneAudioRequest $request
     *
     * @return UpdateCasterSceneAudioResponse
     */
    public function updateCasterSceneAudio($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateCasterSceneAudioWithOptions($request, $runtime);
    }

    /**
     * Modifies a scene, including the layout, without invalidating the previous configurations. This operation is more efficient than the SetCasterSceneConfig operation.
     *
     * @remarks
     * You can call this operation to modify a scene, including the layout, without invalidating the previous configurations. This operation is more efficient than the SetCasterSceneConfig operation.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateCasterSceneConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateCasterSceneConfigResponse
     *
     * @param UpdateCasterSceneConfigRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return UpdateCasterSceneConfigResponse
     */
    public function updateCasterSceneConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->casterId) {
            @$query['CasterId'] = $request->casterId;
        }

        if (null !== $request->componentId) {
            @$query['ComponentId'] = $request->componentId;
        }

        if (null !== $request->layoutId) {
            @$query['LayoutId'] = $request->layoutId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->sceneId) {
            @$query['SceneId'] = $request->sceneId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateCasterSceneConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateCasterSceneConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies a scene, including the layout, without invalidating the previous configurations. This operation is more efficient than the SetCasterSceneConfig operation.
     *
     * @remarks
     * You can call this operation to modify a scene, including the layout, without invalidating the previous configurations. This operation is more efficient than the SetCasterSceneConfig operation.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateCasterSceneConfigRequest
     *
     * @returns UpdateCasterSceneConfigResponse
     *
     * @param UpdateCasterSceneConfigRequest $request
     *
     * @return UpdateCasterSceneConfigResponse
     */
    public function updateCasterSceneConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateCasterSceneConfigWithOptions($request, $runtime);
    }

    /**
     * Updates a custom transcoding configuration.
     *
     * @remarks
     * This operation supports the following types of custom transcoding templates:
     * *   h264: custom H.264 standard transcoding.
     * *   h264-nbhd: custom H.264 Narrowband HD™ transcoding.
     * *   h265: custom H.265 standard transcoding.
     * *   h265-nbhd: custom H.265 Narrowband HD™ transcoding.
     * *   audio: audio-only transcoding.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account.
     *
     * @param request - UpdateCustomLiveStreamTranscodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateCustomLiveStreamTranscodeResponse
     *
     * @param UpdateCustomLiveStreamTranscodeRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return UpdateCustomLiveStreamTranscodeResponse
     */
    public function updateCustomLiveStreamTranscodeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->app) {
            @$query['App'] = $request->app;
        }

        if (null !== $request->audioBitrate) {
            @$query['AudioBitrate'] = $request->audioBitrate;
        }

        if (null !== $request->audioChannelNum) {
            @$query['AudioChannelNum'] = $request->audioChannelNum;
        }

        if (null !== $request->audioCodec) {
            @$query['AudioCodec'] = $request->audioCodec;
        }

        if (null !== $request->audioProfile) {
            @$query['AudioProfile'] = $request->audioProfile;
        }

        if (null !== $request->audioRate) {
            @$query['AudioRate'] = $request->audioRate;
        }

        if (null !== $request->bitrateWithSource) {
            @$query['BitrateWithSource'] = $request->bitrateWithSource;
        }

        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->encryptParameters) {
            @$query['EncryptParameters'] = $request->encryptParameters;
        }

        if (null !== $request->extWithSource) {
            @$query['ExtWithSource'] = $request->extWithSource;
        }

        if (null !== $request->FPS) {
            @$query['FPS'] = $request->FPS;
        }

        if (null !== $request->fpsWithSource) {
            @$query['FpsWithSource'] = $request->fpsWithSource;
        }

        if (null !== $request->gop) {
            @$query['Gop'] = $request->gop;
        }

        if (null !== $request->height) {
            @$query['Height'] = $request->height;
        }

        if (null !== $request->lazy) {
            @$query['Lazy'] = $request->lazy;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->profile) {
            @$query['Profile'] = $request->profile;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resWithSource) {
            @$query['ResWithSource'] = $request->resWithSource;
        }

        if (null !== $request->template) {
            @$query['Template'] = $request->template;
        }

        if (null !== $request->templateType) {
            @$query['TemplateType'] = $request->templateType;
        }

        if (null !== $request->videoBitrate) {
            @$query['VideoBitrate'] = $request->videoBitrate;
        }

        if (null !== $request->width) {
            @$query['Width'] = $request->width;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateCustomLiveStreamTranscode',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateCustomLiveStreamTranscodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates a custom transcoding configuration.
     *
     * @remarks
     * This operation supports the following types of custom transcoding templates:
     * *   h264: custom H.264 standard transcoding.
     * *   h264-nbhd: custom H.264 Narrowband HD™ transcoding.
     * *   h265: custom H.265 standard transcoding.
     * *   h265-nbhd: custom H.265 Narrowband HD™ transcoding.
     * *   audio: audio-only transcoding.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account.
     *
     * @param request - UpdateCustomLiveStreamTranscodeRequest
     *
     * @returns UpdateCustomLiveStreamTranscodeResponse
     *
     * @param UpdateCustomLiveStreamTranscodeRequest $request
     *
     * @return UpdateCustomLiveStreamTranscodeResponse
     */
    public function updateCustomLiveStreamTranscode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateCustomLiveStreamTranscodeWithOptions($request, $runtime);
    }

    /**
     * Updates an edge transcoding task.
     *
     * @remarks
     *   You can call this operation to update an edge transcoding task.
     * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature and the edge transcoding task that you specify is not started.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateEdgeTranscodeJobRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateEdgeTranscodeJobResponse
     *
     * @param UpdateEdgeTranscodeJobRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return UpdateEdgeTranscodeJobResponse
     */
    public function updateEdgeTranscodeJobWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->jobId) {
            @$query['JobId'] = $request->jobId;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->streamInput) {
            @$query['StreamInput'] = $request->streamInput;
        }

        if (null !== $request->streamOutput) {
            @$query['StreamOutput'] = $request->streamOutput;
        }

        if (null !== $request->templateId) {
            @$query['TemplateId'] = $request->templateId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateEdgeTranscodeJob',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateEdgeTranscodeJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates an edge transcoding task.
     *
     * @remarks
     *   You can call this operation to update an edge transcoding task.
     * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature and the edge transcoding task that you specify is not started.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateEdgeTranscodeJobRequest
     *
     * @returns UpdateEdgeTranscodeJobResponse
     *
     * @param UpdateEdgeTranscodeJobRequest $request
     *
     * @return UpdateEdgeTranscodeJobResponse
     */
    public function updateEdgeTranscodeJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateEdgeTranscodeJobWithOptions($request, $runtime);
    }

    /**
     * Updates a callback that is used to subscribe to channel or user events.
     *
     * @remarks
     *   Before you call this operation, make sure that you have called the [CreateEventSub](https://help.aliyun.com/document_detail/2848209.html) operation to create a callback that is used to subscribe to channel or user events.
     * *   An existing channel that you specify in this operation still uses its original callback configuration. The updated configuration can apply to the channel only if you restart the channel after it is closed for longer than 20 minutes.
     * *   If you only want to update specific parameters, you must also specify the other required parameters with their original values.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateEventSubRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateEventSubResponse
     *
     * @param UpdateEventSubRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return UpdateEventSubResponse
     */
    public function updateEventSubWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->callbackUrl) {
            @$query['CallbackUrl'] = $request->callbackUrl;
        }

        if (null !== $request->channelId) {
            @$query['ChannelId'] = $request->channelId;
        }

        if (null !== $request->events) {
            @$query['Events'] = $request->events;
        }

        if (null !== $request->subscribeId) {
            @$query['SubscribeId'] = $request->subscribeId;
        }

        if (null !== $request->users) {
            @$query['Users'] = $request->users;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateEventSub',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateEventSubResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates a callback that is used to subscribe to channel or user events.
     *
     * @remarks
     *   Before you call this operation, make sure that you have called the [CreateEventSub](https://help.aliyun.com/document_detail/2848209.html) operation to create a callback that is used to subscribe to channel or user events.
     * *   An existing channel that you specify in this operation still uses its original callback configuration. The updated configuration can apply to the channel only if you restart the channel after it is closed for longer than 20 minutes.
     * *   If you only want to update specific parameters, you must also specify the other required parameters with their original values.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateEventSubRequest
     *
     * @returns UpdateEventSubResponse
     *
     * @param UpdateEventSubRequest $request
     *
     * @return UpdateEventSubResponse
     */
    public function updateEventSub($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateEventSubWithOptions($request, $runtime);
    }

    /**
     * Updates a subtitle rule.
     *
     * @remarks
     * You can call this operation to modify the parameters of a specified subtitle rule.
     * >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateLiveAIProduceRulesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateLiveAIProduceRulesResponse
     *
     * @param UpdateLiveAIProduceRulesRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return UpdateLiveAIProduceRulesResponse
     */
    public function updateLiveAIProduceRulesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->app) {
            @$query['App'] = $request->app;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->isLazy) {
            @$query['IsLazy'] = $request->isLazy;
        }

        if (null !== $request->liveTemplate) {
            @$query['LiveTemplate'] = $request->liveTemplate;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->rulesId) {
            @$query['RulesId'] = $request->rulesId;
        }

        if (null !== $request->studioName) {
            @$query['StudioName'] = $request->studioName;
        }

        if (null !== $request->subtitleId) {
            @$query['SubtitleId'] = $request->subtitleId;
        }

        if (null !== $request->subtitleName) {
            @$query['SubtitleName'] = $request->subtitleName;
        }

        if (null !== $request->suffix) {
            @$query['Suffix'] = $request->suffix;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveAIProduceRules',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveAIProduceRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates a subtitle rule.
     *
     * @remarks
     * You can call this operation to modify the parameters of a specified subtitle rule.
     * >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateLiveAIProduceRulesRequest
     *
     * @returns UpdateLiveAIProduceRulesResponse
     *
     * @param UpdateLiveAIProduceRulesRequest $request
     *
     * @return UpdateLiveAIProduceRulesResponse
     */
    public function updateLiveAIProduceRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveAIProduceRulesWithOptions($request, $runtime);
    }

    /**
     * Updates a subtitle template.
     *
     * @param tmpReq - UpdateLiveAISubtitleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateLiveAISubtitleResponse
     *
     * @param UpdateLiveAISubtitleRequest $tmpReq
     * @param RuntimeOptions              $runtime
     *
     * @return UpdateLiveAISubtitleResponse
     */
    public function updateLiveAISubtitleWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new UpdateLiveAISubtitleShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->positionNormalized) {
            $request->positionNormalizedShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->positionNormalized, 'PositionNormalized', 'json');
        }

        $query = [];
        if (null !== $request->bgColor) {
            @$query['BgColor'] = $request->bgColor;
        }

        if (null !== $request->bgWidthNormalized) {
            @$query['BgWidthNormalized'] = $request->bgWidthNormalized;
        }

        if (null !== $request->borderWidthNormalized) {
            @$query['BorderWidthNormalized'] = $request->borderWidthNormalized;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->dstLanguage) {
            @$query['DstLanguage'] = $request->dstLanguage;
        }

        if (null !== $request->fontColor) {
            @$query['FontColor'] = $request->fontColor;
        }

        if (null !== $request->fontName) {
            @$query['FontName'] = $request->fontName;
        }

        if (null !== $request->fontSizeNormalized) {
            @$query['FontSizeNormalized'] = $request->fontSizeNormalized;
        }

        if (null !== $request->height) {
            @$query['Height'] = $request->height;
        }

        if (null !== $request->maxLines) {
            @$query['MaxLines'] = $request->maxLines;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->positionNormalizedShrink) {
            @$query['PositionNormalized'] = $request->positionNormalizedShrink;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->showSourceLan) {
            @$query['ShowSourceLan'] = $request->showSourceLan;
        }

        if (null !== $request->srcLanguage) {
            @$query['SrcLanguage'] = $request->srcLanguage;
        }

        if (null !== $request->subtitleId) {
            @$query['SubtitleId'] = $request->subtitleId;
        }

        if (null !== $request->subtitleName) {
            @$query['SubtitleName'] = $request->subtitleName;
        }

        if (null !== $request->width) {
            @$query['Width'] = $request->width;
        }

        if (null !== $request->wordPerLine) {
            @$query['WordPerLine'] = $request->wordPerLine;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveAISubtitle',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveAISubtitleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates a subtitle template.
     *
     * @param request - UpdateLiveAISubtitleRequest
     *
     * @returns UpdateLiveAISubtitleResponse
     *
     * @param UpdateLiveAISubtitleRequest $request
     *
     * @return UpdateLiveAISubtitleResponse
     */
    public function updateLiveAISubtitle($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveAISubtitleWithOptions($request, $runtime);
    }

    /**
     * Updates a recording configuration for an application. The recordings are stored in Object Storage Service (OSS).
     *
     * @remarks
     * Obtain the main streaming domain, and then call this operation to update a recording configuration.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateLiveAppRecordConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateLiveAppRecordConfigResponse
     *
     * @param UpdateLiveAppRecordConfigRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return UpdateLiveAppRecordConfigResponse
     */
    public function updateLiveAppRecordConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->delayTime) {
            @$query['DelayTime'] = $request->delayTime;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->onDemand) {
            @$query['OnDemand'] = $request->onDemand;
        }

        if (null !== $request->ossEndpoint) {
            @$query['OssEndpoint'] = $request->ossEndpoint;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->recordFormat) {
            @$query['RecordFormat'] = $request->recordFormat;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        if (null !== $request->transcodeRecordFormat) {
            @$query['TranscodeRecordFormat'] = $request->transcodeRecordFormat;
        }

        if (null !== $request->transcodeTemplates) {
            @$query['TranscodeTemplates'] = $request->transcodeTemplates;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveAppRecordConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveAppRecordConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates a recording configuration for an application. The recordings are stored in Object Storage Service (OSS).
     *
     * @remarks
     * Obtain the main streaming domain, and then call this operation to update a recording configuration.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateLiveAppRecordConfigRequest
     *
     * @returns UpdateLiveAppRecordConfigResponse
     *
     * @param UpdateLiveAppRecordConfigRequest $request
     *
     * @return UpdateLiveAppRecordConfigResponse
     */
    public function updateLiveAppRecordConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveAppRecordConfigWithOptions($request, $runtime);
    }

    /**
     * Modifies a snapshot configuration of a streaming domain. The captured snapshots are stored in Object Storage Service (OSS). The modification takes effect after you restart stream ingest.
     *
     * @remarks
     * You can call this operation to modify a snapshot configuration of a streaming domain. The captured snapshots are stored in OSS. The modification takes effect after you restart stream ingest.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateLiveAppSnapshotConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateLiveAppSnapshotConfigResponse
     *
     * @param UpdateLiveAppSnapshotConfigRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return UpdateLiveAppSnapshotConfigResponse
     */
    public function updateLiveAppSnapshotConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->callback) {
            @$query['Callback'] = $request->callback;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ossBucket) {
            @$query['OssBucket'] = $request->ossBucket;
        }

        if (null !== $request->ossEndpoint) {
            @$query['OssEndpoint'] = $request->ossEndpoint;
        }

        if (null !== $request->overwriteOssObject) {
            @$query['OverwriteOssObject'] = $request->overwriteOssObject;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        if (null !== $request->sequenceOssObject) {
            @$query['SequenceOssObject'] = $request->sequenceOssObject;
        }

        if (null !== $request->timeInterval) {
            @$query['TimeInterval'] = $request->timeInterval;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveAppSnapshotConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveAppSnapshotConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies a snapshot configuration of a streaming domain. The captured snapshots are stored in Object Storage Service (OSS). The modification takes effect after you restart stream ingest.
     *
     * @remarks
     * You can call this operation to modify a snapshot configuration of a streaming domain. The captured snapshots are stored in OSS. The modification takes effect after you restart stream ingest.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateLiveAppSnapshotConfigRequest
     *
     * @returns UpdateLiveAppSnapshotConfigResponse
     *
     * @param UpdateLiveAppSnapshotConfigRequest $request
     *
     * @return UpdateLiveAppSnapshotConfigResponse
     */
    public function updateLiveAppSnapshotConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveAppSnapshotConfigWithOptions($request, $runtime);
    }

    /**
     * Modifies an audio moderation configuration.
     *
     * @remarks
     *   Obtain the main streaming domain, and then call this operation to modify an audio moderation configuration.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateLiveAudioAuditConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateLiveAudioAuditConfigResponse
     *
     * @param UpdateLiveAudioAuditConfigRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return UpdateLiveAudioAuditConfigResponse
     */
    public function updateLiveAudioAuditConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->bizType) {
            @$query['BizType'] = $request->bizType;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ossBucket) {
            @$query['OssBucket'] = $request->ossBucket;
        }

        if (null !== $request->ossEndpoint) {
            @$query['OssEndpoint'] = $request->ossEndpoint;
        }

        if (null !== $request->ossObject) {
            @$query['OssObject'] = $request->ossObject;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveAudioAuditConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveAudioAuditConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies an audio moderation configuration.
     *
     * @remarks
     *   Obtain the main streaming domain, and then call this operation to modify an audio moderation configuration.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateLiveAudioAuditConfigRequest
     *
     * @returns UpdateLiveAudioAuditConfigResponse
     *
     * @param UpdateLiveAudioAuditConfigRequest $request
     *
     * @return UpdateLiveAudioAuditConfigResponse
     */
    public function updateLiveAudioAuditConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveAudioAuditConfigWithOptions($request, $runtime);
    }

    /**
     * Modifies the configuration of callbacks for audio moderation results.
     *
     * @param request - UpdateLiveAudioAuditNotifyConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateLiveAudioAuditNotifyConfigResponse
     *
     * @param UpdateLiveAudioAuditNotifyConfigRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return UpdateLiveAudioAuditNotifyConfigResponse
     */
    public function updateLiveAudioAuditNotifyConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->callback) {
            @$query['Callback'] = $request->callback;
        }

        if (null !== $request->callbackTemplate) {
            @$query['CallbackTemplate'] = $request->callbackTemplate;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveAudioAuditNotifyConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveAudioAuditNotifyConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configuration of callbacks for audio moderation results.
     *
     * @param request - UpdateLiveAudioAuditNotifyConfigRequest
     *
     * @returns UpdateLiveAudioAuditNotifyConfigResponse
     *
     * @param UpdateLiveAudioAuditNotifyConfigRequest $request
     *
     * @return UpdateLiveAudioAuditNotifyConfigResponse
     */
    public function updateLiveAudioAuditNotifyConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveAudioAuditNotifyConfigWithOptions($request, $runtime);
    }

    /**
     * Modifies the configurations of live center stream relay.
     *
     * @remarks
     * You can call this operation to modify only the **time-related** parameters, including TransferArgs, StartTime, and EndTime.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateLiveCenterTransferRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateLiveCenterTransferResponse
     *
     * @param UpdateLiveCenterTransferRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return UpdateLiveCenterTransferResponse
     */
    public function updateLiveCenterTransferWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->dstUrl) {
            @$query['DstUrl'] = $request->dstUrl;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        if (null !== $request->transferArgs) {
            @$query['TransferArgs'] = $request->transferArgs;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveCenterTransfer',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveCenterTransferResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configurations of live center stream relay.
     *
     * @remarks
     * You can call this operation to modify only the **time-related** parameters, including TransferArgs, StartTime, and EndTime.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateLiveCenterTransferRequest
     *
     * @returns UpdateLiveCenterTransferResponse
     *
     * @param UpdateLiveCenterTransferRequest $request
     *
     * @return UpdateLiveCenterTransferResponse
     */
    public function updateLiveCenterTransfer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveCenterTransferWithOptions($request, $runtime);
    }

    /**
     * Updates a stream delay configuration.
     *
     * @remarks
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - UpdateLiveDelayConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateLiveDelayConfigResponse
     *
     * @param UpdateLiveDelayConfigRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return UpdateLiveDelayConfigResponse
     */
    public function updateLiveDelayConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->app) {
            @$query['App'] = $request->app;
        }

        if (null !== $request->delayTime) {
            @$query['DelayTime'] = $request->delayTime;
        }

        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->stream) {
            @$query['Stream'] = $request->stream;
        }

        if (null !== $request->taskTriggerMode) {
            @$query['TaskTriggerMode'] = $request->taskTriggerMode;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveDelayConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveDelayConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates a stream delay configuration.
     *
     * @remarks
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - UpdateLiveDelayConfigRequest
     *
     * @returns UpdateLiveDelayConfigResponse
     *
     * @param UpdateLiveDelayConfigRequest $request
     *
     * @return UpdateLiveDelayConfigResponse
     */
    public function updateLiveDelayConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveDelayConfigWithOptions($request, $runtime);
    }

    /**
     * Modifies the configuration of callbacks for video moderation results. As a result, the callback URL that is used to receive the callback notifications is changed.
     *
     * @remarks
     *   Obtain the main streaming domain, and then call this operation to modify the configuration of callbacks for video moderation results.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateLiveDetectNotifyConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateLiveDetectNotifyConfigResponse
     *
     * @param UpdateLiveDetectNotifyConfigRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return UpdateLiveDetectNotifyConfigResponse
     */
    public function updateLiveDetectNotifyConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->notifyUrl) {
            @$query['NotifyUrl'] = $request->notifyUrl;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveDetectNotifyConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveDetectNotifyConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configuration of callbacks for video moderation results. As a result, the callback URL that is used to receive the callback notifications is changed.
     *
     * @remarks
     *   Obtain the main streaming domain, and then call this operation to modify the configuration of callbacks for video moderation results.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateLiveDetectNotifyConfigRequest
     *
     * @returns UpdateLiveDetectNotifyConfigResponse
     *
     * @param UpdateLiveDetectNotifyConfigRequest $request
     *
     * @return UpdateLiveDetectNotifyConfigResponse
     */
    public function updateLiveDetectNotifyConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveDetectNotifyConfigWithOptions($request, $runtime);
    }

    /**
     * Updates a mixed-stream relay task.
     *
     * @remarks
     * Make sure that a mixed-stream relay task is created before you call this operation. You can call the [StartLiveMPUTask](https://help.aliyun.com/document_detail/2848199.html) operation to create a mixed-stream relay task.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 500 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param tmpReq - UpdateLiveMPUTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateLiveMPUTaskResponse
     *
     * @param UpdateLiveMPUTaskRequest $tmpReq
     * @param RuntimeOptions           $runtime
     *
     * @return UpdateLiveMPUTaskResponse
     */
    public function updateLiveMPUTaskWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new UpdateLiveMPUTaskShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->multiStreamURL) {
            $request->multiStreamURLShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->multiStreamURL, 'MultiStreamURL', 'json');
        }

        if (null !== $tmpReq->seiParams) {
            $request->seiParamsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->seiParams, 'SeiParams', 'json');
        }

        if (null !== $tmpReq->singleSubParams) {
            $request->singleSubParamsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->singleSubParams, 'SingleSubParams', 'json');
        }

        if (null !== $tmpReq->transcodeParams) {
            $request->transcodeParamsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->transcodeParams, 'TranscodeParams', 'json');
        }

        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->channelId) {
            @$query['ChannelId'] = $request->channelId;
        }

        if (null !== $request->mixMode) {
            @$query['MixMode'] = $request->mixMode;
        }

        if (null !== $request->multiStreamURLShrink) {
            @$query['MultiStreamURL'] = $request->multiStreamURLShrink;
        }

        if (null !== $request->seiParamsShrink) {
            @$query['SeiParams'] = $request->seiParamsShrink;
        }

        if (null !== $request->singleSubParamsShrink) {
            @$query['SingleSubParams'] = $request->singleSubParamsShrink;
        }

        if (null !== $request->streamURL) {
            @$query['StreamURL'] = $request->streamURL;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        if (null !== $request->transcodeParamsShrink) {
            @$query['TranscodeParams'] = $request->transcodeParamsShrink;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveMPUTask',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveMPUTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates a mixed-stream relay task.
     *
     * @remarks
     * Make sure that a mixed-stream relay task is created before you call this operation. You can call the [StartLiveMPUTask](https://help.aliyun.com/document_detail/2848199.html) operation to create a mixed-stream relay task.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 500 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateLiveMPUTaskRequest
     *
     * @returns UpdateLiveMPUTaskResponse
     *
     * @param UpdateLiveMPUTaskRequest $request
     *
     * @return UpdateLiveMPUTaskResponse
     */
    public function updateLiveMPUTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveMPUTaskWithOptions($request, $runtime);
    }

    /**
     * Updates a live stream encapsulation configuration.
     *
     * @remarks
     * You can call this operation to update a live stream encapsulation configuration. The update takes effect only after you re-ingest the stream.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateLivePackageConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateLivePackageConfigResponse
     *
     * @param UpdateLivePackageConfigRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return UpdateLivePackageConfigResponse
     */
    public function updateLivePackageConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ignoreTranscode) {
            @$query['IgnoreTranscode'] = $request->ignoreTranscode;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->partDuration) {
            @$query['PartDuration'] = $request->partDuration;
        }

        if (null !== $request->protocol) {
            @$query['Protocol'] = $request->protocol;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->segmentDuration) {
            @$query['SegmentDuration'] = $request->segmentDuration;
        }

        if (null !== $request->segmentNum) {
            @$query['SegmentNum'] = $request->segmentNum;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLivePackageConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLivePackageConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates a live stream encapsulation configuration.
     *
     * @remarks
     * You can call this operation to update a live stream encapsulation configuration. The update takes effect only after you re-ingest the stream.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateLivePackageConfigRequest
     *
     * @returns UpdateLivePackageConfigResponse
     *
     * @param UpdateLivePackageConfigRequest $request
     *
     * @return UpdateLivePackageConfigResponse
     */
    public function updateLivePackageConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLivePackageConfigWithOptions($request, $runtime);
    }

    /**
     * Modifies the stream pulling settings of a live stream, including the origin URL, start time, and end time.
     *
     * @remarks
     * This operation is applicable to regular stream pulling. You can call this operation to modify the stream pulling settings of a live stream, including the origin URL, start time, and end time.
     * >  After this operation is complete, ApsaraVideo Live uses the updated settings for regular stream pulling. Make sure that the modification does not affect your business.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateLivePullStreamInfoConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateLivePullStreamInfoConfigResponse
     *
     * @param UpdateLivePullStreamInfoConfigRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return UpdateLivePullStreamInfoConfigResponse
     */
    public function updateLivePullStreamInfoConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLivePullStreamInfoConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLivePullStreamInfoConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the stream pulling settings of a live stream, including the origin URL, start time, and end time.
     *
     * @remarks
     * This operation is applicable to regular stream pulling. You can call this operation to modify the stream pulling settings of a live stream, including the origin URL, start time, and end time.
     * >  After this operation is complete, ApsaraVideo Live uses the updated settings for regular stream pulling. Make sure that the modification does not affect your business.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateLivePullStreamInfoConfigRequest
     *
     * @returns UpdateLivePullStreamInfoConfigResponse
     *
     * @param UpdateLivePullStreamInfoConfigRequest $request
     *
     * @return UpdateLivePullStreamInfoConfigResponse
     */
    public function updateLivePullStreamInfoConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLivePullStreamInfoConfigWithOptions($request, $runtime);
    }

    /**
     * Updates a pulled-stream relay task.
     *
     * @remarks
     *   You can call this operation to update a pulled-stream relay task.
     * *   As long as the specified start time of a task has not been reached, you can modify the SourceType, Region, and DstUrl parameters of the task.
     * *   If a task is running (even if the task is in an abnormal retry state), you can modify only the CallbackUrl and RepeatTime parameters of the task. The update takes effect immediately.
     * *   If a task is stopped, you can modify all parameters of the task except SourceType, Region, and DstUrl.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param tmpReq - UpdateLivePullToPushRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateLivePullToPushResponse
     *
     * @param UpdateLivePullToPushRequest $tmpReq
     * @param RuntimeOptions              $runtime
     *
     * @return UpdateLivePullToPushResponse
     */
    public function updateLivePullToPushWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new UpdateLivePullToPushShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->sourceUrls) {
            $request->sourceUrlsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->sourceUrls, 'SourceUrls', 'json');
        }

        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLivePullToPush',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLivePullToPushResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates a pulled-stream relay task.
     *
     * @remarks
     *   You can call this operation to update a pulled-stream relay task.
     * *   As long as the specified start time of a task has not been reached, you can modify the SourceType, Region, and DstUrl parameters of the task.
     * *   If a task is running (even if the task is in an abnormal retry state), you can modify only the CallbackUrl and RepeatTime parameters of the task. The update takes effect immediately.
     * *   If a task is stopped, you can modify all parameters of the task except SourceType, Region, and DstUrl.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateLivePullToPushRequest
     *
     * @returns UpdateLivePullToPushResponse
     *
     * @param UpdateLivePullToPushRequest $request
     *
     * @return UpdateLivePullToPushResponse
     */
    public function updateLivePullToPush($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLivePullToPushWithOptions($request, $runtime);
    }

    /**
     * Modifies the recording callback configuration of a streaming domain.
     *
     * @remarks
     * You can call this operation to modify the following settings:
     * *   The callback URL that is used to receive notifications about recording events and status. For more information, see [Recording event callbacks](https://help.aliyun.com/document_detail/55016.html).
     * *   The callback URL for on-demand recordings. For more information, see [On-demand recording callbacks](https://help.aliyun.com/document_detail/85910.html).
     * *   The setting that specifies whether to enable callbacks for recording status.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateLiveRecordNotifyConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateLiveRecordNotifyConfigResponse
     *
     * @param UpdateLiveRecordNotifyConfigRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return UpdateLiveRecordNotifyConfigResponse
     */
    public function updateLiveRecordNotifyConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->needStatusNotify) {
            @$query['NeedStatusNotify'] = $request->needStatusNotify;
        }

        if (null !== $request->notifyUrl) {
            @$query['NotifyUrl'] = $request->notifyUrl;
        }

        if (null !== $request->onDemandUrl) {
            @$query['OnDemandUrl'] = $request->onDemandUrl;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveRecordNotifyConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveRecordNotifyConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the recording callback configuration of a streaming domain.
     *
     * @remarks
     * You can call this operation to modify the following settings:
     * *   The callback URL that is used to receive notifications about recording events and status. For more information, see [Recording event callbacks](https://help.aliyun.com/document_detail/55016.html).
     * *   The callback URL for on-demand recordings. For more information, see [On-demand recording callbacks](https://help.aliyun.com/document_detail/85910.html).
     * *   The setting that specifies whether to enable callbacks for recording status.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateLiveRecordNotifyConfigRequest
     *
     * @returns UpdateLiveRecordNotifyConfigResponse
     *
     * @param UpdateLiveRecordNotifyConfigRequest $request
     *
     * @return UpdateLiveRecordNotifyConfigResponse
     */
    public function updateLiveRecordNotifyConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveRecordNotifyConfigWithOptions($request, $runtime);
    }

    /**
     * Updates a Live-to-VOD configuration.
     *
     * @remarks
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateLiveRecordVodConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateLiveRecordVodConfigResponse
     *
     * @param UpdateLiveRecordVodConfigRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return UpdateLiveRecordVodConfigResponse
     */
    public function updateLiveRecordVodConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->autoCompose) {
            @$query['AutoCompose'] = $request->autoCompose;
        }

        if (null !== $request->composeVodTranscodeGroupId) {
            @$query['ComposeVodTranscodeGroupId'] = $request->composeVodTranscodeGroupId;
        }

        if (null !== $request->cycleDuration) {
            @$query['CycleDuration'] = $request->cycleDuration;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->onDemand) {
            @$query['OnDemand'] = $request->onDemand;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->streamName) {
            @$query['StreamName'] = $request->streamName;
        }

        if (null !== $request->vodTranscodeGroupId) {
            @$query['VodTranscodeGroupId'] = $request->vodTranscodeGroupId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveRecordVodConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveRecordVodConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates a Live-to-VOD configuration.
     *
     * @remarks
     * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateLiveRecordVodConfigRequest
     *
     * @returns UpdateLiveRecordVodConfigResponse
     *
     * @param UpdateLiveRecordVodConfigRequest $request
     *
     * @return UpdateLiveRecordVodConfigResponse
     */
    public function updateLiveRecordVodConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveRecordVodConfigWithOptions($request, $runtime);
    }

    /**
     * Modifies a video moderation configuration.
     *
     * @remarks
     *   Obtain the main streaming domain, and then call this operation to modify a video moderation configuration.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateLiveSnapshotDetectPornConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateLiveSnapshotDetectPornConfigResponse
     *
     * @param UpdateLiveSnapshotDetectPornConfigRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return UpdateLiveSnapshotDetectPornConfigResponse
     */
    public function updateLiveSnapshotDetectPornConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->interval) {
            @$query['Interval'] = $request->interval;
        }

        if (null !== $request->ossBucket) {
            @$query['OssBucket'] = $request->ossBucket;
        }

        if (null !== $request->ossEndpoint) {
            @$query['OssEndpoint'] = $request->ossEndpoint;
        }

        if (null !== $request->ossObject) {
            @$query['OssObject'] = $request->ossObject;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->scene) {
            @$query['Scene'] = $request->scene;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveSnapshotDetectPornConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveSnapshotDetectPornConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies a video moderation configuration.
     *
     * @remarks
     *   Obtain the main streaming domain, and then call this operation to modify a video moderation configuration.
     * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateLiveSnapshotDetectPornConfigRequest
     *
     * @returns UpdateLiveSnapshotDetectPornConfigResponse
     *
     * @param UpdateLiveSnapshotDetectPornConfigRequest $request
     *
     * @return UpdateLiveSnapshotDetectPornConfigResponse
     */
    public function updateLiveSnapshotDetectPornConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveSnapshotDetectPornConfigWithOptions($request, $runtime);
    }

    /**
     * Modifies the configuration of snapshot callbacks.
     *
     * @remarks
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateLiveSnapshotNotifyConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateLiveSnapshotNotifyConfigResponse
     *
     * @param UpdateLiveSnapshotNotifyConfigRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return UpdateLiveSnapshotNotifyConfigResponse
     */
    public function updateLiveSnapshotNotifyConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->notifyAuthKey) {
            @$query['NotifyAuthKey'] = $request->notifyAuthKey;
        }

        if (null !== $request->notifyReqAuth) {
            @$query['NotifyReqAuth'] = $request->notifyReqAuth;
        }

        if (null !== $request->notifyUrl) {
            @$query['NotifyUrl'] = $request->notifyUrl;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveSnapshotNotifyConfig',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveSnapshotNotifyConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configuration of snapshot callbacks.
     *
     * @remarks
     * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateLiveSnapshotNotifyConfigRequest
     *
     * @returns UpdateLiveSnapshotNotifyConfigResponse
     *
     * @param UpdateLiveSnapshotNotifyConfigRequest $request
     *
     * @return UpdateLiveSnapshotNotifyConfigResponse
     */
    public function updateLiveSnapshotNotifyConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveSnapshotNotifyConfigWithOptions($request, $runtime);
    }

    /**
     * Updates the configurations of a monitoring session.
     *
     * @remarks
     * You can call this operation to update the configurations of a monitoring session. The updates that you make to the input source configurations when the monitoring session is in the Running state immediately take effect.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateLiveStreamMonitorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateLiveStreamMonitorResponse
     *
     * @param UpdateLiveStreamMonitorRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return UpdateLiveStreamMonitorResponse
     */
    public function updateLiveStreamMonitorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->app) {
            @$query['App'] = $request->app;
        }

        if (null !== $request->callbackUrl) {
            @$query['CallbackUrl'] = $request->callbackUrl;
        }

        if (null !== $request->dingTalkWebHookUrl) {
            @$query['DingTalkWebHookUrl'] = $request->dingTalkWebHookUrl;
        }

        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->inputList) {
            @$query['InputList'] = $request->inputList;
        }

        if (null !== $request->monitorConfig) {
            @$query['MonitorConfig'] = $request->monitorConfig;
        }

        if (null !== $request->monitorId) {
            @$query['MonitorId'] = $request->monitorId;
        }

        if (null !== $request->monitorName) {
            @$query['MonitorName'] = $request->monitorName;
        }

        if (null !== $request->outputTemplate) {
            @$query['OutputTemplate'] = $request->outputTemplate;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->stream) {
            @$query['Stream'] = $request->stream;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveStreamMonitor',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveStreamMonitorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates the configurations of a monitoring session.
     *
     * @remarks
     * You can call this operation to update the configurations of a monitoring session. The updates that you make to the input source configurations when the monitoring session is in the Running state immediately take effect.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateLiveStreamMonitorRequest
     *
     * @returns UpdateLiveStreamMonitorResponse
     *
     * @param UpdateLiveStreamMonitorRequest $request
     *
     * @return UpdateLiveStreamMonitorResponse
     */
    public function updateLiveStreamMonitor($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveStreamMonitorWithOptions($request, $runtime);
    }

    /**
     * Updates a default transcoding configuration.
     *
     * @remarks
     * You must obtain the customer master key (CMK) in Key Management Service (KMS) before you call this operation to update a transcoding configuration. Only standard transcoding templates and Narrowband HD™ transcoding templates are supported for this operation.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account.
     *
     * @param request - UpdateLiveStreamTranscodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateLiveStreamTranscodeResponse
     *
     * @param UpdateLiveStreamTranscodeRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return UpdateLiveStreamTranscodeResponse
     */
    public function updateLiveStreamTranscodeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->app) {
            @$query['App'] = $request->app;
        }

        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->encryptParameters) {
            @$query['EncryptParameters'] = $request->encryptParameters;
        }

        if (null !== $request->lazy) {
            @$query['Lazy'] = $request->lazy;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->template) {
            @$query['Template'] = $request->template;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveStreamTranscode',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveStreamTranscodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates a default transcoding configuration.
     *
     * @remarks
     * You must obtain the customer master key (CMK) in Key Management Service (KMS) before you call this operation to update a transcoding configuration. Only standard transcoding templates and Narrowband HD™ transcoding templates are supported for this operation.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 30 times per second per account.
     *
     * @param request - UpdateLiveStreamTranscodeRequest
     *
     * @returns UpdateLiveStreamTranscodeResponse
     *
     * @param UpdateLiveStreamTranscodeRequest $request
     *
     * @return UpdateLiveStreamTranscodeResponse
     */
    public function updateLiveStreamTranscode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveStreamTranscodeWithOptions($request, $runtime);
    }

    /**
     * Updates a watermark template.
     *
     * @remarks
     * This operation allows you to modify the parameters of a watermark template with a specified ID.
     * ## QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
     *
     * @param request - UpdateLiveStreamWatermarkRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateLiveStreamWatermarkResponse
     *
     * @param UpdateLiveStreamWatermarkRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return UpdateLiveStreamWatermarkResponse
     */
    public function updateLiveStreamWatermarkWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->height) {
            @$query['Height'] = $request->height;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->offsetCorner) {
            @$query['OffsetCorner'] = $request->offsetCorner;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pictureUrl) {
            @$query['PictureUrl'] = $request->pictureUrl;
        }

        if (null !== $request->refHeight) {
            @$query['RefHeight'] = $request->refHeight;
        }

        if (null !== $request->refWidth) {
            @$query['RefWidth'] = $request->refWidth;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->templateId) {
            @$query['TemplateId'] = $request->templateId;
        }

        if (null !== $request->transparency) {
            @$query['Transparency'] = $request->transparency;
        }

        if (null !== $request->XOffset) {
            @$query['XOffset'] = $request->XOffset;
        }

        if (null !== $request->YOffset) {
            @$query['YOffset'] = $request->YOffset;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveStreamWatermark',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveStreamWatermarkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates a watermark template.
     *
     * @remarks
     * This operation allows you to modify the parameters of a watermark template with a specified ID.
     * ## QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
     *
     * @param request - UpdateLiveStreamWatermarkRequest
     *
     * @returns UpdateLiveStreamWatermarkResponse
     *
     * @param UpdateLiveStreamWatermarkRequest $request
     *
     * @return UpdateLiveStreamWatermarkResponse
     */
    public function updateLiveStreamWatermark($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveStreamWatermarkWithOptions($request, $runtime);
    }

    /**
     * Updates a watermark rule.
     *
     * @remarks
     * This operation allows you to modify the parameters of a watermark rule with a specified ID.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateLiveStreamWatermarkRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateLiveStreamWatermarkRuleResponse
     *
     * @param UpdateLiveStreamWatermarkRuleRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return UpdateLiveStreamWatermarkRuleResponse
     */
    public function updateLiveStreamWatermarkRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->ruleId) {
            @$query['RuleId'] = $request->ruleId;
        }

        if (null !== $request->templateId) {
            @$query['TemplateId'] = $request->templateId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLiveStreamWatermarkRule',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLiveStreamWatermarkRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates a watermark rule.
     *
     * @remarks
     * This operation allows you to modify the parameters of a watermark rule with a specified ID.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateLiveStreamWatermarkRuleRequest
     *
     * @returns UpdateLiveStreamWatermarkRuleResponse
     *
     * @param UpdateLiveStreamWatermarkRuleRequest $request
     *
     * @return UpdateLiveStreamWatermarkRuleResponse
     */
    public function updateLiveStreamWatermarkRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLiveStreamWatermarkRuleWithOptions($request, $runtime);
    }

    /**
     * Updates the configurations of an interactive message application.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param tmpReq - UpdateMessageAppRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateMessageAppResponse
     *
     * @param UpdateMessageAppRequest $tmpReq
     * @param RuntimeOptions          $runtime
     *
     * @return UpdateMessageAppResponse
     */
    public function updateMessageAppWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new UpdateMessageAppShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->appConfig) {
            $request->appConfigShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->appConfig, 'AppConfig', 'json');
        }

        if (null !== $tmpReq->extension) {
            $request->extensionShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->extension, 'Extension', 'json');
        }

        $body = [];
        if (null !== $request->appConfigShrink) {
            @$body['AppConfig'] = $request->appConfigShrink;
        }

        if (null !== $request->appId) {
            @$body['AppId'] = $request->appId;
        }

        if (null !== $request->appName) {
            @$body['AppName'] = $request->appName;
        }

        if (null !== $request->extensionShrink) {
            @$body['Extension'] = $request->extensionShrink;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'UpdateMessageApp',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateMessageAppResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates the configurations of an interactive message application.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - UpdateMessageAppRequest
     *
     * @returns UpdateMessageAppResponse
     *
     * @param UpdateMessageAppRequest $request
     *
     * @return UpdateMessageAppResponse
     */
    public function updateMessageApp($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateMessageAppWithOptions($request, $runtime);
    }

    /**
     * Updates the information about a message group.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param tmpReq - UpdateMessageGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateMessageGroupResponse
     *
     * @param UpdateMessageGroupRequest $tmpReq
     * @param RuntimeOptions            $runtime
     *
     * @return UpdateMessageGroupResponse
     */
    public function updateMessageGroupWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new UpdateMessageGroupShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->extension) {
            $request->extensionShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->extension, 'Extension', 'json');
        }

        $body = [];
        if (null !== $request->appId) {
            @$body['AppId'] = $request->appId;
        }

        if (null !== $request->extensionShrink) {
            @$body['Extension'] = $request->extensionShrink;
        }

        if (null !== $request->groupId) {
            @$body['GroupId'] = $request->groupId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'UpdateMessageGroup',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateMessageGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates the information about a message group.
     *
     * @remarks
     * ## QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - UpdateMessageGroupRequest
     *
     * @returns UpdateMessageGroupResponse
     *
     * @param UpdateMessageGroupRequest $request
     *
     * @return UpdateMessageGroupResponse
     */
    public function updateMessageGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateMessageGroupWithOptions($request, $runtime);
    }

    /**
     * Updates a stream mixing task.
     *
     * @remarks
     * You can call this operation to update a stream mixing task. This operation allows you to modify the input sources and layout, but not other parameters such as the output resolution.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateMixStreamRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateMixStreamResponse
     *
     * @param UpdateMixStreamRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return UpdateMixStreamResponse
     */
    public function updateMixStreamWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->inputStreamList) {
            @$query['InputStreamList'] = $request->inputStreamList;
        }

        if (null !== $request->layoutId) {
            @$query['LayoutId'] = $request->layoutId;
        }

        if (null !== $request->mixStreamId) {
            @$query['MixStreamId'] = $request->mixStreamId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateMixStream',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateMixStreamResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates a stream mixing task.
     *
     * @remarks
     * You can call this operation to update a stream mixing task. This operation allows you to modify the input sources and layout, but not other parameters such as the output resolution.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateMixStreamRequest
     *
     * @returns UpdateMixStreamResponse
     *
     * @param UpdateMixStreamRequest $request
     *
     * @return UpdateMixStreamResponse
     */
    public function updateMixStream($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateMixStreamWithOptions($request, $runtime);
    }

    /**
     * 更新rtc云端录制任务
     *
     * @param tmpReq - UpdateRtcCloudRecordingRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateRtcCloudRecordingResponse
     *
     * @param UpdateRtcCloudRecordingRequest $tmpReq
     * @param RuntimeOptions                 $runtime
     *
     * @return UpdateRtcCloudRecordingResponse
     */
    public function updateRtcCloudRecordingWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new UpdateRtcCloudRecordingShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->mixLayoutParams) {
            $request->mixLayoutParamsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->mixLayoutParams, 'MixLayoutParams', 'json');
        }

        if (null !== $tmpReq->subscribeParams) {
            $request->subscribeParamsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->subscribeParams, 'SubscribeParams', 'json');
        }

        $query = [];
        if (null !== $request->mixLayoutParamsShrink) {
            @$query['MixLayoutParams'] = $request->mixLayoutParamsShrink;
        }

        if (null !== $request->subscribeParamsShrink) {
            @$query['SubscribeParams'] = $request->subscribeParamsShrink;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateRtcCloudRecording',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateRtcCloudRecordingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 更新rtc云端录制任务
     *
     * @param request - UpdateRtcCloudRecordingRequest
     *
     * @returns UpdateRtcCloudRecordingResponse
     *
     * @param UpdateRtcCloudRecordingRequest $request
     *
     * @return UpdateRtcCloudRecordingResponse
     */
    public function updateRtcCloudRecording($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateRtcCloudRecordingWithOptions($request, $runtime);
    }

    /**
     * Updates a subscription to mixed-stream relay events.
     *
     * @remarks
     *   You can call this operation to update a subscription to mixed-stream relay events. You can modify parameters such as the callback URL and channel IDs.
     * *   Before you call this operation, make sure that you have called the CreateRtcMPUEventSub operation to create the subscription.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateRtcMPUEventSubRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateRtcMPUEventSubResponse
     *
     * @param UpdateRtcMPUEventSubRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return UpdateRtcMPUEventSubResponse
     */
    public function updateRtcMPUEventSubWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->callbackUrl) {
            @$query['CallbackUrl'] = $request->callbackUrl;
        }

        if (null !== $request->channelIds) {
            @$query['ChannelIds'] = $request->channelIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateRtcMPUEventSub',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateRtcMPUEventSubResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates a subscription to mixed-stream relay events.
     *
     * @remarks
     *   You can call this operation to update a subscription to mixed-stream relay events. You can modify parameters such as the callback URL and channel IDs.
     * *   Before you call this operation, make sure that you have called the CreateRtcMPUEventSub operation to create the subscription.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - UpdateRtcMPUEventSubRequest
     *
     * @returns UpdateRtcMPUEventSubResponse
     *
     * @param UpdateRtcMPUEventSubRequest $request
     *
     * @return UpdateRtcMPUEventSubResponse
     */
    public function updateRtcMPUEventSub($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateRtcMPUEventSubWithOptions($request, $runtime);
    }

    /**
     * Updates a custom Real-Time Streaming (RTS) transcoding configuration.
     *
     * @remarks
     * This operation supports the following types of custom transcoding templates: h264, h264-nbhd, h264-origin, and audio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account.
     *
     * @param request - UpdateRtsLiveStreamTranscodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateRtsLiveStreamTranscodeResponse
     *
     * @param UpdateRtsLiveStreamTranscodeRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return UpdateRtsLiveStreamTranscodeResponse
     */
    public function updateRtsLiveStreamTranscodeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->app) {
            @$query['App'] = $request->app;
        }

        if (null !== $request->audioBitrate) {
            @$query['AudioBitrate'] = $request->audioBitrate;
        }

        if (null !== $request->audioChannelNum) {
            @$query['AudioChannelNum'] = $request->audioChannelNum;
        }

        if (null !== $request->audioCodec) {
            @$query['AudioCodec'] = $request->audioCodec;
        }

        if (null !== $request->audioProfile) {
            @$query['AudioProfile'] = $request->audioProfile;
        }

        if (null !== $request->audioRate) {
            @$query['AudioRate'] = $request->audioRate;
        }

        if (null !== $request->deleteBframes) {
            @$query['DeleteBframes'] = $request->deleteBframes;
        }

        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->FPS) {
            @$query['FPS'] = $request->FPS;
        }

        if (null !== $request->gop) {
            @$query['Gop'] = $request->gop;
        }

        if (null !== $request->height) {
            @$query['Height'] = $request->height;
        }

        if (null !== $request->lazy) {
            @$query['Lazy'] = $request->lazy;
        }

        if (null !== $request->opus) {
            @$query['Opus'] = $request->opus;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->profile) {
            @$query['Profile'] = $request->profile;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->template) {
            @$query['Template'] = $request->template;
        }

        if (null !== $request->templateType) {
            @$query['TemplateType'] = $request->templateType;
        }

        if (null !== $request->videoBitrate) {
            @$query['VideoBitrate'] = $request->videoBitrate;
        }

        if (null !== $request->width) {
            @$query['Width'] = $request->width;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateRtsLiveStreamTranscode',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateRtsLiveStreamTranscodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates a custom Real-Time Streaming (RTS) transcoding configuration.
     *
     * @remarks
     * This operation supports the following types of custom transcoding templates: h264, h264-nbhd, h264-origin, and audio.
     * ## [](#qps-)QPS limit
     * You can call this operation up to 10 times per second per account.
     *
     * @param request - UpdateRtsLiveStreamTranscodeRequest
     *
     * @returns UpdateRtsLiveStreamTranscodeResponse
     *
     * @param UpdateRtsLiveStreamTranscodeRequest $request
     *
     * @return UpdateRtsLiveStreamTranscodeResponse
     */
    public function updateRtsLiveStreamTranscode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateRtsLiveStreamTranscodeWithOptions($request, $runtime);
    }

    /**
     * Verifies the ownership of a domain name.
     *
     * @remarks
     * ### [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - VerifyLiveDomainOwnerRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns VerifyLiveDomainOwnerResponse
     *
     * @param VerifyLiveDomainOwnerRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return VerifyLiveDomainOwnerResponse
     */
    public function verifyLiveDomainOwnerWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->verifyType) {
            @$query['VerifyType'] = $request->verifyType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'VerifyLiveDomainOwner',
            'version' => '2016-11-01',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return VerifyLiveDomainOwnerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Verifies the ownership of a domain name.
     *
     * @remarks
     * ### [](#qps-)QPS limit
     * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
     *
     * @param request - VerifyLiveDomainOwnerRequest
     *
     * @returns VerifyLiveDomainOwnerResponse
     *
     * @param VerifyLiveDomainOwnerRequest $request
     *
     * @return VerifyLiveDomainOwnerResponse
     */
    public function verifyLiveDomainOwner($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->verifyLiveDomainOwnerWithOptions($request, $runtime);
    }
}
