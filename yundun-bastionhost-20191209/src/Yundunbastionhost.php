<?php

// This file is auto-generated, don't edit it. Thanks.

namespace AlibabaCloud\SDK\Yundunbastionhost\V20191209;

use AlibabaCloud\Dara\Models\RuntimeOptions;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\AcceptApproveCommandRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\AcceptApproveCommandResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\AcceptOperationTicketRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\AcceptOperationTicketResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\AddDatabasesToGroupRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\AddDatabasesToGroupResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\AddHostsToGroupRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\AddHostsToGroupResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\AddInstanceRdMemberRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\AddInstanceRdMemberResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\AddUsersToGroupRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\AddUsersToGroupResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\AttachDatabaseAccountsToUserGroupRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\AttachDatabaseAccountsToUserGroupResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\AttachDatabaseAccountsToUserRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\AttachDatabaseAccountsToUserResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\AttachHostAccountsToHostShareKeyRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\AttachHostAccountsToHostShareKeyResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\AttachHostAccountsToUserGroupRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\AttachHostAccountsToUserGroupResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\AttachHostAccountsToUserRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\AttachHostAccountsToUserResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\AttachHostGroupAccountsToUserGroupRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\AttachHostGroupAccountsToUserGroupResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\AttachHostGroupAccountsToUserRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\AttachHostGroupAccountsToUserResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ConfigInstanceSecurityGroupsRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ConfigInstanceSecurityGroupsResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ConfigInstanceWhiteListRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ConfigInstanceWhiteListResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\CreateDatabaseAccountRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\CreateDatabaseAccountResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\CreateDatabaseRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\CreateDatabaseResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\CreateExportConfigJobRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\CreateExportConfigJobResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\CreateHostAccountRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\CreateHostAccountResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\CreateHostGroupRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\CreateHostGroupResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\CreateHostRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\CreateHostResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\CreateHostShareKeyRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\CreateHostShareKeyResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\CreateNetworkDomainRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\CreateNetworkDomainResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\CreateOperationTicketRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\CreateOperationTicketResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\CreatePolicyRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\CreatePolicyResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\CreateRuleRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\CreateRuleResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\CreateUserGroupRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\CreateUserGroupResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\CreateUserPublicKeyRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\CreateUserPublicKeyResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\CreateUserRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\CreateUserResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DeleteDatabaseAccountRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DeleteDatabaseAccountResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DeleteDatabaseRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DeleteDatabaseResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DeleteHostAccountRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DeleteHostAccountResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DeleteHostGroupRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DeleteHostGroupResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DeleteHostRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DeleteHostResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DeleteHostShareKeyRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DeleteHostShareKeyResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DeleteNetworkDomainRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DeleteNetworkDomainResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DeletePolicyRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DeletePolicyResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DeleteRuleRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DeleteRuleResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DeleteUserGroupRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DeleteUserGroupResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DeleteUserPublicKeyRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DeleteUserPublicKeyResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DeleteUserRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DeleteUserResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DescribeInstanceAttributeRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DescribeInstanceAttributeResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DescribeInstancesRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DescribeInstancesResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DescribeRegionsRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DescribeRegionsResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DetachDatabaseAccountsFromUserGroupRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DetachDatabaseAccountsFromUserGroupResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DetachDatabaseAccountsFromUserRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DetachDatabaseAccountsFromUserResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DetachHostAccountsFromHostShareKeyRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DetachHostAccountsFromHostShareKeyResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DetachHostAccountsFromUserGroupRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DetachHostAccountsFromUserGroupResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DetachHostAccountsFromUserRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DetachHostAccountsFromUserResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DetachHostGroupAccountsFromUserGroupRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DetachHostGroupAccountsFromUserGroupResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DetachHostGroupAccountsFromUserRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DetachHostGroupAccountsFromUserResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DisableInstancePublicAccessRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DisableInstancePublicAccessResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DisableRuleRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\DisableRuleResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\EnableInstancePublicAccessRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\EnableInstancePublicAccessResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\EnableRuleRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\EnableRuleResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GenerateAssetOperationTokenRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GenerateAssetOperationTokenResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetDatabaseAccountRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetDatabaseAccountResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetDatabaseRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetDatabaseResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetExportConfigJobRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetExportConfigJobResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetHostAccountRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetHostAccountResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetHostGroupRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetHostGroupResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetHostRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetHostResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetHostShareKeyRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetHostShareKeyResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetInstanceADAuthServerRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetInstanceADAuthServerResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetInstanceLDAPAuthServerRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetInstanceLDAPAuthServerResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetInstanceStoreInfoRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetInstanceStoreInfoResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetInstanceTwoFactorRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetInstanceTwoFactorResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetNetworkDomainRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetNetworkDomainResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetPolicyAssetScopeRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetPolicyAssetScopeResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetPolicyRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetPolicyResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetPolicyUserScopeRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetPolicyUserScopeResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetRuleRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetRuleResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetUserGroupRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetUserGroupResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetUserRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\GetUserResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListApproveCommandsRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListApproveCommandsResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListDatabaseAccountsForUserGroupRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListDatabaseAccountsForUserGroupResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListDatabaseAccountsForUserRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListDatabaseAccountsForUserResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListDatabaseAccountsRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListDatabaseAccountsResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListDatabasesForUserGroupRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListDatabasesForUserGroupResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListDatabasesForUserRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListDatabasesForUserResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListDatabasesRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListDatabasesResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListHostAccountsForHostShareKeyRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListHostAccountsForHostShareKeyResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListHostAccountsForUserGroupRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListHostAccountsForUserGroupResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListHostAccountsForUserRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListHostAccountsForUserResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListHostAccountsRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListHostAccountsResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListHostGroupAccountNamesForUserGroupRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListHostGroupAccountNamesForUserGroupResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListHostGroupAccountNamesForUserRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListHostGroupAccountNamesForUserResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListHostGroupsForUserGroupRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListHostGroupsForUserGroupResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListHostGroupsForUserRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListHostGroupsForUserResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListHostGroupsRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListHostGroupsResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListHostsForUserGroupRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListHostsForUserGroupResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListHostsForUserRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListHostsForUserResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListHostShareKeysRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListHostShareKeysResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListHostsRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListHostsResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListInstanceRdMembersRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListInstanceRdMembersResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListNetworkDomainsRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListNetworkDomainsResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListOperationDatabaseAccountsRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListOperationDatabaseAccountsResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListOperationDatabasesRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListOperationDatabasesResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListOperationHostAccountsRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListOperationHostAccountsResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListOperationHostsRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListOperationHostsResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListOperationTicketsRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListOperationTicketsResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListPoliciesRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListPoliciesResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListRulesRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListRulesResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListTagKeysRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListTagKeysResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListTagResourcesRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListTagResourcesResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListUserGroupsRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListUserGroupsResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListUserPublicKeysRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListUserPublicKeysResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListUsersRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ListUsersResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\LockUsersRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\LockUsersResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyDatabaseAccountRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyDatabaseAccountResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyDatabaseRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyDatabaseResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyHostAccountRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyHostAccountResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyHostGroupRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyHostGroupResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyHostRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyHostResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyHostsActiveAddressTypeRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyHostsActiveAddressTypeResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyHostShareKeyRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyHostShareKeyResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyHostsPortRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyHostsPortResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyInstanceADAuthServerRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyInstanceADAuthServerResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyInstanceAttributeRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyInstanceAttributeResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyInstanceLDAPAuthServerRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyInstanceLDAPAuthServerResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyInstanceTwoFactorRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyInstanceTwoFactorResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyNetworkDomainRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyNetworkDomainResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyPolicyRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyPolicyResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyRuleRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyRuleResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyUserGroupRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyUserGroupResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyUserPublicKeyRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyUserPublicKeyResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyUserRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ModifyUserResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\MoveDatabasesToNetworkDomainRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\MoveDatabasesToNetworkDomainResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\MoveHostsToNetworkDomainRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\MoveHostsToNetworkDomainResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\MoveResourceGroupRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\MoveResourceGroupResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\RejectApproveCommandRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\RejectApproveCommandResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\RejectOperationTicketRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\RejectOperationTicketResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\RemoveDatabasesFromGroupRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\RemoveDatabasesFromGroupResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\RemoveHostsFromGroupRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\RemoveHostsFromGroupResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\RemoveInstanceRdMemberRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\RemoveInstanceRdMemberResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\RemoveUsersFromGroupRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\RemoveUsersFromGroupResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\RenewAssetOperationTokenRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\RenewAssetOperationTokenResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ResetHostAccountCredentialRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\ResetHostAccountCredentialResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\SetPolicyAccessTimeRangeConfigRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\SetPolicyAccessTimeRangeConfigResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\SetPolicyAccessTimeRangeConfigShrinkRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\SetPolicyApprovalConfigRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\SetPolicyApprovalConfigResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\SetPolicyApprovalConfigShrinkRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\SetPolicyAssetScopeRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\SetPolicyAssetScopeResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\SetPolicyCommandConfigRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\SetPolicyCommandConfigResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\SetPolicyCommandConfigShrinkRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\SetPolicyIPAclConfigRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\SetPolicyIPAclConfigResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\SetPolicyIPAclConfigShrinkRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\SetPolicyProtocolConfigRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\SetPolicyProtocolConfigResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\SetPolicyProtocolConfigShrinkRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\SetPolicyUserScopeRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\SetPolicyUserScopeResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\StartInstanceRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\StartInstanceResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\TagResourcesRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\TagResourcesResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\UnlockUsersRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\UnlockUsersResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\UntagResourcesRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\UntagResourcesResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\VerifyInstanceADAuthServerRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\VerifyInstanceADAuthServerResponse;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\VerifyInstanceLDAPAuthServerRequest;
use AlibabaCloud\SDK\Yundunbastionhost\V20191209\Models\VerifyInstanceLDAPAuthServerResponse;
use Darabonba\OpenApi\Models\OpenApiRequest;
use Darabonba\OpenApi\Models\Params;
use Darabonba\OpenApi\OpenApiClient;
use Darabonba\OpenApi\Utils;

class Yundunbastionhost extends OpenApiClient
{
    public function __construct($config)
    {
        parent::__construct($config);
        $this->_endpointRule = '';
        $this->checkConfig($config);
        $this->_endpoint = $this->getEndpoint('yundun-bastionhost', $this->_regionId, $this->_endpointRule, $this->_network, $this->_suffix, $this->_endpointMap, $this->_endpoint);
    }

    /**
     * @param string   $productId
     * @param string   $regionId
     * @param string   $endpointRule
     * @param string   $network
     * @param string   $suffix
     * @param string[] $endpointMap
     * @param string   $endpoint
     *
     * @return string
     */
    public function getEndpoint($productId, $regionId, $endpointRule, $network, $suffix, $endpointMap, $endpoint)
    {
        if (null !== $endpoint) {
            return $endpoint;
        }

        if (null !== $endpointMap && null !== @$endpointMap[$regionId]) {
            return @$endpointMap[$regionId];
        }

        return Utils::getEndpointRules($productId, $regionId, $endpointRule, $network, $suffix);
    }

    /**
     * If an O\\&M engineer attempts to run a command specified in the Command Approval field on the Create Control Policy page, the administrator is notified to review the command in the Bastionhost console. The command can be run only after it is approved by the administrator.
     *
     * @remarks
     * You can call this operation as a Bastionhost administrator to approve the request to run a command of an O\\&M engineer.
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - AcceptApproveCommandRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AcceptApproveCommandResponse
     *
     * @param AcceptApproveCommandRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return AcceptApproveCommandResponse
     */
    public function acceptApproveCommandWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->commandId) {
            @$query['CommandId'] = $request->commandId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AcceptApproveCommand',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AcceptApproveCommandResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * If an O\\&M engineer attempts to run a command specified in the Command Approval field on the Create Control Policy page, the administrator is notified to review the command in the Bastionhost console. The command can be run only after it is approved by the administrator.
     *
     * @remarks
     * You can call this operation as a Bastionhost administrator to approve the request to run a command of an O\\&M engineer.
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - AcceptApproveCommandRequest
     *
     * @returns AcceptApproveCommandResponse
     *
     * @param AcceptApproveCommandRequest $request
     *
     * @return AcceptApproveCommandResponse
     */
    public function acceptApproveCommand($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->acceptApproveCommandWithOptions($request, $runtime);
    }

    /**
     * Approves an O\\\\\\\\\\\\&M application.
     *
     * @remarks
     * You can call this operation as a Bastionhost administrator to approve an O\\&M application of an O\\&M engineer.
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - AcceptOperationTicketRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AcceptOperationTicketResponse
     *
     * @param AcceptOperationTicketRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return AcceptOperationTicketResponse
     */
    public function acceptOperationTicketWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->comment) {
            @$query['Comment'] = $request->comment;
        }

        if (null !== $request->effectCount) {
            @$query['EffectCount'] = $request->effectCount;
        }

        if (null !== $request->effectEndTime) {
            @$query['EffectEndTime'] = $request->effectEndTime;
        }

        if (null !== $request->effectStartTime) {
            @$query['EffectStartTime'] = $request->effectStartTime;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->operationTicketId) {
            @$query['OperationTicketId'] = $request->operationTicketId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AcceptOperationTicket',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AcceptOperationTicketResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Approves an O\\\\\\\\\\\\&M application.
     *
     * @remarks
     * You can call this operation as a Bastionhost administrator to approve an O\\&M application of an O\\&M engineer.
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - AcceptOperationTicketRequest
     *
     * @returns AcceptOperationTicketResponse
     *
     * @param AcceptOperationTicketRequest $request
     *
     * @return AcceptOperationTicketResponse
     */
    public function acceptOperationTicket($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->acceptOperationTicketWithOptions($request, $runtime);
    }

    /**
     * Adds multiple databases to a specified asset group.
     *
     * @param request - AddDatabasesToGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddDatabasesToGroupResponse
     *
     * @param AddDatabasesToGroupRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return AddDatabasesToGroupResponse
     */
    public function addDatabasesToGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->databaseIds) {
            @$query['DatabaseIds'] = $request->databaseIds;
        }

        if (null !== $request->hostGroupId) {
            @$query['HostGroupId'] = $request->hostGroupId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddDatabasesToGroup',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddDatabasesToGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds multiple databases to a specified asset group.
     *
     * @param request - AddDatabasesToGroupRequest
     *
     * @returns AddDatabasesToGroupResponse
     *
     * @param AddDatabasesToGroupRequest $request
     *
     * @return AddDatabasesToGroupResponse
     */
    public function addDatabasesToGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addDatabasesToGroupWithOptions($request, $runtime);
    }

    /**
     * Adds one or more hosts to the specified host group.
     *
     * @remarks
     * You can call this operation to add one or more hosts to a host group. You can add multiple hosts to a host group to manage and grant permissions on the hosts in a centralized manner.
     * # Limits
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds a limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limits when you call this operation.
     *
     * @param request - AddHostsToGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddHostsToGroupResponse
     *
     * @param AddHostsToGroupRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return AddHostsToGroupResponse
     */
    public function addHostsToGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostGroupId) {
            @$query['HostGroupId'] = $request->hostGroupId;
        }

        if (null !== $request->hostIds) {
            @$query['HostIds'] = $request->hostIds;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddHostsToGroup',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddHostsToGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds one or more hosts to the specified host group.
     *
     * @remarks
     * You can call this operation to add one or more hosts to a host group. You can add multiple hosts to a host group to manage and grant permissions on the hosts in a centralized manner.
     * # Limits
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds a limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limits when you call this operation.
     *
     * @param request - AddHostsToGroupRequest
     *
     * @returns AddHostsToGroupResponse
     *
     * @param AddHostsToGroupRequest $request
     *
     * @return AddHostsToGroupResponse
     */
    public function addHostsToGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addHostsToGroupWithOptions($request, $runtime);
    }

    /**
     * 添加RD成员账号.
     *
     * @param request - AddInstanceRdMemberRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddInstanceRdMemberResponse
     *
     * @param AddInstanceRdMemberRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return AddInstanceRdMemberResponse
     */
    public function addInstanceRdMemberWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->memberId) {
            @$query['MemberId'] = $request->memberId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddInstanceRdMember',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddInstanceRdMemberResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 添加RD成员账号.
     *
     * @param request - AddInstanceRdMemberRequest
     *
     * @returns AddInstanceRdMemberResponse
     *
     * @param AddInstanceRdMemberRequest $request
     *
     * @return AddInstanceRdMemberResponse
     */
    public function addInstanceRdMember($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addInstanceRdMemberWithOptions($request, $runtime);
    }

    /**
     * Add one or more users to a user group.
     *
     * @remarks
     * #
     * You can call this operation to add one or more users to a user group. After you call the [CreateUserGroup](https://help.aliyun.com/document_detail/204596.html) operation to create a user group, you can call the AddUsersToGroup operation to add multiple users to the user group. Then, you can manage and grant permissions to the users at a time.
     * # Limit
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - AddUsersToGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddUsersToGroupResponse
     *
     * @param AddUsersToGroupRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return AddUsersToGroupResponse
     */
    public function addUsersToGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userGroupId) {
            @$query['UserGroupId'] = $request->userGroupId;
        }

        if (null !== $request->userIds) {
            @$query['UserIds'] = $request->userIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddUsersToGroup',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddUsersToGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Add one or more users to a user group.
     *
     * @remarks
     * #
     * You can call this operation to add one or more users to a user group. After you call the [CreateUserGroup](https://help.aliyun.com/document_detail/204596.html) operation to create a user group, you can call the AddUsersToGroup operation to add multiple users to the user group. Then, you can manage and grant permissions to the users at a time.
     * # Limit
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - AddUsersToGroupRequest
     *
     * @returns AddUsersToGroupResponse
     *
     * @param AddUsersToGroupRequest $request
     *
     * @return AddUsersToGroupResponse
     */
    public function addUsersToGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addUsersToGroupWithOptions($request, $runtime);
    }

    /**
     * Authorizes a user to manage databases and database accounts.
     *
     * @param request - AttachDatabaseAccountsToUserRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AttachDatabaseAccountsToUserResponse
     *
     * @param AttachDatabaseAccountsToUserRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return AttachDatabaseAccountsToUserResponse
     */
    public function attachDatabaseAccountsToUserWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->databases) {
            @$query['Databases'] = $request->databases;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userId) {
            @$query['UserId'] = $request->userId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AttachDatabaseAccountsToUser',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AttachDatabaseAccountsToUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Authorizes a user to manage databases and database accounts.
     *
     * @param request - AttachDatabaseAccountsToUserRequest
     *
     * @returns AttachDatabaseAccountsToUserResponse
     *
     * @param AttachDatabaseAccountsToUserRequest $request
     *
     * @return AttachDatabaseAccountsToUserResponse
     */
    public function attachDatabaseAccountsToUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->attachDatabaseAccountsToUserWithOptions($request, $runtime);
    }

    /**
     * Authorizes a user group to manage databases and database accounts.
     *
     * @param request - AttachDatabaseAccountsToUserGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AttachDatabaseAccountsToUserGroupResponse
     *
     * @param AttachDatabaseAccountsToUserGroupRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return AttachDatabaseAccountsToUserGroupResponse
     */
    public function attachDatabaseAccountsToUserGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->databases) {
            @$query['Databases'] = $request->databases;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userGroupId) {
            @$query['UserGroupId'] = $request->userGroupId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AttachDatabaseAccountsToUserGroup',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AttachDatabaseAccountsToUserGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Authorizes a user group to manage databases and database accounts.
     *
     * @param request - AttachDatabaseAccountsToUserGroupRequest
     *
     * @returns AttachDatabaseAccountsToUserGroupResponse
     *
     * @param AttachDatabaseAccountsToUserGroupRequest $request
     *
     * @return AttachDatabaseAccountsToUserGroupResponse
     */
    public function attachDatabaseAccountsToUserGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->attachDatabaseAccountsToUserGroupWithOptions($request, $runtime);
    }

    /**
     * Associates host accounts with a shared key.
     *
     * @param request - AttachHostAccountsToHostShareKeyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AttachHostAccountsToHostShareKeyResponse
     *
     * @param AttachHostAccountsToHostShareKeyRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return AttachHostAccountsToHostShareKeyResponse
     */
    public function attachHostAccountsToHostShareKeyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostAccountIds) {
            @$query['HostAccountIds'] = $request->hostAccountIds;
        }

        if (null !== $request->hostShareKeyId) {
            @$query['HostShareKeyId'] = $request->hostShareKeyId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AttachHostAccountsToHostShareKey',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AttachHostAccountsToHostShareKeyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Associates host accounts with a shared key.
     *
     * @param request - AttachHostAccountsToHostShareKeyRequest
     *
     * @returns AttachHostAccountsToHostShareKeyResponse
     *
     * @param AttachHostAccountsToHostShareKeyRequest $request
     *
     * @return AttachHostAccountsToHostShareKeyResponse
     */
    public function attachHostAccountsToHostShareKey($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->attachHostAccountsToHostShareKeyWithOptions($request, $runtime);
    }

    /**
     * Authorizes a user to manage the hosts and host accounts.
     *
     * @param request - AttachHostAccountsToUserRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AttachHostAccountsToUserResponse
     *
     * @param AttachHostAccountsToUserRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return AttachHostAccountsToUserResponse
     */
    public function attachHostAccountsToUserWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hosts) {
            @$query['Hosts'] = $request->hosts;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userId) {
            @$query['UserId'] = $request->userId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AttachHostAccountsToUser',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AttachHostAccountsToUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Authorizes a user to manage the hosts and host accounts.
     *
     * @param request - AttachHostAccountsToUserRequest
     *
     * @returns AttachHostAccountsToUserResponse
     *
     * @param AttachHostAccountsToUserRequest $request
     *
     * @return AttachHostAccountsToUserResponse
     */
    public function attachHostAccountsToUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->attachHostAccountsToUserWithOptions($request, $runtime);
    }

    /**
     * Authorizes a user group to manage one or more hosts and host accounts.
     *
     * @remarks
     * After you authorize a user group to manage specific hosts and host accounts, all the users in the user group have access to the authorized hosts and host accounts.
     *
     * @param request - AttachHostAccountsToUserGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AttachHostAccountsToUserGroupResponse
     *
     * @param AttachHostAccountsToUserGroupRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return AttachHostAccountsToUserGroupResponse
     */
    public function attachHostAccountsToUserGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hosts) {
            @$query['Hosts'] = $request->hosts;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userGroupId) {
            @$query['UserGroupId'] = $request->userGroupId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AttachHostAccountsToUserGroup',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AttachHostAccountsToUserGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Authorizes a user group to manage one or more hosts and host accounts.
     *
     * @remarks
     * After you authorize a user group to manage specific hosts and host accounts, all the users in the user group have access to the authorized hosts and host accounts.
     *
     * @param request - AttachHostAccountsToUserGroupRequest
     *
     * @returns AttachHostAccountsToUserGroupResponse
     *
     * @param AttachHostAccountsToUserGroupRequest $request
     *
     * @return AttachHostAccountsToUserGroupResponse
     */
    public function attachHostAccountsToUserGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->attachHostAccountsToUserGroupWithOptions($request, $runtime);
    }

    /**
     * Authorizes a user to manage one or more host groups and host accounts.
     *
     * @param request - AttachHostGroupAccountsToUserRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AttachHostGroupAccountsToUserResponse
     *
     * @param AttachHostGroupAccountsToUserRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return AttachHostGroupAccountsToUserResponse
     */
    public function attachHostGroupAccountsToUserWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostGroups) {
            @$query['HostGroups'] = $request->hostGroups;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userId) {
            @$query['UserId'] = $request->userId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AttachHostGroupAccountsToUser',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AttachHostGroupAccountsToUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Authorizes a user to manage one or more host groups and host accounts.
     *
     * @param request - AttachHostGroupAccountsToUserRequest
     *
     * @returns AttachHostGroupAccountsToUserResponse
     *
     * @param AttachHostGroupAccountsToUserRequest $request
     *
     * @return AttachHostGroupAccountsToUserResponse
     */
    public function attachHostGroupAccountsToUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->attachHostGroupAccountsToUserWithOptions($request, $runtime);
    }

    /**
     * Authorizes a user to manage one or more host groups and host accounts.
     *
     * @param request - AttachHostGroupAccountsToUserGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AttachHostGroupAccountsToUserGroupResponse
     *
     * @param AttachHostGroupAccountsToUserGroupRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return AttachHostGroupAccountsToUserGroupResponse
     */
    public function attachHostGroupAccountsToUserGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostGroups) {
            @$query['HostGroups'] = $request->hostGroups;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userGroupId) {
            @$query['UserGroupId'] = $request->userGroupId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AttachHostGroupAccountsToUserGroup',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AttachHostGroupAccountsToUserGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Authorizes a user to manage one or more host groups and host accounts.
     *
     * @param request - AttachHostGroupAccountsToUserGroupRequest
     *
     * @returns AttachHostGroupAccountsToUserGroupResponse
     *
     * @param AttachHostGroupAccountsToUserGroupRequest $request
     *
     * @return AttachHostGroupAccountsToUserGroupResponse
     */
    public function attachHostGroupAccountsToUserGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->attachHostGroupAccountsToUserGroupWithOptions($request, $runtime);
    }

    /**
     * Configures security groups for a bastion host.
     *
     * @param request - ConfigInstanceSecurityGroupsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ConfigInstanceSecurityGroupsResponse
     *
     * @param ConfigInstanceSecurityGroupsRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return ConfigInstanceSecurityGroupsResponse
     */
    public function configInstanceSecurityGroupsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->authorizedSecurityGroups) {
            @$query['AuthorizedSecurityGroups'] = $request->authorizedSecurityGroups;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ConfigInstanceSecurityGroups',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ConfigInstanceSecurityGroupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures security groups for a bastion host.
     *
     * @param request - ConfigInstanceSecurityGroupsRequest
     *
     * @returns ConfigInstanceSecurityGroupsResponse
     *
     * @param ConfigInstanceSecurityGroupsRequest $request
     *
     * @return ConfigInstanceSecurityGroupsResponse
     */
    public function configInstanceSecurityGroups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->configInstanceSecurityGroupsWithOptions($request, $runtime);
    }

    /**
     * Configures a whitelist of public IP addresses for a bastion host.
     *
     * @remarks
     * ## Usage notes
     * You can call this operation to configure a whitelist of public IP addresses for a bastion host. By default, a bastion host is accessible from all public IP addresses. If you want to allow the requests from specific public IP addresses, you can call this operation to add trusted IP addresses to the whitelist of the bastion host.
     * ## Limits
     * You can call this operation up to 30 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - ConfigInstanceWhiteListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ConfigInstanceWhiteListResponse
     *
     * @param ConfigInstanceWhiteListRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ConfigInstanceWhiteListResponse
     */
    public function configInstanceWhiteListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->whiteList) {
            @$query['WhiteList'] = $request->whiteList;
        }

        if (null !== $request->whiteListPolicies) {
            @$query['WhiteListPolicies'] = $request->whiteListPolicies;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ConfigInstanceWhiteList',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ConfigInstanceWhiteListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures a whitelist of public IP addresses for a bastion host.
     *
     * @remarks
     * ## Usage notes
     * You can call this operation to configure a whitelist of public IP addresses for a bastion host. By default, a bastion host is accessible from all public IP addresses. If you want to allow the requests from specific public IP addresses, you can call this operation to add trusted IP addresses to the whitelist of the bastion host.
     * ## Limits
     * You can call this operation up to 30 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - ConfigInstanceWhiteListRequest
     *
     * @returns ConfigInstanceWhiteListResponse
     *
     * @param ConfigInstanceWhiteListRequest $request
     *
     * @return ConfigInstanceWhiteListResponse
     */
    public function configInstanceWhiteList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->configInstanceWhiteListWithOptions($request, $runtime);
    }

    /**
     * Imports an ApsaraDB RDS for MySQL instance, ApsaraDB RDS for SQL Server instance, ApsaraDB RDS for PostgreSQL instance, PolarDB for MySQL cluster, PolarDB for PostgreSQL cluster, PolarDB for PostgreSQL (Compatible with Oracle) cluster, self-managed MySQL database, self-managed SQL Server database, self-managed PostgreSQL database, or self-managed Oracle database to a bastion host.
     *
     * @param request - CreateDatabaseRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateDatabaseResponse
     *
     * @param CreateDatabaseRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return CreateDatabaseResponse
     */
    public function createDatabaseWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->activeAddressType) {
            @$query['ActiveAddressType'] = $request->activeAddressType;
        }

        if (null !== $request->comment) {
            @$query['Comment'] = $request->comment;
        }

        if (null !== $request->databaseName) {
            @$query['DatabaseName'] = $request->databaseName;
        }

        if (null !== $request->databasePort) {
            @$query['DatabasePort'] = $request->databasePort;
        }

        if (null !== $request->databasePrivateAddress) {
            @$query['DatabasePrivateAddress'] = $request->databasePrivateAddress;
        }

        if (null !== $request->databasePublicAddress) {
            @$query['DatabasePublicAddress'] = $request->databasePublicAddress;
        }

        if (null !== $request->databaseType) {
            @$query['DatabaseType'] = $request->databaseType;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->instanceMemberId) {
            @$query['InstanceMemberId'] = $request->instanceMemberId;
        }

        if (null !== $request->networkDomainId) {
            @$query['NetworkDomainId'] = $request->networkDomainId;
        }

        if (null !== $request->polarDBEndpointType) {
            @$query['PolarDBEndpointType'] = $request->polarDBEndpointType;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        if (null !== $request->sourceInstanceId) {
            @$query['SourceInstanceId'] = $request->sourceInstanceId;
        }

        if (null !== $request->sourceInstanceRegionId) {
            @$query['SourceInstanceRegionId'] = $request->sourceInstanceRegionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateDatabase',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateDatabaseResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Imports an ApsaraDB RDS for MySQL instance, ApsaraDB RDS for SQL Server instance, ApsaraDB RDS for PostgreSQL instance, PolarDB for MySQL cluster, PolarDB for PostgreSQL cluster, PolarDB for PostgreSQL (Compatible with Oracle) cluster, self-managed MySQL database, self-managed SQL Server database, self-managed PostgreSQL database, or self-managed Oracle database to a bastion host.
     *
     * @param request - CreateDatabaseRequest
     *
     * @returns CreateDatabaseResponse
     *
     * @param CreateDatabaseRequest $request
     *
     * @return CreateDatabaseResponse
     */
    public function createDatabase($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDatabaseWithOptions($request, $runtime);
    }

    /**
     * After a database is created, you can create a database account for the database. After the account is created, O\\&M engineers can use the account to log on to and perform O\\&M operations on the database.
     *
     * @param request - CreateDatabaseAccountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateDatabaseAccountResponse
     *
     * @param CreateDatabaseAccountRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return CreateDatabaseAccountResponse
     */
    public function createDatabaseAccountWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->databaseAccountName) {
            @$query['DatabaseAccountName'] = $request->databaseAccountName;
        }

        if (null !== $request->databaseId) {
            @$query['DatabaseId'] = $request->databaseId;
        }

        if (null !== $request->databaseSchema) {
            @$query['DatabaseSchema'] = $request->databaseSchema;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->loginAttribute) {
            @$query['LoginAttribute'] = $request->loginAttribute;
        }

        if (null !== $request->password) {
            @$query['Password'] = $request->password;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateDatabaseAccount',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateDatabaseAccountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * After a database is created, you can create a database account for the database. After the account is created, O\\&M engineers can use the account to log on to and perform O\\&M operations on the database.
     *
     * @param request - CreateDatabaseAccountRequest
     *
     * @returns CreateDatabaseAccountResponse
     *
     * @param CreateDatabaseAccountRequest $request
     *
     * @return CreateDatabaseAccountResponse
     */
    public function createDatabaseAccount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDatabaseAccountWithOptions($request, $runtime);
    }

    /**
     * 创建导出配置的任务
     *
     * @param request - CreateExportConfigJobRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateExportConfigJobResponse
     *
     * @param CreateExportConfigJobRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return CreateExportConfigJobResponse
     */
    public function createExportConfigJobWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateExportConfigJob',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateExportConfigJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 创建导出配置的任务
     *
     * @param request - CreateExportConfigJobRequest
     *
     * @returns CreateExportConfigJobResponse
     *
     * @param CreateExportConfigJobRequest $request
     *
     * @return CreateExportConfigJobResponse
     */
    public function createExportConfigJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createExportConfigJobWithOptions($request, $runtime);
    }

    /**
     * Bastionhost allows you to perform O\\&M operations on hosts from different sources, such as Alibaba Cloud Elastic Compute Service (ECS) instances, servers in on-premises data centers, and servers on other cloud platforms. Before you perform O\\&M operations on hosts by using a bastion host, you must import the hosts to the bastion host. You can call this operation to import a host to a bastion host.
     *
     * @param request - CreateHostRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateHostResponse
     *
     * @param CreateHostRequest $request
     * @param RuntimeOptions    $runtime
     *
     * @return CreateHostResponse
     */
    public function createHostWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->activeAddressType) {
            @$query['ActiveAddressType'] = $request->activeAddressType;
        }

        if (null !== $request->comment) {
            @$query['Comment'] = $request->comment;
        }

        if (null !== $request->hostName) {
            @$query['HostName'] = $request->hostName;
        }

        if (null !== $request->hostPrivateAddress) {
            @$query['HostPrivateAddress'] = $request->hostPrivateAddress;
        }

        if (null !== $request->hostPublicAddress) {
            @$query['HostPublicAddress'] = $request->hostPublicAddress;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->instanceMemberId) {
            @$query['InstanceMemberId'] = $request->instanceMemberId;
        }

        if (null !== $request->instanceRegionId) {
            @$query['InstanceRegionId'] = $request->instanceRegionId;
        }

        if (null !== $request->networkDomainId) {
            @$query['NetworkDomainId'] = $request->networkDomainId;
        }

        if (null !== $request->OSType) {
            @$query['OSType'] = $request->OSType;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        if (null !== $request->sourceInstanceId) {
            @$query['SourceInstanceId'] = $request->sourceInstanceId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateHost',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateHostResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Bastionhost allows you to perform O\\&M operations on hosts from different sources, such as Alibaba Cloud Elastic Compute Service (ECS) instances, servers in on-premises data centers, and servers on other cloud platforms. Before you perform O\\&M operations on hosts by using a bastion host, you must import the hosts to the bastion host. You can call this operation to import a host to a bastion host.
     *
     * @param request - CreateHostRequest
     *
     * @returns CreateHostResponse
     *
     * @param CreateHostRequest $request
     *
     * @return CreateHostResponse
     */
    public function createHost($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createHostWithOptions($request, $runtime);
    }

    /**
     * After you import a host to a bastion host, you must add an account of the host to the bastion host. This way, O\\&M engineers can use the account to log on to and perform O\\&M operations on the host by using the bastion host.
     *
     * @param request - CreateHostAccountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateHostAccountResponse
     *
     * @param CreateHostAccountRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return CreateHostAccountResponse
     */
    public function createHostAccountWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostAccountName) {
            @$query['HostAccountName'] = $request->hostAccountName;
        }

        if (null !== $request->hostId) {
            @$query['HostId'] = $request->hostId;
        }

        if (null !== $request->hostShareKeyId) {
            @$query['HostShareKeyId'] = $request->hostShareKeyId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->passPhrase) {
            @$query['PassPhrase'] = $request->passPhrase;
        }

        if (null !== $request->password) {
            @$query['Password'] = $request->password;
        }

        if (null !== $request->privateKey) {
            @$query['PrivateKey'] = $request->privateKey;
        }

        if (null !== $request->privilegeType) {
            @$query['PrivilegeType'] = $request->privilegeType;
        }

        if (null !== $request->protocolName) {
            @$query['ProtocolName'] = $request->protocolName;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->rotationMode) {
            @$query['RotationMode'] = $request->rotationMode;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateHostAccount',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateHostAccountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * After you import a host to a bastion host, you must add an account of the host to the bastion host. This way, O\\&M engineers can use the account to log on to and perform O\\&M operations on the host by using the bastion host.
     *
     * @param request - CreateHostAccountRequest
     *
     * @returns CreateHostAccountResponse
     *
     * @param CreateHostAccountRequest $request
     *
     * @return CreateHostAccountResponse
     */
    public function createHostAccount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createHostAccountWithOptions($request, $runtime);
    }

    /**
     * You can create asset groups based on your business requirements and add assets of the same type to an asset group. This allows you to classify assets and manage multiple assets at a time.
     *
     * @param request - CreateHostGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateHostGroupResponse
     *
     * @param CreateHostGroupRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return CreateHostGroupResponse
     */
    public function createHostGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->comment) {
            @$query['Comment'] = $request->comment;
        }

        if (null !== $request->hostGroupName) {
            @$query['HostGroupName'] = $request->hostGroupName;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateHostGroup',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateHostGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * You can create asset groups based on your business requirements and add assets of the same type to an asset group. This allows you to classify assets and manage multiple assets at a time.
     *
     * @param request - CreateHostGroupRequest
     *
     * @returns CreateHostGroupResponse
     *
     * @param CreateHostGroupRequest $request
     *
     * @return CreateHostGroupResponse
     */
    public function createHostGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createHostGroupWithOptions($request, $runtime);
    }

    /**
     * Bastionhost provides the shared key feature. This feature allows you to manage the private key that is used to log on to a host in a bastion host. This way, you can associate the private key with multiple accounts of the host to make host account management more efficient.
     *
     * @param request - CreateHostShareKeyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateHostShareKeyResponse
     *
     * @param CreateHostShareKeyRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return CreateHostShareKeyResponse
     */
    public function createHostShareKeyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostShareKeyName) {
            @$query['HostShareKeyName'] = $request->hostShareKeyName;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->passPhrase) {
            @$query['PassPhrase'] = $request->passPhrase;
        }

        if (null !== $request->privateKey) {
            @$query['PrivateKey'] = $request->privateKey;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateHostShareKey',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateHostShareKeyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Bastionhost provides the shared key feature. This feature allows you to manage the private key that is used to log on to a host in a bastion host. This way, you can associate the private key with multiple accounts of the host to make host account management more efficient.
     *
     * @param request - CreateHostShareKeyRequest
     *
     * @returns CreateHostShareKeyResponse
     *
     * @param CreateHostShareKeyRequest $request
     *
     * @return CreateHostShareKeyResponse
     */
    public function createHostShareKey($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createHostShareKeyWithOptions($request, $runtime);
    }

    /**
     * Creates a network domain.
     *
     * @param request - CreateNetworkDomainRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateNetworkDomainResponse
     *
     * @param CreateNetworkDomainRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return CreateNetworkDomainResponse
     */
    public function createNetworkDomainWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->comment) {
            @$query['Comment'] = $request->comment;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->networkDomainName) {
            @$query['NetworkDomainName'] = $request->networkDomainName;
        }

        if (null !== $request->networkDomainType) {
            @$query['NetworkDomainType'] = $request->networkDomainType;
        }

        if (null !== $request->proxies) {
            @$query['Proxies'] = $request->proxies;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateNetworkDomain',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateNetworkDomainResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a network domain.
     *
     * @param request - CreateNetworkDomainRequest
     *
     * @returns CreateNetworkDomainResponse
     *
     * @param CreateNetworkDomainRequest $request
     *
     * @return CreateNetworkDomainResponse
     */
    public function createNetworkDomain($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createNetworkDomainWithOptions($request, $runtime);
    }

    /**
     * 创建运维审批工单.
     *
     * @param request - CreateOperationTicketRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateOperationTicketResponse
     *
     * @param CreateOperationTicketRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return CreateOperationTicketResponse
     */
    public function createOperationTicketWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->approveComment) {
            @$query['ApproveComment'] = $request->approveComment;
        }

        if (null !== $request->assetAccountName) {
            @$query['AssetAccountName'] = $request->assetAccountName;
        }

        if (null !== $request->assetId) {
            @$query['AssetId'] = $request->assetId;
        }

        if (null !== $request->effectEndTime) {
            @$query['EffectEndTime'] = $request->effectEndTime;
        }

        if (null !== $request->effectStartTime) {
            @$query['EffectStartTime'] = $request->effectStartTime;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->isOneTimeEffect) {
            @$query['IsOneTimeEffect'] = $request->isOneTimeEffect;
        }

        if (null !== $request->protocolName) {
            @$query['ProtocolName'] = $request->protocolName;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateOperationTicket',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateOperationTicketResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 创建运维审批工单.
     *
     * @param request - CreateOperationTicketRequest
     *
     * @returns CreateOperationTicketResponse
     *
     * @param CreateOperationTicketRequest $request
     *
     * @return CreateOperationTicketResponse
     */
    public function createOperationTicket($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createOperationTicketWithOptions($request, $runtime);
    }

    /**
     * Configures a command control, command approval, protocol control, or access control policy to manage O\\&M operations. This effectively prevents users from performing high-risk operations or accidental operations to ensure O\\&M security.
     *
     * @param request - CreatePolicyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreatePolicyResponse
     *
     * @param CreatePolicyRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return CreatePolicyResponse
     */
    public function createPolicyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->comment) {
            @$query['Comment'] = $request->comment;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->policyName) {
            @$query['PolicyName'] = $request->policyName;
        }

        if (null !== $request->priority) {
            @$query['Priority'] = $request->priority;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreatePolicy',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreatePolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures a command control, command approval, protocol control, or access control policy to manage O\\&M operations. This effectively prevents users from performing high-risk operations or accidental operations to ensure O\\&M security.
     *
     * @param request - CreatePolicyRequest
     *
     * @returns CreatePolicyResponse
     *
     * @param CreatePolicyRequest $request
     *
     * @return CreatePolicyResponse
     */
    public function createPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createPolicyWithOptions($request, $runtime);
    }

    /**
     * You can create authorization rules to authorize multiple users to manage assets. You can also specify a validity period for an authorization rule. This way, you can manage users and assets in a more efficient manner and limit the time periods during which users can access assets.
     *
     * @param request - CreateRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateRuleResponse
     *
     * @param CreateRuleRequest $request
     * @param RuntimeOptions    $runtime
     *
     * @return CreateRuleResponse
     */
    public function createRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->comment) {
            @$query['Comment'] = $request->comment;
        }

        if (null !== $request->databases) {
            @$query['Databases'] = $request->databases;
        }

        if (null !== $request->effectiveEndTime) {
            @$query['EffectiveEndTime'] = $request->effectiveEndTime;
        }

        if (null !== $request->effectiveStartTime) {
            @$query['EffectiveStartTime'] = $request->effectiveStartTime;
        }

        if (null !== $request->hostGroups) {
            @$query['HostGroups'] = $request->hostGroups;
        }

        if (null !== $request->hosts) {
            @$query['Hosts'] = $request->hosts;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->ruleName) {
            @$query['RuleName'] = $request->ruleName;
        }

        if (null !== $request->userGroupIds) {
            @$query['UserGroupIds'] = $request->userGroupIds;
        }

        if (null !== $request->userIds) {
            @$query['UserIds'] = $request->userIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateRule',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * You can create authorization rules to authorize multiple users to manage assets. You can also specify a validity period for an authorization rule. This way, you can manage users and assets in a more efficient manner and limit the time periods during which users can access assets.
     *
     * @param request - CreateRuleRequest
     *
     * @returns CreateRuleResponse
     *
     * @param CreateRuleRequest $request
     *
     * @return CreateRuleResponse
     */
    public function createRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createRuleWithOptions($request, $runtime);
    }

    /**
     * Adds a user to a bastion host.
     *
     * @remarks
     * You can call the CreateUser operation to add local users, Resource Access Management (RAM) users, Active Directory (AD)-authenticated users, or Lightweight Directory Access Protocol (LDAP)-authenticated users to a bastion host. After a Bastionhost administrator adds a user to a bastion host, O\\&M engineers can log on to the bastion host as the user to perform O\\&M operations on the hosts that the user is authorized to manage.
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds a limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limits when you call this operation.
     *
     * @param request - CreateUserRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateUserResponse
     *
     * @param CreateUserRequest $request
     * @param RuntimeOptions    $runtime
     *
     * @return CreateUserResponse
     */
    public function createUserWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->comment) {
            @$query['Comment'] = $request->comment;
        }

        if (null !== $request->displayName) {
            @$query['DisplayName'] = $request->displayName;
        }

        if (null !== $request->effectiveEndTime) {
            @$query['EffectiveEndTime'] = $request->effectiveEndTime;
        }

        if (null !== $request->effectiveStartTime) {
            @$query['EffectiveStartTime'] = $request->effectiveStartTime;
        }

        if (null !== $request->email) {
            @$query['Email'] = $request->email;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->language) {
            @$query['Language'] = $request->language;
        }

        if (null !== $request->languageStatus) {
            @$query['LanguageStatus'] = $request->languageStatus;
        }

        if (null !== $request->mobile) {
            @$query['Mobile'] = $request->mobile;
        }

        if (null !== $request->mobileCountryCode) {
            @$query['MobileCountryCode'] = $request->mobileCountryCode;
        }

        if (null !== $request->needResetPassword) {
            @$query['NeedResetPassword'] = $request->needResetPassword;
        }

        if (null !== $request->password) {
            @$query['Password'] = $request->password;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        if (null !== $request->sourceUserId) {
            @$query['SourceUserId'] = $request->sourceUserId;
        }

        if (null !== $request->twoFactorMethods) {
            @$query['TwoFactorMethods'] = $request->twoFactorMethods;
        }

        if (null !== $request->twoFactorStatus) {
            @$query['TwoFactorStatus'] = $request->twoFactorStatus;
        }

        if (null !== $request->userName) {
            @$query['UserName'] = $request->userName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateUser',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds a user to a bastion host.
     *
     * @remarks
     * You can call the CreateUser operation to add local users, Resource Access Management (RAM) users, Active Directory (AD)-authenticated users, or Lightweight Directory Access Protocol (LDAP)-authenticated users to a bastion host. After a Bastionhost administrator adds a user to a bastion host, O\\&M engineers can log on to the bastion host as the user to perform O\\&M operations on the hosts that the user is authorized to manage.
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds a limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limits when you call this operation.
     *
     * @param request - CreateUserRequest
     *
     * @returns CreateUserResponse
     *
     * @param CreateUserRequest $request
     *
     * @return CreateUserResponse
     */
    public function createUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createUserWithOptions($request, $runtime);
    }

    /**
     * Creates a user group for the specified bastion host.
     *
     * @remarks
     * You can call this operation to create a user group for a bastion host as an administrator. Then, you can call the [AddUsersToGroup](https://help.aliyun.com/document_detail/204600.html) operation to add users to the user group at a time. After you add the users to the user group, you can authorize and manage the users in a centralized manner.
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - CreateUserGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateUserGroupResponse
     *
     * @param CreateUserGroupRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return CreateUserGroupResponse
     */
    public function createUserGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->comment) {
            @$query['Comment'] = $request->comment;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userGroupName) {
            @$query['UserGroupName'] = $request->userGroupName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateUserGroup',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateUserGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a user group for the specified bastion host.
     *
     * @remarks
     * You can call this operation to create a user group for a bastion host as an administrator. Then, you can call the [AddUsersToGroup](https://help.aliyun.com/document_detail/204600.html) operation to add users to the user group at a time. After you add the users to the user group, you can authorize and manage the users in a centralized manner.
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - CreateUserGroupRequest
     *
     * @returns CreateUserGroupResponse
     *
     * @param CreateUserGroupRequest $request
     *
     * @return CreateUserGroupResponse
     */
    public function createUserGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createUserGroupWithOptions($request, $runtime);
    }

    /**
     * Creates a public key for a bastion host user and hosts the public key in the bastion host. This way, O\\&M engineers can use the private key that corresponds to the public key to log on to the bastion host from an O\\&M client.
     *
     * @remarks
     * You can call the CreateUserPublicKey operation to create a public key for the specified user of a bastion host.
     *
     * @param request - CreateUserPublicKeyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateUserPublicKeyResponse
     *
     * @param CreateUserPublicKeyRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return CreateUserPublicKeyResponse
     */
    public function createUserPublicKeyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->comment) {
            @$query['Comment'] = $request->comment;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->publicKey) {
            @$query['PublicKey'] = $request->publicKey;
        }

        if (null !== $request->publicKeyName) {
            @$query['PublicKeyName'] = $request->publicKeyName;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userId) {
            @$query['UserId'] = $request->userId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateUserPublicKey',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateUserPublicKeyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a public key for a bastion host user and hosts the public key in the bastion host. This way, O\\&M engineers can use the private key that corresponds to the public key to log on to the bastion host from an O\\&M client.
     *
     * @remarks
     * You can call the CreateUserPublicKey operation to create a public key for the specified user of a bastion host.
     *
     * @param request - CreateUserPublicKeyRequest
     *
     * @returns CreateUserPublicKeyResponse
     *
     * @param CreateUserPublicKeyRequest $request
     *
     * @return CreateUserPublicKeyResponse
     */
    public function createUserPublicKey($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createUserPublicKeyWithOptions($request, $runtime);
    }

    /**
     * Deletes a database.
     *
     * @param request - DeleteDatabaseRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteDatabaseResponse
     *
     * @param DeleteDatabaseRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return DeleteDatabaseResponse
     */
    public function deleteDatabaseWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->databaseId) {
            @$query['DatabaseId'] = $request->databaseId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteDatabase',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteDatabaseResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a database.
     *
     * @param request - DeleteDatabaseRequest
     *
     * @returns DeleteDatabaseResponse
     *
     * @param DeleteDatabaseRequest $request
     *
     * @return DeleteDatabaseResponse
     */
    public function deleteDatabase($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteDatabaseWithOptions($request, $runtime);
    }

    /**
     * Deletes a database account.
     *
     * @param request - DeleteDatabaseAccountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteDatabaseAccountResponse
     *
     * @param DeleteDatabaseAccountRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DeleteDatabaseAccountResponse
     */
    public function deleteDatabaseAccountWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->databaseAccountId) {
            @$query['DatabaseAccountId'] = $request->databaseAccountId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteDatabaseAccount',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteDatabaseAccountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a database account.
     *
     * @param request - DeleteDatabaseAccountRequest
     *
     * @returns DeleteDatabaseAccountResponse
     *
     * @param DeleteDatabaseAccountRequest $request
     *
     * @return DeleteDatabaseAccountResponse
     */
    public function deleteDatabaseAccount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteDatabaseAccountWithOptions($request, $runtime);
    }

    /**
     * Deletes the specified host.
     *
     * @param request - DeleteHostRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteHostResponse
     *
     * @param DeleteHostRequest $request
     * @param RuntimeOptions    $runtime
     *
     * @return DeleteHostResponse
     */
    public function deleteHostWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostId) {
            @$query['HostId'] = $request->hostId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteHost',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteHostResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the specified host.
     *
     * @param request - DeleteHostRequest
     *
     * @returns DeleteHostResponse
     *
     * @param DeleteHostRequest $request
     *
     * @return DeleteHostResponse
     */
    public function deleteHost($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteHostWithOptions($request, $runtime);
    }

    /**
     * Removes a host account.
     *
     * @remarks
     * ## Usage notes
     * This interface is used to delete individual host accounts. If a host account is no longer in use, you can invoke this interface to delete the host account for that host that has been configured on the bastion.
     * >  After you remove the host account, you must enter the username and password of the host when you log on to the host in Bastionhost.
     * ## QPS Limit
     * The single-user QPS limit of this interface is 10 times/second. If the limit is exceeded, the API call will be stream-limited, which may affect your business, please call reasonably.
     *
     * @param request - DeleteHostAccountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteHostAccountResponse
     *
     * @param DeleteHostAccountRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return DeleteHostAccountResponse
     */
    public function deleteHostAccountWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostAccountId) {
            @$query['HostAccountId'] = $request->hostAccountId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteHostAccount',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteHostAccountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Removes a host account.
     *
     * @remarks
     * ## Usage notes
     * This interface is used to delete individual host accounts. If a host account is no longer in use, you can invoke this interface to delete the host account for that host that has been configured on the bastion.
     * >  After you remove the host account, you must enter the username and password of the host when you log on to the host in Bastionhost.
     * ## QPS Limit
     * The single-user QPS limit of this interface is 10 times/second. If the limit is exceeded, the API call will be stream-limited, which may affect your business, please call reasonably.
     *
     * @param request - DeleteHostAccountRequest
     *
     * @returns DeleteHostAccountResponse
     *
     * @param DeleteHostAccountRequest $request
     *
     * @return DeleteHostAccountResponse
     */
    public function deleteHostAccount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteHostAccountWithOptions($request, $runtime);
    }

    /**
     * Deletes a host group.
     *
     * @remarks
     * You can call this operation to delete a single host group. If you no longer need to perform O\\&M operations on all hosts in a host group, you can call this operation to delete the host group.
     * ### Limits
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - DeleteHostGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteHostGroupResponse
     *
     * @param DeleteHostGroupRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return DeleteHostGroupResponse
     */
    public function deleteHostGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostGroupId) {
            @$query['HostGroupId'] = $request->hostGroupId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteHostGroup',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteHostGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a host group.
     *
     * @remarks
     * You can call this operation to delete a single host group. If you no longer need to perform O\\&M operations on all hosts in a host group, you can call this operation to delete the host group.
     * ### Limits
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - DeleteHostGroupRequest
     *
     * @returns DeleteHostGroupResponse
     *
     * @param DeleteHostGroupRequest $request
     *
     * @return DeleteHostGroupResponse
     */
    public function deleteHostGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteHostGroupWithOptions($request, $runtime);
    }

    /**
     * Deletes a shared key.
     *
     * @param request - DeleteHostShareKeyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteHostShareKeyResponse
     *
     * @param DeleteHostShareKeyRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return DeleteHostShareKeyResponse
     */
    public function deleteHostShareKeyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostShareKeyId) {
            @$query['HostShareKeyId'] = $request->hostShareKeyId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteHostShareKey',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteHostShareKeyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a shared key.
     *
     * @param request - DeleteHostShareKeyRequest
     *
     * @returns DeleteHostShareKeyResponse
     *
     * @param DeleteHostShareKeyRequest $request
     *
     * @return DeleteHostShareKeyResponse
     */
    public function deleteHostShareKey($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteHostShareKeyWithOptions($request, $runtime);
    }

    /**
     * Deletes a network domain.
     *
     * @param request - DeleteNetworkDomainRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteNetworkDomainResponse
     *
     * @param DeleteNetworkDomainRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DeleteNetworkDomainResponse
     */
    public function deleteNetworkDomainWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->networkDomainId) {
            @$query['NetworkDomainId'] = $request->networkDomainId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteNetworkDomain',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteNetworkDomainResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a network domain.
     *
     * @param request - DeleteNetworkDomainRequest
     *
     * @returns DeleteNetworkDomainResponse
     *
     * @param DeleteNetworkDomainRequest $request
     *
     * @return DeleteNetworkDomainResponse
     */
    public function deleteNetworkDomain($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteNetworkDomainWithOptions($request, $runtime);
    }

    /**
     * Deletes a control policy.
     *
     * @param request - DeletePolicyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeletePolicyResponse
     *
     * @param DeletePolicyRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return DeletePolicyResponse
     */
    public function deletePolicyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->policyId) {
            @$query['PolicyId'] = $request->policyId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeletePolicy',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeletePolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a control policy.
     *
     * @param request - DeletePolicyRequest
     *
     * @returns DeletePolicyResponse
     *
     * @param DeletePolicyRequest $request
     *
     * @return DeletePolicyResponse
     */
    public function deletePolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deletePolicyWithOptions($request, $runtime);
    }

    /**
     * Deletes an authorization rule.
     *
     * @param request - DeleteRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteRuleResponse
     *
     * @param DeleteRuleRequest $request
     * @param RuntimeOptions    $runtime
     *
     * @return DeleteRuleResponse
     */
    public function deleteRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->ruleId) {
            @$query['RuleId'] = $request->ruleId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteRule',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an authorization rule.
     *
     * @param request - DeleteRuleRequest
     *
     * @returns DeleteRuleResponse
     *
     * @param DeleteRuleRequest $request
     *
     * @return DeleteRuleResponse
     */
    public function deleteRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteRuleWithOptions($request, $runtime);
    }

    /**
     * Deletes a bastion host user.
     *
     * @param request - DeleteUserRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteUserResponse
     *
     * @param DeleteUserRequest $request
     * @param RuntimeOptions    $runtime
     *
     * @return DeleteUserResponse
     */
    public function deleteUserWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userId) {
            @$query['UserId'] = $request->userId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteUser',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a bastion host user.
     *
     * @param request - DeleteUserRequest
     *
     * @returns DeleteUserResponse
     *
     * @param DeleteUserRequest $request
     *
     * @return DeleteUserResponse
     */
    public function deleteUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteUserWithOptions($request, $runtime);
    }

    /**
     * Deletes a specified user group from a specified bastion host.
     *
     * @param request - DeleteUserGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteUserGroupResponse
     *
     * @param DeleteUserGroupRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return DeleteUserGroupResponse
     */
    public function deleteUserGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userGroupId) {
            @$query['UserGroupId'] = $request->userGroupId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteUserGroup',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteUserGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a specified user group from a specified bastion host.
     *
     * @param request - DeleteUserGroupRequest
     *
     * @returns DeleteUserGroupResponse
     *
     * @param DeleteUserGroupRequest $request
     *
     * @return DeleteUserGroupResponse
     */
    public function deleteUserGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteUserGroupWithOptions($request, $runtime);
    }

    /**
     * Deletes a public key from the specified user.
     *
     * @remarks
     * You can call the DeleteUserPublicKey operation to delete a public key from the specified user of a bastion host.
     *
     * @param request - DeleteUserPublicKeyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteUserPublicKeyResponse
     *
     * @param DeleteUserPublicKeyRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DeleteUserPublicKeyResponse
     */
    public function deleteUserPublicKeyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->publicKeyId) {
            @$query['PublicKeyId'] = $request->publicKeyId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteUserPublicKey',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteUserPublicKeyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a public key from the specified user.
     *
     * @remarks
     * You can call the DeleteUserPublicKey operation to delete a public key from the specified user of a bastion host.
     *
     * @param request - DeleteUserPublicKeyRequest
     *
     * @returns DeleteUserPublicKeyResponse
     *
     * @param DeleteUserPublicKeyRequest $request
     *
     * @return DeleteUserPublicKeyResponse
     */
    public function deleteUserPublicKey($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteUserPublicKeyWithOptions($request, $runtime);
    }

    /**
     * Queries the attribute information about the specified bastion host. The information includes the ID and remarks of the bastion host.
     *
     * @remarks
     *
     * @param request - DescribeInstanceAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeInstanceAttributeResponse
     *
     * @param DescribeInstanceAttributeRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeInstanceAttributeResponse
     */
    public function describeInstanceAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeInstanceAttribute',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeInstanceAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the attribute information about the specified bastion host. The information includes the ID and remarks of the bastion host.
     *
     * @remarks
     *
     * @param request - DescribeInstanceAttributeRequest
     *
     * @returns DescribeInstanceAttributeResponse
     *
     * @param DescribeInstanceAttributeRequest $request
     *
     * @return DescribeInstanceAttributeResponse
     */
    public function describeInstanceAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeInstanceAttributeWithOptions($request, $runtime);
    }

    /**
     * 堡垒机实例列表.
     *
     * @param request - DescribeInstancesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeInstancesResponse
     *
     * @param DescribeInstancesRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return DescribeInstancesResponse
     */
    public function describeInstancesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->instanceStatus) {
            @$query['InstanceStatus'] = $request->instanceStatus;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeInstances',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 堡垒机实例列表.
     *
     * @param request - DescribeInstancesRequest
     *
     * @returns DescribeInstancesResponse
     *
     * @param DescribeInstancesRequest $request
     *
     * @return DescribeInstancesResponse
     */
    public function describeInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeInstancesWithOptions($request, $runtime);
    }

    /**
     * Queries available regions where you can create bastion hosts.
     *
     * @param request - DescribeRegionsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRegionsResponse
     *
     * @param DescribeRegionsRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return DescribeRegionsResponse
     */
    public function describeRegionsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceptLanguage) {
            @$query['AcceptLanguage'] = $request->acceptLanguage;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRegions',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRegionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries available regions where you can create bastion hosts.
     *
     * @param request - DescribeRegionsRequest
     *
     * @returns DescribeRegionsResponse
     *
     * @param DescribeRegionsRequest $request
     *
     * @return DescribeRegionsResponse
     */
    public function describeRegions($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRegionsWithOptions($request, $runtime);
    }

    /**
     * Revokes permissions on databases and database accounts from a user.
     *
     * @param request - DetachDatabaseAccountsFromUserRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DetachDatabaseAccountsFromUserResponse
     *
     * @param DetachDatabaseAccountsFromUserRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DetachDatabaseAccountsFromUserResponse
     */
    public function detachDatabaseAccountsFromUserWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->databases) {
            @$query['Databases'] = $request->databases;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userId) {
            @$query['UserId'] = $request->userId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DetachDatabaseAccountsFromUser',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DetachDatabaseAccountsFromUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Revokes permissions on databases and database accounts from a user.
     *
     * @param request - DetachDatabaseAccountsFromUserRequest
     *
     * @returns DetachDatabaseAccountsFromUserResponse
     *
     * @param DetachDatabaseAccountsFromUserRequest $request
     *
     * @return DetachDatabaseAccountsFromUserResponse
     */
    public function detachDatabaseAccountsFromUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->detachDatabaseAccountsFromUserWithOptions($request, $runtime);
    }

    /**
     * Revokes permissions on databases and database accounts from a user group.
     *
     * @param request - DetachDatabaseAccountsFromUserGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DetachDatabaseAccountsFromUserGroupResponse
     *
     * @param DetachDatabaseAccountsFromUserGroupRequest $request
     * @param RuntimeOptions                             $runtime
     *
     * @return DetachDatabaseAccountsFromUserGroupResponse
     */
    public function detachDatabaseAccountsFromUserGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->databases) {
            @$query['Databases'] = $request->databases;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userGroupId) {
            @$query['UserGroupId'] = $request->userGroupId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DetachDatabaseAccountsFromUserGroup',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DetachDatabaseAccountsFromUserGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Revokes permissions on databases and database accounts from a user group.
     *
     * @param request - DetachDatabaseAccountsFromUserGroupRequest
     *
     * @returns DetachDatabaseAccountsFromUserGroupResponse
     *
     * @param DetachDatabaseAccountsFromUserGroupRequest $request
     *
     * @return DetachDatabaseAccountsFromUserGroupResponse
     */
    public function detachDatabaseAccountsFromUserGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->detachDatabaseAccountsFromUserGroupWithOptions($request, $runtime);
    }

    /**
     * Disassociate host accounts from a shared key.
     *
     * @param request - DetachHostAccountsFromHostShareKeyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DetachHostAccountsFromHostShareKeyResponse
     *
     * @param DetachHostAccountsFromHostShareKeyRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return DetachHostAccountsFromHostShareKeyResponse
     */
    public function detachHostAccountsFromHostShareKeyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostAccountIds) {
            @$query['HostAccountIds'] = $request->hostAccountIds;
        }

        if (null !== $request->hostShareKeyId) {
            @$query['HostShareKeyId'] = $request->hostShareKeyId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DetachHostAccountsFromHostShareKey',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DetachHostAccountsFromHostShareKeyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Disassociate host accounts from a shared key.
     *
     * @param request - DetachHostAccountsFromHostShareKeyRequest
     *
     * @returns DetachHostAccountsFromHostShareKeyResponse
     *
     * @param DetachHostAccountsFromHostShareKeyRequest $request
     *
     * @return DetachHostAccountsFromHostShareKeyResponse
     */
    public function detachHostAccountsFromHostShareKey($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->detachHostAccountsFromHostShareKeyWithOptions($request, $runtime);
    }

    /**
     * Revokes permissions on hosts and host accounts from a user.
     *
     * @param request - DetachHostAccountsFromUserRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DetachHostAccountsFromUserResponse
     *
     * @param DetachHostAccountsFromUserRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DetachHostAccountsFromUserResponse
     */
    public function detachHostAccountsFromUserWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hosts) {
            @$query['Hosts'] = $request->hosts;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userId) {
            @$query['UserId'] = $request->userId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DetachHostAccountsFromUser',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DetachHostAccountsFromUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Revokes permissions on hosts and host accounts from a user.
     *
     * @param request - DetachHostAccountsFromUserRequest
     *
     * @returns DetachHostAccountsFromUserResponse
     *
     * @param DetachHostAccountsFromUserRequest $request
     *
     * @return DetachHostAccountsFromUserResponse
     */
    public function detachHostAccountsFromUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->detachHostAccountsFromUserWithOptions($request, $runtime);
    }

    /**
     * Revokes the permissions on one or more hosts and host accounts from a user group.
     *
     * @param request - DetachHostAccountsFromUserGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DetachHostAccountsFromUserGroupResponse
     *
     * @param DetachHostAccountsFromUserGroupRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return DetachHostAccountsFromUserGroupResponse
     */
    public function detachHostAccountsFromUserGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hosts) {
            @$query['Hosts'] = $request->hosts;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userGroupId) {
            @$query['UserGroupId'] = $request->userGroupId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DetachHostAccountsFromUserGroup',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DetachHostAccountsFromUserGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Revokes the permissions on one or more hosts and host accounts from a user group.
     *
     * @param request - DetachHostAccountsFromUserGroupRequest
     *
     * @returns DetachHostAccountsFromUserGroupResponse
     *
     * @param DetachHostAccountsFromUserGroupRequest $request
     *
     * @return DetachHostAccountsFromUserGroupResponse
     */
    public function detachHostAccountsFromUserGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->detachHostAccountsFromUserGroupWithOptions($request, $runtime);
    }

    /**
     * Removes host groups and host accounts from the list of host groups and host accounts that a user is authorized to manage.
     *
     * @param request - DetachHostGroupAccountsFromUserRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DetachHostGroupAccountsFromUserResponse
     *
     * @param DetachHostGroupAccountsFromUserRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return DetachHostGroupAccountsFromUserResponse
     */
    public function detachHostGroupAccountsFromUserWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostGroups) {
            @$query['HostGroups'] = $request->hostGroups;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userId) {
            @$query['UserId'] = $request->userId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DetachHostGroupAccountsFromUser',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DetachHostGroupAccountsFromUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Removes host groups and host accounts from the list of host groups and host accounts that a user is authorized to manage.
     *
     * @param request - DetachHostGroupAccountsFromUserRequest
     *
     * @returns DetachHostGroupAccountsFromUserResponse
     *
     * @param DetachHostGroupAccountsFromUserRequest $request
     *
     * @return DetachHostGroupAccountsFromUserResponse
     */
    public function detachHostGroupAccountsFromUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->detachHostGroupAccountsFromUserWithOptions($request, $runtime);
    }

    /**
     * Revokes permissions on one or more host groups and host accounts from a user group.
     *
     * @remarks
     *
     * @param request - DetachHostGroupAccountsFromUserGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DetachHostGroupAccountsFromUserGroupResponse
     *
     * @param DetachHostGroupAccountsFromUserGroupRequest $request
     * @param RuntimeOptions                              $runtime
     *
     * @return DetachHostGroupAccountsFromUserGroupResponse
     */
    public function detachHostGroupAccountsFromUserGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostGroups) {
            @$query['HostGroups'] = $request->hostGroups;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userGroupId) {
            @$query['UserGroupId'] = $request->userGroupId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DetachHostGroupAccountsFromUserGroup',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DetachHostGroupAccountsFromUserGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Revokes permissions on one or more host groups and host accounts from a user group.
     *
     * @remarks
     *
     * @param request - DetachHostGroupAccountsFromUserGroupRequest
     *
     * @returns DetachHostGroupAccountsFromUserGroupResponse
     *
     * @param DetachHostGroupAccountsFromUserGroupRequest $request
     *
     * @return DetachHostGroupAccountsFromUserGroupResponse
     */
    public function detachHostGroupAccountsFromUserGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->detachHostGroupAccountsFromUserGroupWithOptions($request, $runtime);
    }

    /**
     * Disables Internet access for a bastion host.
     *
     * @param request - DisableInstancePublicAccessRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DisableInstancePublicAccessResponse
     *
     * @param DisableInstancePublicAccessRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DisableInstancePublicAccessResponse
     */
    public function disableInstancePublicAccessWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DisableInstancePublicAccess',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DisableInstancePublicAccessResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Disables Internet access for a bastion host.
     *
     * @param request - DisableInstancePublicAccessRequest
     *
     * @returns DisableInstancePublicAccessResponse
     *
     * @param DisableInstancePublicAccessRequest $request
     *
     * @return DisableInstancePublicAccessResponse
     */
    public function disableInstancePublicAccess($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->disableInstancePublicAccessWithOptions($request, $runtime);
    }

    /**
     * Disables an authorization rule.
     *
     * @param request - DisableRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DisableRuleResponse
     *
     * @param DisableRuleRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return DisableRuleResponse
     */
    public function disableRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->ruleId) {
            @$query['RuleId'] = $request->ruleId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DisableRule',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DisableRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Disables an authorization rule.
     *
     * @param request - DisableRuleRequest
     *
     * @returns DisableRuleResponse
     *
     * @param DisableRuleRequest $request
     *
     * @return DisableRuleResponse
     */
    public function disableRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->disableRuleWithOptions($request, $runtime);
    }

    /**
     * Enables Internet access for a bastion host.
     *
     * @param request - EnableInstancePublicAccessRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns EnableInstancePublicAccessResponse
     *
     * @param EnableInstancePublicAccessRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return EnableInstancePublicAccessResponse
     */
    public function enableInstancePublicAccessWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'EnableInstancePublicAccess',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return EnableInstancePublicAccessResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables Internet access for a bastion host.
     *
     * @param request - EnableInstancePublicAccessRequest
     *
     * @returns EnableInstancePublicAccessResponse
     *
     * @param EnableInstancePublicAccessRequest $request
     *
     * @return EnableInstancePublicAccessResponse
     */
    public function enableInstancePublicAccess($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->enableInstancePublicAccessWithOptions($request, $runtime);
    }

    /**
     * Enables an authorization rule.
     *
     * @param request - EnableRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns EnableRuleResponse
     *
     * @param EnableRuleRequest $request
     * @param RuntimeOptions    $runtime
     *
     * @return EnableRuleResponse
     */
    public function enableRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->ruleId) {
            @$query['RuleId'] = $request->ruleId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'EnableRule',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return EnableRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables an authorization rule.
     *
     * @param request - EnableRuleRequest
     *
     * @returns EnableRuleResponse
     *
     * @param EnableRuleRequest $request
     *
     * @return EnableRuleResponse
     */
    public function enableRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->enableRuleWithOptions($request, $runtime);
    }

    /**
     * Applies for an O\\&M token.
     *
     * @param request - GenerateAssetOperationTokenRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GenerateAssetOperationTokenResponse
     *
     * @param GenerateAssetOperationTokenRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return GenerateAssetOperationTokenResponse
     */
    public function generateAssetOperationTokenWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->assetAccountId) {
            @$query['AssetAccountId'] = $request->assetAccountId;
        }

        if (null !== $request->assetAccountName) {
            @$query['AssetAccountName'] = $request->assetAccountName;
        }

        if (null !== $request->assetAccountPassword) {
            @$query['AssetAccountPassword'] = $request->assetAccountPassword;
        }

        if (null !== $request->assetAccountProtocolName) {
            @$query['AssetAccountProtocolName'] = $request->assetAccountProtocolName;
        }

        if (null !== $request->assetId) {
            @$query['AssetId'] = $request->assetId;
        }

        if (null !== $request->assetType) {
            @$query['AssetType'] = $request->assetType;
        }

        if (null !== $request->databaseSchema) {
            @$query['DatabaseSchema'] = $request->databaseSchema;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->loginAttribute) {
            @$query['LoginAttribute'] = $request->loginAttribute;
        }

        if (null !== $request->operationMode) {
            @$query['OperationMode'] = $request->operationMode;
        }

        if (null !== $request->operationNote) {
            @$query['OperationNote'] = $request->operationNote;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->ssoClient) {
            @$query['SsoClient'] = $request->ssoClient;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GenerateAssetOperationToken',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GenerateAssetOperationTokenResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Applies for an O\\&M token.
     *
     * @param request - GenerateAssetOperationTokenRequest
     *
     * @returns GenerateAssetOperationTokenResponse
     *
     * @param GenerateAssetOperationTokenRequest $request
     *
     * @return GenerateAssetOperationTokenResponse
     */
    public function generateAssetOperationToken($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->generateAssetOperationTokenWithOptions($request, $runtime);
    }

    /**
     * Queries the detailed information about a database.
     *
     * @param request - GetDatabaseRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetDatabaseResponse
     *
     * @param GetDatabaseRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return GetDatabaseResponse
     */
    public function getDatabaseWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->databaseId) {
            @$query['DatabaseId'] = $request->databaseId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetDatabase',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetDatabaseResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the detailed information about a database.
     *
     * @param request - GetDatabaseRequest
     *
     * @returns GetDatabaseResponse
     *
     * @param GetDatabaseRequest $request
     *
     * @return GetDatabaseResponse
     */
    public function getDatabase($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDatabaseWithOptions($request, $runtime);
    }

    /**
     * Queries the detailed information about a database account.
     *
     * @param request - GetDatabaseAccountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetDatabaseAccountResponse
     *
     * @param GetDatabaseAccountRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return GetDatabaseAccountResponse
     */
    public function getDatabaseAccountWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->databaseAccountId) {
            @$query['DatabaseAccountId'] = $request->databaseAccountId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetDatabaseAccount',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetDatabaseAccountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the detailed information about a database account.
     *
     * @param request - GetDatabaseAccountRequest
     *
     * @returns GetDatabaseAccountResponse
     *
     * @param GetDatabaseAccountRequest $request
     *
     * @return GetDatabaseAccountResponse
     */
    public function getDatabaseAccount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDatabaseAccountWithOptions($request, $runtime);
    }

    /**
     * 获取导出配置任务进度.
     *
     * @param request - GetExportConfigJobRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetExportConfigJobResponse
     *
     * @param GetExportConfigJobRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return GetExportConfigJobResponse
     */
    public function getExportConfigJobWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->jobId) {
            @$query['JobId'] = $request->jobId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetExportConfigJob',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetExportConfigJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 获取导出配置任务进度.
     *
     * @param request - GetExportConfigJobRequest
     *
     * @returns GetExportConfigJobResponse
     *
     * @param GetExportConfigJobRequest $request
     *
     * @return GetExportConfigJobResponse
     */
    public function getExportConfigJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getExportConfigJobWithOptions($request, $runtime);
    }

    /**
     * Queries the details of a host, such as the name, source, address, protocol, and service port of the host.
     *
     * @param request - GetHostRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetHostResponse
     *
     * @param GetHostRequest $request
     * @param RuntimeOptions $runtime
     *
     * @return GetHostResponse
     */
    public function getHostWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostId) {
            @$query['HostId'] = $request->hostId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetHost',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetHostResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of a host, such as the name, source, address, protocol, and service port of the host.
     *
     * @param request - GetHostRequest
     *
     * @returns GetHostResponse
     *
     * @param GetHostRequest $request
     *
     * @return GetHostResponse
     */
    public function getHost($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getHostWithOptions($request, $runtime);
    }

    /**
     * Queries the details of a specified host account.
     *
     * @param request - GetHostAccountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetHostAccountResponse
     *
     * @param GetHostAccountRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return GetHostAccountResponse
     */
    public function getHostAccountWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostAccountId) {
            @$query['HostAccountId'] = $request->hostAccountId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetHostAccount',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetHostAccountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of a specified host account.
     *
     * @param request - GetHostAccountRequest
     *
     * @returns GetHostAccountResponse
     *
     * @param GetHostAccountRequest $request
     *
     * @return GetHostAccountResponse
     */
    public function getHostAccount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getHostAccountWithOptions($request, $runtime);
    }

    /**
     * Queries the details of a specified host group.
     *
     * @param request - GetHostGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetHostGroupResponse
     *
     * @param GetHostGroupRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return GetHostGroupResponse
     */
    public function getHostGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostGroupId) {
            @$query['HostGroupId'] = $request->hostGroupId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetHostGroup',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetHostGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of a specified host group.
     *
     * @param request - GetHostGroupRequest
     *
     * @returns GetHostGroupResponse
     *
     * @param GetHostGroupRequest $request
     *
     * @return GetHostGroupResponse
     */
    public function getHostGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getHostGroupWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a shared key.
     *
     * @param request - GetHostShareKeyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetHostShareKeyResponse
     *
     * @param GetHostShareKeyRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return GetHostShareKeyResponse
     */
    public function getHostShareKeyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostShareKeyId) {
            @$query['HostShareKeyId'] = $request->hostShareKeyId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetHostShareKey',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetHostShareKeyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a shared key.
     *
     * @param request - GetHostShareKeyRequest
     *
     * @returns GetHostShareKeyResponse
     *
     * @param GetHostShareKeyRequest $request
     *
     * @return GetHostShareKeyResponse
     */
    public function getHostShareKey($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getHostShareKeyWithOptions($request, $runtime);
    }

    /**
     * Queries the settings of Active Directory (AD) authentication on a bastion host.
     *
     * @remarks
     * ###
     * You can call this operation to query the settings of AD authentication on a bastion host. After you configure AD authentication on a bastion host, you can import AD-authenticated users into the bastion host. After the AD-authenticated users are imported into the bastion host, the AD-authenticated users can log on to the bastion host to perform O\\&M operations on servers.
     * ### Limit
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - GetInstanceADAuthServerRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetInstanceADAuthServerResponse
     *
     * @param GetInstanceADAuthServerRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return GetInstanceADAuthServerResponse
     */
    public function getInstanceADAuthServerWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetInstanceADAuthServer',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetInstanceADAuthServerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the settings of Active Directory (AD) authentication on a bastion host.
     *
     * @remarks
     * ###
     * You can call this operation to query the settings of AD authentication on a bastion host. After you configure AD authentication on a bastion host, you can import AD-authenticated users into the bastion host. After the AD-authenticated users are imported into the bastion host, the AD-authenticated users can log on to the bastion host to perform O\\&M operations on servers.
     * ### Limit
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - GetInstanceADAuthServerRequest
     *
     * @returns GetInstanceADAuthServerResponse
     *
     * @param GetInstanceADAuthServerRequest $request
     *
     * @return GetInstanceADAuthServerResponse
     */
    public function getInstanceADAuthServer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInstanceADAuthServerWithOptions($request, $runtime);
    }

    /**
     * Queries the settings of Lightweight Directory Access Protocol (LDAP) authentication on a bastion host.
     *
     * @param request - GetInstanceLDAPAuthServerRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetInstanceLDAPAuthServerResponse
     *
     * @param GetInstanceLDAPAuthServerRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return GetInstanceLDAPAuthServerResponse
     */
    public function getInstanceLDAPAuthServerWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetInstanceLDAPAuthServer',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetInstanceLDAPAuthServerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the settings of Lightweight Directory Access Protocol (LDAP) authentication on a bastion host.
     *
     * @param request - GetInstanceLDAPAuthServerRequest
     *
     * @returns GetInstanceLDAPAuthServerResponse
     *
     * @param GetInstanceLDAPAuthServerRequest $request
     *
     * @return GetInstanceLDAPAuthServerResponse
     */
    public function getInstanceLDAPAuthServer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInstanceLDAPAuthServerWithOptions($request, $runtime);
    }

    /**
     * 获取堡垒机实例存储信息.
     *
     * @param request - GetInstanceStoreInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetInstanceStoreInfoResponse
     *
     * @param GetInstanceStoreInfoRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return GetInstanceStoreInfoResponse
     */
    public function getInstanceStoreInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetInstanceStoreInfo',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetInstanceStoreInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 获取堡垒机实例存储信息.
     *
     * @param request - GetInstanceStoreInfoRequest
     *
     * @returns GetInstanceStoreInfoResponse
     *
     * @param GetInstanceStoreInfoRequest $request
     *
     * @return GetInstanceStoreInfoResponse
     */
    public function getInstanceStoreInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInstanceStoreInfoWithOptions($request, $runtime);
    }

    /**
     * Queries the settings of two-factor authentication on a bastion host.
     *
     * @remarks
     * You can call this operation to query the settings of two-factor authentication on a bastion host. After you enable two-factor authentication, Bastionhost sends a verification code to a local user when the local user logs on to a bastion host. A local user can log on to the bastion host only when the local user enters the valid username and password and the verification code. This reduces the security risks caused by account information leaks.
     * ### Limit
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - GetInstanceTwoFactorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetInstanceTwoFactorResponse
     *
     * @param GetInstanceTwoFactorRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return GetInstanceTwoFactorResponse
     */
    public function getInstanceTwoFactorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetInstanceTwoFactor',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetInstanceTwoFactorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the settings of two-factor authentication on a bastion host.
     *
     * @remarks
     * You can call this operation to query the settings of two-factor authentication on a bastion host. After you enable two-factor authentication, Bastionhost sends a verification code to a local user when the local user logs on to a bastion host. A local user can log on to the bastion host only when the local user enters the valid username and password and the verification code. This reduces the security risks caused by account information leaks.
     * ### Limit
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - GetInstanceTwoFactorRequest
     *
     * @returns GetInstanceTwoFactorResponse
     *
     * @param GetInstanceTwoFactorRequest $request
     *
     * @return GetInstanceTwoFactorResponse
     */
    public function getInstanceTwoFactor($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInstanceTwoFactorWithOptions($request, $runtime);
    }

    /**
     * Queries the detailed information about a network domain.
     *
     * @param request - GetNetworkDomainRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetNetworkDomainResponse
     *
     * @param GetNetworkDomainRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return GetNetworkDomainResponse
     */
    public function getNetworkDomainWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->checkProxyState) {
            @$query['CheckProxyState'] = $request->checkProxyState;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->networkDomainId) {
            @$query['NetworkDomainId'] = $request->networkDomainId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetNetworkDomain',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetNetworkDomainResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the detailed information about a network domain.
     *
     * @param request - GetNetworkDomainRequest
     *
     * @returns GetNetworkDomainResponse
     *
     * @param GetNetworkDomainRequest $request
     *
     * @return GetNetworkDomainResponse
     */
    public function getNetworkDomain($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getNetworkDomainWithOptions($request, $runtime);
    }

    /**
     * Queries the detailed information about a control policy.
     *
     * @param request - GetPolicyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetPolicyResponse
     *
     * @param GetPolicyRequest $request
     * @param RuntimeOptions   $runtime
     *
     * @return GetPolicyResponse
     */
    public function getPolicyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->policyId) {
            @$query['PolicyId'] = $request->policyId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetPolicy',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the detailed information about a control policy.
     *
     * @param request - GetPolicyRequest
     *
     * @returns GetPolicyResponse
     *
     * @param GetPolicyRequest $request
     *
     * @return GetPolicyResponse
     */
    public function getPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getPolicyWithOptions($request, $runtime);
    }

    /**
     * Queries the assets to which a control policy applies.
     *
     * @param request - GetPolicyAssetScopeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetPolicyAssetScopeResponse
     *
     * @param GetPolicyAssetScopeRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return GetPolicyAssetScopeResponse
     */
    public function getPolicyAssetScopeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->policyId) {
            @$query['PolicyId'] = $request->policyId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetPolicyAssetScope',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetPolicyAssetScopeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the assets to which a control policy applies.
     *
     * @param request - GetPolicyAssetScopeRequest
     *
     * @returns GetPolicyAssetScopeResponse
     *
     * @param GetPolicyAssetScopeRequest $request
     *
     * @return GetPolicyAssetScopeResponse
     */
    public function getPolicyAssetScope($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getPolicyAssetScopeWithOptions($request, $runtime);
    }

    /**
     * Queries the scope of users to whom a control policy applies.
     *
     * @param request - GetPolicyUserScopeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetPolicyUserScopeResponse
     *
     * @param GetPolicyUserScopeRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return GetPolicyUserScopeResponse
     */
    public function getPolicyUserScopeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->policyId) {
            @$query['PolicyId'] = $request->policyId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetPolicyUserScope',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetPolicyUserScopeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the scope of users to whom a control policy applies.
     *
     * @param request - GetPolicyUserScopeRequest
     *
     * @returns GetPolicyUserScopeResponse
     *
     * @param GetPolicyUserScopeRequest $request
     *
     * @return GetPolicyUserScopeResponse
     */
    public function getPolicyUserScope($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getPolicyUserScopeWithOptions($request, $runtime);
    }

    /**
     * Queries the detailed information about an authorization rule.
     *
     * @param request - GetRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetRuleResponse
     *
     * @param GetRuleRequest $request
     * @param RuntimeOptions $runtime
     *
     * @return GetRuleResponse
     */
    public function getRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->ruleId) {
            @$query['RuleId'] = $request->ruleId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetRule',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the detailed information about an authorization rule.
     *
     * @param request - GetRuleRequest
     *
     * @returns GetRuleResponse
     *
     * @param GetRuleRequest $request
     *
     * @return GetRuleResponse
     */
    public function getRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getRuleWithOptions($request, $runtime);
    }

    /**
     * Queries the details of a user of the specified bastion host.
     *
     * @param request - GetUserRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetUserResponse
     *
     * @param GetUserRequest $request
     * @param RuntimeOptions $runtime
     *
     * @return GetUserResponse
     */
    public function getUserWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userId) {
            @$query['UserId'] = $request->userId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetUser',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of a user of the specified bastion host.
     *
     * @param request - GetUserRequest
     *
     * @returns GetUserResponse
     *
     * @param GetUserRequest $request
     *
     * @return GetUserResponse
     */
    public function getUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getUserWithOptions($request, $runtime);
    }

    /**
     * Queries the details of a user group in a bastion host.
     *
     * @param request - GetUserGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetUserGroupResponse
     *
     * @param GetUserGroupRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return GetUserGroupResponse
     */
    public function getUserGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userGroupId) {
            @$query['UserGroupId'] = $request->userGroupId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetUserGroup',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetUserGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of a user group in a bastion host.
     *
     * @param request - GetUserGroupRequest
     *
     * @returns GetUserGroupResponse
     *
     * @param GetUserGroupRequest $request
     *
     * @return GetUserGroupResponse
     */
    public function getUserGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getUserGroupWithOptions($request, $runtime);
    }

    /**
     * Queries commands to be reviewed.
     *
     * @remarks
     * You can call this operation to query commands to be reviewed by a Bastionhost administrator.
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - ListApproveCommandsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListApproveCommandsResponse
     *
     * @param ListApproveCommandsRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ListApproveCommandsResponse
     */
    public function listApproveCommandsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListApproveCommands',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListApproveCommandsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries commands to be reviewed.
     *
     * @remarks
     * You can call this operation to query commands to be reviewed by a Bastionhost administrator.
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - ListApproveCommandsRequest
     *
     * @returns ListApproveCommandsResponse
     *
     * @param ListApproveCommandsRequest $request
     *
     * @return ListApproveCommandsResponse
     */
    public function listApproveCommands($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listApproveCommandsWithOptions($request, $runtime);
    }

    /**
     * Queries the database accounts of a database.
     *
     * @param request - ListDatabaseAccountsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListDatabaseAccountsResponse
     *
     * @param ListDatabaseAccountsRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return ListDatabaseAccountsResponse
     */
    public function listDatabaseAccountsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->databaseAccountName) {
            @$query['DatabaseAccountName'] = $request->databaseAccountName;
        }

        if (null !== $request->databaseId) {
            @$query['DatabaseId'] = $request->databaseId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListDatabaseAccounts',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListDatabaseAccountsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the database accounts of a database.
     *
     * @param request - ListDatabaseAccountsRequest
     *
     * @returns ListDatabaseAccountsResponse
     *
     * @param ListDatabaseAccountsRequest $request
     *
     * @return ListDatabaseAccountsResponse
     */
    public function listDatabaseAccounts($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDatabaseAccountsWithOptions($request, $runtime);
    }

    /**
     * Queries the database accounts of a database and whether a user is authorized to manage each database account.
     *
     * @param request - ListDatabaseAccountsForUserRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListDatabaseAccountsForUserResponse
     *
     * @param ListDatabaseAccountsForUserRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return ListDatabaseAccountsForUserResponse
     */
    public function listDatabaseAccountsForUserWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->databaseAccountName) {
            @$query['DatabaseAccountName'] = $request->databaseAccountName;
        }

        if (null !== $request->databaseId) {
            @$query['DatabaseId'] = $request->databaseId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userId) {
            @$query['UserId'] = $request->userId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListDatabaseAccountsForUser',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListDatabaseAccountsForUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the database accounts of a database and whether a user is authorized to manage each database account.
     *
     * @param request - ListDatabaseAccountsForUserRequest
     *
     * @returns ListDatabaseAccountsForUserResponse
     *
     * @param ListDatabaseAccountsForUserRequest $request
     *
     * @return ListDatabaseAccountsForUserResponse
     */
    public function listDatabaseAccountsForUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDatabaseAccountsForUserWithOptions($request, $runtime);
    }

    /**
     * Queries the database accounts of a database and whether a user group is authorized to manage each database account.
     *
     * @param request - ListDatabaseAccountsForUserGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListDatabaseAccountsForUserGroupResponse
     *
     * @param ListDatabaseAccountsForUserGroupRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return ListDatabaseAccountsForUserGroupResponse
     */
    public function listDatabaseAccountsForUserGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->databaseAccountName) {
            @$query['DatabaseAccountName'] = $request->databaseAccountName;
        }

        if (null !== $request->databaseId) {
            @$query['DatabaseId'] = $request->databaseId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userGroupId) {
            @$query['UserGroupId'] = $request->userGroupId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListDatabaseAccountsForUserGroup',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListDatabaseAccountsForUserGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the database accounts of a database and whether a user group is authorized to manage each database account.
     *
     * @param request - ListDatabaseAccountsForUserGroupRequest
     *
     * @returns ListDatabaseAccountsForUserGroupResponse
     *
     * @param ListDatabaseAccountsForUserGroupRequest $request
     *
     * @return ListDatabaseAccountsForUserGroupResponse
     */
    public function listDatabaseAccountsForUserGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDatabaseAccountsForUserGroupWithOptions($request, $runtime);
    }

    /**
     * Queries the databases that are managed by a bastion host.
     *
     * @param request - ListDatabasesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListDatabasesResponse
     *
     * @param ListDatabasesRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return ListDatabasesResponse
     */
    public function listDatabasesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->databaseType) {
            @$query['DatabaseType'] = $request->databaseType;
        }

        if (null !== $request->hostGroupId) {
            @$query['HostGroupId'] = $request->hostGroupId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->networkDomainId) {
            @$query['NetworkDomainId'] = $request->networkDomainId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListDatabases',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListDatabasesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the databases that are managed by a bastion host.
     *
     * @param request - ListDatabasesRequest
     *
     * @returns ListDatabasesResponse
     *
     * @param ListDatabasesRequest $request
     *
     * @return ListDatabasesResponse
     */
    public function listDatabases($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDatabasesWithOptions($request, $runtime);
    }

    /**
     * Queries the databases that a user is authorized to manage.
     *
     * @param request - ListDatabasesForUserRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListDatabasesForUserResponse
     *
     * @param ListDatabasesForUserRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return ListDatabasesForUserResponse
     */
    public function listDatabasesForUserWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->databaseAddress) {
            @$query['DatabaseAddress'] = $request->databaseAddress;
        }

        if (null !== $request->databaseName) {
            @$query['DatabaseName'] = $request->databaseName;
        }

        if (null !== $request->databaseType) {
            @$query['DatabaseType'] = $request->databaseType;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->networkDomainId) {
            @$query['NetworkDomainId'] = $request->networkDomainId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userId) {
            @$query['UserId'] = $request->userId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListDatabasesForUser',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListDatabasesForUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the databases that a user is authorized to manage.
     *
     * @param request - ListDatabasesForUserRequest
     *
     * @returns ListDatabasesForUserResponse
     *
     * @param ListDatabasesForUserRequest $request
     *
     * @return ListDatabasesForUserResponse
     */
    public function listDatabasesForUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDatabasesForUserWithOptions($request, $runtime);
    }

    /**
     * Queries the databases that a user group is authorized to manage.
     *
     * @param request - ListDatabasesForUserGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListDatabasesForUserGroupResponse
     *
     * @param ListDatabasesForUserGroupRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return ListDatabasesForUserGroupResponse
     */
    public function listDatabasesForUserGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->databaseAddress) {
            @$query['DatabaseAddress'] = $request->databaseAddress;
        }

        if (null !== $request->databaseName) {
            @$query['DatabaseName'] = $request->databaseName;
        }

        if (null !== $request->databaseType) {
            @$query['DatabaseType'] = $request->databaseType;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->networkDomainId) {
            @$query['NetworkDomainId'] = $request->networkDomainId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userGroupId) {
            @$query['UserGroupId'] = $request->userGroupId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListDatabasesForUserGroup',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListDatabasesForUserGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the databases that a user group is authorized to manage.
     *
     * @param request - ListDatabasesForUserGroupRequest
     *
     * @returns ListDatabasesForUserGroupResponse
     *
     * @param ListDatabasesForUserGroupRequest $request
     *
     * @return ListDatabasesForUserGroupResponse
     */
    public function listDatabasesForUserGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDatabasesForUserGroupWithOptions($request, $runtime);
    }

    /**
     * Queries accounts of a specified host.
     *
     * @param request - ListHostAccountsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListHostAccountsResponse
     *
     * @param ListHostAccountsRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return ListHostAccountsResponse
     */
    public function listHostAccountsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostAccountName) {
            @$query['HostAccountName'] = $request->hostAccountName;
        }

        if (null !== $request->hostId) {
            @$query['HostId'] = $request->hostId;
        }

        if (null !== $request->hostIds) {
            @$query['HostIds'] = $request->hostIds;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->protocolName) {
            @$query['ProtocolName'] = $request->protocolName;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListHostAccounts',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListHostAccountsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries accounts of a specified host.
     *
     * @param request - ListHostAccountsRequest
     *
     * @returns ListHostAccountsResponse
     *
     * @param ListHostAccountsRequest $request
     *
     * @return ListHostAccountsResponse
     */
    public function listHostAccounts($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHostAccountsWithOptions($request, $runtime);
    }

    /**
     * Queries the host accounts that are associated with a shared key.
     *
     * @param request - ListHostAccountsForHostShareKeyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListHostAccountsForHostShareKeyResponse
     *
     * @param ListHostAccountsForHostShareKeyRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return ListHostAccountsForHostShareKeyResponse
     */
    public function listHostAccountsForHostShareKeyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostShareKeyId) {
            @$query['HostShareKeyId'] = $request->hostShareKeyId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListHostAccountsForHostShareKey',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListHostAccountsForHostShareKeyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the host accounts that are associated with a shared key.
     *
     * @param request - ListHostAccountsForHostShareKeyRequest
     *
     * @returns ListHostAccountsForHostShareKeyResponse
     *
     * @param ListHostAccountsForHostShareKeyRequest $request
     *
     * @return ListHostAccountsForHostShareKeyResponse
     */
    public function listHostAccountsForHostShareKey($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHostAccountsForHostShareKeyWithOptions($request, $runtime);
    }

    /**
     * Queries the host accounts that the specified user is authorized to manage on the specified host.
     *
     * @param request - ListHostAccountsForUserRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListHostAccountsForUserResponse
     *
     * @param ListHostAccountsForUserRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ListHostAccountsForUserResponse
     */
    public function listHostAccountsForUserWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostAccountName) {
            @$query['HostAccountName'] = $request->hostAccountName;
        }

        if (null !== $request->hostId) {
            @$query['HostId'] = $request->hostId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userId) {
            @$query['UserId'] = $request->userId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListHostAccountsForUser',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListHostAccountsForUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the host accounts that the specified user is authorized to manage on the specified host.
     *
     * @param request - ListHostAccountsForUserRequest
     *
     * @returns ListHostAccountsForUserResponse
     *
     * @param ListHostAccountsForUserRequest $request
     *
     * @return ListHostAccountsForUserResponse
     */
    public function listHostAccountsForUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHostAccountsForUserWithOptions($request, $runtime);
    }

    /**
     * Queries the host accounts of the specified host that the specified user group is authorized to manage.
     *
     * @param request - ListHostAccountsForUserGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListHostAccountsForUserGroupResponse
     *
     * @param ListHostAccountsForUserGroupRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return ListHostAccountsForUserGroupResponse
     */
    public function listHostAccountsForUserGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostAccountName) {
            @$query['HostAccountName'] = $request->hostAccountName;
        }

        if (null !== $request->hostId) {
            @$query['HostId'] = $request->hostId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userGroupId) {
            @$query['UserGroupId'] = $request->userGroupId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListHostAccountsForUserGroup',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListHostAccountsForUserGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the host accounts of the specified host that the specified user group is authorized to manage.
     *
     * @param request - ListHostAccountsForUserGroupRequest
     *
     * @returns ListHostAccountsForUserGroupResponse
     *
     * @param ListHostAccountsForUserGroupRequest $request
     *
     * @return ListHostAccountsForUserGroupResponse
     */
    public function listHostAccountsForUserGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHostAccountsForUserGroupWithOptions($request, $runtime);
    }

    /**
     * Queries the names of the host accounts that a specified user is authorized to manage in a specified host group.
     *
     * @param request - ListHostGroupAccountNamesForUserRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListHostGroupAccountNamesForUserResponse
     *
     * @param ListHostGroupAccountNamesForUserRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return ListHostGroupAccountNamesForUserResponse
     */
    public function listHostGroupAccountNamesForUserWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostGroupId) {
            @$query['HostGroupId'] = $request->hostGroupId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userId) {
            @$query['UserId'] = $request->userId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListHostGroupAccountNamesForUser',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListHostGroupAccountNamesForUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the names of the host accounts that a specified user is authorized to manage in a specified host group.
     *
     * @param request - ListHostGroupAccountNamesForUserRequest
     *
     * @returns ListHostGroupAccountNamesForUserResponse
     *
     * @param ListHostGroupAccountNamesForUserRequest $request
     *
     * @return ListHostGroupAccountNamesForUserResponse
     */
    public function listHostGroupAccountNamesForUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHostGroupAccountNamesForUserWithOptions($request, $runtime);
    }

    /**
     * Queries the names of the host accounts that a user group is authorized to manage in a host group.
     *
     * @param request - ListHostGroupAccountNamesForUserGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListHostGroupAccountNamesForUserGroupResponse
     *
     * @param ListHostGroupAccountNamesForUserGroupRequest $request
     * @param RuntimeOptions                               $runtime
     *
     * @return ListHostGroupAccountNamesForUserGroupResponse
     */
    public function listHostGroupAccountNamesForUserGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostGroupId) {
            @$query['HostGroupId'] = $request->hostGroupId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userGroupId) {
            @$query['UserGroupId'] = $request->userGroupId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListHostGroupAccountNamesForUserGroup',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListHostGroupAccountNamesForUserGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the names of the host accounts that a user group is authorized to manage in a host group.
     *
     * @param request - ListHostGroupAccountNamesForUserGroupRequest
     *
     * @returns ListHostGroupAccountNamesForUserGroupResponse
     *
     * @param ListHostGroupAccountNamesForUserGroupRequest $request
     *
     * @return ListHostGroupAccountNamesForUserGroupResponse
     */
    public function listHostGroupAccountNamesForUserGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHostGroupAccountNamesForUserGroupWithOptions($request, $runtime);
    }

    /**
     * Queries a list of asset groups that are managed by a bastion host.
     *
     * @param request - ListHostGroupsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListHostGroupsResponse
     *
     * @param ListHostGroupsRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return ListHostGroupsResponse
     */
    public function listHostGroupsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostGroupName) {
            @$query['HostGroupName'] = $request->hostGroupName;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListHostGroups',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListHostGroupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of asset groups that are managed by a bastion host.
     *
     * @param request - ListHostGroupsRequest
     *
     * @returns ListHostGroupsResponse
     *
     * @param ListHostGroupsRequest $request
     *
     * @return ListHostGroupsResponse
     */
    public function listHostGroups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHostGroupsWithOptions($request, $runtime);
    }

    /**
     * Queries a list of host groups that a bastion host user is authorized or is not authorized to manage.
     *
     * @param request - ListHostGroupsForUserRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListHostGroupsForUserResponse
     *
     * @param ListHostGroupsForUserRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return ListHostGroupsForUserResponse
     */
    public function listHostGroupsForUserWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostGroupName) {
            @$query['HostGroupName'] = $request->hostGroupName;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->mode) {
            @$query['Mode'] = $request->mode;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userId) {
            @$query['UserId'] = $request->userId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListHostGroupsForUser',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListHostGroupsForUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of host groups that a bastion host user is authorized or is not authorized to manage.
     *
     * @param request - ListHostGroupsForUserRequest
     *
     * @returns ListHostGroupsForUserResponse
     *
     * @param ListHostGroupsForUserRequest $request
     *
     * @return ListHostGroupsForUserResponse
     */
    public function listHostGroupsForUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHostGroupsForUserWithOptions($request, $runtime);
    }

    /**
     * Queries the hosts that a specified user group is authorized or not authorized to manage.
     *
     * @param request - ListHostGroupsForUserGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListHostGroupsForUserGroupResponse
     *
     * @param ListHostGroupsForUserGroupRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return ListHostGroupsForUserGroupResponse
     */
    public function listHostGroupsForUserGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostGroupName) {
            @$query['HostGroupName'] = $request->hostGroupName;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->mode) {
            @$query['Mode'] = $request->mode;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userGroupId) {
            @$query['UserGroupId'] = $request->userGroupId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListHostGroupsForUserGroup',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListHostGroupsForUserGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the hosts that a specified user group is authorized or not authorized to manage.
     *
     * @param request - ListHostGroupsForUserGroupRequest
     *
     * @returns ListHostGroupsForUserGroupResponse
     *
     * @param ListHostGroupsForUserGroupRequest $request
     *
     * @return ListHostGroupsForUserGroupResponse
     */
    public function listHostGroupsForUserGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHostGroupsForUserGroupWithOptions($request, $runtime);
    }

    /**
     * Queries the shared keys that are associated with a host.
     *
     * @param request - ListHostShareKeysRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListHostShareKeysResponse
     *
     * @param ListHostShareKeysRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return ListHostShareKeysResponse
     */
    public function listHostShareKeysWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListHostShareKeys',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListHostShareKeysResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the shared keys that are associated with a host.
     *
     * @param request - ListHostShareKeysRequest
     *
     * @returns ListHostShareKeysResponse
     *
     * @param ListHostShareKeysRequest $request
     *
     * @return ListHostShareKeysResponse
     */
    public function listHostShareKeys($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHostShareKeysWithOptions($request, $runtime);
    }

    /**
     * Queries the hosts in a bastion host.
     *
     * @param request - ListHostsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListHostsResponse
     *
     * @param ListHostsRequest $request
     * @param RuntimeOptions   $runtime
     *
     * @return ListHostsResponse
     */
    public function listHostsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostAddress) {
            @$query['HostAddress'] = $request->hostAddress;
        }

        if (null !== $request->hostGroupId) {
            @$query['HostGroupId'] = $request->hostGroupId;
        }

        if (null !== $request->hostName) {
            @$query['HostName'] = $request->hostName;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->OSType) {
            @$query['OSType'] = $request->OSType;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        if (null !== $request->sourceInstanceId) {
            @$query['SourceInstanceId'] = $request->sourceInstanceId;
        }

        if (null !== $request->sourceInstanceState) {
            @$query['SourceInstanceState'] = $request->sourceInstanceState;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListHosts',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListHostsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the hosts in a bastion host.
     *
     * @param request - ListHostsRequest
     *
     * @returns ListHostsResponse
     *
     * @param ListHostsRequest $request
     *
     * @return ListHostsResponse
     */
    public function listHosts($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHostsWithOptions($request, $runtime);
    }

    /**
     * Queries the hosts that a user group is authorized or not authorized to manage.
     *
     * @param request - ListHostsForUserRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListHostsForUserResponse
     *
     * @param ListHostsForUserRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return ListHostsForUserResponse
     */
    public function listHostsForUserWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostAddress) {
            @$query['HostAddress'] = $request->hostAddress;
        }

        if (null !== $request->hostName) {
            @$query['HostName'] = $request->hostName;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->mode) {
            @$query['Mode'] = $request->mode;
        }

        if (null !== $request->OSType) {
            @$query['OSType'] = $request->OSType;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userId) {
            @$query['UserId'] = $request->userId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListHostsForUser',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListHostsForUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the hosts that a user group is authorized or not authorized to manage.
     *
     * @param request - ListHostsForUserRequest
     *
     * @returns ListHostsForUserResponse
     *
     * @param ListHostsForUserRequest $request
     *
     * @return ListHostsForUserResponse
     */
    public function listHostsForUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHostsForUserWithOptions($request, $runtime);
    }

    /**
     * Queries the hosts that a user group is authorized or not authorized to manage.
     *
     * @param request - ListHostsForUserGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListHostsForUserGroupResponse
     *
     * @param ListHostsForUserGroupRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return ListHostsForUserGroupResponse
     */
    public function listHostsForUserGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostAddress) {
            @$query['HostAddress'] = $request->hostAddress;
        }

        if (null !== $request->hostName) {
            @$query['HostName'] = $request->hostName;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->mode) {
            @$query['Mode'] = $request->mode;
        }

        if (null !== $request->OSType) {
            @$query['OSType'] = $request->OSType;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userGroupId) {
            @$query['UserGroupId'] = $request->userGroupId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListHostsForUserGroup',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListHostsForUserGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the hosts that a user group is authorized or not authorized to manage.
     *
     * @param request - ListHostsForUserGroupRequest
     *
     * @returns ListHostsForUserGroupResponse
     *
     * @param ListHostsForUserGroupRequest $request
     *
     * @return ListHostsForUserGroupResponse
     */
    public function listHostsForUserGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHostsForUserGroupWithOptions($request, $runtime);
    }

    /**
     * 获取RD成员账号列表.
     *
     * @param request - ListInstanceRdMembersRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListInstanceRdMembersResponse
     *
     * @param ListInstanceRdMembersRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return ListInstanceRdMembersResponse
     */
    public function listInstanceRdMembersWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListInstanceRdMembers',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListInstanceRdMembersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 获取RD成员账号列表.
     *
     * @param request - ListInstanceRdMembersRequest
     *
     * @returns ListInstanceRdMembersResponse
     *
     * @param ListInstanceRdMembersRequest $request
     *
     * @return ListInstanceRdMembersResponse
     */
    public function listInstanceRdMembers($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listInstanceRdMembersWithOptions($request, $runtime);
    }

    /**
     * Queries the network domains created in a bastion host.
     *
     * @param request - ListNetworkDomainsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListNetworkDomainsResponse
     *
     * @param ListNetworkDomainsRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return ListNetworkDomainsResponse
     */
    public function listNetworkDomainsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->networkDomainName) {
            @$query['NetworkDomainName'] = $request->networkDomainName;
        }

        if (null !== $request->networkDomainType) {
            @$query['NetworkDomainType'] = $request->networkDomainType;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListNetworkDomains',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListNetworkDomainsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the network domains created in a bastion host.
     *
     * @param request - ListNetworkDomainsRequest
     *
     * @returns ListNetworkDomainsResponse
     *
     * @param ListNetworkDomainsRequest $request
     *
     * @return ListNetworkDomainsResponse
     */
    public function listNetworkDomains($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listNetworkDomainsWithOptions($request, $runtime);
    }

    /**
     * Queries a list of database accounts that the current Resource Access Management (RAM) user is authorized to manage.
     *
     * @param request - ListOperationDatabaseAccountsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListOperationDatabaseAccountsResponse
     *
     * @param ListOperationDatabaseAccountsRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return ListOperationDatabaseAccountsResponse
     */
    public function listOperationDatabaseAccountsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->databaseAccountName) {
            @$query['DatabaseAccountName'] = $request->databaseAccountName;
        }

        if (null !== $request->databaseId) {
            @$query['DatabaseId'] = $request->databaseId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListOperationDatabaseAccounts',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListOperationDatabaseAccountsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of database accounts that the current Resource Access Management (RAM) user is authorized to manage.
     *
     * @param request - ListOperationDatabaseAccountsRequest
     *
     * @returns ListOperationDatabaseAccountsResponse
     *
     * @param ListOperationDatabaseAccountsRequest $request
     *
     * @return ListOperationDatabaseAccountsResponse
     */
    public function listOperationDatabaseAccounts($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listOperationDatabaseAccountsWithOptions($request, $runtime);
    }

    /**
     * Queries a list of databases that the current Resource Access Management (RAM) user is authorized to manage.
     *
     * @param request - ListOperationDatabasesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListOperationDatabasesResponse
     *
     * @param ListOperationDatabasesRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return ListOperationDatabasesResponse
     */
    public function listOperationDatabasesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->databaseAddress) {
            @$query['DatabaseAddress'] = $request->databaseAddress;
        }

        if (null !== $request->databaseName) {
            @$query['DatabaseName'] = $request->databaseName;
        }

        if (null !== $request->databaseType) {
            @$query['DatabaseType'] = $request->databaseType;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        if (null !== $request->sourceInstanceId) {
            @$query['SourceInstanceId'] = $request->sourceInstanceId;
        }

        if (null !== $request->sourceInstanceState) {
            @$query['SourceInstanceState'] = $request->sourceInstanceState;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListOperationDatabases',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListOperationDatabasesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of databases that the current Resource Access Management (RAM) user is authorized to manage.
     *
     * @param request - ListOperationDatabasesRequest
     *
     * @returns ListOperationDatabasesResponse
     *
     * @param ListOperationDatabasesRequest $request
     *
     * @return ListOperationDatabasesResponse
     */
    public function listOperationDatabases($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listOperationDatabasesWithOptions($request, $runtime);
    }

    /**
     * Queries a list of host accounts that the current Resource Access Management (RAM) user is authorized to manage.
     *
     * @param request - ListOperationHostAccountsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListOperationHostAccountsResponse
     *
     * @param ListOperationHostAccountsRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return ListOperationHostAccountsResponse
     */
    public function listOperationHostAccountsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostAccountName) {
            @$query['HostAccountName'] = $request->hostAccountName;
        }

        if (null !== $request->hostId) {
            @$query['HostId'] = $request->hostId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListOperationHostAccounts',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListOperationHostAccountsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of host accounts that the current Resource Access Management (RAM) user is authorized to manage.
     *
     * @param request - ListOperationHostAccountsRequest
     *
     * @returns ListOperationHostAccountsResponse
     *
     * @param ListOperationHostAccountsRequest $request
     *
     * @return ListOperationHostAccountsResponse
     */
    public function listOperationHostAccounts($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listOperationHostAccountsWithOptions($request, $runtime);
    }

    /**
     * Queries a list of hosts that the current Resource Access Management (RAM) user is authorized to manage.
     *
     * @param request - ListOperationHostsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListOperationHostsResponse
     *
     * @param ListOperationHostsRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return ListOperationHostsResponse
     */
    public function listOperationHostsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostAddress) {
            @$query['HostAddress'] = $request->hostAddress;
        }

        if (null !== $request->hostName) {
            @$query['HostName'] = $request->hostName;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->OSType) {
            @$query['OSType'] = $request->OSType;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        if (null !== $request->sourceInstanceId) {
            @$query['SourceInstanceId'] = $request->sourceInstanceId;
        }

        if (null !== $request->sourceInstanceState) {
            @$query['SourceInstanceState'] = $request->sourceInstanceState;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListOperationHosts',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListOperationHostsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of hosts that the current Resource Access Management (RAM) user is authorized to manage.
     *
     * @param request - ListOperationHostsRequest
     *
     * @returns ListOperationHostsResponse
     *
     * @param ListOperationHostsRequest $request
     *
     * @return ListOperationHostsResponse
     */
    public function listOperationHosts($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listOperationHostsWithOptions($request, $runtime);
    }

    /**
     * Queries O\\\\\\\\\\\\&M applications to be reviewed.
     *
     * @remarks
     * You can call this operation to query the O\\&M applications to be reviewed by a Bastionhost administrator.
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - ListOperationTicketsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListOperationTicketsResponse
     *
     * @param ListOperationTicketsRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return ListOperationTicketsResponse
     */
    public function listOperationTicketsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->assetAddress) {
            @$query['AssetAddress'] = $request->assetAddress;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListOperationTickets',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListOperationTicketsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries O\\\\\\\\\\\\&M applications to be reviewed.
     *
     * @remarks
     * You can call this operation to query the O\\&M applications to be reviewed by a Bastionhost administrator.
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - ListOperationTicketsRequest
     *
     * @returns ListOperationTicketsResponse
     *
     * @param ListOperationTicketsRequest $request
     *
     * @return ListOperationTicketsResponse
     */
    public function listOperationTickets($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listOperationTicketsWithOptions($request, $runtime);
    }

    /**
     * Queries a list of control policies.
     *
     * @param request - ListPoliciesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListPoliciesResponse
     *
     * @param ListPoliciesRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return ListPoliciesResponse
     */
    public function listPoliciesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->policyName) {
            @$query['PolicyName'] = $request->policyName;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListPolicies',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListPoliciesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of control policies.
     *
     * @param request - ListPoliciesRequest
     *
     * @returns ListPoliciesResponse
     *
     * @param ListPoliciesRequest $request
     *
     * @return ListPoliciesResponse
     */
    public function listPolicies($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listPoliciesWithOptions($request, $runtime);
    }

    /**
     * Queries a list of authorization rules of a bastion host.
     *
     * @param request - ListRulesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListRulesResponse
     *
     * @param ListRulesRequest $request
     * @param RuntimeOptions   $runtime
     *
     * @return ListRulesResponse
     */
    public function listRulesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->ruleName) {
            @$query['RuleName'] = $request->ruleName;
        }

        if (null !== $request->ruleState) {
            @$query['RuleState'] = $request->ruleState;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListRules',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of authorization rules of a bastion host.
     *
     * @param request - ListRulesRequest
     *
     * @returns ListRulesResponse
     *
     * @param ListRulesRequest $request
     *
     * @return ListRulesResponse
     */
    public function listRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listRulesWithOptions($request, $runtime);
    }

    /**
     * Queries the tags that are added to a resource.
     *
     * @param request - ListTagKeysRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListTagKeysResponse
     *
     * @param ListTagKeysRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return ListTagKeysResponse
     */
    public function listTagKeysWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListTagKeys',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListTagKeysResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the tags that are added to a resource.
     *
     * @param request - ListTagKeysRequest
     *
     * @returns ListTagKeysResponse
     *
     * @param ListTagKeysRequest $request
     *
     * @return ListTagKeysResponse
     */
    public function listTagKeys($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listTagKeysWithOptions($request, $runtime);
    }

    /**
     * Queries the tags bound to one or more Bastionhost instances.
     *
     * @param request - ListTagResourcesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListTagResourcesResponse
     *
     * @param ListTagResourcesRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return ListTagResourcesResponse
     */
    public function listTagResourcesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListTagResources',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListTagResourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the tags bound to one or more Bastionhost instances.
     *
     * @param request - ListTagResourcesRequest
     *
     * @returns ListTagResourcesResponse
     *
     * @param ListTagResourcesRequest $request
     *
     * @return ListTagResourcesResponse
     */
    public function listTagResources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listTagResourcesWithOptions($request, $runtime);
    }

    /**
     * Queries a list of user groups on a bastion host.
     *
     * @param request - ListUserGroupsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListUserGroupsResponse
     *
     * @param ListUserGroupsRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return ListUserGroupsResponse
     */
    public function listUserGroupsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userGroupName) {
            @$query['UserGroupName'] = $request->userGroupName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListUserGroups',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListUserGroupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of user groups on a bastion host.
     *
     * @param request - ListUserGroupsRequest
     *
     * @returns ListUserGroupsResponse
     *
     * @param ListUserGroupsRequest $request
     *
     * @return ListUserGroupsResponse
     */
    public function listUserGroups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listUserGroupsWithOptions($request, $runtime);
    }

    /**
     * Queries all public keys of the specified user.
     *
     * @param request - ListUserPublicKeysRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListUserPublicKeysResponse
     *
     * @param ListUserPublicKeysRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return ListUserPublicKeysResponse
     */
    public function listUserPublicKeysWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userId) {
            @$query['UserId'] = $request->userId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListUserPublicKeys',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListUserPublicKeysResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries all public keys of the specified user.
     *
     * @param request - ListUserPublicKeysRequest
     *
     * @returns ListUserPublicKeysResponse
     *
     * @param ListUserPublicKeysRequest $request
     *
     * @return ListUserPublicKeysResponse
     */
    public function listUserPublicKeys($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listUserPublicKeysWithOptions($request, $runtime);
    }

    /**
     * Queries a list of users of a bastion host.
     *
     * @param request - ListUsersRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListUsersResponse
     *
     * @param ListUsersRequest $request
     * @param RuntimeOptions   $runtime
     *
     * @return ListUsersResponse
     */
    public function listUsersWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->displayName) {
            @$query['DisplayName'] = $request->displayName;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->mobile) {
            @$query['Mobile'] = $request->mobile;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        if (null !== $request->sourceUserId) {
            @$query['SourceUserId'] = $request->sourceUserId;
        }

        if (null !== $request->userGroupId) {
            @$query['UserGroupId'] = $request->userGroupId;
        }

        if (null !== $request->userName) {
            @$query['UserName'] = $request->userName;
        }

        if (null !== $request->userState) {
            @$query['UserState'] = $request->userState;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListUsers',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListUsersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of users of a bastion host.
     *
     * @param request - ListUsersRequest
     *
     * @returns ListUsersResponse
     *
     * @param ListUsersRequest $request
     *
     * @return ListUsersResponse
     */
    public function listUsers($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listUsersWithOptions($request, $runtime);
    }

    /**
     * Locks one or more users of a bastion host.
     *
     * @remarks
     * # Description
     * You can call this operation to lock one or more users of a bastion host. If a user does not need to use a bastion host to perform O\\&M operations within a specific period of time, you can lock the user. The locked user can no longer log on to or perform O\\&M operations on the hosts on which the user is granted permissions. If you want to unlock the user later, you can call the [UnlockUsers](https://help.aliyun.com/document_detail/204590.html) operation.
     * # Limits
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - LockUsersRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns LockUsersResponse
     *
     * @param LockUsersRequest $request
     * @param RuntimeOptions   $runtime
     *
     * @return LockUsersResponse
     */
    public function lockUsersWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userIds) {
            @$query['UserIds'] = $request->userIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'LockUsers',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return LockUsersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Locks one or more users of a bastion host.
     *
     * @remarks
     * # Description
     * You can call this operation to lock one or more users of a bastion host. If a user does not need to use a bastion host to perform O\\&M operations within a specific period of time, you can lock the user. The locked user can no longer log on to or perform O\\&M operations on the hosts on which the user is granted permissions. If you want to unlock the user later, you can call the [UnlockUsers](https://help.aliyun.com/document_detail/204590.html) operation.
     * # Limits
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - LockUsersRequest
     *
     * @returns LockUsersResponse
     *
     * @param LockUsersRequest $request
     *
     * @return LockUsersResponse
     */
    public function lockUsers($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->lockUsersWithOptions($request, $runtime);
    }

    /**
     * Modifies the basic information about a database.
     *
     * @param request - ModifyDatabaseRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyDatabaseResponse
     *
     * @param ModifyDatabaseRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return ModifyDatabaseResponse
     */
    public function modifyDatabaseWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->activeAddressType) {
            @$query['ActiveAddressType'] = $request->activeAddressType;
        }

        if (null !== $request->comment) {
            @$query['Comment'] = $request->comment;
        }

        if (null !== $request->databaseId) {
            @$query['DatabaseId'] = $request->databaseId;
        }

        if (null !== $request->databaseName) {
            @$query['DatabaseName'] = $request->databaseName;
        }

        if (null !== $request->databasePort) {
            @$query['DatabasePort'] = $request->databasePort;
        }

        if (null !== $request->databasePrivateAddress) {
            @$query['DatabasePrivateAddress'] = $request->databasePrivateAddress;
        }

        if (null !== $request->databasePublicAddress) {
            @$query['DatabasePublicAddress'] = $request->databasePublicAddress;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->networkDomainId) {
            @$query['NetworkDomainId'] = $request->networkDomainId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->sourceInstanceId) {
            @$query['SourceInstanceId'] = $request->sourceInstanceId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyDatabase',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyDatabaseResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the basic information about a database.
     *
     * @param request - ModifyDatabaseRequest
     *
     * @returns ModifyDatabaseResponse
     *
     * @param ModifyDatabaseRequest $request
     *
     * @return ModifyDatabaseResponse
     */
    public function modifyDatabase($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDatabaseWithOptions($request, $runtime);
    }

    /**
     * Modifies the basic information about a database account.
     *
     * @param request - ModifyDatabaseAccountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyDatabaseAccountResponse
     *
     * @param ModifyDatabaseAccountRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return ModifyDatabaseAccountResponse
     */
    public function modifyDatabaseAccountWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->databaseAccountId) {
            @$query['DatabaseAccountId'] = $request->databaseAccountId;
        }

        if (null !== $request->databaseAccountName) {
            @$query['DatabaseAccountName'] = $request->databaseAccountName;
        }

        if (null !== $request->databaseSchema) {
            @$query['DatabaseSchema'] = $request->databaseSchema;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->password) {
            @$query['Password'] = $request->password;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyDatabaseAccount',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyDatabaseAccountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the basic information about a database account.
     *
     * @param request - ModifyDatabaseAccountRequest
     *
     * @returns ModifyDatabaseAccountResponse
     *
     * @param ModifyDatabaseAccountRequest $request
     *
     * @return ModifyDatabaseAccountResponse
     */
    public function modifyDatabaseAccount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDatabaseAccountWithOptions($request, $runtime);
    }

    /**
     * Modifies information about a host. The information includes the address, name, and description of the host and the operating system that the host runs.
     *
     * @remarks
     * You can call the ModifyHost operation to modify the basic information about a host in a data center, an Elastic Compute Service (ECS) instance, or a host in an ApsaraDB MyBase dedicated cluster.
     * > The basic information about ECS instances and hosts in ApsaraDB MyBase dedicated clusters within your Alibaba Cloud account is synchronized to Bastionhost on a regular basis. After you modify the basic information about an ECS instance or a host in an ApsaraDB MyBase dedicated cluster, the modification result may be overwritten by the synchronized information.
     *
     * @param request - ModifyHostRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyHostResponse
     *
     * @param ModifyHostRequest $request
     * @param RuntimeOptions    $runtime
     *
     * @return ModifyHostResponse
     */
    public function modifyHostWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->comment) {
            @$query['Comment'] = $request->comment;
        }

        if (null !== $request->hostId) {
            @$query['HostId'] = $request->hostId;
        }

        if (null !== $request->hostName) {
            @$query['HostName'] = $request->hostName;
        }

        if (null !== $request->hostPrivateAddress) {
            @$query['HostPrivateAddress'] = $request->hostPrivateAddress;
        }

        if (null !== $request->hostPublicAddress) {
            @$query['HostPublicAddress'] = $request->hostPublicAddress;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->networkDomainId) {
            @$query['NetworkDomainId'] = $request->networkDomainId;
        }

        if (null !== $request->OSType) {
            @$query['OSType'] = $request->OSType;
        }

        if (null !== $request->prefKex) {
            @$query['PrefKex'] = $request->prefKex;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyHost',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyHostResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies information about a host. The information includes the address, name, and description of the host and the operating system that the host runs.
     *
     * @remarks
     * You can call the ModifyHost operation to modify the basic information about a host in a data center, an Elastic Compute Service (ECS) instance, or a host in an ApsaraDB MyBase dedicated cluster.
     * > The basic information about ECS instances and hosts in ApsaraDB MyBase dedicated clusters within your Alibaba Cloud account is synchronized to Bastionhost on a regular basis. After you modify the basic information about an ECS instance or a host in an ApsaraDB MyBase dedicated cluster, the modification result may be overwritten by the synchronized information.
     *
     * @param request - ModifyHostRequest
     *
     * @returns ModifyHostResponse
     *
     * @param ModifyHostRequest $request
     *
     * @return ModifyHostResponse
     */
    public function modifyHost($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyHostWithOptions($request, $runtime);
    }

    /**
     * Modifies the information about a host account, such as the username, password, and private key of the host account.
     *
     * @param request - ModifyHostAccountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyHostAccountResponse
     *
     * @param ModifyHostAccountRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return ModifyHostAccountResponse
     */
    public function modifyHostAccountWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostAccountId) {
            @$query['HostAccountId'] = $request->hostAccountId;
        }

        if (null !== $request->hostAccountName) {
            @$query['HostAccountName'] = $request->hostAccountName;
        }

        if (null !== $request->hostShareKeyId) {
            @$query['HostShareKeyId'] = $request->hostShareKeyId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->passPhrase) {
            @$query['PassPhrase'] = $request->passPhrase;
        }

        if (null !== $request->password) {
            @$query['Password'] = $request->password;
        }

        if (null !== $request->privateKey) {
            @$query['PrivateKey'] = $request->privateKey;
        }

        if (null !== $request->privilegeType) {
            @$query['PrivilegeType'] = $request->privilegeType;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->rotationMode) {
            @$query['RotationMode'] = $request->rotationMode;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyHostAccount',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyHostAccountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the information about a host account, such as the username, password, and private key of the host account.
     *
     * @param request - ModifyHostAccountRequest
     *
     * @returns ModifyHostAccountResponse
     *
     * @param ModifyHostAccountRequest $request
     *
     * @return ModifyHostAccountResponse
     */
    public function modifyHostAccount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyHostAccountWithOptions($request, $runtime);
    }

    /**
     * Modifies the name or description of the specified host group.
     *
     * @param request - ModifyHostGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyHostGroupResponse
     *
     * @param ModifyHostGroupRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return ModifyHostGroupResponse
     */
    public function modifyHostGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->comment) {
            @$query['Comment'] = $request->comment;
        }

        if (null !== $request->hostGroupId) {
            @$query['HostGroupId'] = $request->hostGroupId;
        }

        if (null !== $request->hostGroupName) {
            @$query['HostGroupName'] = $request->hostGroupName;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyHostGroup',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyHostGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the name or description of the specified host group.
     *
     * @param request - ModifyHostGroupRequest
     *
     * @returns ModifyHostGroupResponse
     *
     * @param ModifyHostGroupRequest $request
     *
     * @return ModifyHostGroupResponse
     */
    public function modifyHostGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyHostGroupWithOptions($request, $runtime);
    }

    /**
     * Modifies a shared key.
     *
     * @param request - ModifyHostShareKeyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyHostShareKeyResponse
     *
     * @param ModifyHostShareKeyRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return ModifyHostShareKeyResponse
     */
    public function modifyHostShareKeyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostShareKeyId) {
            @$query['HostShareKeyId'] = $request->hostShareKeyId;
        }

        if (null !== $request->hostShareKeyName) {
            @$query['HostShareKeyName'] = $request->hostShareKeyName;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->passPhrase) {
            @$query['PassPhrase'] = $request->passPhrase;
        }

        if (null !== $request->privateKey) {
            @$query['PrivateKey'] = $request->privateKey;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyHostShareKey',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyHostShareKeyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies a shared key.
     *
     * @param request - ModifyHostShareKeyRequest
     *
     * @returns ModifyHostShareKeyResponse
     *
     * @param ModifyHostShareKeyRequest $request
     *
     * @return ModifyHostShareKeyResponse
     */
    public function modifyHostShareKey($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyHostShareKeyWithOptions($request, $runtime);
    }

    /**
     * Changes the portal type of one or more hosts for O\\&M.
     *
     * @param request - ModifyHostsActiveAddressTypeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyHostsActiveAddressTypeResponse
     *
     * @param ModifyHostsActiveAddressTypeRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return ModifyHostsActiveAddressTypeResponse
     */
    public function modifyHostsActiveAddressTypeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->activeAddressType) {
            @$query['ActiveAddressType'] = $request->activeAddressType;
        }

        if (null !== $request->hostIds) {
            @$query['HostIds'] = $request->hostIds;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyHostsActiveAddressType',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyHostsActiveAddressTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the portal type of one or more hosts for O\\&M.
     *
     * @param request - ModifyHostsActiveAddressTypeRequest
     *
     * @returns ModifyHostsActiveAddressTypeResponse
     *
     * @param ModifyHostsActiveAddressTypeRequest $request
     *
     * @return ModifyHostsActiveAddressTypeResponse
     */
    public function modifyHostsActiveAddressType($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyHostsActiveAddressTypeWithOptions($request, $runtime);
    }

    /**
     * Changes the port for the O\\\\\\\\\\\\&M protocol on one or more hosts.
     *
     * @remarks
     * ## Usage notes
     * You can call this operation to change the port for the O&M protocol on one or more hosts. If the standard port for the O&M protocol on your host is vulnerable to attacks, you can call this operation to specify a custom port. For example, the standard port for SSH is port 22.
     * >  Ports 0 to 1024 are reserved for Bastionhost. Do not change the port for the O&M protocol to a reserved port.
     * ## QPS limit
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - ModifyHostsPortRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyHostsPortResponse
     *
     * @param ModifyHostsPortRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return ModifyHostsPortResponse
     */
    public function modifyHostsPortWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostIds) {
            @$query['HostIds'] = $request->hostIds;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->port) {
            @$query['Port'] = $request->port;
        }

        if (null !== $request->protocolName) {
            @$query['ProtocolName'] = $request->protocolName;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyHostsPort',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyHostsPortResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the port for the O\\\\\\\\\\\\&M protocol on one or more hosts.
     *
     * @remarks
     * ## Usage notes
     * You can call this operation to change the port for the O&M protocol on one or more hosts. If the standard port for the O&M protocol on your host is vulnerable to attacks, you can call this operation to specify a custom port. For example, the standard port for SSH is port 22.
     * >  Ports 0 to 1024 are reserved for Bastionhost. Do not change the port for the O&M protocol to a reserved port.
     * ## QPS limit
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - ModifyHostsPortRequest
     *
     * @returns ModifyHostsPortResponse
     *
     * @param ModifyHostsPortRequest $request
     *
     * @return ModifyHostsPortResponse
     */
    public function modifyHostsPort($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyHostsPortWithOptions($request, $runtime);
    }

    /**
     * Modifies the settings of the Active Directory (AD) authentication server of a bastion host.
     *
     * @param request - ModifyInstanceADAuthServerRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyInstanceADAuthServerResponse
     *
     * @param ModifyInstanceADAuthServerRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return ModifyInstanceADAuthServerResponse
     */
    public function modifyInstanceADAuthServerWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->account) {
            @$query['Account'] = $request->account;
        }

        if (null !== $request->baseDN) {
            @$query['BaseDN'] = $request->baseDN;
        }

        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->emailMapping) {
            @$query['EmailMapping'] = $request->emailMapping;
        }

        if (null !== $request->filter) {
            @$query['Filter'] = $request->filter;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->isSSL) {
            @$query['IsSSL'] = $request->isSSL;
        }

        if (null !== $request->mobileMapping) {
            @$query['MobileMapping'] = $request->mobileMapping;
        }

        if (null !== $request->nameMapping) {
            @$query['NameMapping'] = $request->nameMapping;
        }

        if (null !== $request->password) {
            @$query['Password'] = $request->password;
        }

        if (null !== $request->port) {
            @$query['Port'] = $request->port;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->server) {
            @$query['Server'] = $request->server;
        }

        if (null !== $request->standbyServer) {
            @$query['StandbyServer'] = $request->standbyServer;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyInstanceADAuthServer',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyInstanceADAuthServerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the settings of the Active Directory (AD) authentication server of a bastion host.
     *
     * @param request - ModifyInstanceADAuthServerRequest
     *
     * @returns ModifyInstanceADAuthServerResponse
     *
     * @param ModifyInstanceADAuthServerRequest $request
     *
     * @return ModifyInstanceADAuthServerResponse
     */
    public function modifyInstanceADAuthServer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyInstanceADAuthServerWithOptions($request, $runtime);
    }

    /**
     * Modifies the information about a bastion host.
     *
     * @param request - ModifyInstanceAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyInstanceAttributeResponse
     *
     * @param ModifyInstanceAttributeRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ModifyInstanceAttributeResponse
     */
    public function modifyInstanceAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyInstanceAttribute',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyInstanceAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the information about a bastion host.
     *
     * @param request - ModifyInstanceAttributeRequest
     *
     * @returns ModifyInstanceAttributeResponse
     *
     * @param ModifyInstanceAttributeRequest $request
     *
     * @return ModifyInstanceAttributeResponse
     */
    public function modifyInstanceAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyInstanceAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies the settings of the Lightweight Directory Access Protocol (LDAP) authentication server of a bastion host.
     *
     * @param request - ModifyInstanceLDAPAuthServerRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyInstanceLDAPAuthServerResponse
     *
     * @param ModifyInstanceLDAPAuthServerRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return ModifyInstanceLDAPAuthServerResponse
     */
    public function modifyInstanceLDAPAuthServerWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->account) {
            @$query['Account'] = $request->account;
        }

        if (null !== $request->baseDN) {
            @$query['BaseDN'] = $request->baseDN;
        }

        if (null !== $request->emailMapping) {
            @$query['EmailMapping'] = $request->emailMapping;
        }

        if (null !== $request->filter) {
            @$query['Filter'] = $request->filter;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->isSSL) {
            @$query['IsSSL'] = $request->isSSL;
        }

        if (null !== $request->loginNameMapping) {
            @$query['LoginNameMapping'] = $request->loginNameMapping;
        }

        if (null !== $request->mobileMapping) {
            @$query['MobileMapping'] = $request->mobileMapping;
        }

        if (null !== $request->nameMapping) {
            @$query['NameMapping'] = $request->nameMapping;
        }

        if (null !== $request->password) {
            @$query['Password'] = $request->password;
        }

        if (null !== $request->port) {
            @$query['Port'] = $request->port;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->server) {
            @$query['Server'] = $request->server;
        }

        if (null !== $request->standbyServer) {
            @$query['StandbyServer'] = $request->standbyServer;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyInstanceLDAPAuthServer',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyInstanceLDAPAuthServerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the settings of the Lightweight Directory Access Protocol (LDAP) authentication server of a bastion host.
     *
     * @param request - ModifyInstanceLDAPAuthServerRequest
     *
     * @returns ModifyInstanceLDAPAuthServerResponse
     *
     * @param ModifyInstanceLDAPAuthServerRequest $request
     *
     * @return ModifyInstanceLDAPAuthServerResponse
     */
    public function modifyInstanceLDAPAuthServer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyInstanceLDAPAuthServerWithOptions($request, $runtime);
    }

    /**
     * Modifies the two-factor authentication settings of a bastion host.
     *
     * @param request - ModifyInstanceTwoFactorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyInstanceTwoFactorResponse
     *
     * @param ModifyInstanceTwoFactorRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ModifyInstanceTwoFactorResponse
     */
    public function modifyInstanceTwoFactorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->enableTwoFactor) {
            @$query['EnableTwoFactor'] = $request->enableTwoFactor;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->skipTwoFactorTime) {
            @$query['SkipTwoFactorTime'] = $request->skipTwoFactorTime;
        }

        if (null !== $request->twoFactorMethods) {
            @$query['TwoFactorMethods'] = $request->twoFactorMethods;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyInstanceTwoFactor',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyInstanceTwoFactorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the two-factor authentication settings of a bastion host.
     *
     * @param request - ModifyInstanceTwoFactorRequest
     *
     * @returns ModifyInstanceTwoFactorResponse
     *
     * @param ModifyInstanceTwoFactorRequest $request
     *
     * @return ModifyInstanceTwoFactorResponse
     */
    public function modifyInstanceTwoFactor($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyInstanceTwoFactorWithOptions($request, $runtime);
    }

    /**
     * Modifies the basic information about a network domain.
     *
     * @param request - ModifyNetworkDomainRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyNetworkDomainResponse
     *
     * @param ModifyNetworkDomainRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ModifyNetworkDomainResponse
     */
    public function modifyNetworkDomainWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->comment) {
            @$query['Comment'] = $request->comment;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->networkDomainId) {
            @$query['NetworkDomainId'] = $request->networkDomainId;
        }

        if (null !== $request->networkDomainName) {
            @$query['NetworkDomainName'] = $request->networkDomainName;
        }

        if (null !== $request->networkDomainType) {
            @$query['NetworkDomainType'] = $request->networkDomainType;
        }

        if (null !== $request->proxies) {
            @$query['Proxies'] = $request->proxies;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyNetworkDomain',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyNetworkDomainResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the basic information about a network domain.
     *
     * @param request - ModifyNetworkDomainRequest
     *
     * @returns ModifyNetworkDomainResponse
     *
     * @param ModifyNetworkDomainRequest $request
     *
     * @return ModifyNetworkDomainResponse
     */
    public function modifyNetworkDomain($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyNetworkDomainWithOptions($request, $runtime);
    }

    /**
     * Modifies the basic information about a control policy.
     *
     * @param request - ModifyPolicyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyPolicyResponse
     *
     * @param ModifyPolicyRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return ModifyPolicyResponse
     */
    public function modifyPolicyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->comment) {
            @$query['Comment'] = $request->comment;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->policyId) {
            @$query['PolicyId'] = $request->policyId;
        }

        if (null !== $request->policyName) {
            @$query['PolicyName'] = $request->policyName;
        }

        if (null !== $request->priority) {
            @$query['Priority'] = $request->priority;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyPolicy',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the basic information about a control policy.
     *
     * @param request - ModifyPolicyRequest
     *
     * @returns ModifyPolicyResponse
     *
     * @param ModifyPolicyRequest $request
     *
     * @return ModifyPolicyResponse
     */
    public function modifyPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyPolicyWithOptions($request, $runtime);
    }

    /**
     * Modifies the basic information of an authorization rule.
     *
     * @param request - ModifyRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyRuleResponse
     *
     * @param ModifyRuleRequest $request
     * @param RuntimeOptions    $runtime
     *
     * @return ModifyRuleResponse
     */
    public function modifyRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->comment) {
            @$query['Comment'] = $request->comment;
        }

        if (null !== $request->databases) {
            @$query['Databases'] = $request->databases;
        }

        if (null !== $request->effectiveEndTime) {
            @$query['EffectiveEndTime'] = $request->effectiveEndTime;
        }

        if (null !== $request->effectiveStartTime) {
            @$query['EffectiveStartTime'] = $request->effectiveStartTime;
        }

        if (null !== $request->hostGroups) {
            @$query['HostGroups'] = $request->hostGroups;
        }

        if (null !== $request->hosts) {
            @$query['Hosts'] = $request->hosts;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->ruleId) {
            @$query['RuleId'] = $request->ruleId;
        }

        if (null !== $request->ruleName) {
            @$query['RuleName'] = $request->ruleName;
        }

        if (null !== $request->userGroupIds) {
            @$query['UserGroupIds'] = $request->userGroupIds;
        }

        if (null !== $request->userIds) {
            @$query['UserIds'] = $request->userIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyRule',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the basic information of an authorization rule.
     *
     * @param request - ModifyRuleRequest
     *
     * @returns ModifyRuleResponse
     *
     * @param ModifyRuleRequest $request
     *
     * @return ModifyRuleResponse
     */
    public function modifyRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyRuleWithOptions($request, $runtime);
    }

    /**
     * Modifies the information about a user of a bastion host.
     *
     * @param request - ModifyUserRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyUserResponse
     *
     * @param ModifyUserRequest $request
     * @param RuntimeOptions    $runtime
     *
     * @return ModifyUserResponse
     */
    public function modifyUserWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->comment) {
            @$query['Comment'] = $request->comment;
        }

        if (null !== $request->displayName) {
            @$query['DisplayName'] = $request->displayName;
        }

        if (null !== $request->effectiveEndTime) {
            @$query['EffectiveEndTime'] = $request->effectiveEndTime;
        }

        if (null !== $request->effectiveStartTime) {
            @$query['EffectiveStartTime'] = $request->effectiveStartTime;
        }

        if (null !== $request->email) {
            @$query['Email'] = $request->email;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->language) {
            @$query['Language'] = $request->language;
        }

        if (null !== $request->languageStatus) {
            @$query['LanguageStatus'] = $request->languageStatus;
        }

        if (null !== $request->mobile) {
            @$query['Mobile'] = $request->mobile;
        }

        if (null !== $request->mobileCountryCode) {
            @$query['MobileCountryCode'] = $request->mobileCountryCode;
        }

        if (null !== $request->needResetPassword) {
            @$query['NeedResetPassword'] = $request->needResetPassword;
        }

        if (null !== $request->password) {
            @$query['Password'] = $request->password;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->twoFactorMethods) {
            @$query['TwoFactorMethods'] = $request->twoFactorMethods;
        }

        if (null !== $request->twoFactorStatus) {
            @$query['TwoFactorStatus'] = $request->twoFactorStatus;
        }

        if (null !== $request->userId) {
            @$query['UserId'] = $request->userId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyUser',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the information about a user of a bastion host.
     *
     * @param request - ModifyUserRequest
     *
     * @returns ModifyUserResponse
     *
     * @param ModifyUserRequest $request
     *
     * @return ModifyUserResponse
     */
    public function modifyUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyUserWithOptions($request, $runtime);
    }

    /**
     * Modifies the information about the specified user group.
     *
     * @param request - ModifyUserGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyUserGroupResponse
     *
     * @param ModifyUserGroupRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return ModifyUserGroupResponse
     */
    public function modifyUserGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->comment) {
            @$query['Comment'] = $request->comment;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userGroupId) {
            @$query['UserGroupId'] = $request->userGroupId;
        }

        if (null !== $request->userGroupName) {
            @$query['UserGroupName'] = $request->userGroupName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyUserGroup',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyUserGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the information about the specified user group.
     *
     * @param request - ModifyUserGroupRequest
     *
     * @returns ModifyUserGroupResponse
     *
     * @param ModifyUserGroupRequest $request
     *
     * @return ModifyUserGroupResponse
     */
    public function modifyUserGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyUserGroupWithOptions($request, $runtime);
    }

    /**
     * Modifies the public key of the user.
     *
     * @param request - ModifyUserPublicKeyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyUserPublicKeyResponse
     *
     * @param ModifyUserPublicKeyRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ModifyUserPublicKeyResponse
     */
    public function modifyUserPublicKeyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->comment) {
            @$query['Comment'] = $request->comment;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->publicKey) {
            @$query['PublicKey'] = $request->publicKey;
        }

        if (null !== $request->publicKeyId) {
            @$query['PublicKeyId'] = $request->publicKeyId;
        }

        if (null !== $request->publicKeyName) {
            @$query['PublicKeyName'] = $request->publicKeyName;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyUserPublicKey',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyUserPublicKeyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the public key of the user.
     *
     * @param request - ModifyUserPublicKeyRequest
     *
     * @returns ModifyUserPublicKeyResponse
     *
     * @param ModifyUserPublicKeyRequest $request
     *
     * @return ModifyUserPublicKeyResponse
     */
    public function modifyUserPublicKey($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyUserPublicKeyWithOptions($request, $runtime);
    }

    /**
     * Adds multiple databases to a network domain at a time.
     *
     * @param request - MoveDatabasesToNetworkDomainRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns MoveDatabasesToNetworkDomainResponse
     *
     * @param MoveDatabasesToNetworkDomainRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return MoveDatabasesToNetworkDomainResponse
     */
    public function moveDatabasesToNetworkDomainWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->databaseIds) {
            @$query['DatabaseIds'] = $request->databaseIds;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->networkDomainId) {
            @$query['NetworkDomainId'] = $request->networkDomainId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'MoveDatabasesToNetworkDomain',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return MoveDatabasesToNetworkDomainResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds multiple databases to a network domain at a time.
     *
     * @param request - MoveDatabasesToNetworkDomainRequest
     *
     * @returns MoveDatabasesToNetworkDomainResponse
     *
     * @param MoveDatabasesToNetworkDomainRequest $request
     *
     * @return MoveDatabasesToNetworkDomainResponse
     */
    public function moveDatabasesToNetworkDomain($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->moveDatabasesToNetworkDomainWithOptions($request, $runtime);
    }

    /**
     * Adds multiple hosts to a network domain at a time.
     *
     * @param request - MoveHostsToNetworkDomainRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns MoveHostsToNetworkDomainResponse
     *
     * @param MoveHostsToNetworkDomainRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return MoveHostsToNetworkDomainResponse
     */
    public function moveHostsToNetworkDomainWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostIds) {
            @$query['HostIds'] = $request->hostIds;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->networkDomainId) {
            @$query['NetworkDomainId'] = $request->networkDomainId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'MoveHostsToNetworkDomain',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return MoveHostsToNetworkDomainResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds multiple hosts to a network domain at a time.
     *
     * @param request - MoveHostsToNetworkDomainRequest
     *
     * @returns MoveHostsToNetworkDomainResponse
     *
     * @param MoveHostsToNetworkDomainRequest $request
     *
     * @return MoveHostsToNetworkDomainResponse
     */
    public function moveHostsToNetworkDomain($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->moveHostsToNetworkDomainWithOptions($request, $runtime);
    }

    /**
     * Moves a bastion host from one resource group to another resource group.
     *
     * @param request - MoveResourceGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns MoveResourceGroupResponse
     *
     * @param MoveResourceGroupRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return MoveResourceGroupResponse
     */
    public function moveResourceGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'MoveResourceGroup',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return MoveResourceGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Moves a bastion host from one resource group to another resource group.
     *
     * @param request - MoveResourceGroupRequest
     *
     * @returns MoveResourceGroupResponse
     *
     * @param MoveResourceGroupRequest $request
     *
     * @return MoveResourceGroupResponse
     */
    public function moveResourceGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->moveResourceGroupWithOptions($request, $runtime);
    }

    /**
     * If an O\\&M engineer attempts to run a command specified in the Command Approval section of the Create Control Policy page, the administrator is notified to review the command in the Bastionhost console. The command can be run only after it is approved by the administrator.
     *
     * @remarks
     * You can call this operation as a Bastionhost administrator to reject the request to run a command of an O\\&M engineer.
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - RejectApproveCommandRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RejectApproveCommandResponse
     *
     * @param RejectApproveCommandRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return RejectApproveCommandResponse
     */
    public function rejectApproveCommandWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->commandId) {
            @$query['CommandId'] = $request->commandId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RejectApproveCommand',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RejectApproveCommandResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * If an O\\&M engineer attempts to run a command specified in the Command Approval section of the Create Control Policy page, the administrator is notified to review the command in the Bastionhost console. The command can be run only after it is approved by the administrator.
     *
     * @remarks
     * You can call this operation as a Bastionhost administrator to reject the request to run a command of an O\\&M engineer.
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - RejectApproveCommandRequest
     *
     * @returns RejectApproveCommandResponse
     *
     * @param RejectApproveCommandRequest $request
     *
     * @return RejectApproveCommandResponse
     */
    public function rejectApproveCommand($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->rejectApproveCommandWithOptions($request, $runtime);
    }

    /**
     * If a Bastionhost administrator enables O\\\\\\&M Approval on the Create Control Policy page, O\\\\\\&M engineers can log on to assets to perform O\\\\\\&M operations only after the administrator approves their O\\\\\\&M applications.
     *
     * @remarks
     * You can call this operation to reject an O\\&M application of an O\\&M engineer as a Bastionhost administrator.
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - RejectOperationTicketRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RejectOperationTicketResponse
     *
     * @param RejectOperationTicketRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return RejectOperationTicketResponse
     */
    public function rejectOperationTicketWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->comment) {
            @$query['Comment'] = $request->comment;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->operationTicketId) {
            @$query['OperationTicketId'] = $request->operationTicketId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RejectOperationTicket',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RejectOperationTicketResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * If a Bastionhost administrator enables O\\\\\\&M Approval on the Create Control Policy page, O\\\\\\&M engineers can log on to assets to perform O\\\\\\&M operations only after the administrator approves their O\\\\\\&M applications.
     *
     * @remarks
     * You can call this operation to reject an O\\&M application of an O\\&M engineer as a Bastionhost administrator.
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - RejectOperationTicketRequest
     *
     * @returns RejectOperationTicketResponse
     *
     * @param RejectOperationTicketRequest $request
     *
     * @return RejectOperationTicketResponse
     */
    public function rejectOperationTicket($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->rejectOperationTicketWithOptions($request, $runtime);
    }

    /**
     * Removes multiple databases from an asset group at a time.
     *
     * @param request - RemoveDatabasesFromGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RemoveDatabasesFromGroupResponse
     *
     * @param RemoveDatabasesFromGroupRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return RemoveDatabasesFromGroupResponse
     */
    public function removeDatabasesFromGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->databaseIds) {
            @$query['DatabaseIds'] = $request->databaseIds;
        }

        if (null !== $request->hostGroupId) {
            @$query['HostGroupId'] = $request->hostGroupId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RemoveDatabasesFromGroup',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RemoveDatabasesFromGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Removes multiple databases from an asset group at a time.
     *
     * @param request - RemoveDatabasesFromGroupRequest
     *
     * @returns RemoveDatabasesFromGroupResponse
     *
     * @param RemoveDatabasesFromGroupRequest $request
     *
     * @return RemoveDatabasesFromGroupResponse
     */
    public function removeDatabasesFromGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->removeDatabasesFromGroupWithOptions($request, $runtime);
    }

    /**
     * Removes multiple hosts from an asset group at a time.
     *
     * @remarks
     * You can call the RemoveHostsFromGroup operation to remove multiple hosts from an asset group at a time. If you no longer need to manage some hosts in an asset group, you can call this operation to remove the hosts from the asset group.
     * # [](#qps-)QPS limit
     * You can call this API operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - RemoveHostsFromGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RemoveHostsFromGroupResponse
     *
     * @param RemoveHostsFromGroupRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return RemoveHostsFromGroupResponse
     */
    public function removeHostsFromGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostGroupId) {
            @$query['HostGroupId'] = $request->hostGroupId;
        }

        if (null !== $request->hostIds) {
            @$query['HostIds'] = $request->hostIds;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RemoveHostsFromGroup',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RemoveHostsFromGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Removes multiple hosts from an asset group at a time.
     *
     * @remarks
     * You can call the RemoveHostsFromGroup operation to remove multiple hosts from an asset group at a time. If you no longer need to manage some hosts in an asset group, you can call this operation to remove the hosts from the asset group.
     * # [](#qps-)QPS limit
     * You can call this API operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - RemoveHostsFromGroupRequest
     *
     * @returns RemoveHostsFromGroupResponse
     *
     * @param RemoveHostsFromGroupRequest $request
     *
     * @return RemoveHostsFromGroupResponse
     */
    public function removeHostsFromGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->removeHostsFromGroupWithOptions($request, $runtime);
    }

    /**
     * 移除RD成员账号.
     *
     * @param request - RemoveInstanceRdMemberRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RemoveInstanceRdMemberResponse
     *
     * @param RemoveInstanceRdMemberRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return RemoveInstanceRdMemberResponse
     */
    public function removeInstanceRdMemberWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->memberId) {
            @$query['MemberId'] = $request->memberId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RemoveInstanceRdMember',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RemoveInstanceRdMemberResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 移除RD成员账号.
     *
     * @param request - RemoveInstanceRdMemberRequest
     *
     * @returns RemoveInstanceRdMemberResponse
     *
     * @param RemoveInstanceRdMemberRequest $request
     *
     * @return RemoveInstanceRdMemberResponse
     */
    public function removeInstanceRdMember($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->removeInstanceRdMemberWithOptions($request, $runtime);
    }

    /**
     * Removes one or more users from a user group.
     *
     * @remarks
     * You can call this operation to remove one or more users from a user group. When users in a user group are transferred to a new position, resign, or are switched to another user group, you can call this operation to remove the users from the current user group at a time.
     * ## QPS limit
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - RemoveUsersFromGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RemoveUsersFromGroupResponse
     *
     * @param RemoveUsersFromGroupRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return RemoveUsersFromGroupResponse
     */
    public function removeUsersFromGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userGroupId) {
            @$query['UserGroupId'] = $request->userGroupId;
        }

        if (null !== $request->userIds) {
            @$query['UserIds'] = $request->userIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RemoveUsersFromGroup',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RemoveUsersFromGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Removes one or more users from a user group.
     *
     * @remarks
     * You can call this operation to remove one or more users from a user group. When users in a user group are transferred to a new position, resign, or are switched to another user group, you can call this operation to remove the users from the current user group at a time.
     * ## QPS limit
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - RemoveUsersFromGroupRequest
     *
     * @returns RemoveUsersFromGroupResponse
     *
     * @param RemoveUsersFromGroupRequest $request
     *
     * @return RemoveUsersFromGroupResponse
     */
    public function removeUsersFromGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->removeUsersFromGroupWithOptions($request, $runtime);
    }

    /**
     * Renews an O\\&M token for one hour.
     *
     * @param request - RenewAssetOperationTokenRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RenewAssetOperationTokenResponse
     *
     * @param RenewAssetOperationTokenRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return RenewAssetOperationTokenResponse
     */
    public function renewAssetOperationTokenWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->tokenId) {
            @$query['TokenId'] = $request->tokenId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RenewAssetOperationToken',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RenewAssetOperationTokenResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Renews an O\\&M token for one hour.
     *
     * @param request - RenewAssetOperationTokenRequest
     *
     * @returns RenewAssetOperationTokenResponse
     *
     * @param RenewAssetOperationTokenRequest $request
     *
     * @return RenewAssetOperationTokenResponse
     */
    public function renewAssetOperationToken($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->renewAssetOperationTokenWithOptions($request, $runtime);
    }

    /**
     * Deletes the logon credential of a specified host account. The logon credential can be the password or Secure Shell (SSH) private key.
     *
     * @param request - ResetHostAccountCredentialRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ResetHostAccountCredentialResponse
     *
     * @param ResetHostAccountCredentialRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return ResetHostAccountCredentialResponse
     */
    public function resetHostAccountCredentialWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->credentialType) {
            @$query['CredentialType'] = $request->credentialType;
        }

        if (null !== $request->hostAccountId) {
            @$query['HostAccountId'] = $request->hostAccountId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ResetHostAccountCredential',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ResetHostAccountCredentialResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the logon credential of a specified host account. The logon credential can be the password or Secure Shell (SSH) private key.
     *
     * @param request - ResetHostAccountCredentialRequest
     *
     * @returns ResetHostAccountCredentialResponse
     *
     * @param ResetHostAccountCredentialRequest $request
     *
     * @return ResetHostAccountCredentialResponse
     */
    public function resetHostAccountCredential($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->resetHostAccountCredentialWithOptions($request, $runtime);
    }

    /**
     * Configures the logon period limits in a control policy.
     *
     * @param tmpReq - SetPolicyAccessTimeRangeConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetPolicyAccessTimeRangeConfigResponse
     *
     * @param SetPolicyAccessTimeRangeConfigRequest $tmpReq
     * @param RuntimeOptions                        $runtime
     *
     * @return SetPolicyAccessTimeRangeConfigResponse
     */
    public function setPolicyAccessTimeRangeConfigWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new SetPolicyAccessTimeRangeConfigShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->accessTimeRangeConfig) {
            $request->accessTimeRangeConfigShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->accessTimeRangeConfig, 'AccessTimeRangeConfig', 'json');
        }

        $query = [];
        if (null !== $request->accessTimeRangeConfigShrink) {
            @$query['AccessTimeRangeConfig'] = $request->accessTimeRangeConfigShrink;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->policyId) {
            @$query['PolicyId'] = $request->policyId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SetPolicyAccessTimeRangeConfig',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetPolicyAccessTimeRangeConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures the logon period limits in a control policy.
     *
     * @param request - SetPolicyAccessTimeRangeConfigRequest
     *
     * @returns SetPolicyAccessTimeRangeConfigResponse
     *
     * @param SetPolicyAccessTimeRangeConfigRequest $request
     *
     * @return SetPolicyAccessTimeRangeConfigResponse
     */
    public function setPolicyAccessTimeRangeConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setPolicyAccessTimeRangeConfigWithOptions($request, $runtime);
    }

    /**
     * Configures the O&M approval setting in a control policy.
     *
     * @param tmpReq - SetPolicyApprovalConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetPolicyApprovalConfigResponse
     *
     * @param SetPolicyApprovalConfigRequest $tmpReq
     * @param RuntimeOptions                 $runtime
     *
     * @return SetPolicyApprovalConfigResponse
     */
    public function setPolicyApprovalConfigWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new SetPolicyApprovalConfigShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->approvalConfig) {
            $request->approvalConfigShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->approvalConfig, 'ApprovalConfig', 'json');
        }

        $query = [];
        if (null !== $request->approvalConfigShrink) {
            @$query['ApprovalConfig'] = $request->approvalConfigShrink;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->policyId) {
            @$query['PolicyId'] = $request->policyId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SetPolicyApprovalConfig',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetPolicyApprovalConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures the O&M approval setting in a control policy.
     *
     * @param request - SetPolicyApprovalConfigRequest
     *
     * @returns SetPolicyApprovalConfigResponse
     *
     * @param SetPolicyApprovalConfigRequest $request
     *
     * @return SetPolicyApprovalConfigResponse
     */
    public function setPolicyApprovalConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setPolicyApprovalConfigWithOptions($request, $runtime);
    }

    /**
     * Specifies the assets to which a control policy applies.
     *
     * @param request - SetPolicyAssetScopeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetPolicyAssetScopeResponse
     *
     * @param SetPolicyAssetScopeRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return SetPolicyAssetScopeResponse
     */
    public function setPolicyAssetScopeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->databases) {
            @$query['Databases'] = $request->databases;
        }

        if (null !== $request->hostGroups) {
            @$query['HostGroups'] = $request->hostGroups;
        }

        if (null !== $request->hosts) {
            @$query['Hosts'] = $request->hosts;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->policyId) {
            @$query['PolicyId'] = $request->policyId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->scopeType) {
            @$query['ScopeType'] = $request->scopeType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SetPolicyAssetScope',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetPolicyAssetScopeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Specifies the assets to which a control policy applies.
     *
     * @param request - SetPolicyAssetScopeRequest
     *
     * @returns SetPolicyAssetScopeResponse
     *
     * @param SetPolicyAssetScopeRequest $request
     *
     * @return SetPolicyAssetScopeResponse
     */
    public function setPolicyAssetScope($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setPolicyAssetScopeWithOptions($request, $runtime);
    }

    /**
     * Specifies the commands that can or cannot be run by the users or on the assets associated with the policy and the commands that must be reviewed.
     *
     * @param tmpReq - SetPolicyCommandConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetPolicyCommandConfigResponse
     *
     * @param SetPolicyCommandConfigRequest $tmpReq
     * @param RuntimeOptions                $runtime
     *
     * @return SetPolicyCommandConfigResponse
     */
    public function setPolicyCommandConfigWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new SetPolicyCommandConfigShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->commandConfig) {
            $request->commandConfigShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->commandConfig, 'CommandConfig', 'json');
        }

        $query = [];
        if (null !== $request->commandConfigShrink) {
            @$query['CommandConfig'] = $request->commandConfigShrink;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->policyId) {
            @$query['PolicyId'] = $request->policyId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SetPolicyCommandConfig',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetPolicyCommandConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Specifies the commands that can or cannot be run by the users or on the assets associated with the policy and the commands that must be reviewed.
     *
     * @param request - SetPolicyCommandConfigRequest
     *
     * @returns SetPolicyCommandConfigResponse
     *
     * @param SetPolicyCommandConfigRequest $request
     *
     * @return SetPolicyCommandConfigResponse
     */
    public function setPolicyCommandConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setPolicyCommandConfigWithOptions($request, $runtime);
    }

    /**
     * Configures access control settings in a control policy.
     *
     * @param tmpReq - SetPolicyIPAclConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetPolicyIPAclConfigResponse
     *
     * @param SetPolicyIPAclConfigRequest $tmpReq
     * @param RuntimeOptions              $runtime
     *
     * @return SetPolicyIPAclConfigResponse
     */
    public function setPolicyIPAclConfigWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new SetPolicyIPAclConfigShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->IPAclConfig) {
            $request->IPAclConfigShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->IPAclConfig, 'IPAclConfig', 'json');
        }

        $query = [];
        if (null !== $request->IPAclConfigShrink) {
            @$query['IPAclConfig'] = $request->IPAclConfigShrink;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->policyId) {
            @$query['PolicyId'] = $request->policyId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SetPolicyIPAclConfig',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetPolicyIPAclConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures access control settings in a control policy.
     *
     * @param request - SetPolicyIPAclConfigRequest
     *
     * @returns SetPolicyIPAclConfigResponse
     *
     * @param SetPolicyIPAclConfigRequest $request
     *
     * @return SetPolicyIPAclConfigResponse
     */
    public function setPolicyIPAclConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setPolicyIPAclConfigWithOptions($request, $runtime);
    }

    /**
     * Modify the protocol control settings in a control policy.
     *
     * @param tmpReq - SetPolicyProtocolConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetPolicyProtocolConfigResponse
     *
     * @param SetPolicyProtocolConfigRequest $tmpReq
     * @param RuntimeOptions                 $runtime
     *
     * @return SetPolicyProtocolConfigResponse
     */
    public function setPolicyProtocolConfigWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new SetPolicyProtocolConfigShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->protocolConfig) {
            $request->protocolConfigShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->protocolConfig, 'ProtocolConfig', 'json');
        }

        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->policyId) {
            @$query['PolicyId'] = $request->policyId;
        }

        if (null !== $request->protocolConfigShrink) {
            @$query['ProtocolConfig'] = $request->protocolConfigShrink;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SetPolicyProtocolConfig',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetPolicyProtocolConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modify the protocol control settings in a control policy.
     *
     * @param request - SetPolicyProtocolConfigRequest
     *
     * @returns SetPolicyProtocolConfigResponse
     *
     * @param SetPolicyProtocolConfigRequest $request
     *
     * @return SetPolicyProtocolConfigResponse
     */
    public function setPolicyProtocolConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setPolicyProtocolConfigWithOptions($request, $runtime);
    }

    /**
     * Specifies the users to whom a control policy applies.
     *
     * @param request - SetPolicyUserScopeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetPolicyUserScopeResponse
     *
     * @param SetPolicyUserScopeRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return SetPolicyUserScopeResponse
     */
    public function setPolicyUserScopeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->policyId) {
            @$query['PolicyId'] = $request->policyId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->scopeType) {
            @$query['ScopeType'] = $request->scopeType;
        }

        if (null !== $request->userGroupIds) {
            @$query['UserGroupIds'] = $request->userGroupIds;
        }

        if (null !== $request->userIds) {
            @$query['UserIds'] = $request->userIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SetPolicyUserScope',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetPolicyUserScopeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Specifies the users to whom a control policy applies.
     *
     * @param request - SetPolicyUserScopeRequest
     *
     * @returns SetPolicyUserScopeResponse
     *
     * @param SetPolicyUserScopeRequest $request
     *
     * @return SetPolicyUserScopeResponse
     */
    public function setPolicyUserScope($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setPolicyUserScopeWithOptions($request, $runtime);
    }

    /**
     * Enables the specified bastion host.
     *
     * @param request - StartInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StartInstanceResponse
     *
     * @param StartInstanceRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return StartInstanceResponse
     */
    public function startInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientSecurityGroupIds) {
            @$query['ClientSecurityGroupIds'] = $request->clientSecurityGroupIds;
        }

        if (null !== $request->enablePortalPrivateAccess) {
            @$query['EnablePortalPrivateAccess'] = $request->enablePortalPrivateAccess;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->securityGroupIds) {
            @$query['SecurityGroupIds'] = $request->securityGroupIds;
        }

        if (null !== $request->slaveVswitchId) {
            @$query['SlaveVswitchId'] = $request->slaveVswitchId;
        }

        if (null !== $request->vswitchId) {
            @$query['VswitchId'] = $request->vswitchId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StartInstance',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StartInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables the specified bastion host.
     *
     * @param request - StartInstanceRequest
     *
     * @returns StartInstanceResponse
     *
     * @param StartInstanceRequest $request
     *
     * @return StartInstanceResponse
     */
    public function startInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startInstanceWithOptions($request, $runtime);
    }

    /**
     * Creates and adds tags to specified bastion hosts.
     *
     * @param request - TagResourcesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns TagResourcesResponse
     *
     * @param TagResourcesRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return TagResourcesResponse
     */
    public function tagResourcesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'TagResources',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return TagResourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates and adds tags to specified bastion hosts.
     *
     * @param request - TagResourcesRequest
     *
     * @returns TagResourcesResponse
     *
     * @param TagResourcesRequest $request
     *
     * @return TagResourcesResponse
     */
    public function tagResources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->tagResourcesWithOptions($request, $runtime);
    }

    /**
     * Unlocks one or more users of a bastion host.
     *
     * @remarks
     * After you call the [LockUsers](https://help.aliyun.com/document_detail/204591.html) operation to lock one or more users of a bastion host, you can call this operation to unlock the users. After the users are unlocked, the users can perform O\\&M operations by using the bastion host.
     * # Limits
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - UnlockUsersRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UnlockUsersResponse
     *
     * @param UnlockUsersRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return UnlockUsersResponse
     */
    public function unlockUsersWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->userIds) {
            @$query['UserIds'] = $request->userIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UnlockUsers',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UnlockUsersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Unlocks one or more users of a bastion host.
     *
     * @remarks
     * After you call the [LockUsers](https://help.aliyun.com/document_detail/204591.html) operation to lock one or more users of a bastion host, you can call this operation to unlock the users. After the users are unlocked, the users can perform O\\&M operations by using the bastion host.
     * # Limits
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - UnlockUsersRequest
     *
     * @returns UnlockUsersResponse
     *
     * @param UnlockUsersRequest $request
     *
     * @return UnlockUsersResponse
     */
    public function unlockUsers($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->unlockUsersWithOptions($request, $runtime);
    }

    /**
     * Removes tags from the specified bastion host and deletes the tags at a time.
     *
     * @param request - UntagResourcesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UntagResourcesResponse
     *
     * @param UntagResourcesRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return UntagResourcesResponse
     */
    public function untagResourcesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->all) {
            @$query['All'] = $request->all;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        if (null !== $request->tagKey) {
            @$query['TagKey'] = $request->tagKey;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UntagResources',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UntagResourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Removes tags from the specified bastion host and deletes the tags at a time.
     *
     * @param request - UntagResourcesRequest
     *
     * @returns UntagResourcesResponse
     *
     * @param UntagResourcesRequest $request
     *
     * @return UntagResourcesResponse
     */
    public function untagResources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->untagResourcesWithOptions($request, $runtime);
    }

    /**
     * 验证实例AD服务配置.
     *
     * @param request - VerifyInstanceADAuthServerRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns VerifyInstanceADAuthServerResponse
     *
     * @param VerifyInstanceADAuthServerRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return VerifyInstanceADAuthServerResponse
     */
    public function verifyInstanceADAuthServerWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->account) {
            @$query['Account'] = $request->account;
        }

        if (null !== $request->baseDN) {
            @$query['BaseDN'] = $request->baseDN;
        }

        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->filter) {
            @$query['Filter'] = $request->filter;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->isSSL) {
            @$query['IsSSL'] = $request->isSSL;
        }

        if (null !== $request->password) {
            @$query['Password'] = $request->password;
        }

        if (null !== $request->port) {
            @$query['Port'] = $request->port;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->server) {
            @$query['Server'] = $request->server;
        }

        if (null !== $request->standbyServer) {
            @$query['StandbyServer'] = $request->standbyServer;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'VerifyInstanceADAuthServer',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return VerifyInstanceADAuthServerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 验证实例AD服务配置.
     *
     * @param request - VerifyInstanceADAuthServerRequest
     *
     * @returns VerifyInstanceADAuthServerResponse
     *
     * @param VerifyInstanceADAuthServerRequest $request
     *
     * @return VerifyInstanceADAuthServerResponse
     */
    public function verifyInstanceADAuthServer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->verifyInstanceADAuthServerWithOptions($request, $runtime);
    }

    /**
     * 验证实例LDAP服务配置.
     *
     * @param request - VerifyInstanceLDAPAuthServerRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns VerifyInstanceLDAPAuthServerResponse
     *
     * @param VerifyInstanceLDAPAuthServerRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return VerifyInstanceLDAPAuthServerResponse
     */
    public function verifyInstanceLDAPAuthServerWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->account) {
            @$query['Account'] = $request->account;
        }

        if (null !== $request->baseDN) {
            @$query['BaseDN'] = $request->baseDN;
        }

        if (null !== $request->filter) {
            @$query['Filter'] = $request->filter;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->isSSL) {
            @$query['IsSSL'] = $request->isSSL;
        }

        if (null !== $request->password) {
            @$query['Password'] = $request->password;
        }

        if (null !== $request->port) {
            @$query['Port'] = $request->port;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->server) {
            @$query['Server'] = $request->server;
        }

        if (null !== $request->standbyServer) {
            @$query['StandbyServer'] = $request->standbyServer;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'VerifyInstanceLDAPAuthServer',
            'version' => '2019-12-09',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return VerifyInstanceLDAPAuthServerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 验证实例LDAP服务配置.
     *
     * @param request - VerifyInstanceLDAPAuthServerRequest
     *
     * @returns VerifyInstanceLDAPAuthServerResponse
     *
     * @param VerifyInstanceLDAPAuthServerRequest $request
     *
     * @return VerifyInstanceLDAPAuthServerResponse
     */
    public function verifyInstanceLDAPAuthServer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->verifyInstanceLDAPAuthServerWithOptions($request, $runtime);
    }
}
