<?php

// This file is auto-generated, don't edit it. Thanks.

namespace AlibabaCloud\SDK\Vpc\V20160428;

use AlibabaCloud\Endpoint\Endpoint;
use AlibabaCloud\OpenApiUtil\OpenApiUtilClient;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ActivateRouterInterfaceRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ActivateRouterInterfaceResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ActiveFlowLogRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ActiveFlowLogResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AddBgpNetworkRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AddBgpNetworkResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AddCommonBandwidthPackageIpRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AddCommonBandwidthPackageIpResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AddCommonBandwidthPackageIpsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AddCommonBandwidthPackageIpsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AddGlobalAccelerationInstanceIpRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AddGlobalAccelerationInstanceIpResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AddIPv6TranslatorAclListEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AddIPv6TranslatorAclListEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AddPublicIpAddressPoolCidrBlockRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AddPublicIpAddressPoolCidrBlockResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AddSourcesToTrafficMirrorSessionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AddSourcesToTrafficMirrorSessionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AllocateEipAddressProRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AllocateEipAddressProResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AllocateEipAddressRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AllocateEipAddressResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AllocateEipSegmentAddressRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AllocateEipSegmentAddressResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AllocateIpv6AddressRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AllocateIpv6AddressResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AllocateIpv6InternetBandwidthRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AllocateIpv6InternetBandwidthResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AllocateVpcIpv6CidrRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AllocateVpcIpv6CidrResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ApplyPhysicalConnectionLOARequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ApplyPhysicalConnectionLOAResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateEipAddressBatchRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateEipAddressBatchResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateEipAddressRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateEipAddressResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateHaVipRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateHaVipResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateNetworkAclRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateNetworkAclResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociatePhysicalConnectionToVirtualBorderRouterRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociatePhysicalConnectionToVirtualBorderRouterResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateRouteTableRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateRouteTableResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateRouteTablesWithVpcGatewayEndpointRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateRouteTablesWithVpcGatewayEndpointResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateRouteTableWithGatewayRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateRouteTableWithGatewayResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateVpcCidrBlockRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateVpcCidrBlockResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateVpnGatewayWithCertificateRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateVpnGatewayWithCertificateResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AttachDhcpOptionsSetToVpcRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AttachDhcpOptionsSetToVpcResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AttachVbrToVpconnRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AttachVbrToVpconnResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CancelCommonBandwidthPackageIpBandwidthRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CancelCommonBandwidthPackageIpBandwidthResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CancelPhysicalConnectionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CancelPhysicalConnectionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ChangeResourceGroupRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ChangeResourceGroupResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CheckCanAllocateVpcPrivateIpAddressRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CheckCanAllocateVpcPrivateIpAddressResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CheckVpnBgpEnabledRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CheckVpnBgpEnabledResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CompletePhysicalConnectionLOARequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CompletePhysicalConnectionLOAResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ConfirmPhysicalConnectionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ConfirmPhysicalConnectionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ConnectRouterInterfaceRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ConnectRouterInterfaceResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ConvertBandwidthPackageRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ConvertBandwidthPackageResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CopyNetworkAclEntriesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CopyNetworkAclEntriesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateBgpGroupRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateBgpGroupResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateBgpPeerRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateBgpPeerResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateCommonBandwidthPackageRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateCommonBandwidthPackageResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateCustomerGatewayRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateCustomerGatewayResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateDefaultVpcRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateDefaultVpcResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateDefaultVSwitchRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateDefaultVSwitchResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateDhcpOptionsSetRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateDhcpOptionsSetResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateExpressCloudConnectionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateExpressCloudConnectionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateExpressConnectTrafficQosQueueRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateExpressConnectTrafficQosQueueResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateExpressConnectTrafficQosRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateExpressConnectTrafficQosResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateExpressConnectTrafficQosRuleRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateExpressConnectTrafficQosRuleResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateFailoverTestJobRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateFailoverTestJobResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateFlowLogRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateFlowLogResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateForwardEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateForwardEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateFullNatEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateFullNatEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateGlobalAccelerationInstanceRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateGlobalAccelerationInstanceResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateHaVipRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateHaVipResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateHighReliablePhysicalConnectionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateHighReliablePhysicalConnectionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateIpsecServerRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateIpsecServerResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateIpv4GatewayRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateIpv4GatewayResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateIpv6EgressOnlyRuleRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateIpv6EgressOnlyRuleResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateIpv6GatewayRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateIpv6GatewayResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateIPv6TranslatorAclListRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateIPv6TranslatorAclListResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateIPv6TranslatorEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateIPv6TranslatorEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateIPv6TranslatorRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateIPv6TranslatorResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateNatGatewayRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateNatGatewayResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateNatGatewayShrinkRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateNatIpCidrRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateNatIpCidrResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateNatIpRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateNatIpResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateNetworkAclRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateNetworkAclResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreatePhysicalConnectionOccupancyOrderRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreatePhysicalConnectionOccupancyOrderResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreatePhysicalConnectionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreatePhysicalConnectionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreatePhysicalConnectionSetupOrderRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreatePhysicalConnectionSetupOrderResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreatePublicIpAddressPoolRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreatePublicIpAddressPoolResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateRouteEntriesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateRouteEntriesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateRouteEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateRouteEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateRouterInterfaceRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateRouterInterfaceResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateRouteTableRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateRouteTableResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateSnatEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateSnatEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateSslVpnClientCertRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateSslVpnClientCertResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateSslVpnServerRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateSslVpnServerResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateTrafficMirrorFilterRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateTrafficMirrorFilterResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateTrafficMirrorFilterRulesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateTrafficMirrorFilterRulesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateTrafficMirrorSessionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateTrafficMirrorSessionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVbrHaRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVbrHaResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVcoRouteEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVcoRouteEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVirtualBorderRouterRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVirtualBorderRouterResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVirtualPhysicalConnectionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVirtualPhysicalConnectionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpcGatewayEndpointRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpcGatewayEndpointResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpconnFromVbrRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpconnFromVbrResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpcPrefixListRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpcPrefixListResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpcRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpcResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpnAttachmentRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpnAttachmentResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpnConnectionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpnConnectionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpnGatewayRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpnGatewayResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpnPbrRouteEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpnPbrRouteEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpnRouteEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpnRouteEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVSwitchCidrReservationRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVSwitchCidrReservationResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVSwitchRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVSwitchResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeactivateRouterInterfaceRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeactivateRouterInterfaceResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeactiveFlowLogRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeactiveFlowLogResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteBgpGroupRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteBgpGroupResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteBgpNetworkRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteBgpNetworkResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteBgpPeerRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteBgpPeerResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteCommonBandwidthPackageRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteCommonBandwidthPackageResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteCustomerGatewayRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteCustomerGatewayResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteDhcpOptionsSetRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteDhcpOptionsSetResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteExpressConnectTrafficQosQueueRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteExpressConnectTrafficQosQueueResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteExpressConnectTrafficQosRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteExpressConnectTrafficQosResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteExpressConnectTrafficQosRuleRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteExpressConnectTrafficQosRuleResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteFailoverTestJobRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteFailoverTestJobResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteFlowLogRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteFlowLogResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteForwardEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteForwardEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteFullNatEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteFullNatEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteGlobalAccelerationInstanceRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteGlobalAccelerationInstanceResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteHaVipRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteHaVipResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteIpsecServerRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteIpsecServerResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteIpv4GatewayRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteIpv4GatewayResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteIpv6EgressOnlyRuleRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteIpv6EgressOnlyRuleResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteIpv6GatewayRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteIpv6GatewayResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteIpv6InternetBandwidthRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteIpv6InternetBandwidthResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteIPv6TranslatorAclListRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteIPv6TranslatorAclListResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteIPv6TranslatorEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteIPv6TranslatorEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteIPv6TranslatorRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteIPv6TranslatorResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteNatGatewayRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteNatGatewayResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteNatIpCidrRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteNatIpCidrResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteNatIpRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteNatIpResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteNetworkAclRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteNetworkAclResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeletePhysicalConnectionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeletePhysicalConnectionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeletePublicIpAddressPoolCidrBlockRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeletePublicIpAddressPoolCidrBlockResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeletePublicIpAddressPoolRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeletePublicIpAddressPoolResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteRouteEntriesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteRouteEntriesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteRouteEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteRouteEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteRouterInterfaceRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteRouterInterfaceResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteRouteTableRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteRouteTableResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteSnatEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteSnatEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteSslVpnClientCertRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteSslVpnClientCertResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteSslVpnServerRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteSslVpnServerResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteTrafficMirrorFilterRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteTrafficMirrorFilterResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteTrafficMirrorFilterRulesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteTrafficMirrorFilterRulesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteTrafficMirrorSessionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteTrafficMirrorSessionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVbrHaRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVbrHaResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVcoRouteEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVcoRouteEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVirtualBorderRouterRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVirtualBorderRouterResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVpcGatewayEndpointRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVpcGatewayEndpointResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVpcPrefixListRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVpcPrefixListResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVpcRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVpcResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVpnAttachmentRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVpnAttachmentResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVpnConnectionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVpnConnectionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVpnGatewayRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVpnGatewayResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVpnPbrRouteEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVpnPbrRouteEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVpnRouteEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVpnRouteEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVSwitchCidrReservationRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVSwitchCidrReservationResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVSwitchRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVSwitchResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeletionProtectionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeletionProtectionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\Describe95TrafficRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\Describe95TrafficResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeAccessPointsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeAccessPointsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeBgpGroupsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeBgpGroupsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeBgpNetworksRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeBgpNetworksResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeBgpPeersRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeBgpPeersResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeCommonBandwidthPackagesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeCommonBandwidthPackagesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeCustomerGatewayRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeCustomerGatewayResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeCustomerGatewaysRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeCustomerGatewaysResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeEcGrantRelationRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeEcGrantRelationResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeEipAddressesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeEipAddressesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeEipGatewayInfoRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeEipGatewayInfoResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeEipMonitorDataRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeEipMonitorDataResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeEipSegmentRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeEipSegmentResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeExpressConnectTrafficQosQueueRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeExpressConnectTrafficQosQueueResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeExpressConnectTrafficQosRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeExpressConnectTrafficQosResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeExpressConnectTrafficQosRuleRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeExpressConnectTrafficQosRuleResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeFailoverTestJobRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeFailoverTestJobResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeFailoverTestJobsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeFailoverTestJobsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeFlowLogsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeFlowLogsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeForwardTableEntriesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeForwardTableEntriesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeGlobalAccelerationInstancesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeGlobalAccelerationInstancesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeGrantRulesToCenRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeGrantRulesToCenResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeHaVipsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeHaVipsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeHighDefinitionMonitorLogAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeHighDefinitionMonitorLogAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeIpv6AddressesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeIpv6AddressesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeIpv6EgressOnlyRulesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeIpv6EgressOnlyRulesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeIpv6GatewayAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeIpv6GatewayAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeIpv6GatewaysRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeIpv6GatewaysResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeIPv6TranslatorAclListAttributesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeIPv6TranslatorAclListAttributesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeIPv6TranslatorAclListsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeIPv6TranslatorAclListsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeIPv6TranslatorEntriesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeIPv6TranslatorEntriesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeIPv6TranslatorsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeIPv6TranslatorsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeNatGatewayAssociateNetworkInterfacesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeNatGatewayAssociateNetworkInterfacesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeNatGatewaysRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeNatGatewaysResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeNetworkAclAttributesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeNetworkAclAttributesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeNetworkAclsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeNetworkAclsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribePhysicalConnectionLOARequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribePhysicalConnectionLOAResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribePhysicalConnectionsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribePhysicalConnectionsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribePublicIpAddressRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribePublicIpAddressResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeRegionsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeRegionsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeRouteEntryListRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeRouteEntryListResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeRouterInterfaceAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeRouterInterfaceAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeRouterInterfacesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeRouterInterfacesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeRouteTableListRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeRouteTableListResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeRouteTablesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeRouteTablesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeServerRelatedGlobalAccelerationInstancesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeServerRelatedGlobalAccelerationInstancesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeSnatTableEntriesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeSnatTableEntriesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeSslVpnClientCertRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeSslVpnClientCertResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeSslVpnClientCertsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeSslVpnClientCertsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeSslVpnClientsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeSslVpnClientsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeSslVpnServersRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeSslVpnServersResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeTagKeysForExpressConnectRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeTagKeysForExpressConnectResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeTagKeysRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeTagKeysResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeTagsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeTagsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVbrHaRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVbrHaResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVcoRouteEntriesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVcoRouteEntriesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVirtualBorderRoutersForPhysicalConnectionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVirtualBorderRoutersForPhysicalConnectionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVirtualBorderRoutersRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVirtualBorderRoutersResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpcAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpcAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpcsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpcsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnAttachmentsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnAttachmentsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnConnectionLogsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnConnectionLogsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnConnectionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnConnectionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnConnectionsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnConnectionsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnCrossAccountAuthorizationsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnCrossAccountAuthorizationsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnGatewayAvailableZonesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnGatewayAvailableZonesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnGatewayRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnGatewayResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnGatewaysRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnGatewaysResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnPbrRouteEntriesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnPbrRouteEntriesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnRouteEntriesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnRouteEntriesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnSslServerLogsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnSslServerLogsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVRoutersRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVRoutersResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVSwitchAttributesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVSwitchAttributesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVSwitchesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVSwitchesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeZonesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeZonesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DetachDhcpOptionsSetFromVpcRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DetachDhcpOptionsSetFromVpcResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DiagnoseVpnConnectionsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DiagnoseVpnConnectionsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DiagnoseVpnGatewayRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DiagnoseVpnGatewayResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DisableNatGatewayEcsMetricRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DisableNatGatewayEcsMetricResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DisableVpcClassicLinkRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DisableVpcClassicLinkResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DissociateRouteTableFromGatewayRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DissociateRouteTableFromGatewayResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DissociateRouteTablesFromVpcGatewayEndpointRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DissociateRouteTablesFromVpcGatewayEndpointResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DissociateVpnGatewayWithCertificateRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DissociateVpnGatewayWithCertificateResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DownloadVpnConnectionConfigRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DownloadVpnConnectionConfigResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\EnableNatGatewayEcsMetricRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\EnableNatGatewayEcsMetricResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\EnablePhysicalConnectionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\EnablePhysicalConnectionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\EnableVpcClassicLinkRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\EnableVpcClassicLinkResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\EnableVpcIpv4GatewayRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\EnableVpcIpv4GatewayResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetDhcpOptionsSetRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetDhcpOptionsSetResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetFlowLogServiceStatusRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetFlowLogServiceStatusResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetIpv4GatewayAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetIpv4GatewayAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetNatGatewayAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetNatGatewayAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetPhysicalConnectionServiceStatusRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetPhysicalConnectionServiceStatusResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetPublicIpAddressPoolServiceStatusRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetPublicIpAddressPoolServiceStatusResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetTrafficMirrorServiceStatusRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetTrafficMirrorServiceStatusResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetVpcGatewayEndpointAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetVpcGatewayEndpointAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetVpcPrefixListAssociationsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetVpcPrefixListAssociationsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetVpcPrefixListEntriesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetVpcPrefixListEntriesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetVpcRouteEntrySummaryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetVpcRouteEntrySummaryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetVpnGatewayDiagnoseResultRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetVpnGatewayDiagnoseResultResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetVSwitchCidrReservationUsageRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetVSwitchCidrReservationUsageResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GrantInstanceToCenRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GrantInstanceToCenResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GrantInstanceToVbrRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GrantInstanceToVbrResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GrantInstanceToVbrShrinkRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListBusinessAccessPointsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListBusinessAccessPointsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListDhcpOptionsSetsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListDhcpOptionsSetsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListEnhanhcedNatGatewayAvailableZonesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListEnhanhcedNatGatewayAvailableZonesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListFullNatEntriesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListFullNatEntriesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListGatewayRouteTableEntriesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListGatewayRouteTableEntriesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListGeographicSubRegionsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListIpsecServerLogsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListIpsecServerLogsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListIpsecServersRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListIpsecServersResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListIpv4GatewaysRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListIpv4GatewaysResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListNatIpCidrsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListNatIpCidrsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListNatIpsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListNatIpsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListPrefixListsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListPrefixListsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListPublicIpAddressPoolCidrBlocksRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListPublicIpAddressPoolCidrBlocksResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListPublicIpAddressPoolsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListPublicIpAddressPoolsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListTagResourcesForExpressConnectRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListTagResourcesForExpressConnectResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListTagResourcesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListTagResourcesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListTrafficMirrorFiltersRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListTrafficMirrorFiltersResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListTrafficMirrorSessionsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListTrafficMirrorSessionsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListVirtualPhysicalConnectionsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListVirtualPhysicalConnectionsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListVpcEndpointServicesByEndUserRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListVpcEndpointServicesByEndUserResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListVpcGatewayEndpointsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListVpcGatewayEndpointsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListVpcPublishedRouteEntriesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListVpcPublishedRouteEntriesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListVpnCertificateAssociationsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListVpnCertificateAssociationsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListVSwitchCidrReservationsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListVSwitchCidrReservationsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyBgpGroupAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyBgpGroupAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyBgpPeerAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyBgpPeerAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyCommonBandwidthPackageAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyCommonBandwidthPackageAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyCommonBandwidthPackageIpBandwidthRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyCommonBandwidthPackageIpBandwidthResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyCommonBandwidthPackageSpecRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyCommonBandwidthPackageSpecResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyCustomerGatewayAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyCustomerGatewayAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyEipAddressAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyEipAddressAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyExpressCloudConnectionAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyExpressCloudConnectionAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyExpressCloudConnectionBandwidthRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyExpressCloudConnectionBandwidthResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyExpressConnectTrafficQosQueueRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyExpressConnectTrafficQosQueueResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyExpressConnectTrafficQosRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyExpressConnectTrafficQosResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyExpressConnectTrafficQosRuleRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyExpressConnectTrafficQosRuleResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyFlowLogAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyFlowLogAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyForwardEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyForwardEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyFullNatEntryAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyFullNatEntryAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyGlobalAccelerationInstanceAttributesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyGlobalAccelerationInstanceAttributesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyGlobalAccelerationInstanceSpecRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyGlobalAccelerationInstanceSpecResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyHaVipAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyHaVipAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyIpv6AddressAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyIpv6AddressAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyIpv6GatewayAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyIpv6GatewayAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyIpv6InternetBandwidthRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyIpv6InternetBandwidthResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyIPv6TranslatorAclAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyIPv6TranslatorAclAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyIPv6TranslatorAclListEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyIPv6TranslatorAclListEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyIPv6TranslatorAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyIPv6TranslatorAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyIPv6TranslatorBandwidthRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyIPv6TranslatorBandwidthResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyIPv6TranslatorEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyIPv6TranslatorEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyNatGatewayAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyNatGatewayAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyNatGatewayAttributeShrinkRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyNatGatewaySpecRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyNatGatewaySpecResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyNatIpAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyNatIpAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyNatIpCidrAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyNatIpCidrAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyNetworkAclAttributesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyNetworkAclAttributesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyPhysicalConnectionAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyPhysicalConnectionAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyRouteEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyRouteEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyRouterInterfaceAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyRouterInterfaceAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyRouterInterfaceSpecRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyRouterInterfaceSpecResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyRouteTableAttributesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyRouteTableAttributesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifySnatEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifySnatEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifySslVpnClientCertRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifySslVpnClientCertResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifySslVpnServerRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifySslVpnServerResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyTunnelAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyTunnelAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVcoRouteEntryWeightRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVcoRouteEntryWeightResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVirtualBorderRouterAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVirtualBorderRouterAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpcAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpcAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpcPrefixListRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpcPrefixListResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpnAttachmentAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpnAttachmentAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpnConnectionAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpnConnectionAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpnGatewayAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpnGatewayAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpnPbrRouteEntryAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpnPbrRouteEntryAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpnPbrRouteEntryPriorityRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpnPbrRouteEntryPriorityResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpnPbrRouteEntryWeightRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpnPbrRouteEntryWeightResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpnRouteEntryWeightRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpnRouteEntryWeightResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVRouterAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVRouterAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVSwitchAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVSwitchAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVSwitchCidrReservationAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVSwitchCidrReservationAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\MoveResourceGroupRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\MoveResourceGroupResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\MoveVpnResourceGroupRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\MoveVpnResourceGroupResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\OpenFlowLogServiceRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\OpenFlowLogServiceResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\OpenPhysicalConnectionServiceRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\OpenPhysicalConnectionServiceResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\OpenPublicIpAddressPoolServiceRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\OpenPublicIpAddressPoolServiceResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\OpenTrafficMirrorServiceRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\OpenTrafficMirrorServiceResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\PublishVpcRouteEntriesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\PublishVpcRouteEntriesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\PublishVpnRouteEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\PublishVpnRouteEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RecoverPhysicalConnectionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RecoverPhysicalConnectionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RecoverVirtualBorderRouterRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RecoverVirtualBorderRouterResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ReleaseEipAddressRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ReleaseEipAddressResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ReleaseEipSegmentAddressRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ReleaseEipSegmentAddressResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ReleaseIpv6AddressRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ReleaseIpv6AddressResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RemoveCommonBandwidthPackageIpRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RemoveCommonBandwidthPackageIpResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RemoveGlobalAccelerationInstanceIpRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RemoveGlobalAccelerationInstanceIpResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RemoveIPv6TranslatorAclListEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RemoveIPv6TranslatorAclListEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RemoveSourcesFromTrafficMirrorSessionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RemoveSourcesFromTrafficMirrorSessionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ReplaceVpcDhcpOptionsSetRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ReplaceVpcDhcpOptionsSetResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RetryVpcPrefixListAssociationRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RetryVpcPrefixListAssociationResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RevokeInstanceFromCenRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RevokeInstanceFromCenResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RevokeInstanceFromVbrRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RevokeInstanceFromVbrResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RevokeInstanceFromVbrShrinkRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\SecondApplyPhysicalConnectionLOARequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\SecondApplyPhysicalConnectionLOAResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\SetHighDefinitionMonitorLogStatusRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\SetHighDefinitionMonitorLogStatusResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\StartFailoverTestJobRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\StartFailoverTestJobResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\StopFailoverTestJobRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\StopFailoverTestJobResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\TagResourcesForExpressConnectRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\TagResourcesForExpressConnectResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\TagResourcesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\TagResourcesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\TerminatePhysicalConnectionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\TerminatePhysicalConnectionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\TerminateVirtualBorderRouterRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\TerminateVirtualBorderRouterResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UnassociateEipAddressRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UnassociateEipAddressResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UnassociateGlobalAccelerationInstanceRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UnassociateGlobalAccelerationInstanceResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UnassociateHaVipRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UnassociateHaVipResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UnassociateNetworkAclRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UnassociateNetworkAclResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UnassociatePhysicalConnectionFromVirtualBorderRouterRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UnassociatePhysicalConnectionFromVirtualBorderRouterResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UnassociateRouteTableRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UnassociateRouteTableResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UnassociateVpcCidrBlockRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UnassociateVpcCidrBlockResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UntagResourcesForExpressConnectRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UntagResourcesForExpressConnectResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UnTagResourcesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UnTagResourcesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateDhcpOptionsSetAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateDhcpOptionsSetAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateFailoverTestJobRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateFailoverTestJobResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateGatewayRouteTableEntryAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateGatewayRouteTableEntryAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateIpsecServerRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateIpsecServerResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateIpv4GatewayAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateIpv4GatewayAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateNatGatewayNatTypeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateNatGatewayNatTypeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateNetworkAclEntriesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateNetworkAclEntriesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdatePublicIpAddressPoolAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdatePublicIpAddressPoolAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateTrafficMirrorFilterAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateTrafficMirrorFilterAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateTrafficMirrorFilterRuleAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateTrafficMirrorFilterRuleAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateTrafficMirrorSessionAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateTrafficMirrorSessionAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateVirtualBorderBandwidthRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateVirtualBorderBandwidthResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateVirtualPhysicalConnectionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateVirtualPhysicalConnectionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateVpcGatewayEndpointAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateVpcGatewayEndpointAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\WithdrawVpcPublishedRouteEntriesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\WithdrawVpcPublishedRouteEntriesResponse;
use AlibabaCloud\Tea\Tea;
use AlibabaCloud\Tea\Utils\Utils;
use AlibabaCloud\Tea\Utils\Utils\RuntimeOptions;
use Darabonba\OpenApi\Models\OpenApiRequest;
use Darabonba\OpenApi\Models\Params;
use Darabonba\OpenApi\OpenApiClient;

class Vpc extends OpenApiClient
{
    public function __construct($config)
    {
        parent::__construct($config);
        $this->_endpointRule = 'regional';
        $this->_endpointMap  = [
            'cn-hangzhou'                 => 'vpc.aliyuncs.com',
            'cn-shanghai-finance-1'       => 'vpc.aliyuncs.com',
            'cn-shenzhen-finance-1'       => 'vpc.aliyuncs.com',
            'cn-north-2-gov-1'            => 'vpc.aliyuncs.com',
            'ap-northeast-2-pop'          => 'vpc.aliyuncs.com',
            'cn-beijing-finance-pop'      => 'vpc.aliyuncs.com',
            'cn-beijing-gov-1'            => 'vpc.aliyuncs.com',
            'cn-beijing-nu16-b01'         => 'vpc.aliyuncs.com',
            'cn-edge-1'                   => 'vpc-nebula.cn-qingdao-nebula.aliyuncs.com',
            'cn-fujian'                   => 'vpc.aliyuncs.com',
            'cn-haidian-cm12-c01'         => 'vpc.aliyuncs.com',
            'cn-hangzhou-bj-b01'          => 'vpc.aliyuncs.com',
            'cn-hangzhou-finance'         => 'vpc.aliyuncs.com',
            'cn-hangzhou-internal-prod-1' => 'vpc.aliyuncs.com',
            'cn-hangzhou-internal-test-1' => 'vpc-pre.cn-hangzhou.aliyuncs.com',
            'cn-hangzhou-internal-test-2' => 'vpc-inner-pre.cn-hangzhou.aliyuncs.com',
            'cn-hangzhou-internal-test-3' => 'vpc-pre.cn-hangzhou.aliyuncs.com',
            'cn-hangzhou-test-306'        => 'vpc-pre.cn-hangzhou.aliyuncs.com',
            'cn-hongkong-finance-pop'     => 'vpc.aliyuncs.com',
            'cn-huhehaote-nebula-1'       => 'vpc-nebula.cn-qingdao-nebula.aliyuncs.com',
            'cn-qingdao-nebula'           => 'vpc-nebula.cn-qingdao-nebula.aliyuncs.com',
            'cn-shanghai-et15-b01'        => 'vpc-pre.cn-hangzhou.aliyuncs.com',
            'cn-shanghai-et2-b01'         => 'vpc.aliyuncs.com',
            'cn-shanghai-inner'           => 'vpc.aliyuncs.com',
            'cn-shanghai-internal-test-1' => 'vpc-pre.cn-hangzhou.aliyuncs.com',
            'cn-shenzhen-inner'           => 'vpc.aliyuncs.com',
            'cn-shenzhen-st4-d01'         => 'vpc.aliyuncs.com',
            'cn-shenzhen-su18-b01'        => 'vpc.aliyuncs.com',
            'cn-wuhan'                    => 'vpc.aliyuncs.com',
            'cn-yushanfang'               => 'vpc.aliyuncs.com',
            'cn-zhangbei'                 => 'vpc.aliyuncs.com',
            'cn-zhangbei-na61-b01'        => 'vpc.aliyuncs.com',
            'cn-zhangjiakou-na62-a01'     => 'vpc.cn-zhangjiakou.aliyuncs.com',
            'cn-zhengzhou-nebula-1'       => 'vpc-nebula.cn-qingdao-nebula.aliyuncs.com',
            'eu-west-1-oxs'               => 'vpc-nebula.cn-shenzhen-cloudstone.aliyuncs.com',
            'rus-west-1-pop'              => 'vpc.aliyuncs.com',
        ];
        $this->checkConfig($config);
        $this->_endpoint = $this->getEndpoint('vpc', $this->_regionId, $this->_endpointRule, $this->_network, $this->_suffix, $this->_endpointMap, $this->_endpoint);
    }

    /**
     * @param string   $productId
     * @param string   $regionId
     * @param string   $endpointRule
     * @param string   $network
     * @param string   $suffix
     * @param string[] $endpointMap
     * @param string   $endpoint
     *
     * @return string
     */
    public function getEndpoint($productId, $regionId, $endpointRule, $network, $suffix, $endpointMap, $endpoint)
    {
        if (!Utils::empty_($endpoint)) {
            return $endpoint;
        }
        if (!Utils::isUnset($endpointMap) && !Utils::empty_(@$endpointMap[$regionId])) {
            return @$endpointMap[$regionId];
        }

        return Endpoint::getEndpointRules($productId, $regionId, $endpointRule, $network, $suffix);
    }

    /**
     * @summary Activates a router interface that is in the Inactive state.
     *  *
     * @description After you call this operation, the router interface enters the **Activating** state. After the router interface is activated, it enters the **Active** state.
     * >  You cannot activate a router interface that has overdue payments.
     *  *
     * @param ActivateRouterInterfaceRequest $request ActivateRouterInterfaceRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return ActivateRouterInterfaceResponse ActivateRouterInterfaceResponse
     */
    public function activateRouterInterfaceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routerInterfaceId)) {
            $query['RouterInterfaceId'] = $request->routerInterfaceId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ActivateRouterInterface',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ActivateRouterInterfaceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Activates a router interface that is in the Inactive state.
     *  *
     * @description After you call this operation, the router interface enters the **Activating** state. After the router interface is activated, it enters the **Active** state.
     * >  You cannot activate a router interface that has overdue payments.
     *  *
     * @param ActivateRouterInterfaceRequest $request ActivateRouterInterfaceRequest
     *
     * @return ActivateRouterInterfaceResponse ActivateRouterInterfaceResponse
     */
    public function activateRouterInterface($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->activateRouterInterfaceWithOptions($request, $runtime);
    }

    /**
     * @summary Enables a flow log. After the flow log is enabled, traffic information about a resource is captured.
     *  *
     * @description *   The **ActiveFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
     *     *   If the flow log is in the **Activating** state, the flow log is being started.
     *     *   If the flow log is in the **Active** state, the flow log is started.
     * *   You cannot repeatedly call the **ActiveFlowLog** operation to start a flow log within the specified period of time.
     *  *
     * @param ActiveFlowLogRequest $request ActiveFlowLogRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return ActiveFlowLogResponse ActiveFlowLogResponse
     */
    public function activeFlowLogWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->flowLogId)) {
            $query['FlowLogId'] = $request->flowLogId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ActiveFlowLog',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ActiveFlowLogResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables a flow log. After the flow log is enabled, traffic information about a resource is captured.
     *  *
     * @description *   The **ActiveFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
     *     *   If the flow log is in the **Activating** state, the flow log is being started.
     *     *   If the flow log is in the **Active** state, the flow log is started.
     * *   You cannot repeatedly call the **ActiveFlowLog** operation to start a flow log within the specified period of time.
     *  *
     * @param ActiveFlowLogRequest $request ActiveFlowLogRequest
     *
     * @return ActiveFlowLogResponse ActiveFlowLogResponse
     */
    public function activeFlowLog($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->activeFlowLogWithOptions($request, $runtime);
    }

    /**
     * @summary Advertises a Border Gateway Protocol (BGP) network.
     *  *
     * @param AddBgpNetworkRequest $request AddBgpNetworkRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return AddBgpNetworkResponse AddBgpNetworkResponse
     */
    public function addBgpNetworkWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dstCidrBlock)) {
            $query['DstCidrBlock'] = $request->dstCidrBlock;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routerId)) {
            $query['RouterId'] = $request->routerId;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddBgpNetwork',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddBgpNetworkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Advertises a Border Gateway Protocol (BGP) network.
     *  *
     * @param AddBgpNetworkRequest $request AddBgpNetworkRequest
     *
     * @return AddBgpNetworkResponse AddBgpNetworkResponse
     */
    public function addBgpNetwork($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addBgpNetworkWithOptions($request, $runtime);
    }

    /**
     * @summary Associates an elastic IP address (EIP) with an Internet Shared Bandwidth instance.
     *  *
     * @description Before you call this operation, take note of the following items:
     * *   When you call this operation to associate an EIP with an Internet Shared Bandwidth instance, make sure that the EIP meets the following requirements:
     *     *   The EIP uses the pay-as-you-go billing method.
     *     *   The EIP and the Internet Shared Bandwidth instance belong to the same region.
     *     *   The line type of the EIPs is the same as that of the Internet Shared Bandwidth instance.
     * *   **AddCommonBandwidthPackageIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](https://help.aliyun.com/document_detail/120309.html) operation to query the status of the operation.
     *     *   If the Internet Shared Bandwidth instance is in the **BINDING** state, the EIP is being associated with the Internet Shared Bandwidth instance. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
     *     *   If the Internet Shared Bandwidth instance is in the **BINDED** state, the EIP is associated with the Internet Shared Bandwidth instance.
     *  *
     * @param AddCommonBandwidthPackageIpRequest $request AddCommonBandwidthPackageIpRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return AddCommonBandwidthPackageIpResponse AddCommonBandwidthPackageIpResponse
     */
    public function addCommonBandwidthPackageIpWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bandwidthPackageId)) {
            $query['BandwidthPackageId'] = $request->bandwidthPackageId;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ipInstanceId)) {
            $query['IpInstanceId'] = $request->ipInstanceId;
        }
        if (!Utils::isUnset($request->ipType)) {
            $query['IpType'] = $request->ipType;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddCommonBandwidthPackageIp',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddCommonBandwidthPackageIpResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Associates an elastic IP address (EIP) with an Internet Shared Bandwidth instance.
     *  *
     * @description Before you call this operation, take note of the following items:
     * *   When you call this operation to associate an EIP with an Internet Shared Bandwidth instance, make sure that the EIP meets the following requirements:
     *     *   The EIP uses the pay-as-you-go billing method.
     *     *   The EIP and the Internet Shared Bandwidth instance belong to the same region.
     *     *   The line type of the EIPs is the same as that of the Internet Shared Bandwidth instance.
     * *   **AddCommonBandwidthPackageIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](https://help.aliyun.com/document_detail/120309.html) operation to query the status of the operation.
     *     *   If the Internet Shared Bandwidth instance is in the **BINDING** state, the EIP is being associated with the Internet Shared Bandwidth instance. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
     *     *   If the Internet Shared Bandwidth instance is in the **BINDED** state, the EIP is associated with the Internet Shared Bandwidth instance.
     *  *
     * @param AddCommonBandwidthPackageIpRequest $request AddCommonBandwidthPackageIpRequest
     *
     * @return AddCommonBandwidthPackageIpResponse AddCommonBandwidthPackageIpResponse
     */
    public function addCommonBandwidthPackageIp($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addCommonBandwidthPackageIpWithOptions($request, $runtime);
    }

    /**
     * @summary Associates multiple elastic IP addresses (EIPs) with an Internet Shared Bandwidth instance.
     *  *
     * @description *   When you call this operation to associate EIPs with an Internet Shared Bandwidth instance, make sure that the EIPs meet the following requirements:
     *     *   The EIPs use the pay-as-you-go billing method.
     *     *   The EIP and the Internet Shared Bandwidth instance belong to the same region.
     *     *   The line type of the EIPs is the same as that of the Internet Shared Bandwidth instance.
     * *   **AddCommonBandwidthPackageIps** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](~~DescribeCommonBandwidthPackages~~) operation to query the status of the task.
     *     *   If the Internet Shared Bandwidth instance is in the **BINDING** state, the EIP is being associated with the Internet Shared Bandwidth instance. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
     *     *   If the Internet Shared Bandwidth instance is in the **BINDED** state, the EIP is associated with the Internet Shared Bandwidth instance.
     *  *
     * @param AddCommonBandwidthPackageIpsRequest $request AddCommonBandwidthPackageIpsRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return AddCommonBandwidthPackageIpsResponse AddCommonBandwidthPackageIpsResponse
     */
    public function addCommonBandwidthPackageIpsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bandwidthPackageId)) {
            $query['BandwidthPackageId'] = $request->bandwidthPackageId;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ipInstanceIds)) {
            $query['IpInstanceIds'] = $request->ipInstanceIds;
        }
        if (!Utils::isUnset($request->ipType)) {
            $query['IpType'] = $request->ipType;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddCommonBandwidthPackageIps',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddCommonBandwidthPackageIpsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Associates multiple elastic IP addresses (EIPs) with an Internet Shared Bandwidth instance.
     *  *
     * @description *   When you call this operation to associate EIPs with an Internet Shared Bandwidth instance, make sure that the EIPs meet the following requirements:
     *     *   The EIPs use the pay-as-you-go billing method.
     *     *   The EIP and the Internet Shared Bandwidth instance belong to the same region.
     *     *   The line type of the EIPs is the same as that of the Internet Shared Bandwidth instance.
     * *   **AddCommonBandwidthPackageIps** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](~~DescribeCommonBandwidthPackages~~) operation to query the status of the task.
     *     *   If the Internet Shared Bandwidth instance is in the **BINDING** state, the EIP is being associated with the Internet Shared Bandwidth instance. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
     *     *   If the Internet Shared Bandwidth instance is in the **BINDED** state, the EIP is associated with the Internet Shared Bandwidth instance.
     *  *
     * @param AddCommonBandwidthPackageIpsRequest $request AddCommonBandwidthPackageIpsRequest
     *
     * @return AddCommonBandwidthPackageIpsResponse AddCommonBandwidthPackageIpsResponse
     */
    public function addCommonBandwidthPackageIps($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addCommonBandwidthPackageIpsWithOptions($request, $runtime);
    }

    /**
     * @summary Associates an elastic IP address (EIP) with a shared-bandwidth Global Accelerator (GA) instance.
     *  *
     * @param AddGlobalAccelerationInstanceIpRequest $request AddGlobalAccelerationInstanceIpRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return AddGlobalAccelerationInstanceIpResponse AddGlobalAccelerationInstanceIpResponse
     */
    public function addGlobalAccelerationInstanceIpWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->globalAccelerationInstanceId)) {
            $query['GlobalAccelerationInstanceId'] = $request->globalAccelerationInstanceId;
        }
        if (!Utils::isUnset($request->ipInstanceId)) {
            $query['IpInstanceId'] = $request->ipInstanceId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddGlobalAccelerationInstanceIp',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddGlobalAccelerationInstanceIpResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Associates an elastic IP address (EIP) with a shared-bandwidth Global Accelerator (GA) instance.
     *  *
     * @param AddGlobalAccelerationInstanceIpRequest $request AddGlobalAccelerationInstanceIpRequest
     *
     * @return AddGlobalAccelerationInstanceIpResponse AddGlobalAccelerationInstanceIpResponse
     */
    public function addGlobalAccelerationInstanceIp($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addGlobalAccelerationInstanceIpWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI AddIPv6TranslatorAclListEntry is deprecated
     *  *
     * @summary Adds an IP entry to an access control list (ACL).
     *  *
     * Deprecated
     *
     * @param AddIPv6TranslatorAclListEntryRequest $request AddIPv6TranslatorAclListEntryRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return AddIPv6TranslatorAclListEntryResponse AddIPv6TranslatorAclListEntryResponse
     */
    public function addIPv6TranslatorAclListEntryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aclEntryComment)) {
            $query['AclEntryComment'] = $request->aclEntryComment;
        }
        if (!Utils::isUnset($request->aclEntryIp)) {
            $query['AclEntryIp'] = $request->aclEntryIp;
        }
        if (!Utils::isUnset($request->aclId)) {
            $query['AclId'] = $request->aclId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddIPv6TranslatorAclListEntry',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddIPv6TranslatorAclListEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI AddIPv6TranslatorAclListEntry is deprecated
     *  *
     * @summary Adds an IP entry to an access control list (ACL).
     *  *
     * Deprecated
     *
     * @param AddIPv6TranslatorAclListEntryRequest $request AddIPv6TranslatorAclListEntryRequest
     *
     * @return AddIPv6TranslatorAclListEntryResponse AddIPv6TranslatorAclListEntryResponse
     */
    public function addIPv6TranslatorAclListEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addIPv6TranslatorAclListEntryWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a CIDR block to an IP address pool.
     *  *
     * @description Before you call this operation, take note of the following limits:
     * *   The CIDR block and the IP address pool must belong to the same region.
     * *   The CIDR block and the IP address pool must use the same line type.
     * *   **AddPublicIpAddressPoolCidrBlock** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPoolCidrBlocks](https://help.aliyun.com/document_detail/429436.html) operation to query the status of the task.
     *     *   If the CIDR block is in the **Modifying** state, the CIDR block is being added. In this state, you can only query the CIDR block and cannot perform other operations.
     *     *   If the CIDR block is in the **Created** state, the CIDR block is added.
     * *   You cannot repeatedly call the **AddPublicIpAddressPoolCidrBlock** operation to add a CIDR block to an IP address pool within the specified period of time.
     *  *
     * @param AddPublicIpAddressPoolCidrBlockRequest $request AddPublicIpAddressPoolCidrBlockRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return AddPublicIpAddressPoolCidrBlockResponse AddPublicIpAddressPoolCidrBlockResponse
     */
    public function addPublicIpAddressPoolCidrBlockWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->cidrBlock)) {
            $query['CidrBlock'] = $request->cidrBlock;
        }
        if (!Utils::isUnset($request->cidrMask)) {
            $query['CidrMask'] = $request->cidrMask;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->publicIpAddressPoolId)) {
            $query['PublicIpAddressPoolId'] = $request->publicIpAddressPoolId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddPublicIpAddressPoolCidrBlock',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddPublicIpAddressPoolCidrBlockResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a CIDR block to an IP address pool.
     *  *
     * @description Before you call this operation, take note of the following limits:
     * *   The CIDR block and the IP address pool must belong to the same region.
     * *   The CIDR block and the IP address pool must use the same line type.
     * *   **AddPublicIpAddressPoolCidrBlock** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPoolCidrBlocks](https://help.aliyun.com/document_detail/429436.html) operation to query the status of the task.
     *     *   If the CIDR block is in the **Modifying** state, the CIDR block is being added. In this state, you can only query the CIDR block and cannot perform other operations.
     *     *   If the CIDR block is in the **Created** state, the CIDR block is added.
     * *   You cannot repeatedly call the **AddPublicIpAddressPoolCidrBlock** operation to add a CIDR block to an IP address pool within the specified period of time.
     *  *
     * @param AddPublicIpAddressPoolCidrBlockRequest $request AddPublicIpAddressPoolCidrBlockRequest
     *
     * @return AddPublicIpAddressPoolCidrBlockResponse AddPublicIpAddressPoolCidrBlockResponse
     */
    public function addPublicIpAddressPoolCidrBlock($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addPublicIpAddressPoolCidrBlockWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a traffic mirror source to a traffic mirror session.
     *  *
     * @description *   **AddSourcesToTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
     *     *   If the traffic mirror session is in the **Modifying** state, the traffic mirror source is being added to the traffic mirror session.
     *     *   If the traffic mirror session is in the **Created** state, the traffic mirror source is added to the traffic mirror session.
     * *   You cannot repeatedly call the **AddSourcesToTrafficMirrorSession** operation to add a traffic mirror source to a traffic mirror session within the specified period of time.
     *  *
     * @param AddSourcesToTrafficMirrorSessionRequest $request AddSourcesToTrafficMirrorSessionRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return AddSourcesToTrafficMirrorSessionResponse AddSourcesToTrafficMirrorSessionResponse
     */
    public function addSourcesToTrafficMirrorSessionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->trafficMirrorSessionId)) {
            $query['TrafficMirrorSessionId'] = $request->trafficMirrorSessionId;
        }
        if (!Utils::isUnset($request->trafficMirrorSourceIds)) {
            $query['TrafficMirrorSourceIds'] = $request->trafficMirrorSourceIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddSourcesToTrafficMirrorSession',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddSourcesToTrafficMirrorSessionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a traffic mirror source to a traffic mirror session.
     *  *
     * @description *   **AddSourcesToTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
     *     *   If the traffic mirror session is in the **Modifying** state, the traffic mirror source is being added to the traffic mirror session.
     *     *   If the traffic mirror session is in the **Created** state, the traffic mirror source is added to the traffic mirror session.
     * *   You cannot repeatedly call the **AddSourcesToTrafficMirrorSession** operation to add a traffic mirror source to a traffic mirror session within the specified period of time.
     *  *
     * @param AddSourcesToTrafficMirrorSessionRequest $request AddSourcesToTrafficMirrorSessionRequest
     *
     * @return AddSourcesToTrafficMirrorSessionResponse AddSourcesToTrafficMirrorSessionResponse
     */
    public function addSourcesToTrafficMirrorSession($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addSourcesToTrafficMirrorSessionWithOptions($request, $runtime);
    }

    /**
     * @summary Applies for an elastic IP address (EIP).
     *  *
     * @description Before you call this operation, make sure that you are familiar with the billing methods and pricing of EIPs. For more information, see [Billing overview](https://help.aliyun.com/document_detail/122035.html).
     * After you call this operation, the system randomly allocates an EIP that is in the **Available** state in the specified region. EIPs support only the ICMP, TCP, and UDP transport layer protocols. The IGMP and SCTP protocols are not supported.
     *  *
     * @param AllocateEipAddressRequest $request AllocateEipAddressRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return AllocateEipAddressResponse AllocateEipAddressResponse
     */
    public function allocateEipAddressWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->activityId)) {
            $query['ActivityId'] = $request->activityId;
        }
        if (!Utils::isUnset($request->autoPay)) {
            $query['AutoPay'] = $request->autoPay;
        }
        if (!Utils::isUnset($request->bandwidth)) {
            $query['Bandwidth'] = $request->bandwidth;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->ISP)) {
            $query['ISP'] = $request->ISP;
        }
        if (!Utils::isUnset($request->instanceChargeType)) {
            $query['InstanceChargeType'] = $request->instanceChargeType;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->internetChargeType)) {
            $query['InternetChargeType'] = $request->internetChargeType;
        }
        if (!Utils::isUnset($request->ipAddress)) {
            $query['IpAddress'] = $request->ipAddress;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->netmode)) {
            $query['Netmode'] = $request->netmode;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->period)) {
            $query['Period'] = $request->period;
        }
        if (!Utils::isUnset($request->pricingCycle)) {
            $query['PricingCycle'] = $request->pricingCycle;
        }
        if (!Utils::isUnset($request->publicIpAddressPoolId)) {
            $query['PublicIpAddressPoolId'] = $request->publicIpAddressPoolId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->securityProtectionTypes)) {
            $query['SecurityProtectionTypes'] = $request->securityProtectionTypes;
        }
        if (!Utils::isUnset($request->zone)) {
            $query['Zone'] = $request->zone;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AllocateEipAddress',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AllocateEipAddressResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Applies for an elastic IP address (EIP).
     *  *
     * @description Before you call this operation, make sure that you are familiar with the billing methods and pricing of EIPs. For more information, see [Billing overview](https://help.aliyun.com/document_detail/122035.html).
     * After you call this operation, the system randomly allocates an EIP that is in the **Available** state in the specified region. EIPs support only the ICMP, TCP, and UDP transport layer protocols. The IGMP and SCTP protocols are not supported.
     *  *
     * @param AllocateEipAddressRequest $request AllocateEipAddressRequest
     *
     * @return AllocateEipAddressResponse AllocateEipAddressResponse
     */
    public function allocateEipAddress($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->allocateEipAddressWithOptions($request, $runtime);
    }

    /**
     * @summary Requests a specified elastic IP address (EIP).
     *  *
     * @param AllocateEipAddressProRequest $request AllocateEipAddressProRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return AllocateEipAddressProResponse AllocateEipAddressProResponse
     */
    public function allocateEipAddressProWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->autoPay)) {
            $query['AutoPay'] = $request->autoPay;
        }
        if (!Utils::isUnset($request->bandwidth)) {
            $query['Bandwidth'] = $request->bandwidth;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ISP)) {
            $query['ISP'] = $request->ISP;
        }
        if (!Utils::isUnset($request->instanceChargeType)) {
            $query['InstanceChargeType'] = $request->instanceChargeType;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->internetChargeType)) {
            $query['InternetChargeType'] = $request->internetChargeType;
        }
        if (!Utils::isUnset($request->ipAddress)) {
            $query['IpAddress'] = $request->ipAddress;
        }
        if (!Utils::isUnset($request->netmode)) {
            $query['Netmode'] = $request->netmode;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->period)) {
            $query['Period'] = $request->period;
        }
        if (!Utils::isUnset($request->pricingCycle)) {
            $query['PricingCycle'] = $request->pricingCycle;
        }
        if (!Utils::isUnset($request->publicIpAddressPoolId)) {
            $query['PublicIpAddressPoolId'] = $request->publicIpAddressPoolId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->securityProtectionTypes)) {
            $query['SecurityProtectionTypes'] = $request->securityProtectionTypes;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AllocateEipAddressPro',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AllocateEipAddressProResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Requests a specified elastic IP address (EIP).
     *  *
     * @param AllocateEipAddressProRequest $request AllocateEipAddressProRequest
     *
     * @return AllocateEipAddressProResponse AllocateEipAddressProResponse
     */
    public function allocateEipAddressPro($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->allocateEipAddressProWithOptions($request, $runtime);
    }

    /**
     * @summary Applies for contiguous elastic IP addresses (EIPs).
     *  *
     * @description **AllocateEipSegmentAddress** is an asynchronous operation. After a request is sent, the system returns the ID of a contiguous EIP group and runs the task in the background. You can call the [DescribeEipSegment](https://help.aliyun.com/document_detail/156063.html) operation to query the status of the task.
     * *   If the contiguous EIP group is in the **Allocating** state, the EIPs are being allocated. In this case, you can only perform the query operation and cannot perform other operations.
     * *   If the contiguous EIP group is in the **Allocated** state, the EIPs are allocated.
     *  *
     * @param AllocateEipSegmentAddressRequest $request AllocateEipSegmentAddressRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return AllocateEipSegmentAddressResponse AllocateEipSegmentAddressResponse
     */
    public function allocateEipSegmentAddressWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bandwidth)) {
            $query['Bandwidth'] = $request->bandwidth;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->eipMask)) {
            $query['EipMask'] = $request->eipMask;
        }
        if (!Utils::isUnset($request->internetChargeType)) {
            $query['InternetChargeType'] = $request->internetChargeType;
        }
        if (!Utils::isUnset($request->isp)) {
            $query['Isp'] = $request->isp;
        }
        if (!Utils::isUnset($request->netmode)) {
            $query['Netmode'] = $request->netmode;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->zone)) {
            $query['Zone'] = $request->zone;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AllocateEipSegmentAddress',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AllocateEipSegmentAddressResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Applies for contiguous elastic IP addresses (EIPs).
     *  *
     * @description **AllocateEipSegmentAddress** is an asynchronous operation. After a request is sent, the system returns the ID of a contiguous EIP group and runs the task in the background. You can call the [DescribeEipSegment](https://help.aliyun.com/document_detail/156063.html) operation to query the status of the task.
     * *   If the contiguous EIP group is in the **Allocating** state, the EIPs are being allocated. In this case, you can only perform the query operation and cannot perform other operations.
     * *   If the contiguous EIP group is in the **Allocated** state, the EIPs are allocated.
     *  *
     * @param AllocateEipSegmentAddressRequest $request AllocateEipSegmentAddressRequest
     *
     * @return AllocateEipSegmentAddressResponse AllocateEipSegmentAddressResponse
     */
    public function allocateEipSegmentAddress($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->allocateEipSegmentAddressWithOptions($request, $runtime);
    }

    /**
     * @summary Assigns an IPv6 address.
     *  *
     * @param AllocateIpv6AddressRequest $request AllocateIpv6AddressRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return AllocateIpv6AddressResponse AllocateIpv6AddressResponse
     */
    public function allocateIpv6AddressWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->addressType)) {
            $query['AddressType'] = $request->addressType;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ipv6Address)) {
            $query['Ipv6Address'] = $request->ipv6Address;
        }
        if (!Utils::isUnset($request->ipv6AddressDescription)) {
            $query['Ipv6AddressDescription'] = $request->ipv6AddressDescription;
        }
        if (!Utils::isUnset($request->ipv6AddressName)) {
            $query['Ipv6AddressName'] = $request->ipv6AddressName;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->vSwitchId)) {
            $query['VSwitchId'] = $request->vSwitchId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AllocateIpv6Address',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AllocateIpv6AddressResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Assigns an IPv6 address.
     *  *
     * @param AllocateIpv6AddressRequest $request AllocateIpv6AddressRequest
     *
     * @return AllocateIpv6AddressResponse AllocateIpv6AddressResponse
     */
    public function allocateIpv6Address($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->allocateIpv6AddressWithOptions($request, $runtime);
    }

    /**
     * @summary Default IPv6 gateways support only private communication. You can call the AllocateIpv6InternetBandwidth operation to purchase Internet bandwidth resources for an IPv6 address. This way, ECS instances in a VPC can access the Internet through the IPv6 address. IPv6 clients can also access the ECS instances over the Internet.
     *  *
     * @description You cannot repeatedly call the **AllocateIpv6InternetBandwidth** operation within a specific time period.
     *  *
     * @param AllocateIpv6InternetBandwidthRequest $request AllocateIpv6InternetBandwidthRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return AllocateIpv6InternetBandwidthResponse AllocateIpv6InternetBandwidthResponse
     */
    public function allocateIpv6InternetBandwidthWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bandwidth)) {
            $query['Bandwidth'] = $request->bandwidth;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->internetChargeType)) {
            $query['InternetChargeType'] = $request->internetChargeType;
        }
        if (!Utils::isUnset($request->ipv6AddressId)) {
            $query['Ipv6AddressId'] = $request->ipv6AddressId;
        }
        if (!Utils::isUnset($request->ipv6GatewayId)) {
            $query['Ipv6GatewayId'] = $request->ipv6GatewayId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AllocateIpv6InternetBandwidth',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AllocateIpv6InternetBandwidthResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Default IPv6 gateways support only private communication. You can call the AllocateIpv6InternetBandwidth operation to purchase Internet bandwidth resources for an IPv6 address. This way, ECS instances in a VPC can access the Internet through the IPv6 address. IPv6 clients can also access the ECS instances over the Internet.
     *  *
     * @description You cannot repeatedly call the **AllocateIpv6InternetBandwidth** operation within a specific time period.
     *  *
     * @param AllocateIpv6InternetBandwidthRequest $request AllocateIpv6InternetBandwidthRequest
     *
     * @return AllocateIpv6InternetBandwidthResponse AllocateIpv6InternetBandwidthResponse
     */
    public function allocateIpv6InternetBandwidth($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->allocateIpv6InternetBandwidthWithOptions($request, $runtime);
    }

    /**
     * @summary Reserves an IPv6 CIDR block.
     *  *
     * @description # [](#)
     * The following section describes how to allocate an IPv6 CIDR block to a virtual private cloud (VPC):
     * 1.  Call the AllocateVpcIpv6Cidr operation to reserve the IPv6 CIDR block.
     * 2.  To allocate an IPv6 CIDR block to an existing VPC, call the [AssociateVpcCidrBlock](https://help.aliyun.com/document_detail/146745.html) operation. Set **RegionId**, **VpcId**, and **IPv6CidrBlock** to the IPv6 CIDR bock, and set **IpVersion** to **ipv6**. To allocate an IPv6 CIDR block when you create a VPC, call the [CreateVpc](https://help.aliyun.com/document_detail/35737.html) operation. Set **RegionId** and **Ipv6CidrBlock** to the IPv6 CIDR block, and set **EnableIpv6** to **true**.
     *  *
     * @param AllocateVpcIpv6CidrRequest $request AllocateVpcIpv6CidrRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return AllocateVpcIpv6CidrResponse AllocateVpcIpv6CidrResponse
     */
    public function allocateVpcIpv6CidrWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->addressPoolType)) {
            $query['AddressPoolType'] = $request->addressPoolType;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ipv6CidrBlock)) {
            $query['Ipv6CidrBlock'] = $request->ipv6CidrBlock;
        }
        if (!Utils::isUnset($request->ipv6Isp)) {
            $query['Ipv6Isp'] = $request->ipv6Isp;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AllocateVpcIpv6Cidr',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AllocateVpcIpv6CidrResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Reserves an IPv6 CIDR block.
     *  *
     * @description # [](#)
     * The following section describes how to allocate an IPv6 CIDR block to a virtual private cloud (VPC):
     * 1.  Call the AllocateVpcIpv6Cidr operation to reserve the IPv6 CIDR block.
     * 2.  To allocate an IPv6 CIDR block to an existing VPC, call the [AssociateVpcCidrBlock](https://help.aliyun.com/document_detail/146745.html) operation. Set **RegionId**, **VpcId**, and **IPv6CidrBlock** to the IPv6 CIDR bock, and set **IpVersion** to **ipv6**. To allocate an IPv6 CIDR block when you create a VPC, call the [CreateVpc](https://help.aliyun.com/document_detail/35737.html) operation. Set **RegionId** and **Ipv6CidrBlock** to the IPv6 CIDR block, and set **EnableIpv6** to **true**.
     *  *
     * @param AllocateVpcIpv6CidrRequest $request AllocateVpcIpv6CidrRequest
     *
     * @return AllocateVpcIpv6CidrResponse AllocateVpcIpv6CidrResponse
     */
    public function allocateVpcIpv6Cidr($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->allocateVpcIpv6CidrWithOptions($request, $runtime);
    }

    /**
     * @summary Applies for a Letter of Authorization (LOA) for an Express Connect circuit.
     *  *
     * @param ApplyPhysicalConnectionLOARequest $request ApplyPhysicalConnectionLOARequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return ApplyPhysicalConnectionLOAResponse ApplyPhysicalConnectionLOAResponse
     */
    public function applyPhysicalConnectionLOAWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bandwidth)) {
            $query['Bandwidth'] = $request->bandwidth;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->companyName)) {
            $query['CompanyName'] = $request->companyName;
        }
        if (!Utils::isUnset($request->constructionTime)) {
            $query['ConstructionTime'] = $request->constructionTime;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->lineType)) {
            $query['LineType'] = $request->lineType;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->PMInfo)) {
            $query['PMInfo'] = $request->PMInfo;
        }
        if (!Utils::isUnset($request->peerLocation)) {
            $query['PeerLocation'] = $request->peerLocation;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->si)) {
            $query['Si'] = $request->si;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ApplyPhysicalConnectionLOA',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ApplyPhysicalConnectionLOAResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Applies for a Letter of Authorization (LOA) for an Express Connect circuit.
     *  *
     * @param ApplyPhysicalConnectionLOARequest $request ApplyPhysicalConnectionLOARequest
     *
     * @return ApplyPhysicalConnectionLOAResponse ApplyPhysicalConnectionLOAResponse
     */
    public function applyPhysicalConnectionLOA($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->applyPhysicalConnectionLOAWithOptions($request, $runtime);
    }

    /**
     * @summary Associates an elastic IP address (EIP) with an instance in the same region.
     *  *
     * @description *   You can associate an EIP with an Elastic Compute Service (ECS) instance, a Classic Load Balancer (CLB) instance, a secondary elastic network interface (ENI), a NAT gateway, or a high-availability virtual IP address (HAVIP) in the same region. The ECS instance and CLB instance must be deployed in a virtual private cloud (VPC).
     * *   **AssociateEipAddress** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
     *     *   If the EIP is in the **Associating** state, the EIP is being associated. In this state, you can only query the EIP and cannot perform other operations.
     *     *   If the EIP is in the **InUse** state, the EIP is associated.
     * *   You cannot call the **AssociateEipAddress** operation to associate an EIP with multiple instances at a time.
     *  *
     * @param AssociateEipAddressRequest $request AssociateEipAddressRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return AssociateEipAddressResponse AssociateEipAddressResponse
     */
    public function associateEipAddressWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->allocationId)) {
            $query['AllocationId'] = $request->allocationId;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->instanceRegionId)) {
            $query['InstanceRegionId'] = $request->instanceRegionId;
        }
        if (!Utils::isUnset($request->instanceType)) {
            $query['InstanceType'] = $request->instanceType;
        }
        if (!Utils::isUnset($request->mode)) {
            $query['Mode'] = $request->mode;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->privateIpAddress)) {
            $query['PrivateIpAddress'] = $request->privateIpAddress;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AssociateEipAddress',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AssociateEipAddressResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Associates an elastic IP address (EIP) with an instance in the same region.
     *  *
     * @description *   You can associate an EIP with an Elastic Compute Service (ECS) instance, a Classic Load Balancer (CLB) instance, a secondary elastic network interface (ENI), a NAT gateway, or a high-availability virtual IP address (HAVIP) in the same region. The ECS instance and CLB instance must be deployed in a virtual private cloud (VPC).
     * *   **AssociateEipAddress** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
     *     *   If the EIP is in the **Associating** state, the EIP is being associated. In this state, you can only query the EIP and cannot perform other operations.
     *     *   If the EIP is in the **InUse** state, the EIP is associated.
     * *   You cannot call the **AssociateEipAddress** operation to associate an EIP with multiple instances at a time.
     *  *
     * @param AssociateEipAddressRequest $request AssociateEipAddressRequest
     *
     * @return AssociateEipAddressResponse AssociateEipAddressResponse
     */
    public function associateEipAddress($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->associateEipAddressWithOptions($request, $runtime);
    }

    /**
     * @summary Associates multiple elastic IP addresses (EIPs) with an instance in the same region.
     *  *
     * @description *   You can call the **AssociateEipAddressBatch** operation to associate EIPs with an instance in the same region. The instance must be a NAT gateway or a secondary elastic network interface (ENI). For more information about how to associate EIPs with other instances, see [AssociateEipAddress](https://help.aliyun.com/document_detail/120195.html).
     * *   **AssociateEipAddressBatch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
     *     *   If the EIP is in the **Associating** state, the EIP is being associated. You can only query the EIP and cannot perform other operations.
     *     *   If the EIP is in the **InUse** state, the EIP is associated.
     * *   You cannot call the **AssociateEipAddressBatch** operation to associate an EIP with multiple instances at a time.
     *  *
     * @param AssociateEipAddressBatchRequest $request AssociateEipAddressBatchRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return AssociateEipAddressBatchResponse AssociateEipAddressBatchResponse
     */
    public function associateEipAddressBatchWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bindedInstanceId)) {
            $query['BindedInstanceId'] = $request->bindedInstanceId;
        }
        if (!Utils::isUnset($request->bindedInstanceType)) {
            $query['BindedInstanceType'] = $request->bindedInstanceType;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->instanceIds)) {
            $query['InstanceIds'] = $request->instanceIds;
        }
        if (!Utils::isUnset($request->mode)) {
            $query['Mode'] = $request->mode;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AssociateEipAddressBatch',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AssociateEipAddressBatchResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Associates multiple elastic IP addresses (EIPs) with an instance in the same region.
     *  *
     * @description *   You can call the **AssociateEipAddressBatch** operation to associate EIPs with an instance in the same region. The instance must be a NAT gateway or a secondary elastic network interface (ENI). For more information about how to associate EIPs with other instances, see [AssociateEipAddress](https://help.aliyun.com/document_detail/120195.html).
     * *   **AssociateEipAddressBatch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
     *     *   If the EIP is in the **Associating** state, the EIP is being associated. You can only query the EIP and cannot perform other operations.
     *     *   If the EIP is in the **InUse** state, the EIP is associated.
     * *   You cannot call the **AssociateEipAddressBatch** operation to associate an EIP with multiple instances at a time.
     *  *
     * @param AssociateEipAddressBatchRequest $request AssociateEipAddressBatchRequest
     *
     * @return AssociateEipAddressBatchResponse AssociateEipAddressBatchResponse
     */
    public function associateEipAddressBatch($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->associateEipAddressBatchWithOptions($request, $runtime);
    }

    /**
     * @summary Associates a high-availability virtual IP address (HAVIP) with an Elastic Compute Service (ECS) instance or an elastic network interface (ENI).
     *  *
     * @description When you call this operation, take note of the following limits:
     * *   An HAVIP immediately takes effect after it is associated. You do not need to restart the ECS instance. However, you must associate the HAVIP with the ENI of the ECS instance.
     * *   The HAVIP and ECS instance must belong to the same vSwitch.
     * *   You can associate an HAVIP with at most two ECS instances.
     * *   The ECS instance must be in the **Running** or **Stopped** state.
     * *   The HAVIP must be in the **Available** or **InUse** state.
     * *   The **AssociateHaVip** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HAVIP:
     *     *   If the HAVIP is in the **Associating** state, the HAVIP is being associated.
     *     *   If the HAVIP is in the **InUse** state, the HAVIP is associated.
     * *   You cannot repeatedly call the **AssociateHaVip** operation to associate an HAVIP within the specified period of time.
     *  *
     * @param AssociateHaVipRequest $request AssociateHaVipRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return AssociateHaVipResponse AssociateHaVipResponse
     */
    public function associateHaVipWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->haVipId)) {
            $query['HaVipId'] = $request->haVipId;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->instanceType)) {
            $query['InstanceType'] = $request->instanceType;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AssociateHaVip',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AssociateHaVipResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Associates a high-availability virtual IP address (HAVIP) with an Elastic Compute Service (ECS) instance or an elastic network interface (ENI).
     *  *
     * @description When you call this operation, take note of the following limits:
     * *   An HAVIP immediately takes effect after it is associated. You do not need to restart the ECS instance. However, you must associate the HAVIP with the ENI of the ECS instance.
     * *   The HAVIP and ECS instance must belong to the same vSwitch.
     * *   You can associate an HAVIP with at most two ECS instances.
     * *   The ECS instance must be in the **Running** or **Stopped** state.
     * *   The HAVIP must be in the **Available** or **InUse** state.
     * *   The **AssociateHaVip** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HAVIP:
     *     *   If the HAVIP is in the **Associating** state, the HAVIP is being associated.
     *     *   If the HAVIP is in the **InUse** state, the HAVIP is associated.
     * *   You cannot repeatedly call the **AssociateHaVip** operation to associate an HAVIP within the specified period of time.
     *  *
     * @param AssociateHaVipRequest $request AssociateHaVipRequest
     *
     * @return AssociateHaVipResponse AssociateHaVipResponse
     */
    public function associateHaVip($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->associateHaVipWithOptions($request, $runtime);
    }

    /**
     * @summary Associates a network access control list (ACL) with a vSwitch.
     *  *
     * @description ## [](#)Description
     * *   **AssociateNetworkAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
     *     *   If the network ACL is in the **BINDING** state, the network ACL is being associated.
     *     *   If the network ACL is in the **BINDED** state, the network ACL is associated.
     * *   You cannot repeatedly call the **AssociateNetworkAcl** operation to associate a network ACL within the specified period of time.
     *  *
     * @param AssociateNetworkAclRequest $request AssociateNetworkAclRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return AssociateNetworkAclResponse AssociateNetworkAclResponse
     */
    public function associateNetworkAclWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->networkAclId)) {
            $query['NetworkAclId'] = $request->networkAclId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resource)) {
            $query['Resource'] = $request->resource;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AssociateNetworkAcl',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AssociateNetworkAclResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Associates a network access control list (ACL) with a vSwitch.
     *  *
     * @description ## [](#)Description
     * *   **AssociateNetworkAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
     *     *   If the network ACL is in the **BINDING** state, the network ACL is being associated.
     *     *   If the network ACL is in the **BINDED** state, the network ACL is associated.
     * *   You cannot repeatedly call the **AssociateNetworkAcl** operation to associate a network ACL within the specified period of time.
     *  *
     * @param AssociateNetworkAclRequest $request AssociateNetworkAclRequest
     *
     * @return AssociateNetworkAclResponse AssociateNetworkAclResponse
     */
    public function associateNetworkAcl($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->associateNetworkAclWithOptions($request, $runtime);
    }

    /**
     * @summary Associates a virtual border router (VBR) with a specified Express Connect circuit.
     *  *
     * @param AssociatePhysicalConnectionToVirtualBorderRouterRequest $request AssociatePhysicalConnectionToVirtualBorderRouterRequest
     * @param RuntimeOptions                                          $runtime runtime options for this request RuntimeOptions
     *
     * @return AssociatePhysicalConnectionToVirtualBorderRouterResponse AssociatePhysicalConnectionToVirtualBorderRouterResponse
     */
    public function associatePhysicalConnectionToVirtualBorderRouterWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->circuitCode)) {
            $query['CircuitCode'] = $request->circuitCode;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->enableIpv6)) {
            $query['EnableIpv6'] = $request->enableIpv6;
        }
        if (!Utils::isUnset($request->localGatewayIp)) {
            $query['LocalGatewayIp'] = $request->localGatewayIp;
        }
        if (!Utils::isUnset($request->localIpv6GatewayIp)) {
            $query['LocalIpv6GatewayIp'] = $request->localIpv6GatewayIp;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->peerGatewayIp)) {
            $query['PeerGatewayIp'] = $request->peerGatewayIp;
        }
        if (!Utils::isUnset($request->peerIpv6GatewayIp)) {
            $query['PeerIpv6GatewayIp'] = $request->peerIpv6GatewayIp;
        }
        if (!Utils::isUnset($request->peeringIpv6SubnetMask)) {
            $query['PeeringIpv6SubnetMask'] = $request->peeringIpv6SubnetMask;
        }
        if (!Utils::isUnset($request->peeringSubnetMask)) {
            $query['PeeringSubnetMask'] = $request->peeringSubnetMask;
        }
        if (!Utils::isUnset($request->physicalConnectionId)) {
            $query['PhysicalConnectionId'] = $request->physicalConnectionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vbrId)) {
            $query['VbrId'] = $request->vbrId;
        }
        if (!Utils::isUnset($request->vlanId)) {
            $query['VlanId'] = $request->vlanId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AssociatePhysicalConnectionToVirtualBorderRouter',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AssociatePhysicalConnectionToVirtualBorderRouterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Associates a virtual border router (VBR) with a specified Express Connect circuit.
     *  *
     * @param AssociatePhysicalConnectionToVirtualBorderRouterRequest $request AssociatePhysicalConnectionToVirtualBorderRouterRequest
     *
     * @return AssociatePhysicalConnectionToVirtualBorderRouterResponse AssociatePhysicalConnectionToVirtualBorderRouterResponse
     */
    public function associatePhysicalConnectionToVirtualBorderRouter($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->associatePhysicalConnectionToVirtualBorderRouterWithOptions($request, $runtime);
    }

    /**
     * @summary Associates a custom route table with a vSwitch in the same VPC.
     *  *
     * @description **AssociateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
     * *   If the vSwitch is in the **Pending** state, the route table is being associated with the vSwitch.
     * *   If the vSwitch is in the **Available** state, the route table is associated with the vSwitch.
     *  *
     * @param AssociateRouteTableRequest $request AssociateRouteTableRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return AssociateRouteTableResponse AssociateRouteTableResponse
     */
    public function associateRouteTableWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeTableId)) {
            $query['RouteTableId'] = $request->routeTableId;
        }
        if (!Utils::isUnset($request->vSwitchId)) {
            $query['VSwitchId'] = $request->vSwitchId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AssociateRouteTable',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AssociateRouteTableResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Associates a custom route table with a vSwitch in the same VPC.
     *  *
     * @description **AssociateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
     * *   If the vSwitch is in the **Pending** state, the route table is being associated with the vSwitch.
     * *   If the vSwitch is in the **Available** state, the route table is associated with the vSwitch.
     *  *
     * @param AssociateRouteTableRequest $request AssociateRouteTableRequest
     *
     * @return AssociateRouteTableResponse AssociateRouteTableResponse
     */
    public function associateRouteTable($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->associateRouteTableWithOptions($request, $runtime);
    }

    /**
     * @summary Associates a gateway route table with an IPv4 gateway in the same virtual private cloud (VPC).
     *  *
     * @param AssociateRouteTableWithGatewayRequest $request AssociateRouteTableWithGatewayRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return AssociateRouteTableWithGatewayResponse AssociateRouteTableWithGatewayResponse
     */
    public function associateRouteTableWithGatewayWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->gatewayId)) {
            $query['GatewayId'] = $request->gatewayId;
        }
        if (!Utils::isUnset($request->gatewayType)) {
            $query['GatewayType'] = $request->gatewayType;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeTableId)) {
            $query['RouteTableId'] = $request->routeTableId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AssociateRouteTableWithGateway',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AssociateRouteTableWithGatewayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Associates a gateway route table with an IPv4 gateway in the same virtual private cloud (VPC).
     *  *
     * @param AssociateRouteTableWithGatewayRequest $request AssociateRouteTableWithGatewayRequest
     *
     * @return AssociateRouteTableWithGatewayResponse AssociateRouteTableWithGatewayResponse
     */
    public function associateRouteTableWithGateway($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->associateRouteTableWithGatewayWithOptions($request, $runtime);
    }

    /**
     * @summary Associates a route table with a gateway endpoint.
     *  *
     * @description When you call this operation, take note of the following limits:
     * *   The gateway endpoint to be associated with the route table cannot be in one of the following states: **Creating**, **Modifying**, **Associating**, **Dissociating**, or **Deleting**.
     * *   The route table cannot be in one of the following states: **Creating**, **Modifying**, **Associating**, **Dissociating**, or **Deleting**.
     * *   The gateway endpoint and route table must belong to the same virtual private cloud (VPC).
     * *   The route table cannot be shared.
     * *   You cannot associate a gateway endpoint with a virtual border router (VBR) route table.
     * *   You can associate a gateway endpoint with at most 20 route tables at a time.
     * *   **AssociateRouteTablesWithVpcGatewayEndpoint** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetVpcGatewayEndpointAttribute](https://help.aliyun.com/document_detail/311017.html) operation to query whether a route table is associated with a gateway endpoint.
     *     *   If the **Associating** status is returned, the route table is being associated with the gateway endpoint.
     *     *   If the **Created** status is returned, the route table is associated with the gateway endpoint.
     * *   You cannot repeatedly call the **AssociateRouteTablesWithVpcGatewayEndpoint** operation within a specific period of time.
     *  *
     * @param AssociateRouteTablesWithVpcGatewayEndpointRequest $request AssociateRouteTablesWithVpcGatewayEndpointRequest
     * @param RuntimeOptions                                    $runtime runtime options for this request RuntimeOptions
     *
     * @return AssociateRouteTablesWithVpcGatewayEndpointResponse AssociateRouteTablesWithVpcGatewayEndpointResponse
     */
    public function associateRouteTablesWithVpcGatewayEndpointWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->endpointId)) {
            $query['EndpointId'] = $request->endpointId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeTableIds)) {
            $query['RouteTableIds'] = $request->routeTableIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AssociateRouteTablesWithVpcGatewayEndpoint',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AssociateRouteTablesWithVpcGatewayEndpointResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Associates a route table with a gateway endpoint.
     *  *
     * @description When you call this operation, take note of the following limits:
     * *   The gateway endpoint to be associated with the route table cannot be in one of the following states: **Creating**, **Modifying**, **Associating**, **Dissociating**, or **Deleting**.
     * *   The route table cannot be in one of the following states: **Creating**, **Modifying**, **Associating**, **Dissociating**, or **Deleting**.
     * *   The gateway endpoint and route table must belong to the same virtual private cloud (VPC).
     * *   The route table cannot be shared.
     * *   You cannot associate a gateway endpoint with a virtual border router (VBR) route table.
     * *   You can associate a gateway endpoint with at most 20 route tables at a time.
     * *   **AssociateRouteTablesWithVpcGatewayEndpoint** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetVpcGatewayEndpointAttribute](https://help.aliyun.com/document_detail/311017.html) operation to query whether a route table is associated with a gateway endpoint.
     *     *   If the **Associating** status is returned, the route table is being associated with the gateway endpoint.
     *     *   If the **Created** status is returned, the route table is associated with the gateway endpoint.
     * *   You cannot repeatedly call the **AssociateRouteTablesWithVpcGatewayEndpoint** operation within a specific period of time.
     *  *
     * @param AssociateRouteTablesWithVpcGatewayEndpointRequest $request AssociateRouteTablesWithVpcGatewayEndpointRequest
     *
     * @return AssociateRouteTablesWithVpcGatewayEndpointResponse AssociateRouteTablesWithVpcGatewayEndpointResponse
     */
    public function associateRouteTablesWithVpcGatewayEndpoint($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->associateRouteTablesWithVpcGatewayEndpointWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a secondary CIDR block to a virtual private cloud (VPC).
     *  *
     * @description ## [](#)
     * *   Take note of the following limits:
     *     *   Each VPC can contain up to five secondary IPv4 CIDR blocks.
     *     *   Each VPC can contain up to five secondary IPv6 CIDR blocks.
     * *   You cannot repeatedly call the **AssociateVpcCidrBlock** operation to add secondary CIDR blocks to a VPC within the specified period of time.
     *  *
     * @param AssociateVpcCidrBlockRequest $request AssociateVpcCidrBlockRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return AssociateVpcCidrBlockResponse AssociateVpcCidrBlockResponse
     */
    public function associateVpcCidrBlockWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->IPv6CidrBlock)) {
            $query['IPv6CidrBlock'] = $request->IPv6CidrBlock;
        }
        if (!Utils::isUnset($request->ipVersion)) {
            $query['IpVersion'] = $request->ipVersion;
        }
        if (!Utils::isUnset($request->ipamPoolId)) {
            $query['IpamPoolId'] = $request->ipamPoolId;
        }
        if (!Utils::isUnset($request->ipv6Isp)) {
            $query['Ipv6Isp'] = $request->ipv6Isp;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->secondaryCidrBlock)) {
            $query['SecondaryCidrBlock'] = $request->secondaryCidrBlock;
        }
        if (!Utils::isUnset($request->secondaryCidrMask)) {
            $query['SecondaryCidrMask'] = $request->secondaryCidrMask;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AssociateVpcCidrBlock',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AssociateVpcCidrBlockResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a secondary CIDR block to a virtual private cloud (VPC).
     *  *
     * @description ## [](#)
     * *   Take note of the following limits:
     *     *   Each VPC can contain up to five secondary IPv4 CIDR blocks.
     *     *   Each VPC can contain up to five secondary IPv6 CIDR blocks.
     * *   You cannot repeatedly call the **AssociateVpcCidrBlock** operation to add secondary CIDR blocks to a VPC within the specified period of time.
     *  *
     * @param AssociateVpcCidrBlockRequest $request AssociateVpcCidrBlockRequest
     *
     * @return AssociateVpcCidrBlockResponse AssociateVpcCidrBlockResponse
     */
    public function associateVpcCidrBlock($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->associateVpcCidrBlockWithOptions($request, $runtime);
    }

    /**
     * @summary Associates a VPN gateway with a certificate.
     *  *
     * @description Before you associate a VPN gateway with an SSL certificate, take note of the following items:
     * *   You can associate only VPN gateways of the ShangMi (SM) type with SSL certificates. You need to associate a VPN gateway of the SM type with two SSL certificates, one as the encryption certificate and the other as the signature certificate.
     * *   The SSL certificates must use the SM algorithm.
     * *   You cannot specify one SSL certificate as both the encryption certificate and signature certificate for one VPN gateway.
     * *   **AssociateVpnGatewayWithCertificate** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the SSL certificate is being associated.
     *     *   If the VPN gateway is in the **active** state, the SSL certificate is being associated.
     * *   You cannot call **AssociateVpnGatewayWithCertificate** within a specific period of time.
     * ### [](#)Prerequisites
     * Make sure that you have two SSL certificates that use the SM algorithm in the Certificate Management Service console. For more information about SSL certificates, see [What is Certificate Management Service?](https://help.aliyun.com/document_detail/28535.html).
     *  *
     * @param AssociateVpnGatewayWithCertificateRequest $request AssociateVpnGatewayWithCertificateRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return AssociateVpnGatewayWithCertificateResponse AssociateVpnGatewayWithCertificateResponse
     */
    public function associateVpnGatewayWithCertificateWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->certificateId)) {
            $query['CertificateId'] = $request->certificateId;
        }
        if (!Utils::isUnset($request->certificateType)) {
            $query['CertificateType'] = $request->certificateType;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->vpnGatewayId)) {
            $query['VpnGatewayId'] = $request->vpnGatewayId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AssociateVpnGatewayWithCertificate',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AssociateVpnGatewayWithCertificateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Associates a VPN gateway with a certificate.
     *  *
     * @description Before you associate a VPN gateway with an SSL certificate, take note of the following items:
     * *   You can associate only VPN gateways of the ShangMi (SM) type with SSL certificates. You need to associate a VPN gateway of the SM type with two SSL certificates, one as the encryption certificate and the other as the signature certificate.
     * *   The SSL certificates must use the SM algorithm.
     * *   You cannot specify one SSL certificate as both the encryption certificate and signature certificate for one VPN gateway.
     * *   **AssociateVpnGatewayWithCertificate** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the SSL certificate is being associated.
     *     *   If the VPN gateway is in the **active** state, the SSL certificate is being associated.
     * *   You cannot call **AssociateVpnGatewayWithCertificate** within a specific period of time.
     * ### [](#)Prerequisites
     * Make sure that you have two SSL certificates that use the SM algorithm in the Certificate Management Service console. For more information about SSL certificates, see [What is Certificate Management Service?](https://help.aliyun.com/document_detail/28535.html).
     *  *
     * @param AssociateVpnGatewayWithCertificateRequest $request AssociateVpnGatewayWithCertificateRequest
     *
     * @return AssociateVpnGatewayWithCertificateResponse AssociateVpnGatewayWithCertificateResponse
     */
    public function associateVpnGatewayWithCertificate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->associateVpnGatewayWithCertificateWithOptions($request, $runtime);
    }

    /**
     * @description *   The **AttachDhcpOptionsSetToVpc** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a DHCP options set:
     *     *   If the DHCP options set is in the **Pending** state, the DHCP options set is being associated.
     *     *   If the DHCP options set is in the **InUse** state, the DHCP options set is associated.
     * *   You cannot repeatedly call the **AttachDhcpOptionsSetToVpc** operation to associate DHCP options sets with a VPC within the specified period of time.
     *  *
     * @param AttachDhcpOptionsSetToVpcRequest $request AttachDhcpOptionsSetToVpcRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return AttachDhcpOptionsSetToVpcResponse AttachDhcpOptionsSetToVpcResponse
     */
    public function attachDhcpOptionsSetToVpcWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dhcpOptionsSetId)) {
            $query['DhcpOptionsSetId'] = $request->dhcpOptionsSetId;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AttachDhcpOptionsSetToVpc',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AttachDhcpOptionsSetToVpcResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @description *   The **AttachDhcpOptionsSetToVpc** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a DHCP options set:
     *     *   If the DHCP options set is in the **Pending** state, the DHCP options set is being associated.
     *     *   If the DHCP options set is in the **InUse** state, the DHCP options set is associated.
     * *   You cannot repeatedly call the **AttachDhcpOptionsSetToVpc** operation to associate DHCP options sets with a VPC within the specified period of time.
     *  *
     * @param AttachDhcpOptionsSetToVpcRequest $request AttachDhcpOptionsSetToVpcRequest
     *
     * @return AttachDhcpOptionsSetToVpcResponse AttachDhcpOptionsSetToVpcResponse
     */
    public function attachDhcpOptionsSetToVpc($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->attachDhcpOptionsSetToVpcWithOptions($request, $runtime);
    }

    /**
     * @summary Associates a virtual border router (VBR) with a hosted connection.
     *  *
     * @param AttachVbrToVpconnRequest $request AttachVbrToVpconnRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return AttachVbrToVpconnResponse AttachVbrToVpconnResponse
     */
    public function attachVbrToVpconnWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->token)) {
            $query['Token'] = $request->token;
        }
        if (!Utils::isUnset($request->vbrId)) {
            $query['VbrId'] = $request->vbrId;
        }
        if (!Utils::isUnset($request->vpconnId)) {
            $query['VpconnId'] = $request->vpconnId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AttachVbrToVpconn',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AttachVbrToVpconnResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Associates a virtual border router (VBR) with a hosted connection.
     *  *
     * @param AttachVbrToVpconnRequest $request AttachVbrToVpconnRequest
     *
     * @return AttachVbrToVpconnResponse AttachVbrToVpconnResponse
     */
    public function attachVbrToVpconn($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->attachVbrToVpconnWithOptions($request, $runtime);
    }

    /**
     * @summary Cancels the maximum bandwidth configured for an elastic IP address (EIP) that is associated with an Internet Shared Bandwidth instance.
     *  *
     * @description Before you call this operation, take note of the following items:
     * *   After this operation is performed, the maximum bandwidth of the EIP equals that of the Internet Shared Bandwidth instance.
     * *   You cannot repeatedly call the **CancelCommonBandwidthPackageIpBandwidth** operation within a specific time period.
     *  *
     * @param CancelCommonBandwidthPackageIpBandwidthRequest $request CancelCommonBandwidthPackageIpBandwidthRequest
     * @param RuntimeOptions                                 $runtime runtime options for this request RuntimeOptions
     *
     * @return CancelCommonBandwidthPackageIpBandwidthResponse CancelCommonBandwidthPackageIpBandwidthResponse
     */
    public function cancelCommonBandwidthPackageIpBandwidthWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bandwidthPackageId)) {
            $query['BandwidthPackageId'] = $request->bandwidthPackageId;
        }
        if (!Utils::isUnset($request->eipId)) {
            $query['EipId'] = $request->eipId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CancelCommonBandwidthPackageIpBandwidth',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CancelCommonBandwidthPackageIpBandwidthResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Cancels the maximum bandwidth configured for an elastic IP address (EIP) that is associated with an Internet Shared Bandwidth instance.
     *  *
     * @description Before you call this operation, take note of the following items:
     * *   After this operation is performed, the maximum bandwidth of the EIP equals that of the Internet Shared Bandwidth instance.
     * *   You cannot repeatedly call the **CancelCommonBandwidthPackageIpBandwidth** operation within a specific time period.
     *  *
     * @param CancelCommonBandwidthPackageIpBandwidthRequest $request CancelCommonBandwidthPackageIpBandwidthRequest
     *
     * @return CancelCommonBandwidthPackageIpBandwidthResponse CancelCommonBandwidthPackageIpBandwidthResponse
     */
    public function cancelCommonBandwidthPackageIpBandwidth($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->cancelCommonBandwidthPackageIpBandwidthWithOptions($request, $runtime);
    }

    /**
     * @summary Cancels an Express Connect circuit before it is enabled. After you perform this operation, the Express Connect circuit enters the Canceled state.
     *  *
     * @description You can cancel only an Express Connect circuit that is in the **Initial**, **Approved**, **Allocated**, or **Confirmed** state.
     *  *
     * @param CancelPhysicalConnectionRequest $request CancelPhysicalConnectionRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return CancelPhysicalConnectionResponse CancelPhysicalConnectionResponse
     */
    public function cancelPhysicalConnectionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->physicalConnectionId)) {
            $query['PhysicalConnectionId'] = $request->physicalConnectionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CancelPhysicalConnection',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CancelPhysicalConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Cancels an Express Connect circuit before it is enabled. After you perform this operation, the Express Connect circuit enters the Canceled state.
     *  *
     * @description You can cancel only an Express Connect circuit that is in the **Initial**, **Approved**, **Allocated**, or **Confirmed** state.
     *  *
     * @param CancelPhysicalConnectionRequest $request CancelPhysicalConnectionRequest
     *
     * @return CancelPhysicalConnectionResponse CancelPhysicalConnectionResponse
     */
    public function cancelPhysicalConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->cancelPhysicalConnectionWithOptions($request, $runtime);
    }

    /**
     * @summary Moves an Express Connect circuit to a new resource group.
     *  *
     * @description ## [](#)
     * You cannot repeatedly call the **ChangeResourceGroup** operation to modify the resource group of the same Express Connect circuit.
     *  *
     * @param ChangeResourceGroupRequest $request ChangeResourceGroupRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ChangeResourceGroupResponse ChangeResourceGroupResponse
     */
    public function changeResourceGroupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->newResourceGroupId)) {
            $query['NewResourceGroupId'] = $request->newResourceGroupId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceId)) {
            $query['ResourceId'] = $request->resourceId;
        }
        if (!Utils::isUnset($request->resourceType)) {
            $query['ResourceType'] = $request->resourceType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ChangeResourceGroup',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ChangeResourceGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Moves an Express Connect circuit to a new resource group.
     *  *
     * @description ## [](#)
     * You cannot repeatedly call the **ChangeResourceGroup** operation to modify the resource group of the same Express Connect circuit.
     *  *
     * @param ChangeResourceGroupRequest $request ChangeResourceGroupRequest
     *
     * @return ChangeResourceGroupResponse ChangeResourceGroupResponse
     */
    public function changeResourceGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->changeResourceGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Checks whether a private IP address in a specified vSwitch is available.
     *  *
     * @param CheckCanAllocateVpcPrivateIpAddressRequest $request CheckCanAllocateVpcPrivateIpAddressRequest
     * @param RuntimeOptions                             $runtime runtime options for this request RuntimeOptions
     *
     * @return CheckCanAllocateVpcPrivateIpAddressResponse CheckCanAllocateVpcPrivateIpAddressResponse
     */
    public function checkCanAllocateVpcPrivateIpAddressWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ipVersion)) {
            $query['IpVersion'] = $request->ipVersion;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->privateIpAddress)) {
            $query['PrivateIpAddress'] = $request->privateIpAddress;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vSwitchId)) {
            $query['VSwitchId'] = $request->vSwitchId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CheckCanAllocateVpcPrivateIpAddress',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CheckCanAllocateVpcPrivateIpAddressResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Checks whether a private IP address in a specified vSwitch is available.
     *  *
     * @param CheckCanAllocateVpcPrivateIpAddressRequest $request CheckCanAllocateVpcPrivateIpAddressRequest
     *
     * @return CheckCanAllocateVpcPrivateIpAddressResponse CheckCanAllocateVpcPrivateIpAddressResponse
     */
    public function checkCanAllocateVpcPrivateIpAddress($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkCanAllocateVpcPrivateIpAddressWithOptions($request, $runtime);
    }

    /**
     * @summary Checks whether the region of an IPsec-VPN connection supports BGP.
     *  *
     * @param CheckVpnBgpEnabledRequest $request CheckVpnBgpEnabledRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return CheckVpnBgpEnabledResponse CheckVpnBgpEnabledResponse
     */
    public function checkVpnBgpEnabledWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CheckVpnBgpEnabled',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CheckVpnBgpEnabledResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Checks whether the region of an IPsec-VPN connection supports BGP.
     *  *
     * @param CheckVpnBgpEnabledRequest $request CheckVpnBgpEnabledRequest
     *
     * @return CheckVpnBgpEnabledResponse CheckVpnBgpEnabledResponse
     */
    public function checkVpnBgpEnabled($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkVpnBgpEnabledWithOptions($request, $runtime);
    }

    /**
     * @summary Generates a report for an installed Express Connect circuit.
     *  *
     * @param CompletePhysicalConnectionLOARequest $request CompletePhysicalConnectionLOARequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return CompletePhysicalConnectionLOAResponse CompletePhysicalConnectionLOAResponse
     */
    public function completePhysicalConnectionLOAWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->finishWork)) {
            $query['FinishWork'] = $request->finishWork;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->lineCode)) {
            $query['LineCode'] = $request->lineCode;
        }
        if (!Utils::isUnset($request->lineLabel)) {
            $query['LineLabel'] = $request->lineLabel;
        }
        if (!Utils::isUnset($request->lineSPContactInfo)) {
            $query['LineSPContactInfo'] = $request->lineSPContactInfo;
        }
        if (!Utils::isUnset($request->lineServiceProvider)) {
            $query['LineServiceProvider'] = $request->lineServiceProvider;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CompletePhysicalConnectionLOA',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CompletePhysicalConnectionLOAResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Generates a report for an installed Express Connect circuit.
     *  *
     * @param CompletePhysicalConnectionLOARequest $request CompletePhysicalConnectionLOARequest
     *
     * @return CompletePhysicalConnectionLOAResponse CompletePhysicalConnectionLOAResponse
     */
    public function completePhysicalConnectionLOA($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->completePhysicalConnectionLOAWithOptions($request, $runtime);
    }

    /**
     * @summary Changes the status of an Express Connect circuit to Confirmed.
     *  *
     * @param ConfirmPhysicalConnectionRequest $request ConfirmPhysicalConnectionRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ConfirmPhysicalConnectionResponse ConfirmPhysicalConnectionResponse
     */
    public function confirmPhysicalConnectionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->physicalConnectionId)) {
            $query['PhysicalConnectionId'] = $request->physicalConnectionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ConfirmPhysicalConnection',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ConfirmPhysicalConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Changes the status of an Express Connect circuit to Confirmed.
     *  *
     * @param ConfirmPhysicalConnectionRequest $request ConfirmPhysicalConnectionRequest
     *
     * @return ConfirmPhysicalConnectionResponse ConfirmPhysicalConnectionResponse
     */
    public function confirmPhysicalConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->confirmPhysicalConnectionWithOptions($request, $runtime);
    }

    /**
     * @summary Initiates a connection from the router interface of an initiator to the router interface of an accepter.
     *  *
     * @description After you call this operation, the router interface enters the **Connecting** state. When the connection is established, it enters the **Active** state.
     * When you call this operation, take note of the following items:
     * *   Only an initiator router interface in the **Idle** state can initiate a connection.
     * *   You can create only one pair of connected router interfaces between two routers.
     * *   You cannot initiate a connection if your Alibaba Cloud account has a router interface with overdue payments.
     *  *
     * @param ConnectRouterInterfaceRequest $request ConnectRouterInterfaceRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return ConnectRouterInterfaceResponse ConnectRouterInterfaceResponse
     */
    public function connectRouterInterfaceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routerInterfaceId)) {
            $query['RouterInterfaceId'] = $request->routerInterfaceId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ConnectRouterInterface',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ConnectRouterInterfaceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Initiates a connection from the router interface of an initiator to the router interface of an accepter.
     *  *
     * @description After you call this operation, the router interface enters the **Connecting** state. When the connection is established, it enters the **Active** state.
     * When you call this operation, take note of the following items:
     * *   Only an initiator router interface in the **Idle** state can initiate a connection.
     * *   You can create only one pair of connected router interfaces between two routers.
     * *   You cannot initiate a connection if your Alibaba Cloud account has a router interface with overdue payments.
     *  *
     * @param ConnectRouterInterfaceRequest $request ConnectRouterInterfaceRequest
     *
     * @return ConnectRouterInterfaceResponse ConnectRouterInterfaceResponse
     */
    public function connectRouterInterface($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->connectRouterInterfaceWithOptions($request, $runtime);
    }

    /**
     * @summary Converts a NAT service plan to an Internet Shared Bandwidth instance.
     *  *
     * @description Before you convert a NAT service plan to an Internet Shared Bandwidth instance, take note of the following limits:
     * *   You are not charged for the conversion.
     * *   When you convert a NAT service plan to an Internet Shared Bandwidth instance, you can continue to use the SNAT and DNAT features of the NAT gateway, and your workloads are not affected. However, we recommend that you convert your NAT service plan during off-peak hours.
     * *   After the NAT service plan is converted to an Internet Shared Bandwidth instance, the public IP addresses in the NAT service plan are converted to elastic IP addresses (EIPs). The maximum bandwidth and billing method of the Internet Shared Bandwidth instance are the same as those of the NAT service plan.
     *  *
     * @param ConvertBandwidthPackageRequest $request ConvertBandwidthPackageRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return ConvertBandwidthPackageResponse ConvertBandwidthPackageResponse
     */
    public function convertBandwidthPackageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bandwidthPackageId)) {
            $query['BandwidthPackageId'] = $request->bandwidthPackageId;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ConvertBandwidthPackage',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ConvertBandwidthPackageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Converts a NAT service plan to an Internet Shared Bandwidth instance.
     *  *
     * @description Before you convert a NAT service plan to an Internet Shared Bandwidth instance, take note of the following limits:
     * *   You are not charged for the conversion.
     * *   When you convert a NAT service plan to an Internet Shared Bandwidth instance, you can continue to use the SNAT and DNAT features of the NAT gateway, and your workloads are not affected. However, we recommend that you convert your NAT service plan during off-peak hours.
     * *   After the NAT service plan is converted to an Internet Shared Bandwidth instance, the public IP addresses in the NAT service plan are converted to elastic IP addresses (EIPs). The maximum bandwidth and billing method of the Internet Shared Bandwidth instance are the same as those of the NAT service plan.
     *  *
     * @param ConvertBandwidthPackageRequest $request ConvertBandwidthPackageRequest
     *
     * @return ConvertBandwidthPackageResponse ConvertBandwidthPackageResponse
     */
    public function convertBandwidthPackage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->convertBandwidthPackageWithOptions($request, $runtime);
    }

    /**
     * @summary Copies rules of a network access control list (ACL).
     *  *
     * @description ## [](#)Description
     * *   **CopyNetworkAclEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
     *     *   If the network ACL is in the **Modifying** state, the rules of the network ACL are being copied.
     *     *   If the network ACL is in the **Available** state, the rules of the network ACL are copied.
     * *   You cannot repeatedly call the **CopyNetworkAclEntries** operation within the specified period of time.
     *  *
     * @param CopyNetworkAclEntriesRequest $request CopyNetworkAclEntriesRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return CopyNetworkAclEntriesResponse CopyNetworkAclEntriesResponse
     */
    public function copyNetworkAclEntriesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->networkAclId)) {
            $query['NetworkAclId'] = $request->networkAclId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceNetworkAclId)) {
            $query['SourceNetworkAclId'] = $request->sourceNetworkAclId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CopyNetworkAclEntries',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CopyNetworkAclEntriesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Copies rules of a network access control list (ACL).
     *  *
     * @description ## [](#)Description
     * *   **CopyNetworkAclEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
     *     *   If the network ACL is in the **Modifying** state, the rules of the network ACL are being copied.
     *     *   If the network ACL is in the **Available** state, the rules of the network ACL are copied.
     * *   You cannot repeatedly call the **CopyNetworkAclEntries** operation within the specified period of time.
     *  *
     * @param CopyNetworkAclEntriesRequest $request CopyNetworkAclEntriesRequest
     *
     * @return CopyNetworkAclEntriesResponse CopyNetworkAclEntriesResponse
     */
    public function copyNetworkAclEntries($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->copyNetworkAclEntriesWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a BGP group for a virtual border router (VBR).
     *  *
     * @description You can connect a VBR to a data center through BGP. Each BGP group is associated with a VBR. You can add a BGP peer that needs to communicate with a VBR to a BGP group and advertise the BGP network in the VBR.
     * BGP groups are used to simplify BGP configurations. You can add BGP peers that use the same configurations to one BGP group. Before you start, you must create a BGP group with the requested autonomous system number (ASN).
     * When you call this operation, take note of the following limits:
     * *   You can specify only the data center that is connected to the VBR through an Express Connect circuit as a BGP peer.
     * *   VBRs support only BGP-4.
     * *   You can create at most eight BGP peers for each VBR.
     * *   Each BGP peer supports at most 110 dynamic routes.
     * *   The ASN of Alibaba Cloud is 45104. You can specify a 2-byte or 4-byte ASN for the data center.
     *  *
     * @param CreateBgpGroupRequest $request CreateBgpGroupRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateBgpGroupResponse CreateBgpGroupResponse
     */
    public function createBgpGroupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->authKey)) {
            $query['AuthKey'] = $request->authKey;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->ipVersion)) {
            $query['IpVersion'] = $request->ipVersion;
        }
        if (!Utils::isUnset($request->isFakeAsn)) {
            $query['IsFakeAsn'] = $request->isFakeAsn;
        }
        if (!Utils::isUnset($request->localAsn)) {
            $query['LocalAsn'] = $request->localAsn;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->peerAsn)) {
            $query['PeerAsn'] = $request->peerAsn;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeQuota)) {
            $query['RouteQuota'] = $request->routeQuota;
        }
        if (!Utils::isUnset($request->routerId)) {
            $query['RouterId'] = $request->routerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateBgpGroup',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateBgpGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a BGP group for a virtual border router (VBR).
     *  *
     * @description You can connect a VBR to a data center through BGP. Each BGP group is associated with a VBR. You can add a BGP peer that needs to communicate with a VBR to a BGP group and advertise the BGP network in the VBR.
     * BGP groups are used to simplify BGP configurations. You can add BGP peers that use the same configurations to one BGP group. Before you start, you must create a BGP group with the requested autonomous system number (ASN).
     * When you call this operation, take note of the following limits:
     * *   You can specify only the data center that is connected to the VBR through an Express Connect circuit as a BGP peer.
     * *   VBRs support only BGP-4.
     * *   You can create at most eight BGP peers for each VBR.
     * *   Each BGP peer supports at most 110 dynamic routes.
     * *   The ASN of Alibaba Cloud is 45104. You can specify a 2-byte or 4-byte ASN for the data center.
     *  *
     * @param CreateBgpGroupRequest $request CreateBgpGroupRequest
     *
     * @return CreateBgpGroupResponse CreateBgpGroupResponse
     */
    public function createBgpGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createBgpGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a Border Gateway Protocol (BGP) peer to a BGP group.
     *  *
     * @param CreateBgpPeerRequest $request CreateBgpPeerRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateBgpPeerResponse CreateBgpPeerResponse
     */
    public function createBgpPeerWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bfdMultiHop)) {
            $query['BfdMultiHop'] = $request->bfdMultiHop;
        }
        if (!Utils::isUnset($request->bgpGroupId)) {
            $query['BgpGroupId'] = $request->bgpGroupId;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->enableBfd)) {
            $query['EnableBfd'] = $request->enableBfd;
        }
        if (!Utils::isUnset($request->ipVersion)) {
            $query['IpVersion'] = $request->ipVersion;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->peerIpAddress)) {
            $query['PeerIpAddress'] = $request->peerIpAddress;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateBgpPeer',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateBgpPeerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a Border Gateway Protocol (BGP) peer to a BGP group.
     *  *
     * @param CreateBgpPeerRequest $request CreateBgpPeerRequest
     *
     * @return CreateBgpPeerResponse CreateBgpPeerResponse
     */
    public function createBgpPeer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createBgpPeerWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an Internet Shared Bandwidth instance.
     *  *
     * @param CreateCommonBandwidthPackageRequest $request CreateCommonBandwidthPackageRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateCommonBandwidthPackageResponse CreateCommonBandwidthPackageResponse
     */
    public function createCommonBandwidthPackageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bandwidth)) {
            $query['Bandwidth'] = $request->bandwidth;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->ISP)) {
            $query['ISP'] = $request->ISP;
        }
        if (!Utils::isUnset($request->internetChargeType)) {
            $query['InternetChargeType'] = $request->internetChargeType;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->ratio)) {
            $query['Ratio'] = $request->ratio;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->securityProtectionTypes)) {
            $query['SecurityProtectionTypes'] = $request->securityProtectionTypes;
        }
        if (!Utils::isUnset($request->zone)) {
            $query['Zone'] = $request->zone;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateCommonBandwidthPackage',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateCommonBandwidthPackageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an Internet Shared Bandwidth instance.
     *  *
     * @param CreateCommonBandwidthPackageRequest $request CreateCommonBandwidthPackageRequest
     *
     * @return CreateCommonBandwidthPackageResponse CreateCommonBandwidthPackageResponse
     */
    public function createCommonBandwidthPackage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createCommonBandwidthPackageWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a customer gateway.
     *  *
     * @param CreateCustomerGatewayRequest $request CreateCustomerGatewayRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateCustomerGatewayResponse CreateCustomerGatewayResponse
     */
    public function createCustomerGatewayWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->asn)) {
            $query['Asn'] = $request->asn;
        }
        if (!Utils::isUnset($request->authKey)) {
            $query['AuthKey'] = $request->authKey;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->ipAddress)) {
            $query['IpAddress'] = $request->ipAddress;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tags)) {
            $query['Tags'] = $request->tags;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateCustomerGateway',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateCustomerGatewayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a customer gateway.
     *  *
     * @param CreateCustomerGatewayRequest $request CreateCustomerGatewayRequest
     *
     * @return CreateCustomerGatewayResponse CreateCustomerGatewayResponse
     */
    public function createCustomerGateway($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createCustomerGatewayWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a default vSwitch.
     *  *
     * @description When you call this operation, take note of the following limits:
     * *   The first IP address and last three IP addresses of a vSwitch CIDR block are reserved. For example, if the CIDR block of a vSwitch is 192.168.1.0/24, the IP addresses 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255 are reserved.
     * *   The number of instances in the default vSwitch cannot exceed the remaining number of instances supported by the VPC (15,000 minus the number of existing instances).
     * *   Default vSwitches do not support multicasting or broadcasting.
     * *   After you create a default vSwitch, you cannot modify its CIDR block.
     * *   **CreateDefaultVSwitch** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of a default vSwitch:
     *     *   If a default vSwitch is in the **Pending** state, it is being configured.
     *     *   If a default vSwitch is in the **Available** state, it is available.
     * *   If a default vSwitch already exists in a region, you cannot call this operation to create a default vSwitch in this region.
     * *   Before you create a default vSwitch, make sure that a default VPC is created. You can call the [CreateDefaultVpc](https://help.aliyun.com/document_detail/609152.html) operation to create a default VPC.
     *  *
     * @param CreateDefaultVSwitchRequest $request CreateDefaultVSwitchRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateDefaultVSwitchResponse CreateDefaultVSwitchResponse
     */
    public function createDefaultVSwitchWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ipv6CidrBlock)) {
            $query['Ipv6CidrBlock'] = $request->ipv6CidrBlock;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->zoneId)) {
            $query['ZoneId'] = $request->zoneId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateDefaultVSwitch',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateDefaultVSwitchResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a default vSwitch.
     *  *
     * @description When you call this operation, take note of the following limits:
     * *   The first IP address and last three IP addresses of a vSwitch CIDR block are reserved. For example, if the CIDR block of a vSwitch is 192.168.1.0/24, the IP addresses 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255 are reserved.
     * *   The number of instances in the default vSwitch cannot exceed the remaining number of instances supported by the VPC (15,000 minus the number of existing instances).
     * *   Default vSwitches do not support multicasting or broadcasting.
     * *   After you create a default vSwitch, you cannot modify its CIDR block.
     * *   **CreateDefaultVSwitch** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of a default vSwitch:
     *     *   If a default vSwitch is in the **Pending** state, it is being configured.
     *     *   If a default vSwitch is in the **Available** state, it is available.
     * *   If a default vSwitch already exists in a region, you cannot call this operation to create a default vSwitch in this region.
     * *   Before you create a default vSwitch, make sure that a default VPC is created. You can call the [CreateDefaultVpc](https://help.aliyun.com/document_detail/609152.html) operation to create a default VPC.
     *  *
     * @param CreateDefaultVSwitchRequest $request CreateDefaultVSwitchRequest
     *
     * @return CreateDefaultVSwitchResponse CreateDefaultVSwitchResponse
     */
    public function createDefaultVSwitch($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDefaultVSwitchWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a default virtual private cloud (VPC).
     *  *
     * @description ## Usage notes
     * When you call this operation, take note of the following items:
     * *   After you create a default VPC, you cannot change its CIDR block. However, you can add secondary IPv4 CIDR blocks to it.
     * *   In each default VPC, cloud services can use a maximum of 60,000 private IP addresses. You cannot increase the quota.
     * *   After you create a default VPC, a vRouter and a route table are automatically created for the VPC.
     * *   At most three user CIDR blocks can be added to a VPC. If a user CIDR block includes another user CIDR block, the one with the shorter subnet mask takes effect. For example, if 10.0.0.0/8 and 10.1.0.0/16 are specified, only 10.0.0.0/8 takes effect.
     * *   **CreateDefaultVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task:
     *     *   If the default VPC is in the **Pending** state, the VPC is being configured.
     *     *   If the default VPC is in the **Available** state, the VPC is available.
     * *   You cannot repeatedly call the **CreateDefaultVpc** operation within a specific time period.
     * *   You can create only one default VPC in each region.
     *  *
     * @param CreateDefaultVpcRequest $request CreateDefaultVpcRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateDefaultVpcResponse CreateDefaultVpcResponse
     */
    public function createDefaultVpcWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->enableIpv6)) {
            $query['EnableIpv6'] = $request->enableIpv6;
        }
        if (!Utils::isUnset($request->ipv6CidrBlock)) {
            $query['Ipv6CidrBlock'] = $request->ipv6CidrBlock;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateDefaultVpc',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateDefaultVpcResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a default virtual private cloud (VPC).
     *  *
     * @description ## Usage notes
     * When you call this operation, take note of the following items:
     * *   After you create a default VPC, you cannot change its CIDR block. However, you can add secondary IPv4 CIDR blocks to it.
     * *   In each default VPC, cloud services can use a maximum of 60,000 private IP addresses. You cannot increase the quota.
     * *   After you create a default VPC, a vRouter and a route table are automatically created for the VPC.
     * *   At most three user CIDR blocks can be added to a VPC. If a user CIDR block includes another user CIDR block, the one with the shorter subnet mask takes effect. For example, if 10.0.0.0/8 and 10.1.0.0/16 are specified, only 10.0.0.0/8 takes effect.
     * *   **CreateDefaultVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task:
     *     *   If the default VPC is in the **Pending** state, the VPC is being configured.
     *     *   If the default VPC is in the **Available** state, the VPC is available.
     * *   You cannot repeatedly call the **CreateDefaultVpc** operation within a specific time period.
     * *   You can create only one default VPC in each region.
     *  *
     * @param CreateDefaultVpcRequest $request CreateDefaultVpcRequest
     *
     * @return CreateDefaultVpcResponse CreateDefaultVpcResponse
     */
    public function createDefaultVpc($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDefaultVpcWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a DHCP options set.
     *  *
     * @description *   **CreateDhcpOptionsSet** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [GetDhcpOptionsSet](https://help.aliyun.com/document_detail/448820.html) to query the status of the task.
     *     *   If the vSwitch is in the **Pending** state, the DHCP options set is being configured.
     *     *   If the vSwitch is in the **Available** state, the DHCP options set is available.
     *  *
     * @param CreateDhcpOptionsSetRequest $request CreateDhcpOptionsSetRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateDhcpOptionsSetResponse CreateDhcpOptionsSetResponse
     */
    public function createDhcpOptionsSetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dhcpOptionsSetDescription)) {
            $query['DhcpOptionsSetDescription'] = $request->dhcpOptionsSetDescription;
        }
        if (!Utils::isUnset($request->dhcpOptionsSetName)) {
            $query['DhcpOptionsSetName'] = $request->dhcpOptionsSetName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->domainNameServers)) {
            $query['DomainNameServers'] = $request->domainNameServers;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ipv6LeaseTime)) {
            $query['Ipv6LeaseTime'] = $request->ipv6LeaseTime;
        }
        if (!Utils::isUnset($request->leaseTime)) {
            $query['LeaseTime'] = $request->leaseTime;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateDhcpOptionsSet',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateDhcpOptionsSetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a DHCP options set.
     *  *
     * @description *   **CreateDhcpOptionsSet** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [GetDhcpOptionsSet](https://help.aliyun.com/document_detail/448820.html) to query the status of the task.
     *     *   If the vSwitch is in the **Pending** state, the DHCP options set is being configured.
     *     *   If the vSwitch is in the **Available** state, the DHCP options set is available.
     *  *
     * @param CreateDhcpOptionsSetRequest $request CreateDhcpOptionsSetRequest
     *
     * @return CreateDhcpOptionsSetResponse CreateDhcpOptionsSetResponse
     */
    public function createDhcpOptionsSet($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDhcpOptionsSetWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an Express Cloud Connect (ECC) instance.
     *  *
     * @param CreateExpressCloudConnectionRequest $request CreateExpressCloudConnectionRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateExpressCloudConnectionResponse CreateExpressCloudConnectionResponse
     */
    public function createExpressCloudConnectionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bandwidth)) {
            $query['Bandwidth'] = $request->bandwidth;
        }
        if (!Utils::isUnset($request->contactMail)) {
            $query['ContactMail'] = $request->contactMail;
        }
        if (!Utils::isUnset($request->contactTel)) {
            $query['ContactTel'] = $request->contactTel;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->IDCardNo)) {
            $query['IDCardNo'] = $request->IDCardNo;
        }
        if (!Utils::isUnset($request->idcSP)) {
            $query['IdcSP'] = $request->idcSP;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->peerCity)) {
            $query['PeerCity'] = $request->peerCity;
        }
        if (!Utils::isUnset($request->peerLocation)) {
            $query['PeerLocation'] = $request->peerLocation;
        }
        if (!Utils::isUnset($request->portType)) {
            $query['PortType'] = $request->portType;
        }
        if (!Utils::isUnset($request->redundantEccId)) {
            $query['RedundantEccId'] = $request->redundantEccId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateExpressCloudConnection',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateExpressCloudConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an Express Cloud Connect (ECC) instance.
     *  *
     * @param CreateExpressCloudConnectionRequest $request CreateExpressCloudConnectionRequest
     *
     * @return CreateExpressCloudConnectionResponse CreateExpressCloudConnectionResponse
     */
    public function createExpressCloudConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createExpressCloudConnectionWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a quality of service (QoS) policy.
     *  *
     * @param CreateExpressConnectTrafficQosRequest $request CreateExpressConnectTrafficQosRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateExpressConnectTrafficQosResponse CreateExpressConnectTrafficQosResponse
     */
    public function createExpressConnectTrafficQosWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->qosDescription)) {
            $query['QosDescription'] = $request->qosDescription;
        }
        if (!Utils::isUnset($request->qosName)) {
            $query['QosName'] = $request->qosName;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateExpressConnectTrafficQos',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateExpressConnectTrafficQosResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a quality of service (QoS) policy.
     *  *
     * @param CreateExpressConnectTrafficQosRequest $request CreateExpressConnectTrafficQosRequest
     *
     * @return CreateExpressConnectTrafficQosResponse CreateExpressConnectTrafficQosResponse
     */
    public function createExpressConnectTrafficQos($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createExpressConnectTrafficQosWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a quality of service (QoS) queue.
     *  *
     * @param CreateExpressConnectTrafficQosQueueRequest $request CreateExpressConnectTrafficQosQueueRequest
     * @param RuntimeOptions                             $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateExpressConnectTrafficQosQueueResponse CreateExpressConnectTrafficQosQueueResponse
     */
    public function createExpressConnectTrafficQosQueueWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bandwidthPercent)) {
            $query['BandwidthPercent'] = $request->bandwidthPercent;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->qosId)) {
            $query['QosId'] = $request->qosId;
        }
        if (!Utils::isUnset($request->queueDescription)) {
            $query['QueueDescription'] = $request->queueDescription;
        }
        if (!Utils::isUnset($request->queueName)) {
            $query['QueueName'] = $request->queueName;
        }
        if (!Utils::isUnset($request->queueType)) {
            $query['QueueType'] = $request->queueType;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateExpressConnectTrafficQosQueue',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateExpressConnectTrafficQosQueueResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a quality of service (QoS) queue.
     *  *
     * @param CreateExpressConnectTrafficQosQueueRequest $request CreateExpressConnectTrafficQosQueueRequest
     *
     * @return CreateExpressConnectTrafficQosQueueResponse CreateExpressConnectTrafficQosQueueResponse
     */
    public function createExpressConnectTrafficQosQueue($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createExpressConnectTrafficQosQueueWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a quality of service (QoS) rule.
     *  *
     * @param CreateExpressConnectTrafficQosRuleRequest $request CreateExpressConnectTrafficQosRuleRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateExpressConnectTrafficQosRuleResponse CreateExpressConnectTrafficQosRuleResponse
     */
    public function createExpressConnectTrafficQosRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dstCidr)) {
            $query['DstCidr'] = $request->dstCidr;
        }
        if (!Utils::isUnset($request->dstIPv6Cidr)) {
            $query['DstIPv6Cidr'] = $request->dstIPv6Cidr;
        }
        if (!Utils::isUnset($request->dstPortRange)) {
            $query['DstPortRange'] = $request->dstPortRange;
        }
        if (!Utils::isUnset($request->matchDscp)) {
            $query['MatchDscp'] = $request->matchDscp;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->priority)) {
            $query['Priority'] = $request->priority;
        }
        if (!Utils::isUnset($request->protocol)) {
            $query['Protocol'] = $request->protocol;
        }
        if (!Utils::isUnset($request->qosId)) {
            $query['QosId'] = $request->qosId;
        }
        if (!Utils::isUnset($request->queueId)) {
            $query['QueueId'] = $request->queueId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->remarkingDscp)) {
            $query['RemarkingDscp'] = $request->remarkingDscp;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->ruleDescription)) {
            $query['RuleDescription'] = $request->ruleDescription;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $query['RuleName'] = $request->ruleName;
        }
        if (!Utils::isUnset($request->srcCidr)) {
            $query['SrcCidr'] = $request->srcCidr;
        }
        if (!Utils::isUnset($request->srcIPv6Cidr)) {
            $query['SrcIPv6Cidr'] = $request->srcIPv6Cidr;
        }
        if (!Utils::isUnset($request->srcPortRange)) {
            $query['SrcPortRange'] = $request->srcPortRange;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateExpressConnectTrafficQosRule',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateExpressConnectTrafficQosRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a quality of service (QoS) rule.
     *  *
     * @param CreateExpressConnectTrafficQosRuleRequest $request CreateExpressConnectTrafficQosRuleRequest
     *
     * @return CreateExpressConnectTrafficQosRuleResponse CreateExpressConnectTrafficQosRuleResponse
     */
    public function createExpressConnectTrafficQosRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createExpressConnectTrafficQosRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a failover test.
     *  *
     * @description You cannot create a failover test in the following scenarios:
     * *   You have created a failover test in the region and its type is StartNow.
     * *   The Express Connect circuit or hosted connection has pending orders or overdue payments.
     * *   A failover test is already performed on the Express Connect circuit or hosted connection.
     * *   More than one hosted connection is created over the Express Connect circuit.
     * *   More than one cross-account VBR is created on the Express Connect circuit.
     * *   No VBR is associated with the hosted connection.
     * *   The VLAN ID of the hosted connection is set to 0.
     *  *
     * @param CreateFailoverTestJobRequest $request CreateFailoverTestJobRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateFailoverTestJobResponse CreateFailoverTestJobResponse
     */
    public function createFailoverTestJobWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->jobDuration)) {
            $query['JobDuration'] = $request->jobDuration;
        }
        if (!Utils::isUnset($request->jobType)) {
            $query['JobType'] = $request->jobType;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceId)) {
            $query['ResourceId'] = $request->resourceId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceType)) {
            $query['ResourceType'] = $request->resourceType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateFailoverTestJob',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateFailoverTestJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a failover test.
     *  *
     * @description You cannot create a failover test in the following scenarios:
     * *   You have created a failover test in the region and its type is StartNow.
     * *   The Express Connect circuit or hosted connection has pending orders or overdue payments.
     * *   A failover test is already performed on the Express Connect circuit or hosted connection.
     * *   More than one hosted connection is created over the Express Connect circuit.
     * *   More than one cross-account VBR is created on the Express Connect circuit.
     * *   No VBR is associated with the hosted connection.
     * *   The VLAN ID of the hosted connection is set to 0.
     *  *
     * @param CreateFailoverTestJobRequest $request CreateFailoverTestJobRequest
     *
     * @return CreateFailoverTestJobResponse CreateFailoverTestJobResponse
     */
    public function createFailoverTestJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createFailoverTestJobWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a flow log.
     *  *
     * @description **CreateFlowLog** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of the flow log.
     * *   If the flow log is in the **Activating** state, the flow log is being created.
     * *   If the flow log is in the **Active** state, the flow log is created and started.
     *  *
     * @param CreateFlowLogRequest $request CreateFlowLogRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateFlowLogResponse CreateFlowLogResponse
     */
    public function createFlowLogWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aggregationInterval)) {
            $query['AggregationInterval'] = $request->aggregationInterval;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->flowLogName)) {
            $query['FlowLogName'] = $request->flowLogName;
        }
        if (!Utils::isUnset($request->ipVersion)) {
            $query['IpVersion'] = $request->ipVersion;
        }
        if (!Utils::isUnset($request->logStoreName)) {
            $query['LogStoreName'] = $request->logStoreName;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $query['ProjectName'] = $request->projectName;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceId)) {
            $query['ResourceId'] = $request->resourceId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->resourceType)) {
            $query['ResourceType'] = $request->resourceType;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->trafficPath)) {
            $query['TrafficPath'] = $request->trafficPath;
        }
        if (!Utils::isUnset($request->trafficType)) {
            $query['TrafficType'] = $request->trafficType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateFlowLog',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateFlowLogResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a flow log.
     *  *
     * @description **CreateFlowLog** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of the flow log.
     * *   If the flow log is in the **Activating** state, the flow log is being created.
     * *   If the flow log is in the **Active** state, the flow log is created and started.
     *  *
     * @param CreateFlowLogRequest $request CreateFlowLogRequest
     *
     * @return CreateFlowLogResponse CreateFlowLogResponse
     */
    public function createFlowLog($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createFlowLogWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a DNAT entry to a DNAT table.
     *  *
     * @description ## [](#)
     * Each DNAT entry consists of the following parameters: **ExternalIp**, **ExternalPort**, **IpProtocol**, **InternalIp**, and **InternalPort**. After you add a DNAT entry, the NAT gateway forwards packets over the specified protocol from **ExternalIp:ExternalPort** to **InternalIp:InternalPort** and sends responses back through the same route.
     * When you call this operation, take note of the following limits:
     * *   **CreateForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
     *     *   If the DNAT entry is in the **Pending** state, the system is adding the DNAT entry. You can only query the DNAT entry, but cannot perform other operations.
     *     *   If the DNAT entry is in the **Available** state, the DNAT entry is added.
     * *   You cannot repeatedly call the **CreateForwardEntry** operation to add a DNAT entry within a specific period of time.
     * *   All combinations of **ExternalIp**, **ExternalPort**, and **IpProtocol** used in DNAT entries must be unique. You cannot distribute requests to more than one Elastic Compute Service (ECS) instance if these requests are initiated from the same source IP address, received on the same port, and use the same protocol.
     * *   The combinations of **IpProtocol**, **InternalIp**, and **InternalPort** must be unique.
     * *   If one or more DNAT entries in the DNAT table are in the **Pending** or **Modifying** state, you cannot add DNAT entries to the DNAT table.
     * *   You can add at most 100 DNAT entries to a DNAT table.
     * *   For an elastic IP address (EIP) used by an Internet NAT gateway or a NAT IP address used by a Virtual Private Cloud (VPC) NAT gateway, take note of the following limit: If the IP address has IP mapping enabled and is specified in a DNAT entry, the IP address cannot be used by another DNAT or SNAT entry.
     *  *
     * @param CreateForwardEntryRequest $request CreateForwardEntryRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateForwardEntryResponse CreateForwardEntryResponse
     */
    public function createForwardEntryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->externalIp)) {
            $query['ExternalIp'] = $request->externalIp;
        }
        if (!Utils::isUnset($request->externalPort)) {
            $query['ExternalPort'] = $request->externalPort;
        }
        if (!Utils::isUnset($request->forwardEntryName)) {
            $query['ForwardEntryName'] = $request->forwardEntryName;
        }
        if (!Utils::isUnset($request->forwardTableId)) {
            $query['ForwardTableId'] = $request->forwardTableId;
        }
        if (!Utils::isUnset($request->internalIp)) {
            $query['InternalIp'] = $request->internalIp;
        }
        if (!Utils::isUnset($request->internalPort)) {
            $query['InternalPort'] = $request->internalPort;
        }
        if (!Utils::isUnset($request->ipProtocol)) {
            $query['IpProtocol'] = $request->ipProtocol;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->portBreak)) {
            $query['PortBreak'] = $request->portBreak;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateForwardEntry',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateForwardEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a DNAT entry to a DNAT table.
     *  *
     * @description ## [](#)
     * Each DNAT entry consists of the following parameters: **ExternalIp**, **ExternalPort**, **IpProtocol**, **InternalIp**, and **InternalPort**. After you add a DNAT entry, the NAT gateway forwards packets over the specified protocol from **ExternalIp:ExternalPort** to **InternalIp:InternalPort** and sends responses back through the same route.
     * When you call this operation, take note of the following limits:
     * *   **CreateForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
     *     *   If the DNAT entry is in the **Pending** state, the system is adding the DNAT entry. You can only query the DNAT entry, but cannot perform other operations.
     *     *   If the DNAT entry is in the **Available** state, the DNAT entry is added.
     * *   You cannot repeatedly call the **CreateForwardEntry** operation to add a DNAT entry within a specific period of time.
     * *   All combinations of **ExternalIp**, **ExternalPort**, and **IpProtocol** used in DNAT entries must be unique. You cannot distribute requests to more than one Elastic Compute Service (ECS) instance if these requests are initiated from the same source IP address, received on the same port, and use the same protocol.
     * *   The combinations of **IpProtocol**, **InternalIp**, and **InternalPort** must be unique.
     * *   If one or more DNAT entries in the DNAT table are in the **Pending** or **Modifying** state, you cannot add DNAT entries to the DNAT table.
     * *   You can add at most 100 DNAT entries to a DNAT table.
     * *   For an elastic IP address (EIP) used by an Internet NAT gateway or a NAT IP address used by a Virtual Private Cloud (VPC) NAT gateway, take note of the following limit: If the IP address has IP mapping enabled and is specified in a DNAT entry, the IP address cannot be used by another DNAT or SNAT entry.
     *  *
     * @param CreateForwardEntryRequest $request CreateForwardEntryRequest
     *
     * @return CreateForwardEntryResponse CreateForwardEntryResponse
     */
    public function createForwardEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createForwardEntryWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a FULLNAT entry to the FULLNAT table.
     *  *
     * @description *   **CreateFullNatEntry** is an asynchronous operation. After you send a request to call this operation, the system returns a FULLNAT entry and the FULLNAT entry is being added in the backend. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
     *     *   If the FULLNAT entry is in the **Creating** state, the system is adding the FULLNAT entry. You can only query the status of the FULLNAT entry, but cannot perform other operations.
     *     *   If the FULLNAT entry is in the **Available** state, the FULLNAT entry is added.
     * *   You cannot repeatedly call the **CreateFullNatEntry** operation for the same VPN gateway within the specified period of time.
     *  *
     * @param CreateFullNatEntryRequest $request CreateFullNatEntryRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateFullNatEntryResponse CreateFullNatEntryResponse
     */
    public function createFullNatEntryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->accessIp)) {
            $query['AccessIp'] = $request->accessIp;
        }
        if (!Utils::isUnset($request->accessPort)) {
            $query['AccessPort'] = $request->accessPort;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->fullNatEntryDescription)) {
            $query['FullNatEntryDescription'] = $request->fullNatEntryDescription;
        }
        if (!Utils::isUnset($request->fullNatEntryName)) {
            $query['FullNatEntryName'] = $request->fullNatEntryName;
        }
        if (!Utils::isUnset($request->fullNatTableId)) {
            $query['FullNatTableId'] = $request->fullNatTableId;
        }
        if (!Utils::isUnset($request->ipProtocol)) {
            $query['IpProtocol'] = $request->ipProtocol;
        }
        if (!Utils::isUnset($request->natIp)) {
            $query['NatIp'] = $request->natIp;
        }
        if (!Utils::isUnset($request->natIpPort)) {
            $query['NatIpPort'] = $request->natIpPort;
        }
        if (!Utils::isUnset($request->networkInterfaceId)) {
            $query['NetworkInterfaceId'] = $request->networkInterfaceId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateFullNatEntry',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateFullNatEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a FULLNAT entry to the FULLNAT table.
     *  *
     * @description *   **CreateFullNatEntry** is an asynchronous operation. After you send a request to call this operation, the system returns a FULLNAT entry and the FULLNAT entry is being added in the backend. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
     *     *   If the FULLNAT entry is in the **Creating** state, the system is adding the FULLNAT entry. You can only query the status of the FULLNAT entry, but cannot perform other operations.
     *     *   If the FULLNAT entry is in the **Available** state, the FULLNAT entry is added.
     * *   You cannot repeatedly call the **CreateFullNatEntry** operation for the same VPN gateway within the specified period of time.
     *  *
     * @param CreateFullNatEntryRequest $request CreateFullNatEntryRequest
     *
     * @return CreateFullNatEntryResponse CreateFullNatEntryResponse
     */
    public function createFullNatEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createFullNatEntryWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI CreateGlobalAccelerationInstance is deprecated
     *  *
     * @summary Creates a Global Accelerator (GA) instance.
     *  *
     * @description ## Usage notes
     * You can call this operation to create only pay-as-you-go GA instances.
     *  *
     * Deprecated
     *
     * @param CreateGlobalAccelerationInstanceRequest $request CreateGlobalAccelerationInstanceRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateGlobalAccelerationInstanceResponse CreateGlobalAccelerationInstanceResponse
     */
    public function createGlobalAccelerationInstanceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bandwidth)) {
            $query['Bandwidth'] = $request->bandwidth;
        }
        if (!Utils::isUnset($request->bandwidthType)) {
            $query['BandwidthType'] = $request->bandwidthType;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->serviceLocation)) {
            $query['ServiceLocation'] = $request->serviceLocation;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateGlobalAccelerationInstance',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateGlobalAccelerationInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI CreateGlobalAccelerationInstance is deprecated
     *  *
     * @summary Creates a Global Accelerator (GA) instance.
     *  *
     * @description ## Usage notes
     * You can call this operation to create only pay-as-you-go GA instances.
     *  *
     * Deprecated
     *
     * @param CreateGlobalAccelerationInstanceRequest $request CreateGlobalAccelerationInstanceRequest
     *
     * @return CreateGlobalAccelerationInstanceResponse CreateGlobalAccelerationInstanceResponse
     */
    public function createGlobalAccelerationInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createGlobalAccelerationInstanceWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a high-availability virtual IP address (HAVIP).
     *  *
     * @description **CreateHaVip** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of the task:
     * *   If the HAVIP is in the **Creating** state, the HAVIP is being created.
     * *   If the HAVIP is in the **Available** state, the HAVIP is created.
     *  *
     * @param CreateHaVipRequest $request CreateHaVipRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateHaVipResponse CreateHaVipResponse
     */
    public function createHaVipWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->ipAddress)) {
            $query['IpAddress'] = $request->ipAddress;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->vSwitchId)) {
            $query['VSwitchId'] = $request->vSwitchId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateHaVip',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateHaVipResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a high-availability virtual IP address (HAVIP).
     *  *
     * @description **CreateHaVip** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of the task:
     * *   If the HAVIP is in the **Creating** state, the HAVIP is being created.
     * *   If the HAVIP is in the **Available** state, the HAVIP is created.
     *  *
     * @param CreateHaVipRequest $request CreateHaVipRequest
     *
     * @return CreateHaVipResponse CreateHaVipResponse
     */
    public function createHaVip($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createHaVipWithOptions($request, $runtime);
    }

    /**
     * @summary 创建高可靠物理专线
     *  *
     * @param CreateHighReliablePhysicalConnectionRequest $request CreateHighReliablePhysicalConnectionRequest
     * @param RuntimeOptions                              $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateHighReliablePhysicalConnectionResponse CreateHighReliablePhysicalConnectionResponse
     */
    public function createHighReliablePhysicalConnectionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->acceptLanguage)) {
            $query['AcceptLanguage'] = $request->acceptLanguage;
        }
        if (!Utils::isUnset($request->apList)) {
            $query['ApList'] = $request->apList;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->deviceAdvancedCapacity)) {
            $query['DeviceAdvancedCapacity'] = $request->deviceAdvancedCapacity;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->highReliableType)) {
            $query['HighReliableType'] = $request->highReliableType;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->portType)) {
            $query['PortType'] = $request->portType;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateHighReliablePhysicalConnection',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateHighReliablePhysicalConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 创建高可靠物理专线
     *  *
     * @param CreateHighReliablePhysicalConnectionRequest $request CreateHighReliablePhysicalConnectionRequest
     *
     * @return CreateHighReliablePhysicalConnectionResponse CreateHighReliablePhysicalConnectionResponse
     */
    public function createHighReliablePhysicalConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createHighReliablePhysicalConnectionWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI CreateIPv6Translator is deprecated
     *  *
     * @summary Creates an IPv6 Translation Service instance.
     *  *
     * Deprecated
     *
     * @param CreateIPv6TranslatorRequest $request CreateIPv6TranslatorRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateIPv6TranslatorResponse CreateIPv6TranslatorResponse
     */
    public function createIPv6TranslatorWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->autoPay)) {
            $query['AutoPay'] = $request->autoPay;
        }
        if (!Utils::isUnset($request->bandwidth)) {
            $query['Bandwidth'] = $request->bandwidth;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->duration)) {
            $query['Duration'] = $request->duration;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->payType)) {
            $query['PayType'] = $request->payType;
        }
        if (!Utils::isUnset($request->pricingCycle)) {
            $query['PricingCycle'] = $request->pricingCycle;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->spec)) {
            $query['Spec'] = $request->spec;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateIPv6Translator',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateIPv6TranslatorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI CreateIPv6Translator is deprecated
     *  *
     * @summary Creates an IPv6 Translation Service instance.
     *  *
     * Deprecated
     *
     * @param CreateIPv6TranslatorRequest $request CreateIPv6TranslatorRequest
     *
     * @return CreateIPv6TranslatorResponse CreateIPv6TranslatorResponse
     */
    public function createIPv6Translator($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createIPv6TranslatorWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI CreateIPv6TranslatorAclList is deprecated
     *  *
     * @summary Creates an access control list (ACL).
     *  *
     * Deprecated
     *
     * @param CreateIPv6TranslatorAclListRequest $request CreateIPv6TranslatorAclListRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateIPv6TranslatorAclListResponse CreateIPv6TranslatorAclListResponse
     */
    public function createIPv6TranslatorAclListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aclName)) {
            $query['AclName'] = $request->aclName;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateIPv6TranslatorAclList',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateIPv6TranslatorAclListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI CreateIPv6TranslatorAclList is deprecated
     *  *
     * @summary Creates an access control list (ACL).
     *  *
     * Deprecated
     *
     * @param CreateIPv6TranslatorAclListRequest $request CreateIPv6TranslatorAclListRequest
     *
     * @return CreateIPv6TranslatorAclListResponse CreateIPv6TranslatorAclListResponse
     */
    public function createIPv6TranslatorAclList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createIPv6TranslatorAclListWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI CreateIPv6TranslatorEntry is deprecated
     *  *
     * @summary Adds an IPv6 mapping entry to an IPv6 Translation Service instance.
     *  *
     * Deprecated
     *
     * @param CreateIPv6TranslatorEntryRequest $request CreateIPv6TranslatorEntryRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateIPv6TranslatorEntryResponse CreateIPv6TranslatorEntryResponse
     */
    public function createIPv6TranslatorEntryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aclId)) {
            $query['AclId'] = $request->aclId;
        }
        if (!Utils::isUnset($request->aclStatus)) {
            $query['AclStatus'] = $request->aclStatus;
        }
        if (!Utils::isUnset($request->aclType)) {
            $query['AclType'] = $request->aclType;
        }
        if (!Utils::isUnset($request->allocateIpv6Port)) {
            $query['AllocateIpv6Port'] = $request->allocateIpv6Port;
        }
        if (!Utils::isUnset($request->backendIpv4Addr)) {
            $query['BackendIpv4Addr'] = $request->backendIpv4Addr;
        }
        if (!Utils::isUnset($request->backendIpv4Port)) {
            $query['BackendIpv4Port'] = $request->backendIpv4Port;
        }
        if (!Utils::isUnset($request->entryBandwidth)) {
            $query['EntryBandwidth'] = $request->entryBandwidth;
        }
        if (!Utils::isUnset($request->entryDescription)) {
            $query['EntryDescription'] = $request->entryDescription;
        }
        if (!Utils::isUnset($request->entryName)) {
            $query['EntryName'] = $request->entryName;
        }
        if (!Utils::isUnset($request->ipv6TranslatorId)) {
            $query['Ipv6TranslatorId'] = $request->ipv6TranslatorId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->transProtocol)) {
            $query['TransProtocol'] = $request->transProtocol;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateIPv6TranslatorEntry',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateIPv6TranslatorEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI CreateIPv6TranslatorEntry is deprecated
     *  *
     * @summary Adds an IPv6 mapping entry to an IPv6 Translation Service instance.
     *  *
     * Deprecated
     *
     * @param CreateIPv6TranslatorEntryRequest $request CreateIPv6TranslatorEntryRequest
     *
     * @return CreateIPv6TranslatorEntryResponse CreateIPv6TranslatorEntryResponse
     */
    public function createIPv6TranslatorEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createIPv6TranslatorEntryWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an IPsec server.
     *  *
     * @description *   Before you create an IPsec server, you must create a VPN gateway and enable the SSL-VPN feature for the VPN gateway. For more information, see [CreateVpnGateway](https://help.aliyun.com/document_detail/2794049.html).
     * *   Before you create an IPsec server, make sure that no IPsec-VPN connection exists on the VPN gateway. For more information, see [DeleteVpnConnection](https://help.aliyun.com/document_detail/2526948.html).
     * *   **CreateIpsecServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the IPsec server is being created.
     *     *   If the VPN gateway is in the **active** state, the IPsec server is created.
     * *   You cannot repeatedly call **CreateIpsecServer** within the specified period of time.
     *  *
     * @param CreateIpsecServerRequest $request CreateIpsecServerRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateIpsecServerResponse CreateIpsecServerResponse
     */
    public function createIpsecServerWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientIpPool)) {
            $query['ClientIpPool'] = $request->clientIpPool;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->effectImmediately)) {
            $query['EffectImmediately'] = $request->effectImmediately;
        }
        if (!Utils::isUnset($request->ikeConfig)) {
            $query['IkeConfig'] = $request->ikeConfig;
        }
        if (!Utils::isUnset($request->ipSecServerName)) {
            $query['IpSecServerName'] = $request->ipSecServerName;
        }
        if (!Utils::isUnset($request->ipsecConfig)) {
            $query['IpsecConfig'] = $request->ipsecConfig;
        }
        if (!Utils::isUnset($request->localSubnet)) {
            $query['LocalSubnet'] = $request->localSubnet;
        }
        if (!Utils::isUnset($request->psk)) {
            $query['Psk'] = $request->psk;
        }
        if (!Utils::isUnset($request->pskEnabled)) {
            $query['PskEnabled'] = $request->pskEnabled;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->vpnGatewayId)) {
            $query['VpnGatewayId'] = $request->vpnGatewayId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateIpsecServer',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateIpsecServerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an IPsec server.
     *  *
     * @description *   Before you create an IPsec server, you must create a VPN gateway and enable the SSL-VPN feature for the VPN gateway. For more information, see [CreateVpnGateway](https://help.aliyun.com/document_detail/2794049.html).
     * *   Before you create an IPsec server, make sure that no IPsec-VPN connection exists on the VPN gateway. For more information, see [DeleteVpnConnection](https://help.aliyun.com/document_detail/2526948.html).
     * *   **CreateIpsecServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the IPsec server is being created.
     *     *   If the VPN gateway is in the **active** state, the IPsec server is created.
     * *   You cannot repeatedly call **CreateIpsecServer** within the specified period of time.
     *  *
     * @param CreateIpsecServerRequest $request CreateIpsecServerRequest
     *
     * @return CreateIpsecServerResponse CreateIpsecServerResponse
     */
    public function createIpsecServer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createIpsecServerWithOptions($request, $runtime);
    }

    /**
     * @summary 创建IPv4网关。
     *  *
     * @description *   **CreateIpv4Gateway** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of an IPv4 gateway:
     *     *   If the IPv4 gateway is in the **Creating** state, the IPv4 gateway is being created.
     *     *   If the IPv4 gateway is in the **Created** state, the IPv4 gateway is created.
     * *   You cannot repeatedly call the **CreateIpv4Gateway** operation to create IPv4 gateways in a virtual private cloud (VPC) within the specified period of time.
     *  *
     * @param CreateIpv4GatewayRequest $request CreateIpv4GatewayRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateIpv4GatewayResponse CreateIpv4GatewayResponse
     */
    public function createIpv4GatewayWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ipv4GatewayDescription)) {
            $query['Ipv4GatewayDescription'] = $request->ipv4GatewayDescription;
        }
        if (!Utils::isUnset($request->ipv4GatewayName)) {
            $query['Ipv4GatewayName'] = $request->ipv4GatewayName;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateIpv4Gateway',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateIpv4GatewayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 创建IPv4网关。
     *  *
     * @description *   **CreateIpv4Gateway** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of an IPv4 gateway:
     *     *   If the IPv4 gateway is in the **Creating** state, the IPv4 gateway is being created.
     *     *   If the IPv4 gateway is in the **Created** state, the IPv4 gateway is created.
     * *   You cannot repeatedly call the **CreateIpv4Gateway** operation to create IPv4 gateways in a virtual private cloud (VPC) within the specified period of time.
     *  *
     * @param CreateIpv4GatewayRequest $request CreateIpv4GatewayRequest
     *
     * @return CreateIpv4GatewayResponse CreateIpv4GatewayResponse
     */
    public function createIpv4Gateway($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createIpv4GatewayWithOptions($request, $runtime);
    }

    /**
     * @summary You can call CreateIpv6EgressOnlyRule to create egress-only rules to enable ECS instances in VPCs that have IPv6 enabled to access IPv6 clients. However, IPv6 clients cannot access the ECS instances over the Internet.
     *  *
     * @description *   **CreateIpv6EgressOnlyRule** is an asynchronous operation. After a request is sent, the system returns a request ID and creates the rule in the background. You can call the [DescribeIpv6EgressOnlyRules](https://help.aliyun.com/document_detail/102208.html) operation to query the status of the task.
     *     *   If the egress-only rule is in the **Creating** state, the egress-only rule is being created.
     *     *   If the egress-only rule is in the **Created** state, the egress-only rule is created.
     * *   You cannot repeatedly call the **CreateIpv6EgressOnlyRule** operation to add egress-only rules for an IPv6 address within the specified period of time.
     *  *
     * @param CreateIpv6EgressOnlyRuleRequest $request CreateIpv6EgressOnlyRuleRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateIpv6EgressOnlyRuleResponse CreateIpv6EgressOnlyRuleResponse
     */
    public function createIpv6EgressOnlyRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->instanceType)) {
            $query['InstanceType'] = $request->instanceType;
        }
        if (!Utils::isUnset($request->ipv6GatewayId)) {
            $query['Ipv6GatewayId'] = $request->ipv6GatewayId;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateIpv6EgressOnlyRule',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateIpv6EgressOnlyRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary You can call CreateIpv6EgressOnlyRule to create egress-only rules to enable ECS instances in VPCs that have IPv6 enabled to access IPv6 clients. However, IPv6 clients cannot access the ECS instances over the Internet.
     *  *
     * @description *   **CreateIpv6EgressOnlyRule** is an asynchronous operation. After a request is sent, the system returns a request ID and creates the rule in the background. You can call the [DescribeIpv6EgressOnlyRules](https://help.aliyun.com/document_detail/102208.html) operation to query the status of the task.
     *     *   If the egress-only rule is in the **Creating** state, the egress-only rule is being created.
     *     *   If the egress-only rule is in the **Created** state, the egress-only rule is created.
     * *   You cannot repeatedly call the **CreateIpv6EgressOnlyRule** operation to add egress-only rules for an IPv6 address within the specified period of time.
     *  *
     * @param CreateIpv6EgressOnlyRuleRequest $request CreateIpv6EgressOnlyRuleRequest
     *
     * @return CreateIpv6EgressOnlyRuleResponse CreateIpv6EgressOnlyRuleResponse
     */
    public function createIpv6EgressOnlyRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createIpv6EgressOnlyRuleWithOptions($request, $runtime);
    }

    /**
     * @summary IPv6 gateways are used to control the IPv6 traffic of virtual private clouds (VPCs). You can call the CreateIpv6Gateway operation to create IPv6 gateways.
     *  *
     * @description *   **CreateIpv6Gateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6GatewayAttribute](https://help.aliyun.com/document_detail/102226.html) operation to query the status of the task.
     *     *   If the IPv6 gateway is in the **Creating** state, the IPv6 gateway is being created.
     *     *   If the IPv6 gateway is in the **Created** state, the IPv6 gateway is created.
     * *   You cannot repeatedly call the **CreateIpv6Gateway** operation within a specific time period.
     *  *
     * @param CreateIpv6GatewayRequest $request CreateIpv6GatewayRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateIpv6GatewayResponse CreateIpv6GatewayResponse
     */
    public function createIpv6GatewayWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateIpv6Gateway',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateIpv6GatewayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary IPv6 gateways are used to control the IPv6 traffic of virtual private clouds (VPCs). You can call the CreateIpv6Gateway operation to create IPv6 gateways.
     *  *
     * @description *   **CreateIpv6Gateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6GatewayAttribute](https://help.aliyun.com/document_detail/102226.html) operation to query the status of the task.
     *     *   If the IPv6 gateway is in the **Creating** state, the IPv6 gateway is being created.
     *     *   If the IPv6 gateway is in the **Created** state, the IPv6 gateway is created.
     * *   You cannot repeatedly call the **CreateIpv6Gateway** operation within a specific time period.
     *  *
     * @param CreateIpv6GatewayRequest $request CreateIpv6GatewayRequest
     *
     * @return CreateIpv6GatewayResponse CreateIpv6GatewayResponse
     */
    public function createIpv6Gateway($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createIpv6GatewayWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an enhanced Internet NAT gateway or a Virtual Private Cloud (VPC) NAT gateway.
     *  *
     * @description ## Usage notes
     * Before you call this operation, take note of the following items:
     * *   When you create an enhanced NAT gateway for the first time, the system automatically creates the service-linked role AliyunServiceRoleForNatgw. Then, the system attaches the permission policy AliyunServiceRolePolicyForNatgw to the role. This allows the NAT gateway to access other resources on Alibaba Cloud. For more information, see [Service-linked roles](https://help.aliyun.com/document_detail/174251.html).
     * *   After you create an enhanced Internet NAT gateway, a route entry is automatically added to the route table of the VPC. The destination CIDR block of the route entry is 0.0.0.0/0 and the next hop is the NAT gateway. This ensures that traffic is routed to the NAT gateway.
     * *   **CreateNatGateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNatGateways](https://help.aliyun.com/document_detail/36054.html) operation to query the status of the task.
     *     *   If a NAT gateway is in the **Creating** state, the NAT gateway is being created. In this case, you can query the NAT gateway but cannot perform other operations.
     *     *   If a NAT gateway is in the **Available** state, the NAT gateway is created.
     * It takes 1 to 3 minutes to create a NAT gateway.
     *  *
     * @param CreateNatGatewayRequest $tmpReq  CreateNatGatewayRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateNatGatewayResponse CreateNatGatewayResponse
     */
    public function createNatGatewayWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new CreateNatGatewayShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->accessMode)) {
            $request->accessModeShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->accessMode, 'AccessMode', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->accessModeShrink)) {
            $query['AccessMode'] = $request->accessModeShrink;
        }
        if (!Utils::isUnset($request->autoPay)) {
            $query['AutoPay'] = $request->autoPay;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->duration)) {
            $query['Duration'] = $request->duration;
        }
        if (!Utils::isUnset($request->eipBindMode)) {
            $query['EipBindMode'] = $request->eipBindMode;
        }
        if (!Utils::isUnset($request->icmpReplyEnabled)) {
            $query['IcmpReplyEnabled'] = $request->icmpReplyEnabled;
        }
        if (!Utils::isUnset($request->instanceChargeType)) {
            $query['InstanceChargeType'] = $request->instanceChargeType;
        }
        if (!Utils::isUnset($request->internetChargeType)) {
            $query['InternetChargeType'] = $request->internetChargeType;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->natType)) {
            $query['NatType'] = $request->natType;
        }
        if (!Utils::isUnset($request->networkType)) {
            $query['NetworkType'] = $request->networkType;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pricingCycle)) {
            $query['PricingCycle'] = $request->pricingCycle;
        }
        if (!Utils::isUnset($request->privateLinkEnabled)) {
            $query['PrivateLinkEnabled'] = $request->privateLinkEnabled;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->securityProtectionEnabled)) {
            $query['SecurityProtectionEnabled'] = $request->securityProtectionEnabled;
        }
        if (!Utils::isUnset($request->spec)) {
            $query['Spec'] = $request->spec;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->vSwitchId)) {
            $query['VSwitchId'] = $request->vSwitchId;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateNatGateway',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateNatGatewayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an enhanced Internet NAT gateway or a Virtual Private Cloud (VPC) NAT gateway.
     *  *
     * @description ## Usage notes
     * Before you call this operation, take note of the following items:
     * *   When you create an enhanced NAT gateway for the first time, the system automatically creates the service-linked role AliyunServiceRoleForNatgw. Then, the system attaches the permission policy AliyunServiceRolePolicyForNatgw to the role. This allows the NAT gateway to access other resources on Alibaba Cloud. For more information, see [Service-linked roles](https://help.aliyun.com/document_detail/174251.html).
     * *   After you create an enhanced Internet NAT gateway, a route entry is automatically added to the route table of the VPC. The destination CIDR block of the route entry is 0.0.0.0/0 and the next hop is the NAT gateway. This ensures that traffic is routed to the NAT gateway.
     * *   **CreateNatGateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNatGateways](https://help.aliyun.com/document_detail/36054.html) operation to query the status of the task.
     *     *   If a NAT gateway is in the **Creating** state, the NAT gateway is being created. In this case, you can query the NAT gateway but cannot perform other operations.
     *     *   If a NAT gateway is in the **Available** state, the NAT gateway is created.
     * It takes 1 to 3 minutes to create a NAT gateway.
     *  *
     * @param CreateNatGatewayRequest $request CreateNatGatewayRequest
     *
     * @return CreateNatGatewayResponse CreateNatGatewayResponse
     */
    public function createNatGateway($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createNatGatewayWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a NAT IP address.
     *  *
     * @description ## [](#)
     * **CreateNatIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListNatIps](https://help.aliyun.com/document_detail/287000.html) operation to query the status of the task.
     * *   If a NAT IP address is in the **Creating** state, the NAT IP address is being created. In this case, you can only query the NAT IP address and cannot perform other operations.
     * *   If a NAT IP address is in the **Available** state, the NAT IP address is created.
     * You cannot repeatedly call the **CreateNatIp** operation to create a NAT IP address within a specific period of time.
     *  *
     * @param CreateNatIpRequest $request CreateNatIpRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateNatIpResponse CreateNatIpResponse
     */
    public function createNatIpWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->natGatewayId)) {
            $query['NatGatewayId'] = $request->natGatewayId;
        }
        if (!Utils::isUnset($request->natIp)) {
            $query['NatIp'] = $request->natIp;
        }
        if (!Utils::isUnset($request->natIpCidr)) {
            $query['NatIpCidr'] = $request->natIpCidr;
        }
        if (!Utils::isUnset($request->natIpDescription)) {
            $query['NatIpDescription'] = $request->natIpDescription;
        }
        if (!Utils::isUnset($request->natIpName)) {
            $query['NatIpName'] = $request->natIpName;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateNatIp',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateNatIpResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a NAT IP address.
     *  *
     * @description ## [](#)
     * **CreateNatIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListNatIps](https://help.aliyun.com/document_detail/287000.html) operation to query the status of the task.
     * *   If a NAT IP address is in the **Creating** state, the NAT IP address is being created. In this case, you can only query the NAT IP address and cannot perform other operations.
     * *   If a NAT IP address is in the **Available** state, the NAT IP address is created.
     * You cannot repeatedly call the **CreateNatIp** operation to create a NAT IP address within a specific period of time.
     *  *
     * @param CreateNatIpRequest $request CreateNatIpRequest
     *
     * @return CreateNatIpResponse CreateNatIpResponse
     */
    public function createNatIp($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createNatIpWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a NAT CIDR block.
     *  *
     * @description ## [](#)Description
     * You cannot repeatedly call the **CreateNatIpCidr** operation to create a NAT CIDR block within the specified period of time.
     *  *
     * @param CreateNatIpCidrRequest $request CreateNatIpCidrRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateNatIpCidrResponse CreateNatIpCidrResponse
     */
    public function createNatIpCidrWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->natGatewayId)) {
            $query['NatGatewayId'] = $request->natGatewayId;
        }
        if (!Utils::isUnset($request->natIpCidr)) {
            $query['NatIpCidr'] = $request->natIpCidr;
        }
        if (!Utils::isUnset($request->natIpCidrDescription)) {
            $query['NatIpCidrDescription'] = $request->natIpCidrDescription;
        }
        if (!Utils::isUnset($request->natIpCidrName)) {
            $query['NatIpCidrName'] = $request->natIpCidrName;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateNatIpCidr',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateNatIpCidrResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a NAT CIDR block.
     *  *
     * @description ## [](#)Description
     * You cannot repeatedly call the **CreateNatIpCidr** operation to create a NAT CIDR block within the specified period of time.
     *  *
     * @param CreateNatIpCidrRequest $request CreateNatIpCidrRequest
     *
     * @return CreateNatIpCidrResponse CreateNatIpCidrResponse
     */
    public function createNatIpCidr($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createNatIpCidrWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a network ACL.
     *  *
     * @param CreateNetworkAclRequest $request CreateNetworkAclRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateNetworkAclResponse CreateNetworkAclResponse
     */
    public function createNetworkAclWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->networkAclName)) {
            $query['NetworkAclName'] = $request->networkAclName;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateNetworkAcl',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateNetworkAclResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a network ACL.
     *  *
     * @param CreateNetworkAclRequest $request CreateNetworkAclRequest
     *
     * @return CreateNetworkAclResponse CreateNetworkAclResponse
     */
    public function createNetworkAcl($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createNetworkAclWithOptions($request, $runtime);
    }

    /**
     * @summary Applies for an Express Connect circuit.
     *  *
     * @description You can apply for a dedicated Express Connect circuit for yourself or create a hosted connection for a tenant. After your application is approved, the Express Connect circuit changes to the **Initial** state. You can contact the connectivity provider to start construction.
     * When you call this operation, take note of the following limits:
     * *   If your Alibaba Cloud account has more than five Express Connect circuits that are not in the **Enabled** state, you cannot apply for another Express Connect circuit.
     * *   If your Alibaba Cloud account has an Express Connect circuit with overdue payments, you cannot apply for another Express Connect circuit.
     *  *
     * @param CreatePhysicalConnectionRequest $request CreatePhysicalConnectionRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return CreatePhysicalConnectionResponse CreatePhysicalConnectionResponse
     */
    public function createPhysicalConnectionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->accessPointId)) {
            $query['AccessPointId'] = $request->accessPointId;
        }
        if (!Utils::isUnset($request->circuitCode)) {
            $query['CircuitCode'] = $request->circuitCode;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->deviceAdvancedCapacity)) {
            $query['DeviceAdvancedCapacity'] = $request->deviceAdvancedCapacity;
        }
        if (!Utils::isUnset($request->lineOperator)) {
            $query['LineOperator'] = $request->lineOperator;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->peerLocation)) {
            $query['PeerLocation'] = $request->peerLocation;
        }
        if (!Utils::isUnset($request->portType)) {
            $query['PortType'] = $request->portType;
        }
        if (!Utils::isUnset($request->redundantPhysicalConnectionId)) {
            $query['RedundantPhysicalConnectionId'] = $request->redundantPhysicalConnectionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->bandwidth)) {
            $query['bandwidth'] = $request->bandwidth;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreatePhysicalConnection',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreatePhysicalConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Applies for an Express Connect circuit.
     *  *
     * @description You can apply for a dedicated Express Connect circuit for yourself or create a hosted connection for a tenant. After your application is approved, the Express Connect circuit changes to the **Initial** state. You can contact the connectivity provider to start construction.
     * When you call this operation, take note of the following limits:
     * *   If your Alibaba Cloud account has more than five Express Connect circuits that are not in the **Enabled** state, you cannot apply for another Express Connect circuit.
     * *   If your Alibaba Cloud account has an Express Connect circuit with overdue payments, you cannot apply for another Express Connect circuit.
     *  *
     * @param CreatePhysicalConnectionRequest $request CreatePhysicalConnectionRequest
     *
     * @return CreatePhysicalConnectionResponse CreatePhysicalConnectionResponse
     */
    public function createPhysicalConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createPhysicalConnectionWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an order for resource occupation of an Express Connect circuit.
     *  *
     * @description >  You can call this operation only when the Express Connect circuit is in the **Complete** state.
     *  *
     * @param CreatePhysicalConnectionOccupancyOrderRequest $request CreatePhysicalConnectionOccupancyOrderRequest
     * @param RuntimeOptions                                $runtime runtime options for this request RuntimeOptions
     *
     * @return CreatePhysicalConnectionOccupancyOrderResponse CreatePhysicalConnectionOccupancyOrderResponse
     */
    public function createPhysicalConnectionOccupancyOrderWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->autoPay)) {
            $query['AutoPay'] = $request->autoPay;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->instanceChargeType)) {
            $query['InstanceChargeType'] = $request->instanceChargeType;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->period)) {
            $query['Period'] = $request->period;
        }
        if (!Utils::isUnset($request->physicalConnectionId)) {
            $query['PhysicalConnectionId'] = $request->physicalConnectionId;
        }
        if (!Utils::isUnset($request->pricingCycle)) {
            $query['PricingCycle'] = $request->pricingCycle;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreatePhysicalConnectionOccupancyOrder',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreatePhysicalConnectionOccupancyOrderResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an order for resource occupation of an Express Connect circuit.
     *  *
     * @description >  You can call this operation only when the Express Connect circuit is in the **Complete** state.
     *  *
     * @param CreatePhysicalConnectionOccupancyOrderRequest $request CreatePhysicalConnectionOccupancyOrderRequest
     *
     * @return CreatePhysicalConnectionOccupancyOrderResponse CreatePhysicalConnectionOccupancyOrderResponse
     */
    public function createPhysicalConnectionOccupancyOrder($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createPhysicalConnectionOccupancyOrderWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an order for initial installation of an Express Connect circuit.
     *  *
     * @param CreatePhysicalConnectionSetupOrderRequest $request CreatePhysicalConnectionSetupOrderRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return CreatePhysicalConnectionSetupOrderResponse CreatePhysicalConnectionSetupOrderResponse
     */
    public function createPhysicalConnectionSetupOrderWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->accessPointId)) {
            $query['AccessPointId'] = $request->accessPointId;
        }
        if (!Utils::isUnset($request->autoPay)) {
            $query['AutoPay'] = $request->autoPay;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->lineOperator)) {
            $query['LineOperator'] = $request->lineOperator;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->portType)) {
            $query['PortType'] = $request->portType;
        }
        if (!Utils::isUnset($request->redundantPhysicalConnectionId)) {
            $query['RedundantPhysicalConnectionId'] = $request->redundantPhysicalConnectionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreatePhysicalConnectionSetupOrder',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreatePhysicalConnectionSetupOrderResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an order for initial installation of an Express Connect circuit.
     *  *
     * @param CreatePhysicalConnectionSetupOrderRequest $request CreatePhysicalConnectionSetupOrderRequest
     *
     * @return CreatePhysicalConnectionSetupOrderResponse CreatePhysicalConnectionSetupOrderResponse
     */
    public function createPhysicalConnectionSetupOrder($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createPhysicalConnectionSetupOrderWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an IP address pool.
     *  *
     * @description By default, the IP address pool feature is unavailable. You can apply for the privilege to use the **IP address pool feature** in the Quota Center console. For more information, see the "Request a quota increase in the Quota Center console" section in the [Manage EIP quotas](https://help.aliyun.com/document_detail/108213.html) topic.
     *  *
     * @param CreatePublicIpAddressPoolRequest $request CreatePublicIpAddressPoolRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return CreatePublicIpAddressPoolResponse CreatePublicIpAddressPoolResponse
     */
    public function createPublicIpAddressPoolWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bizType)) {
            $query['BizType'] = $request->bizType;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->isp)) {
            $query['Isp'] = $request->isp;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->securityProtectionTypes)) {
            $query['SecurityProtectionTypes'] = $request->securityProtectionTypes;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->zones)) {
            $query['Zones'] = $request->zones;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreatePublicIpAddressPool',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreatePublicIpAddressPoolResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an IP address pool.
     *  *
     * @description By default, the IP address pool feature is unavailable. You can apply for the privilege to use the **IP address pool feature** in the Quota Center console. For more information, see the "Request a quota increase in the Quota Center console" section in the [Manage EIP quotas](https://help.aliyun.com/document_detail/108213.html) topic.
     *  *
     * @param CreatePublicIpAddressPoolRequest $request CreatePublicIpAddressPoolRequest
     *
     * @return CreatePublicIpAddressPoolResponse CreatePublicIpAddressPoolResponse
     */
    public function createPublicIpAddressPool($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createPublicIpAddressPoolWithOptions($request, $runtime);
    }

    /**
     * @summary Adds custom route entries to the route table of a vRouter in a virtual private cloud (VPC).
     *  *
     * @description ## [](#)References
     * *   **CreateRouteEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
     *     *   If the route entry is in the **Creating** state, the route entry is being created.
     *     *   If the route entry is in the **Created** state, the route entry is created.
     * *   You cannot repeatedly call the **CreateRouteEntries** operation to create the same route entry within the specified period of time.
     * **When you call this operation to add custom route entries to the route table of a vRouter, take note of the following items:**
     * *   A route table can contain up to 200 custom route entries.
     * *   The destination CIDR block (**DstCidrBlock**) of a custom route entry cannot be the same as or overlap with the CIDR block of a vSwitch in the VPC.
     * *   The destination CIDR block (**DstCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or its subnets.
     * *   The destination CIDR blocks (**DstCidrBlock**) of route entries in the same route table must be unique.
     * *   If you do not include the mask length when you specify the destination CIDR block (**DstCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
     * *   Multiple custom route entries can point to the same next hop (**NextHop**).
     * *   The next hop (**NextHop**) of a custom route entry must belong to the same VPC as the route table.
     *  *
     * @param CreateRouteEntriesRequest $request CreateRouteEntriesRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateRouteEntriesResponse CreateRouteEntriesResponse
     */
    public function createRouteEntriesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeEntries)) {
            $query['RouteEntries'] = $request->routeEntries;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateRouteEntries',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateRouteEntriesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds custom route entries to the route table of a vRouter in a virtual private cloud (VPC).
     *  *
     * @description ## [](#)References
     * *   **CreateRouteEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
     *     *   If the route entry is in the **Creating** state, the route entry is being created.
     *     *   If the route entry is in the **Created** state, the route entry is created.
     * *   You cannot repeatedly call the **CreateRouteEntries** operation to create the same route entry within the specified period of time.
     * **When you call this operation to add custom route entries to the route table of a vRouter, take note of the following items:**
     * *   A route table can contain up to 200 custom route entries.
     * *   The destination CIDR block (**DstCidrBlock**) of a custom route entry cannot be the same as or overlap with the CIDR block of a vSwitch in the VPC.
     * *   The destination CIDR block (**DstCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or its subnets.
     * *   The destination CIDR blocks (**DstCidrBlock**) of route entries in the same route table must be unique.
     * *   If you do not include the mask length when you specify the destination CIDR block (**DstCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
     * *   Multiple custom route entries can point to the same next hop (**NextHop**).
     * *   The next hop (**NextHop**) of a custom route entry must belong to the same VPC as the route table.
     *  *
     * @param CreateRouteEntriesRequest $request CreateRouteEntriesRequest
     *
     * @return CreateRouteEntriesResponse CreateRouteEntriesResponse
     */
    public function createRouteEntries($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createRouteEntriesWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a custom route entry in the route table of a VRouter or virtual border router (VBR).
     *  *
     * @description *   **CreateRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task:
     *     *   If a route is in the **Creating** state, the route is being added.
     *     *   If a route is in the **Created** state, the route is added.
     * *   You cannot repeatedly call **CreateRouteEntry** within a specific period of time.
     * **When you call this operation to add a custom route entry to the route table of a vRouter, take note of the following limits:**
     * >  When you add a route entry from a prefix list, the quota usage is calculated by adding the number of existing route entries and the maximum number of route entries of the prefix list.
     * *   A route table can contain up to 200 custom route entries.
     * *   The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be the same as or be a subset of the CIDR block of a vSwitch in the virtual private cloud (VPC). The destination CIDR block can contain the CIDR block of a vSwitch.
     * *   The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or a subset of it.
     * *   The destination CIDR blocks (**DestinationCidrBlock**) of route entries in the same route table must be unique.
     * *   If you do not include the mask length when you specify the destination CIDR block (**DestinationCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
     * *   Multiple custom route entries can point to the same next hop (**NextHopId**).
     * *   The next hop (**NextHopId**) of a custom route entry must in the same VPC as the route table.
     * *   Equal-cost multi-path (ECMP) routing can be configured by specifying the **NextHopList** parameter.
     *     *   When you add non-ECMP route entries, you must specify **DestinationCidrBlock**, **NextHopType**, and **NextHopId**, and you must not specify **NextHopList**.
     *     *   When you add route entries for ECMP routing, you must specify **DestinationCidrBlock** and **NextHopList**, and you must not specify **NextHopType** or **NextHopId**.
     * **When you call this operation to add a custom route entry to the route table of a VBR, take note of the following limits:**
     * *   A route table can contain up to 200 custom route entries.
     * *   **NextHopList** is not supported.
     * *   The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or a subset of it.
     * *   The destination CIDR blocks (**DestinationCidrBlock**) of route entries in the same route table must be unique.
     * *   If you do not include the mask length when you specify the destination CIDR block (**DestinationCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
     * *   Multiple custom route entries can point to the same next hop (**NextHopId**).
     * *   The next hop (**NextHopId**) of a custom route entry must be a router interface associated with the VBR.
     * *   You can add route entries only when the VBR is in the **Active** state, and the Express Connect circuit associated with the VBR is in the **Enabled** state and is not locked due to overdue payments.
     * *   Only non-ECMP route entries are supported. When you add non-ECMP route entries, you must specify **DestinationCidrBlock**, **NextHopType**, and **NextHopId**, and you cannot specify **NextHopList**.
     *  *
     * @param CreateRouteEntryRequest $request CreateRouteEntryRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateRouteEntryResponse CreateRouteEntryResponse
     */
    public function createRouteEntryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->destinationCidrBlock)) {
            $query['DestinationCidrBlock'] = $request->destinationCidrBlock;
        }
        if (!Utils::isUnset($request->nextHopId)) {
            $query['NextHopId'] = $request->nextHopId;
        }
        if (!Utils::isUnset($request->nextHopList)) {
            $query['NextHopList'] = $request->nextHopList;
        }
        if (!Utils::isUnset($request->nextHopType)) {
            $query['NextHopType'] = $request->nextHopType;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeEntryName)) {
            $query['RouteEntryName'] = $request->routeEntryName;
        }
        if (!Utils::isUnset($request->routeTableId)) {
            $query['RouteTableId'] = $request->routeTableId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateRouteEntry',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateRouteEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a custom route entry in the route table of a VRouter or virtual border router (VBR).
     *  *
     * @description *   **CreateRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task:
     *     *   If a route is in the **Creating** state, the route is being added.
     *     *   If a route is in the **Created** state, the route is added.
     * *   You cannot repeatedly call **CreateRouteEntry** within a specific period of time.
     * **When you call this operation to add a custom route entry to the route table of a vRouter, take note of the following limits:**
     * >  When you add a route entry from a prefix list, the quota usage is calculated by adding the number of existing route entries and the maximum number of route entries of the prefix list.
     * *   A route table can contain up to 200 custom route entries.
     * *   The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be the same as or be a subset of the CIDR block of a vSwitch in the virtual private cloud (VPC). The destination CIDR block can contain the CIDR block of a vSwitch.
     * *   The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or a subset of it.
     * *   The destination CIDR blocks (**DestinationCidrBlock**) of route entries in the same route table must be unique.
     * *   If you do not include the mask length when you specify the destination CIDR block (**DestinationCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
     * *   Multiple custom route entries can point to the same next hop (**NextHopId**).
     * *   The next hop (**NextHopId**) of a custom route entry must in the same VPC as the route table.
     * *   Equal-cost multi-path (ECMP) routing can be configured by specifying the **NextHopList** parameter.
     *     *   When you add non-ECMP route entries, you must specify **DestinationCidrBlock**, **NextHopType**, and **NextHopId**, and you must not specify **NextHopList**.
     *     *   When you add route entries for ECMP routing, you must specify **DestinationCidrBlock** and **NextHopList**, and you must not specify **NextHopType** or **NextHopId**.
     * **When you call this operation to add a custom route entry to the route table of a VBR, take note of the following limits:**
     * *   A route table can contain up to 200 custom route entries.
     * *   **NextHopList** is not supported.
     * *   The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or a subset of it.
     * *   The destination CIDR blocks (**DestinationCidrBlock**) of route entries in the same route table must be unique.
     * *   If you do not include the mask length when you specify the destination CIDR block (**DestinationCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
     * *   Multiple custom route entries can point to the same next hop (**NextHopId**).
     * *   The next hop (**NextHopId**) of a custom route entry must be a router interface associated with the VBR.
     * *   You can add route entries only when the VBR is in the **Active** state, and the Express Connect circuit associated with the VBR is in the **Enabled** state and is not locked due to overdue payments.
     * *   Only non-ECMP route entries are supported. When you add non-ECMP route entries, you must specify **DestinationCidrBlock**, **NextHopType**, and **NextHopId**, and you cannot specify **NextHopList**.
     *  *
     * @param CreateRouteEntryRequest $request CreateRouteEntryRequest
     *
     * @return CreateRouteEntryResponse CreateRouteEntryResponse
     */
    public function createRouteEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createRouteEntryWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a custom route table.
     *  *
     * @description *   **CreateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the operation in the background. You can call the [DescribeRouteTableList](https://help.aliyun.com/document_detail/87602.html) operation to query the status of the task.
     *     *   If the custom route table is in the **Creating** state, the custom route table is being created.
     *     *   If the custom route table is in the **Created** state, the custom route table is created.
     * *   You cannot repeatedly call the **CreateRouteTable** operation within the specified period of time.
     *  *
     * @param CreateRouteTableRequest $request CreateRouteTableRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateRouteTableResponse CreateRouteTableResponse
     */
    public function createRouteTableWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->associateType)) {
            $query['AssociateType'] = $request->associateType;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeTableName)) {
            $query['RouteTableName'] = $request->routeTableName;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateRouteTable',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateRouteTableResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a custom route table.
     *  *
     * @description *   **CreateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the operation in the background. You can call the [DescribeRouteTableList](https://help.aliyun.com/document_detail/87602.html) operation to query the status of the task.
     *     *   If the custom route table is in the **Creating** state, the custom route table is being created.
     *     *   If the custom route table is in the **Created** state, the custom route table is created.
     * *   You cannot repeatedly call the **CreateRouteTable** operation within the specified period of time.
     *  *
     * @param CreateRouteTableRequest $request CreateRouteTableRequest
     *
     * @return CreateRouteTableResponse CreateRouteTableResponse
     */
    public function createRouteTable($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createRouteTableWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a router interface.
     *  *
     * @description When you call this operation, take note of the following limits:
     * *   You can create only one pair of interfaces to be connected between two routers.
     * *   You can create a maximum of five router interfaces for a router.
     * *   If your Alibaba Cloud account has a router interface with overdue payments, you cannot create new router interfaces.
     * *   Each destination CIDR block of route entries in the same route table must be unique.
     * *   A virtual border router (VBR) can serve only as a requester. The VBR must be in the Activated state.
     * *   You can call this operation to create subscription and pay-as-you-go router interfaces.
     *  *
     * @param CreateRouterInterfaceRequest $request CreateRouterInterfaceRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateRouterInterfaceResponse CreateRouterInterfaceResponse
     */
    public function createRouterInterfaceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->accessPointId)) {
            $query['AccessPointId'] = $request->accessPointId;
        }
        if (!Utils::isUnset($request->autoPay)) {
            $query['AutoPay'] = $request->autoPay;
        }
        if (!Utils::isUnset($request->autoRenew)) {
            $query['AutoRenew'] = $request->autoRenew;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->fastLinkMode)) {
            $query['FastLinkMode'] = $request->fastLinkMode;
        }
        if (!Utils::isUnset($request->healthCheckSourceIp)) {
            $query['HealthCheckSourceIp'] = $request->healthCheckSourceIp;
        }
        if (!Utils::isUnset($request->healthCheckTargetIp)) {
            $query['HealthCheckTargetIp'] = $request->healthCheckTargetIp;
        }
        if (!Utils::isUnset($request->instanceChargeType)) {
            $query['InstanceChargeType'] = $request->instanceChargeType;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->oppositeAccessPointId)) {
            $query['OppositeAccessPointId'] = $request->oppositeAccessPointId;
        }
        if (!Utils::isUnset($request->oppositeInterfaceId)) {
            $query['OppositeInterfaceId'] = $request->oppositeInterfaceId;
        }
        if (!Utils::isUnset($request->oppositeInterfaceOwnerId)) {
            $query['OppositeInterfaceOwnerId'] = $request->oppositeInterfaceOwnerId;
        }
        if (!Utils::isUnset($request->oppositeRegionId)) {
            $query['OppositeRegionId'] = $request->oppositeRegionId;
        }
        if (!Utils::isUnset($request->oppositeRouterId)) {
            $query['OppositeRouterId'] = $request->oppositeRouterId;
        }
        if (!Utils::isUnset($request->oppositeRouterType)) {
            $query['OppositeRouterType'] = $request->oppositeRouterType;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->period)) {
            $query['Period'] = $request->period;
        }
        if (!Utils::isUnset($request->pricingCycle)) {
            $query['PricingCycle'] = $request->pricingCycle;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->role)) {
            $query['Role'] = $request->role;
        }
        if (!Utils::isUnset($request->routerId)) {
            $query['RouterId'] = $request->routerId;
        }
        if (!Utils::isUnset($request->routerType)) {
            $query['RouterType'] = $request->routerType;
        }
        if (!Utils::isUnset($request->spec)) {
            $query['Spec'] = $request->spec;
        }
        if (!Utils::isUnset($request->tags)) {
            $query['Tags'] = $request->tags;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateRouterInterface',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateRouterInterfaceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a router interface.
     *  *
     * @description When you call this operation, take note of the following limits:
     * *   You can create only one pair of interfaces to be connected between two routers.
     * *   You can create a maximum of five router interfaces for a router.
     * *   If your Alibaba Cloud account has a router interface with overdue payments, you cannot create new router interfaces.
     * *   Each destination CIDR block of route entries in the same route table must be unique.
     * *   A virtual border router (VBR) can serve only as a requester. The VBR must be in the Activated state.
     * *   You can call this operation to create subscription and pay-as-you-go router interfaces.
     *  *
     * @param CreateRouterInterfaceRequest $request CreateRouterInterfaceRequest
     *
     * @return CreateRouterInterfaceResponse CreateRouterInterfaceResponse
     */
    public function createRouterInterface($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createRouterInterfaceWithOptions($request, $runtime);
    }

    /**
     * @summary Adds an SNAT entry to an SNAT table.
     *  *
     * @description You can call this operation to add SNAT entries to Internet NAT gateways and Virtual Private Cloud (VPC) NAT gateways. In this topic, a **NAT** gateway refers to both gateway types.
     * Before you call this operation, take note of the following limits:
     * *   **CreateSnatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of the task.
     *     *   If the SNAT entry is in the **Pending** state, the system is adding the SNAT entry. You can only query the status of the SNAT entry, and cannot perform other operations.
     *     *   If the SNAT entry is in the **Available** state, the SNAT entry is added.
     * *   You cannot repeatedly call the **CreateSnatEntry** operation to add an SNAT entry to an SNAT table within the specified period of time.
     * *   The vSwitch and Elastic Compute Service (ECS) instance specified in an SNAT entry must be created in the VPC where the NAT gateway is deployed.
     * *   Each vSwitch or ECS instance can be specified in only one SNAT entry.
     * *   If a high-availability virtual IP address (HAVIP) exists in a vSwitch, you cannot create SNAT entries.
     *  *
     * @param CreateSnatEntryRequest $request CreateSnatEntryRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateSnatEntryResponse CreateSnatEntryResponse
     */
    public function createSnatEntryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->eipAffinity)) {
            $query['EipAffinity'] = $request->eipAffinity;
        }
        if (!Utils::isUnset($request->networkInterfaceId)) {
            $query['NetworkInterfaceId'] = $request->networkInterfaceId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->snatEntryName)) {
            $query['SnatEntryName'] = $request->snatEntryName;
        }
        if (!Utils::isUnset($request->snatIp)) {
            $query['SnatIp'] = $request->snatIp;
        }
        if (!Utils::isUnset($request->snatTableId)) {
            $query['SnatTableId'] = $request->snatTableId;
        }
        if (!Utils::isUnset($request->sourceCIDR)) {
            $query['SourceCIDR'] = $request->sourceCIDR;
        }
        if (!Utils::isUnset($request->sourceVSwitchId)) {
            $query['SourceVSwitchId'] = $request->sourceVSwitchId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateSnatEntry',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateSnatEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds an SNAT entry to an SNAT table.
     *  *
     * @description You can call this operation to add SNAT entries to Internet NAT gateways and Virtual Private Cloud (VPC) NAT gateways. In this topic, a **NAT** gateway refers to both gateway types.
     * Before you call this operation, take note of the following limits:
     * *   **CreateSnatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of the task.
     *     *   If the SNAT entry is in the **Pending** state, the system is adding the SNAT entry. You can only query the status of the SNAT entry, and cannot perform other operations.
     *     *   If the SNAT entry is in the **Available** state, the SNAT entry is added.
     * *   You cannot repeatedly call the **CreateSnatEntry** operation to add an SNAT entry to an SNAT table within the specified period of time.
     * *   The vSwitch and Elastic Compute Service (ECS) instance specified in an SNAT entry must be created in the VPC where the NAT gateway is deployed.
     * *   Each vSwitch or ECS instance can be specified in only one SNAT entry.
     * *   If a high-availability virtual IP address (HAVIP) exists in a vSwitch, you cannot create SNAT entries.
     *  *
     * @param CreateSnatEntryRequest $request CreateSnatEntryRequest
     *
     * @return CreateSnatEntryResponse CreateSnatEntryResponse
     */
    public function createSnatEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createSnatEntryWithOptions($request, $runtime);
    }

    /**
     * @summary 创建SSL-VPN客户端证书
     *  *
     * @param CreateSslVpnClientCertRequest $request CreateSslVpnClientCertRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateSslVpnClientCertResponse CreateSslVpnClientCertResponse
     */
    public function createSslVpnClientCertWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sslVpnServerId)) {
            $query['SslVpnServerId'] = $request->sslVpnServerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateSslVpnClientCert',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateSslVpnClientCertResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 创建SSL-VPN客户端证书
     *  *
     * @param CreateSslVpnClientCertRequest $request CreateSslVpnClientCertRequest
     *
     * @return CreateSslVpnClientCertResponse CreateSslVpnClientCertResponse
     */
    public function createSslVpnClientCert($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createSslVpnClientCertWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an SSL server.
     *  *
     * @description *   **CreateSslVpnServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the SSL server is being created.
     *     *   If the VPN gateway is in the **active** state, the SSL server is created.
     * *   You cannot repeatedly call the **CreateSslVpnServer** operation within the specified period of time.
     * ### [](#)Prerequisite
     * *   A VPN gateway is created, and the SSL-VPN feature is enabled for the VPN gateway. For more information, see [CreateVpnGateway](https://help.aliyun.com/document_detail/2794049.html).
     * *   If you want to enable two-factor authentication for the SSL server, make sure that the VPN gateway supports two-factor authentication. You may need to upgrade the VPN gateway. For more information, see [Two-factor authentication supports IDaaS EIAM 2.0](https://help.aliyun.com/document_detail/2785320.html).
     *  *
     * @param CreateSslVpnServerRequest $request CreateSslVpnServerRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateSslVpnServerResponse CreateSslVpnServerResponse
     */
    public function createSslVpnServerWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->cipher)) {
            $query['Cipher'] = $request->cipher;
        }
        if (!Utils::isUnset($request->clientIpPool)) {
            $query['ClientIpPool'] = $request->clientIpPool;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->compress)) {
            $query['Compress'] = $request->compress;
        }
        if (!Utils::isUnset($request->enableMultiFactorAuth)) {
            $query['EnableMultiFactorAuth'] = $request->enableMultiFactorAuth;
        }
        if (!Utils::isUnset($request->IDaaSApplicationId)) {
            $query['IDaaSApplicationId'] = $request->IDaaSApplicationId;
        }
        if (!Utils::isUnset($request->IDaaSInstanceId)) {
            $query['IDaaSInstanceId'] = $request->IDaaSInstanceId;
        }
        if (!Utils::isUnset($request->IDaaSRegionId)) {
            $query['IDaaSRegionId'] = $request->IDaaSRegionId;
        }
        if (!Utils::isUnset($request->localSubnet)) {
            $query['LocalSubnet'] = $request->localSubnet;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->port)) {
            $query['Port'] = $request->port;
        }
        if (!Utils::isUnset($request->proto)) {
            $query['Proto'] = $request->proto;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vpnGatewayId)) {
            $query['VpnGatewayId'] = $request->vpnGatewayId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateSslVpnServer',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateSslVpnServerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an SSL server.
     *  *
     * @description *   **CreateSslVpnServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the SSL server is being created.
     *     *   If the VPN gateway is in the **active** state, the SSL server is created.
     * *   You cannot repeatedly call the **CreateSslVpnServer** operation within the specified period of time.
     * ### [](#)Prerequisite
     * *   A VPN gateway is created, and the SSL-VPN feature is enabled for the VPN gateway. For more information, see [CreateVpnGateway](https://help.aliyun.com/document_detail/2794049.html).
     * *   If you want to enable two-factor authentication for the SSL server, make sure that the VPN gateway supports two-factor authentication. You may need to upgrade the VPN gateway. For more information, see [Two-factor authentication supports IDaaS EIAM 2.0](https://help.aliyun.com/document_detail/2785320.html).
     *  *
     * @param CreateSslVpnServerRequest $request CreateSslVpnServerRequest
     *
     * @return CreateSslVpnServerResponse CreateSslVpnServerResponse
     */
    public function createSslVpnServer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createSslVpnServerWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a filter for traffic mirroring.
     *  *
     * @description **CreateTrafficMirrorFilter** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of the task.
     * *   If the filter is in the **Creating** state, the filter is being created.
     * *   If the filter is in the **Created** state, the filter is created.
     *  *
     * @param CreateTrafficMirrorFilterRequest $request CreateTrafficMirrorFilterRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateTrafficMirrorFilterResponse CreateTrafficMirrorFilterResponse
     */
    public function createTrafficMirrorFilterWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->egressRules)) {
            $query['EgressRules'] = $request->egressRules;
        }
        if (!Utils::isUnset($request->ingressRules)) {
            $query['IngressRules'] = $request->ingressRules;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->trafficMirrorFilterDescription)) {
            $query['TrafficMirrorFilterDescription'] = $request->trafficMirrorFilterDescription;
        }
        if (!Utils::isUnset($request->trafficMirrorFilterName)) {
            $query['TrafficMirrorFilterName'] = $request->trafficMirrorFilterName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateTrafficMirrorFilter',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateTrafficMirrorFilterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a filter for traffic mirroring.
     *  *
     * @description **CreateTrafficMirrorFilter** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of the task.
     * *   If the filter is in the **Creating** state, the filter is being created.
     * *   If the filter is in the **Created** state, the filter is created.
     *  *
     * @param CreateTrafficMirrorFilterRequest $request CreateTrafficMirrorFilterRequest
     *
     * @return CreateTrafficMirrorFilterResponse CreateTrafficMirrorFilterResponse
     */
    public function createTrafficMirrorFilter($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createTrafficMirrorFilterWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an inbound or outbound rule for traffic mirroring.
     *  *
     * @description *   **CreateTrafficMirrorFilterRules** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) to query the status of the task.
     *     *   If the inbound or outbound rule is in the **Creating** state, the rule is being created.
     *     *   If the inbound or outbound rule is in the **Created** state, the rule is created.
     * *   You cannot call **CreateTrafficMirrorFilterRules** within the specified period of time.
     *  *
     * @param CreateTrafficMirrorFilterRulesRequest $request CreateTrafficMirrorFilterRulesRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateTrafficMirrorFilterRulesResponse CreateTrafficMirrorFilterRulesResponse
     */
    public function createTrafficMirrorFilterRulesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->egressRules)) {
            $query['EgressRules'] = $request->egressRules;
        }
        if (!Utils::isUnset($request->ingressRules)) {
            $query['IngressRules'] = $request->ingressRules;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->trafficMirrorFilterId)) {
            $query['TrafficMirrorFilterId'] = $request->trafficMirrorFilterId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateTrafficMirrorFilterRules',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateTrafficMirrorFilterRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an inbound or outbound rule for traffic mirroring.
     *  *
     * @description *   **CreateTrafficMirrorFilterRules** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) to query the status of the task.
     *     *   If the inbound or outbound rule is in the **Creating** state, the rule is being created.
     *     *   If the inbound or outbound rule is in the **Created** state, the rule is created.
     * *   You cannot call **CreateTrafficMirrorFilterRules** within the specified period of time.
     *  *
     * @param CreateTrafficMirrorFilterRulesRequest $request CreateTrafficMirrorFilterRulesRequest
     *
     * @return CreateTrafficMirrorFilterRulesResponse CreateTrafficMirrorFilterRulesResponse
     */
    public function createTrafficMirrorFilterRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createTrafficMirrorFilterRulesWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a traffic mirror session.
     *  *
     * @description **CreateTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) to query the status of the task.
     * *   If the traffic mirror session is in the **Creating** state, it is being created.
     * *   If the traffic mirror session is in the **Created** state, it is created.
     *  *
     * @param CreateTrafficMirrorSessionRequest $request CreateTrafficMirrorSessionRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateTrafficMirrorSessionResponse CreateTrafficMirrorSessionResponse
     */
    public function createTrafficMirrorSessionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->enabled)) {
            $query['Enabled'] = $request->enabled;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->packetLength)) {
            $query['PacketLength'] = $request->packetLength;
        }
        if (!Utils::isUnset($request->priority)) {
            $query['Priority'] = $request->priority;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->trafficMirrorFilterId)) {
            $query['TrafficMirrorFilterId'] = $request->trafficMirrorFilterId;
        }
        if (!Utils::isUnset($request->trafficMirrorSessionDescription)) {
            $query['TrafficMirrorSessionDescription'] = $request->trafficMirrorSessionDescription;
        }
        if (!Utils::isUnset($request->trafficMirrorSessionName)) {
            $query['TrafficMirrorSessionName'] = $request->trafficMirrorSessionName;
        }
        if (!Utils::isUnset($request->trafficMirrorSourceIds)) {
            $query['TrafficMirrorSourceIds'] = $request->trafficMirrorSourceIds;
        }
        if (!Utils::isUnset($request->trafficMirrorTargetId)) {
            $query['TrafficMirrorTargetId'] = $request->trafficMirrorTargetId;
        }
        if (!Utils::isUnset($request->trafficMirrorTargetType)) {
            $query['TrafficMirrorTargetType'] = $request->trafficMirrorTargetType;
        }
        if (!Utils::isUnset($request->virtualNetworkId)) {
            $query['VirtualNetworkId'] = $request->virtualNetworkId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateTrafficMirrorSession',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateTrafficMirrorSessionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a traffic mirror session.
     *  *
     * @description **CreateTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) to query the status of the task.
     * *   If the traffic mirror session is in the **Creating** state, it is being created.
     * *   If the traffic mirror session is in the **Created** state, it is created.
     *  *
     * @param CreateTrafficMirrorSessionRequest $request CreateTrafficMirrorSessionRequest
     *
     * @return CreateTrafficMirrorSessionResponse CreateTrafficMirrorSessionResponse
     */
    public function createTrafficMirrorSession($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createTrafficMirrorSessionWithOptions($request, $runtime);
    }

    /**
     * @summary 创建交换机。
     *  *
     * @description When you call this operation, take note of the following limits:
     * *   You can create at most 150 vSwitches in a virtual private cloud (VPC).
     * *   The first IP address and last three IP addresses of each vSwitch CIDR block are reserved. For example, if the CIDR block of a vSwitch is 192.168.1.0/24, the IP addresses 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255 are reserved.
     * *   The number of instances in a vSwitch cannot exceed the remaining capacity of the VPC. The remaining capacity is the difference between 15,000 and the current number of instances.
     * *   Each instance can belong to only one vSwitch.
     * *   vSwitches do not support multicast or broadcast.
     * *   After you create a vSwitch, you cannot modify its CIDR block.
     * *   **CreateVSwitch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) to query the status of the task.
     *     *   If the vSwitch is in the **Pending** state, the vSwitch is being configured.
     *     *   If the vSwitch is in the **Available** state, the vSwitch is available.
     * *   You cannot repeatedly call the **CreateVSwitch** operation to create a vSwitch in a VPC within the specified period of time.
     *  *
     * @param CreateVSwitchRequest $request CreateVSwitchRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateVSwitchResponse CreateVSwitchResponse
     */
    public function createVSwitchWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->cidrBlock)) {
            $query['CidrBlock'] = $request->cidrBlock;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->ipv6CidrBlock)) {
            $query['Ipv6CidrBlock'] = $request->ipv6CidrBlock;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->vSwitchName)) {
            $query['VSwitchName'] = $request->vSwitchName;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        if (!Utils::isUnset($request->vpcIpv6CidrBlock)) {
            $query['VpcIpv6CidrBlock'] = $request->vpcIpv6CidrBlock;
        }
        if (!Utils::isUnset($request->zoneId)) {
            $query['ZoneId'] = $request->zoneId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateVSwitch',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateVSwitchResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 创建交换机。
     *  *
     * @description When you call this operation, take note of the following limits:
     * *   You can create at most 150 vSwitches in a virtual private cloud (VPC).
     * *   The first IP address and last three IP addresses of each vSwitch CIDR block are reserved. For example, if the CIDR block of a vSwitch is 192.168.1.0/24, the IP addresses 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255 are reserved.
     * *   The number of instances in a vSwitch cannot exceed the remaining capacity of the VPC. The remaining capacity is the difference between 15,000 and the current number of instances.
     * *   Each instance can belong to only one vSwitch.
     * *   vSwitches do not support multicast or broadcast.
     * *   After you create a vSwitch, you cannot modify its CIDR block.
     * *   **CreateVSwitch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) to query the status of the task.
     *     *   If the vSwitch is in the **Pending** state, the vSwitch is being configured.
     *     *   If the vSwitch is in the **Available** state, the vSwitch is available.
     * *   You cannot repeatedly call the **CreateVSwitch** operation to create a vSwitch in a VPC within the specified period of time.
     *  *
     * @param CreateVSwitchRequest $request CreateVSwitchRequest
     *
     * @return CreateVSwitchResponse CreateVSwitchResponse
     */
    public function createVSwitch($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVSwitchWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a reserved CIDR block for a vSwitch.
     *  *
     * @description ## [](#)Description
     * Take note of the following items:
     * *   You can create at most 10 reserved IPv4 CIDR blocks and 10 reserved IPv6 CIDR blocks for each vSwitch in a virtual private cloud (VPC).
     * *   After you create a reserved CIDR block for a vSwitch, the CIDR block cannot contain the IP address of the subnet gateway of the VPC to which the vSwitch belongs.
     * *   **CreateVSwitchCidrReservation** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListVSwitchCidrReservations](https://help.aliyun.com/document_detail/610155.html) to query the status of the task:
     *     *   If the vSwitch is in the **Assigning** state, the reserved CIDR block is being created.
     *     *   If the vSwitch is in the **Assigned** state, the reserved CIDR block is created.
     * *   When you create a reserved IPv4 CIDR block for a vSwitch, the first IP address and the last three IP addresses of the vSwitch are reserved by the system. The four IP addresses will not be allocated.
     * *   When you create a reserved IPv6 CIDR block for a vSwitch, the first IP address and the last nine IP addresses of the vSwitch are reserved by the system. The 10 IP addresses will not be allocated. For example, if you create a reserved IPv4 CIDR block for a vSwitch whose CIDR block is 192.168.1.0/24, the reserved CIDR block cannot contain the following IP addresses: 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255.
     *  *
     * @param CreateVSwitchCidrReservationRequest $request CreateVSwitchCidrReservationRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateVSwitchCidrReservationResponse CreateVSwitchCidrReservationResponse
     */
    public function createVSwitchCidrReservationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ipVersion)) {
            $query['IpVersion'] = $request->ipVersion;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->vSwitchCidrReservationCidr)) {
            $query['VSwitchCidrReservationCidr'] = $request->vSwitchCidrReservationCidr;
        }
        if (!Utils::isUnset($request->vSwitchCidrReservationDescription)) {
            $query['VSwitchCidrReservationDescription'] = $request->vSwitchCidrReservationDescription;
        }
        if (!Utils::isUnset($request->vSwitchCidrReservationMask)) {
            $query['VSwitchCidrReservationMask'] = $request->vSwitchCidrReservationMask;
        }
        if (!Utils::isUnset($request->vSwitchCidrReservationName)) {
            $query['VSwitchCidrReservationName'] = $request->vSwitchCidrReservationName;
        }
        if (!Utils::isUnset($request->vSwitchCidrReservationType)) {
            $query['VSwitchCidrReservationType'] = $request->vSwitchCidrReservationType;
        }
        if (!Utils::isUnset($request->vSwitchId)) {
            $query['VSwitchId'] = $request->vSwitchId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateVSwitchCidrReservation',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateVSwitchCidrReservationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a reserved CIDR block for a vSwitch.
     *  *
     * @description ## [](#)Description
     * Take note of the following items:
     * *   You can create at most 10 reserved IPv4 CIDR blocks and 10 reserved IPv6 CIDR blocks for each vSwitch in a virtual private cloud (VPC).
     * *   After you create a reserved CIDR block for a vSwitch, the CIDR block cannot contain the IP address of the subnet gateway of the VPC to which the vSwitch belongs.
     * *   **CreateVSwitchCidrReservation** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListVSwitchCidrReservations](https://help.aliyun.com/document_detail/610155.html) to query the status of the task:
     *     *   If the vSwitch is in the **Assigning** state, the reserved CIDR block is being created.
     *     *   If the vSwitch is in the **Assigned** state, the reserved CIDR block is created.
     * *   When you create a reserved IPv4 CIDR block for a vSwitch, the first IP address and the last three IP addresses of the vSwitch are reserved by the system. The four IP addresses will not be allocated.
     * *   When you create a reserved IPv6 CIDR block for a vSwitch, the first IP address and the last nine IP addresses of the vSwitch are reserved by the system. The 10 IP addresses will not be allocated. For example, if you create a reserved IPv4 CIDR block for a vSwitch whose CIDR block is 192.168.1.0/24, the reserved CIDR block cannot contain the following IP addresses: 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255.
     *  *
     * @param CreateVSwitchCidrReservationRequest $request CreateVSwitchCidrReservationRequest
     *
     * @return CreateVSwitchCidrReservationResponse CreateVSwitchCidrReservationResponse
     */
    public function createVSwitchCidrReservation($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVSwitchCidrReservationWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a virtual border router (VBR) failover group.
     *  *
     * @param CreateVbrHaRequest $request CreateVbrHaRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateVbrHaResponse CreateVbrHaResponse
     */
    public function createVbrHaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->peerVbrId)) {
            $query['PeerVbrId'] = $request->peerVbrId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vbrId)) {
            $query['VbrId'] = $request->vbrId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateVbrHa',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateVbrHaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a virtual border router (VBR) failover group.
     *  *
     * @param CreateVbrHaRequest $request CreateVbrHaRequest
     *
     * @return CreateVbrHaResponse CreateVbrHaResponse
     */
    public function createVbrHa($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVbrHaWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a destination-based route for an IPsec-VPN connection.
     *  *
     * @description *   The IPsec-VPN connection must be associated with a transit router. For more information, see [CreateTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/468249.html).
     * *   You cannot create a destination-based route whose destination CIDR block is 0.0.0.0/0.
     * *   Do not add a destination-based route whose destination CIDR block is 100.64.0.0/10, or a CIDR block that contains 100.64.0.0/10 or belongs to 100.64.0.0/10. Such a route will make the console fail to display the status of the IPsec-VPN connection or cause IPsec negotiation failures.
     * *   **CreateVcoRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) to query the status of the task.
     *     *   If the IPsec-VPN connection is in the **updating** state, the destination-based route is being created.
     *     *   If the IPsec-VPN connection is in the **attached** state, the destination-based route is created.
     * *   You cannot repeatedly call **CreateVcoRouteEntry** within the specified period of time.
     *  *
     * @param CreateVcoRouteEntryRequest $request CreateVcoRouteEntryRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateVcoRouteEntryResponse CreateVcoRouteEntryResponse
     */
    public function createVcoRouteEntryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->nextHop)) {
            $query['NextHop'] = $request->nextHop;
        }
        if (!Utils::isUnset($request->overlayMode)) {
            $query['OverlayMode'] = $request->overlayMode;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeDest)) {
            $query['RouteDest'] = $request->routeDest;
        }
        if (!Utils::isUnset($request->vpnConnectionId)) {
            $query['VpnConnectionId'] = $request->vpnConnectionId;
        }
        if (!Utils::isUnset($request->weight)) {
            $query['Weight'] = $request->weight;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateVcoRouteEntry',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateVcoRouteEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a destination-based route for an IPsec-VPN connection.
     *  *
     * @description *   The IPsec-VPN connection must be associated with a transit router. For more information, see [CreateTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/468249.html).
     * *   You cannot create a destination-based route whose destination CIDR block is 0.0.0.0/0.
     * *   Do not add a destination-based route whose destination CIDR block is 100.64.0.0/10, or a CIDR block that contains 100.64.0.0/10 or belongs to 100.64.0.0/10. Such a route will make the console fail to display the status of the IPsec-VPN connection or cause IPsec negotiation failures.
     * *   **CreateVcoRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) to query the status of the task.
     *     *   If the IPsec-VPN connection is in the **updating** state, the destination-based route is being created.
     *     *   If the IPsec-VPN connection is in the **attached** state, the destination-based route is created.
     * *   You cannot repeatedly call **CreateVcoRouteEntry** within the specified period of time.
     *  *
     * @param CreateVcoRouteEntryRequest $request CreateVcoRouteEntryRequest
     *
     * @return CreateVcoRouteEntryResponse CreateVcoRouteEntryResponse
     */
    public function createVcoRouteEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVcoRouteEntryWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a virtual border router (VBR).
     *  *
     * @description After you create a VBR, the VBR is in the **active** state.
     *  *
     * @param CreateVirtualBorderRouterRequest $request CreateVirtualBorderRouterRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateVirtualBorderRouterResponse CreateVirtualBorderRouterResponse
     */
    public function createVirtualBorderRouterWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bandwidth)) {
            $query['Bandwidth'] = $request->bandwidth;
        }
        if (!Utils::isUnset($request->circuitCode)) {
            $query['CircuitCode'] = $request->circuitCode;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->enableIpv6)) {
            $query['EnableIpv6'] = $request->enableIpv6;
        }
        if (!Utils::isUnset($request->localGatewayIp)) {
            $query['LocalGatewayIp'] = $request->localGatewayIp;
        }
        if (!Utils::isUnset($request->localIpv6GatewayIp)) {
            $query['LocalIpv6GatewayIp'] = $request->localIpv6GatewayIp;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->peerGatewayIp)) {
            $query['PeerGatewayIp'] = $request->peerGatewayIp;
        }
        if (!Utils::isUnset($request->peerIpv6GatewayIp)) {
            $query['PeerIpv6GatewayIp'] = $request->peerIpv6GatewayIp;
        }
        if (!Utils::isUnset($request->peeringIpv6SubnetMask)) {
            $query['PeeringIpv6SubnetMask'] = $request->peeringIpv6SubnetMask;
        }
        if (!Utils::isUnset($request->peeringSubnetMask)) {
            $query['PeeringSubnetMask'] = $request->peeringSubnetMask;
        }
        if (!Utils::isUnset($request->physicalConnectionId)) {
            $query['PhysicalConnectionId'] = $request->physicalConnectionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tags)) {
            $query['Tags'] = $request->tags;
        }
        if (!Utils::isUnset($request->vbrOwnerId)) {
            $query['VbrOwnerId'] = $request->vbrOwnerId;
        }
        if (!Utils::isUnset($request->vlanId)) {
            $query['VlanId'] = $request->vlanId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateVirtualBorderRouter',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateVirtualBorderRouterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a virtual border router (VBR).
     *  *
     * @description After you create a VBR, the VBR is in the **active** state.
     *  *
     * @param CreateVirtualBorderRouterRequest $request CreateVirtualBorderRouterRequest
     *
     * @return CreateVirtualBorderRouterResponse CreateVirtualBorderRouterResponse
     */
    public function createVirtualBorderRouter($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVirtualBorderRouterWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a hosted connection over Express Connect circuit.
     *  *
     * @description # [](#)Description
     * Before you call this operation, we recommend that you learn about the workflow for creating a hosted connection and the environment requirements. For more information, see [Overview of hosted connections](https://help.aliyun.com/document_detail/146571.html) and [Operations performed by Express Connect partners](https://help.aliyun.com/document_detail/155987.html).
     *  *
     * @param CreateVirtualPhysicalConnectionRequest $request CreateVirtualPhysicalConnectionRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateVirtualPhysicalConnectionResponse CreateVirtualPhysicalConnectionResponse
     */
    public function createVirtualPhysicalConnectionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->orderMode)) {
            $query['OrderMode'] = $request->orderMode;
        }
        if (!Utils::isUnset($request->physicalConnectionId)) {
            $query['PhysicalConnectionId'] = $request->physicalConnectionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->spec)) {
            $query['Spec'] = $request->spec;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->token)) {
            $query['Token'] = $request->token;
        }
        if (!Utils::isUnset($request->vlanId)) {
            $query['VlanId'] = $request->vlanId;
        }
        if (!Utils::isUnset($request->vpconnAliUid)) {
            $query['VpconnAliUid'] = $request->vpconnAliUid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateVirtualPhysicalConnection',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateVirtualPhysicalConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a hosted connection over Express Connect circuit.
     *  *
     * @description # [](#)Description
     * Before you call this operation, we recommend that you learn about the workflow for creating a hosted connection and the environment requirements. For more information, see [Overview of hosted connections](https://help.aliyun.com/document_detail/146571.html) and [Operations performed by Express Connect partners](https://help.aliyun.com/document_detail/155987.html).
     *  *
     * @param CreateVirtualPhysicalConnectionRequest $request CreateVirtualPhysicalConnectionRequest
     *
     * @return CreateVirtualPhysicalConnectionResponse CreateVirtualPhysicalConnectionResponse
     */
    public function createVirtualPhysicalConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVirtualPhysicalConnectionWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a virtual private cloud (VPC).
     *  *
     * @description When you call this operation, take note of the following items:
     * *   You can specify only one CIDR block for each VPC.
     * *   After you create a VPC, you cannot change its CIDR block. However, you can add secondary IPv4 CIDR blocks to the VPC.
     * *   In each VPC, cloud services can use a maximum of 60,000 private IP addresses. You cannot increase the quota.
     * *   After you create a VPC, a vRouter and a route table are automatically created.
     * *   At most three user CIDR blocks can be added to a VPC. If a user CIDR block includes another user CIDR block, the one with the shorter subnet mask takes effect. For example, if both 10.0.0.0/8 and 10.1.0.0/16 are specified, only 10.0.0.0/8 takes effect.
     * *   **CreateVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task:
     *     *   If the VPC is in the **Creating** state, the VPC is being created.
     *     *   If the VPC is in the **Created** state, the VPC is created.
     * *   You cannot repeatedly call the **DeleteRouteEntry** operation to create default VPCs within a specific time period. However, you can repeatedly call this operation to create custom VPCs within a specific time period.
     *  *
     * @param CreateVpcRequest $request CreateVpcRequest
     * @param RuntimeOptions   $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateVpcResponse CreateVpcResponse
     */
    public function createVpcWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->cidrBlock)) {
            $query['CidrBlock'] = $request->cidrBlock;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->enableDnsHostname)) {
            $query['EnableDnsHostname'] = $request->enableDnsHostname;
        }
        if (!Utils::isUnset($request->enableIpv6)) {
            $query['EnableIpv6'] = $request->enableIpv6;
        }
        if (!Utils::isUnset($request->ipv4CidrMask)) {
            $query['Ipv4CidrMask'] = $request->ipv4CidrMask;
        }
        if (!Utils::isUnset($request->ipv4IpamPoolId)) {
            $query['Ipv4IpamPoolId'] = $request->ipv4IpamPoolId;
        }
        if (!Utils::isUnset($request->ipv6CidrBlock)) {
            $query['Ipv6CidrBlock'] = $request->ipv6CidrBlock;
        }
        if (!Utils::isUnset($request->ipv6Isp)) {
            $query['Ipv6Isp'] = $request->ipv6Isp;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->userCidr)) {
            $query['UserCidr'] = $request->userCidr;
        }
        if (!Utils::isUnset($request->vpcName)) {
            $query['VpcName'] = $request->vpcName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateVpc',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateVpcResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a virtual private cloud (VPC).
     *  *
     * @description When you call this operation, take note of the following items:
     * *   You can specify only one CIDR block for each VPC.
     * *   After you create a VPC, you cannot change its CIDR block. However, you can add secondary IPv4 CIDR blocks to the VPC.
     * *   In each VPC, cloud services can use a maximum of 60,000 private IP addresses. You cannot increase the quota.
     * *   After you create a VPC, a vRouter and a route table are automatically created.
     * *   At most three user CIDR blocks can be added to a VPC. If a user CIDR block includes another user CIDR block, the one with the shorter subnet mask takes effect. For example, if both 10.0.0.0/8 and 10.1.0.0/16 are specified, only 10.0.0.0/8 takes effect.
     * *   **CreateVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task:
     *     *   If the VPC is in the **Creating** state, the VPC is being created.
     *     *   If the VPC is in the **Created** state, the VPC is created.
     * *   You cannot repeatedly call the **DeleteRouteEntry** operation to create default VPCs within a specific time period. However, you can repeatedly call this operation to create custom VPCs within a specific time period.
     *  *
     * @param CreateVpcRequest $request CreateVpcRequest
     *
     * @return CreateVpcResponse CreateVpcResponse
     */
    public function createVpc($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVpcWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a gateway endpoint.
     *  *
     * @description *   **CreateVpcGatewayEndpoint** is an asynchronous operation. After a request is sent, the system returns an **EndpointId** and runs the task in the background. You can call the [ListVpcGatewayEndpoints](https://help.aliyun.com/document_detail/448682.html) operation to query the status of the task.
     *     *   If the gateway endpoint is in the **Creating** state, the gateway endpoint is being created.
     *     *   If the gateway endpoint is in the **Created** state, the gateway endpoint is created.
     * *   You cannot repeatedly call the **CreateVpcGatewayEndpoint** operation for the same endpoint service within the specified period of time.
     *  *
     * @param CreateVpcGatewayEndpointRequest $request CreateVpcGatewayEndpointRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateVpcGatewayEndpointResponse CreateVpcGatewayEndpointResponse
     */
    public function createVpcGatewayEndpointWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->endpointDescription)) {
            $query['EndpointDescription'] = $request->endpointDescription;
        }
        if (!Utils::isUnset($request->endpointName)) {
            $query['EndpointName'] = $request->endpointName;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->policyDocument)) {
            $query['PolicyDocument'] = $request->policyDocument;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->serviceName)) {
            $query['ServiceName'] = $request->serviceName;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateVpcGatewayEndpoint',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateVpcGatewayEndpointResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a gateway endpoint.
     *  *
     * @description *   **CreateVpcGatewayEndpoint** is an asynchronous operation. After a request is sent, the system returns an **EndpointId** and runs the task in the background. You can call the [ListVpcGatewayEndpoints](https://help.aliyun.com/document_detail/448682.html) operation to query the status of the task.
     *     *   If the gateway endpoint is in the **Creating** state, the gateway endpoint is being created.
     *     *   If the gateway endpoint is in the **Created** state, the gateway endpoint is created.
     * *   You cannot repeatedly call the **CreateVpcGatewayEndpoint** operation for the same endpoint service within the specified period of time.
     *  *
     * @param CreateVpcGatewayEndpointRequest $request CreateVpcGatewayEndpointRequest
     *
     * @return CreateVpcGatewayEndpointResponse CreateVpcGatewayEndpointResponse
     */
    public function createVpcGatewayEndpoint($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVpcGatewayEndpointWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a prefix list.
     *  *
     * @description You cannot repeatedly call the **CreateVpcPrefixList** operation within the specified period of time.
     *  *
     * @param CreateVpcPrefixListRequest $request CreateVpcPrefixListRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateVpcPrefixListResponse CreateVpcPrefixListResponse
     */
    public function createVpcPrefixListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ipVersion)) {
            $query['IpVersion'] = $request->ipVersion;
        }
        if (!Utils::isUnset($request->maxEntries)) {
            $query['MaxEntries'] = $request->maxEntries;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->prefixListDescription)) {
            $query['PrefixListDescription'] = $request->prefixListDescription;
        }
        if (!Utils::isUnset($request->prefixListEntries)) {
            $query['PrefixListEntries'] = $request->prefixListEntries;
        }
        if (!Utils::isUnset($request->prefixListName)) {
            $query['PrefixListName'] = $request->prefixListName;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateVpcPrefixList',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateVpcPrefixListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a prefix list.
     *  *
     * @description You cannot repeatedly call the **CreateVpcPrefixList** operation within the specified period of time.
     *  *
     * @param CreateVpcPrefixListRequest $request CreateVpcPrefixListRequest
     *
     * @return CreateVpcPrefixListResponse CreateVpcPrefixListResponse
     */
    public function createVpcPrefixList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVpcPrefixListWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a shared port to a hosted connection.
     *  *
     * @description If an Express Connect partner has created a virtual border router (VBR) for a tenant before, the Express Connect partner can push the Express Connect circuit that is associated with the VBR to the tenant account by adding a shared port for the tenant account. The service of the tenant is not interrupted in this process.
     * Preparations:
     * Before the Express Connect partner performs the operation, the Express Connect partner must notify the tenant and request the tenant to enable outbound data transfer billing. For more information, see [Enable outbound data transfer billing](https://help.aliyun.com/document_detail/274385.html).
     * What to do next:
     * 1.  After the Express Connect partner performs the operation, a shared port is added for the tenant account. The tenant must call the [ConfirmPhysicalConnection](https://help.aliyun.com/document_detail/324198.html) operation to accept the shared port.
     * 2.  Then, the Express Connect partner must call the [AttachVbrToVpconn](https://help.aliyun.com/document_detail/324191.html) operation to associate the VBR with the newly added shared port that belongs to the tenant account.
     *  *
     * @param CreateVpconnFromVbrRequest $request CreateVpconnFromVbrRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateVpconnFromVbrResponse CreateVpconnFromVbrResponse
     */
    public function createVpconnFromVbrWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->orderMode)) {
            $query['OrderMode'] = $request->orderMode;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->token)) {
            $query['Token'] = $request->token;
        }
        if (!Utils::isUnset($request->vbrId)) {
            $query['VbrId'] = $request->vbrId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateVpconnFromVbr',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateVpconnFromVbrResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a shared port to a hosted connection.
     *  *
     * @description If an Express Connect partner has created a virtual border router (VBR) for a tenant before, the Express Connect partner can push the Express Connect circuit that is associated with the VBR to the tenant account by adding a shared port for the tenant account. The service of the tenant is not interrupted in this process.
     * Preparations:
     * Before the Express Connect partner performs the operation, the Express Connect partner must notify the tenant and request the tenant to enable outbound data transfer billing. For more information, see [Enable outbound data transfer billing](https://help.aliyun.com/document_detail/274385.html).
     * What to do next:
     * 1.  After the Express Connect partner performs the operation, a shared port is added for the tenant account. The tenant must call the [ConfirmPhysicalConnection](https://help.aliyun.com/document_detail/324198.html) operation to accept the shared port.
     * 2.  Then, the Express Connect partner must call the [AttachVbrToVpconn](https://help.aliyun.com/document_detail/324191.html) operation to associate the VBR with the newly added shared port that belongs to the tenant account.
     *  *
     * @param CreateVpconnFromVbrRequest $request CreateVpconnFromVbrRequest
     *
     * @return CreateVpconnFromVbrResponse CreateVpconnFromVbrResponse
     */
    public function createVpconnFromVbr($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVpconnFromVbrWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an IPsec-VPN connection. After you create the IPsec-VPN connection, you can associate the IPsec-VPN connection with a transit router.
     *  *
     * @description By default, an IPsec-VPN connection created by calling the `CreateVpnAttachment` operation is not associated with a resource. You can associate an IPsec-VPN connection with a transit router by calling the [CreateTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/443993.html) operation.
     * ### [](#)Prerequisites
     * Before you create an IPsec-VPN connection, make sure that you created a customer gateway in the region where you want to create the IPsec-VPN connection. For more information, see [CreateCustomerGateway](https://help.aliyun.com/document_detail/120368.html).
     * If you want to add BGP configurations to an IPsec-VPN connection, make sure that an autonomous system number (ASN) is assigned to the customer gateway.
     *  *
     * @param CreateVpnAttachmentRequest $request CreateVpnAttachmentRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateVpnAttachmentResponse CreateVpnAttachmentResponse
     */
    public function createVpnAttachmentWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->autoConfigRoute)) {
            $query['AutoConfigRoute'] = $request->autoConfigRoute;
        }
        if (!Utils::isUnset($request->bgpConfig)) {
            $query['BgpConfig'] = $request->bgpConfig;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->customerGatewayId)) {
            $query['CustomerGatewayId'] = $request->customerGatewayId;
        }
        if (!Utils::isUnset($request->effectImmediately)) {
            $query['EffectImmediately'] = $request->effectImmediately;
        }
        if (!Utils::isUnset($request->enableDpd)) {
            $query['EnableDpd'] = $request->enableDpd;
        }
        if (!Utils::isUnset($request->enableNatTraversal)) {
            $query['EnableNatTraversal'] = $request->enableNatTraversal;
        }
        if (!Utils::isUnset($request->enableTunnelsBgp)) {
            $query['EnableTunnelsBgp'] = $request->enableTunnelsBgp;
        }
        if (!Utils::isUnset($request->healthCheckConfig)) {
            $query['HealthCheckConfig'] = $request->healthCheckConfig;
        }
        if (!Utils::isUnset($request->ikeConfig)) {
            $query['IkeConfig'] = $request->ikeConfig;
        }
        if (!Utils::isUnset($request->ipsecConfig)) {
            $query['IpsecConfig'] = $request->ipsecConfig;
        }
        if (!Utils::isUnset($request->localSubnet)) {
            $query['LocalSubnet'] = $request->localSubnet;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->networkType)) {
            $query['NetworkType'] = $request->networkType;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->remoteCaCert)) {
            $query['RemoteCaCert'] = $request->remoteCaCert;
        }
        if (!Utils::isUnset($request->remoteSubnet)) {
            $query['RemoteSubnet'] = $request->remoteSubnet;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tags)) {
            $query['Tags'] = $request->tags;
        }
        $body     = [];
        $bodyFlat = [];
        if (!Utils::isUnset($request->tunnelOptionsSpecification)) {
            $bodyFlat['TunnelOptionsSpecification'] = $request->tunnelOptionsSpecification;
        }
        $body = Tea::merge($body, OpenApiUtilClient::query($bodyFlat));
        $req  = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateVpnAttachment',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateVpnAttachmentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an IPsec-VPN connection. After you create the IPsec-VPN connection, you can associate the IPsec-VPN connection with a transit router.
     *  *
     * @description By default, an IPsec-VPN connection created by calling the `CreateVpnAttachment` operation is not associated with a resource. You can associate an IPsec-VPN connection with a transit router by calling the [CreateTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/443993.html) operation.
     * ### [](#)Prerequisites
     * Before you create an IPsec-VPN connection, make sure that you created a customer gateway in the region where you want to create the IPsec-VPN connection. For more information, see [CreateCustomerGateway](https://help.aliyun.com/document_detail/120368.html).
     * If you want to add BGP configurations to an IPsec-VPN connection, make sure that an autonomous system number (ASN) is assigned to the customer gateway.
     *  *
     * @param CreateVpnAttachmentRequest $request CreateVpnAttachmentRequest
     *
     * @return CreateVpnAttachmentResponse CreateVpnAttachmentResponse
     */
    public function createVpnAttachment($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVpnAttachmentWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an IPsec-VPN connection.
     *  *
     * @description *   If the VPN gateway supports the dual-tunnel mode, you can specify the following parameters in addition to the required parameters when you call `CreateVpnConnection`:
     *     **ClientToken**, **Name**, **EffectImmediately**, **AutoConfigRoute**, **Tags** array, **TunnelOptionsSpecification** array, and **EnableTunnelsBgp**.
     *     For more information about the regions and zones that support the dual-tunnel mode, see [IPsec-VPN connections support the dual-tunnel mode](https://help.aliyun.com/document_detail/2358946.html).
     * *   If the VPN gateway supports only the dual-tunnel mode, you can specify the following parameters in addition to the required parameters when you call `CreateVpnConnection`:
     *     **ClientToken**, **CustomerGatewayId**, **Name**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, **RemoteCaCertificate**, and **Tags** array.
     * *   **CreateVpnConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the IPsec-VPN connection is being created.
     *     *   If the VPN gateway is in the **active** state, the IPsec-VPN connection is created.
     * *   You cannot call **CreateVpnConnection** to create multiple IPsec-VPN connections associated with a VPN gateway at the same time.
     *  *
     * @param CreateVpnConnectionRequest $request CreateVpnConnectionRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateVpnConnectionResponse CreateVpnConnectionResponse
     */
    public function createVpnConnectionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->autoConfigRoute)) {
            $query['AutoConfigRoute'] = $request->autoConfigRoute;
        }
        if (!Utils::isUnset($request->bgpConfig)) {
            $query['BgpConfig'] = $request->bgpConfig;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->customerGatewayId)) {
            $query['CustomerGatewayId'] = $request->customerGatewayId;
        }
        if (!Utils::isUnset($request->effectImmediately)) {
            $query['EffectImmediately'] = $request->effectImmediately;
        }
        if (!Utils::isUnset($request->enableDpd)) {
            $query['EnableDpd'] = $request->enableDpd;
        }
        if (!Utils::isUnset($request->enableNatTraversal)) {
            $query['EnableNatTraversal'] = $request->enableNatTraversal;
        }
        if (!Utils::isUnset($request->enableTunnelsBgp)) {
            $query['EnableTunnelsBgp'] = $request->enableTunnelsBgp;
        }
        if (!Utils::isUnset($request->healthCheckConfig)) {
            $query['HealthCheckConfig'] = $request->healthCheckConfig;
        }
        if (!Utils::isUnset($request->ikeConfig)) {
            $query['IkeConfig'] = $request->ikeConfig;
        }
        if (!Utils::isUnset($request->ipsecConfig)) {
            $query['IpsecConfig'] = $request->ipsecConfig;
        }
        if (!Utils::isUnset($request->localSubnet)) {
            $query['LocalSubnet'] = $request->localSubnet;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->remoteCaCertificate)) {
            $query['RemoteCaCertificate'] = $request->remoteCaCertificate;
        }
        if (!Utils::isUnset($request->remoteSubnet)) {
            $query['RemoteSubnet'] = $request->remoteSubnet;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tags)) {
            $query['Tags'] = $request->tags;
        }
        if (!Utils::isUnset($request->vpnGatewayId)) {
            $query['VpnGatewayId'] = $request->vpnGatewayId;
        }
        $body     = [];
        $bodyFlat = [];
        if (!Utils::isUnset($request->tunnelOptionsSpecification)) {
            $bodyFlat['TunnelOptionsSpecification'] = $request->tunnelOptionsSpecification;
        }
        $body = Tea::merge($body, OpenApiUtilClient::query($bodyFlat));
        $req  = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateVpnConnection',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateVpnConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an IPsec-VPN connection.
     *  *
     * @description *   If the VPN gateway supports the dual-tunnel mode, you can specify the following parameters in addition to the required parameters when you call `CreateVpnConnection`:
     *     **ClientToken**, **Name**, **EffectImmediately**, **AutoConfigRoute**, **Tags** array, **TunnelOptionsSpecification** array, and **EnableTunnelsBgp**.
     *     For more information about the regions and zones that support the dual-tunnel mode, see [IPsec-VPN connections support the dual-tunnel mode](https://help.aliyun.com/document_detail/2358946.html).
     * *   If the VPN gateway supports only the dual-tunnel mode, you can specify the following parameters in addition to the required parameters when you call `CreateVpnConnection`:
     *     **ClientToken**, **CustomerGatewayId**, **Name**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, **RemoteCaCertificate**, and **Tags** array.
     * *   **CreateVpnConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the IPsec-VPN connection is being created.
     *     *   If the VPN gateway is in the **active** state, the IPsec-VPN connection is created.
     * *   You cannot call **CreateVpnConnection** to create multiple IPsec-VPN connections associated with a VPN gateway at the same time.
     *  *
     * @param CreateVpnConnectionRequest $request CreateVpnConnectionRequest
     *
     * @return CreateVpnConnectionResponse CreateVpnConnectionResponse
     */
    public function createVpnConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVpnConnectionWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a VPN gateway.
     *  *
     * @description *   Before you create a VPN gateway, we recommend that you know more about the limits of VPN gateways. For more information, see the [Limits](https://help.aliyun.com/document_detail/65290.html) section in the "Create and manage a VPN gateway" topic.
     * *   VPN gateways in some regions support only IPsec-VPN connections in dual-tunnel mode. If you call `CreateVpnGateway` in these regions, you must specify **VSwitchId** and **DisasterRecoveryVSwitchId** in addition to the required parameters. For more information about the regions and zones that support the IPsec-VPN connections in dual-tunnel mode, see [IPsec-VPN connections support the dual-tunnel mode](https://help.aliyun.com/document_detail/2358946.html).
     * *   **CreateVpnGateway** is an asynchronous operation. After you send a request to call this operation, the system returns a request ID and the endpoint service is being created in the backend. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of a VPN gateway.
     *     *   If the VPN gateway is in the **provisioning** state, the VPN gateway is being created.
     *     *   If the VPN gateway is in the **active** state, the VPN gateway is created.
     *  *
     * @param CreateVpnGatewayRequest $request CreateVpnGatewayRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateVpnGatewayResponse CreateVpnGatewayResponse
     */
    public function createVpnGatewayWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->autoPay)) {
            $query['AutoPay'] = $request->autoPay;
        }
        if (!Utils::isUnset($request->bandwidth)) {
            $query['Bandwidth'] = $request->bandwidth;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->disasterRecoveryVSwitchId)) {
            $query['DisasterRecoveryVSwitchId'] = $request->disasterRecoveryVSwitchId;
        }
        if (!Utils::isUnset($request->enableIpsec)) {
            $query['EnableIpsec'] = $request->enableIpsec;
        }
        if (!Utils::isUnset($request->enableSsl)) {
            $query['EnableSsl'] = $request->enableSsl;
        }
        if (!Utils::isUnset($request->instanceChargeType)) {
            $query['InstanceChargeType'] = $request->instanceChargeType;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->networkType)) {
            $query['NetworkType'] = $request->networkType;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->period)) {
            $query['Period'] = $request->period;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sslConnections)) {
            $query['SslConnections'] = $request->sslConnections;
        }
        if (!Utils::isUnset($request->vSwitchId)) {
            $query['VSwitchId'] = $request->vSwitchId;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        if (!Utils::isUnset($request->vpnType)) {
            $query['VpnType'] = $request->vpnType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateVpnGateway',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateVpnGatewayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a VPN gateway.
     *  *
     * @description *   Before you create a VPN gateway, we recommend that you know more about the limits of VPN gateways. For more information, see the [Limits](https://help.aliyun.com/document_detail/65290.html) section in the "Create and manage a VPN gateway" topic.
     * *   VPN gateways in some regions support only IPsec-VPN connections in dual-tunnel mode. If you call `CreateVpnGateway` in these regions, you must specify **VSwitchId** and **DisasterRecoveryVSwitchId** in addition to the required parameters. For more information about the regions and zones that support the IPsec-VPN connections in dual-tunnel mode, see [IPsec-VPN connections support the dual-tunnel mode](https://help.aliyun.com/document_detail/2358946.html).
     * *   **CreateVpnGateway** is an asynchronous operation. After you send a request to call this operation, the system returns a request ID and the endpoint service is being created in the backend. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of a VPN gateway.
     *     *   If the VPN gateway is in the **provisioning** state, the VPN gateway is being created.
     *     *   If the VPN gateway is in the **active** state, the VPN gateway is created.
     *  *
     * @param CreateVpnGatewayRequest $request CreateVpnGatewayRequest
     *
     * @return CreateVpnGatewayResponse CreateVpnGatewayResponse
     */
    public function createVpnGateway($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVpnGatewayWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a policy-based route for a VPN gateway.
     *  *
     * @description *   Before you call this operation, make sure that you are familiar with the match rules of and limits on policy-based routes. For more information, see [Manage policy-based routes](https://help.aliyun.com/document_detail/110777.html).
     * *   Before you create a policy-based route, make sure that an IPsec-VPN connection is created. For more information, see [CreateVpnConnection](https://help.aliyun.com/document_detail/120391.html).
     * *   **CreateVpnPbrRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of the VPN gateway.
     *     *   If the VPN gateway is in the **updating** state, the policy-based route is being created.
     *     *   If the VPN gateway is in the **active** state, the policy-based route is created.
     * *   You cannot call the **CreateVpnPbrRouteEntry** operation to create multiple policy-based routes for a VPN gateway at a time.
     *  *
     * @param CreateVpnPbrRouteEntryRequest $request CreateVpnPbrRouteEntryRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateVpnPbrRouteEntryResponse CreateVpnPbrRouteEntryResponse
     */
    public function createVpnPbrRouteEntryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->nextHop)) {
            $query['NextHop'] = $request->nextHop;
        }
        if (!Utils::isUnset($request->overlayMode)) {
            $query['OverlayMode'] = $request->overlayMode;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->priority)) {
            $query['Priority'] = $request->priority;
        }
        if (!Utils::isUnset($request->publishVpc)) {
            $query['PublishVpc'] = $request->publishVpc;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeDest)) {
            $query['RouteDest'] = $request->routeDest;
        }
        if (!Utils::isUnset($request->routeSource)) {
            $query['RouteSource'] = $request->routeSource;
        }
        if (!Utils::isUnset($request->vpnGatewayId)) {
            $query['VpnGatewayId'] = $request->vpnGatewayId;
        }
        if (!Utils::isUnset($request->weight)) {
            $query['Weight'] = $request->weight;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateVpnPbrRouteEntry',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateVpnPbrRouteEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a policy-based route for a VPN gateway.
     *  *
     * @description *   Before you call this operation, make sure that you are familiar with the match rules of and limits on policy-based routes. For more information, see [Manage policy-based routes](https://help.aliyun.com/document_detail/110777.html).
     * *   Before you create a policy-based route, make sure that an IPsec-VPN connection is created. For more information, see [CreateVpnConnection](https://help.aliyun.com/document_detail/120391.html).
     * *   **CreateVpnPbrRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of the VPN gateway.
     *     *   If the VPN gateway is in the **updating** state, the policy-based route is being created.
     *     *   If the VPN gateway is in the **active** state, the policy-based route is created.
     * *   You cannot call the **CreateVpnPbrRouteEntry** operation to create multiple policy-based routes for a VPN gateway at a time.
     *  *
     * @param CreateVpnPbrRouteEntryRequest $request CreateVpnPbrRouteEntryRequest
     *
     * @return CreateVpnPbrRouteEntryResponse CreateVpnPbrRouteEntryResponse
     */
    public function createVpnPbrRouteEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVpnPbrRouteEntryWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a destination-based route entry for a VPN gateway.
     *  *
     * @description *   **CreateVpnRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If a VPN gateway is in the **updating** state, the destination-based route entry is being created.
     *     *   If a VPN gateway is in the **active** state, the destination-based route entry has been created.
     * *   You cannot repeatedly call **CreateVpnRouteEntry** to create a destination-based route entry for a VPN gateway within the specified period of time.
     *  *
     * @param CreateVpnRouteEntryRequest $request CreateVpnRouteEntryRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateVpnRouteEntryResponse CreateVpnRouteEntryResponse
     */
    public function createVpnRouteEntryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->nextHop)) {
            $query['NextHop'] = $request->nextHop;
        }
        if (!Utils::isUnset($request->overlayMode)) {
            $query['OverlayMode'] = $request->overlayMode;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->publishVpc)) {
            $query['PublishVpc'] = $request->publishVpc;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeDest)) {
            $query['RouteDest'] = $request->routeDest;
        }
        if (!Utils::isUnset($request->vpnGatewayId)) {
            $query['VpnGatewayId'] = $request->vpnGatewayId;
        }
        if (!Utils::isUnset($request->weight)) {
            $query['Weight'] = $request->weight;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateVpnRouteEntry',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateVpnRouteEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a destination-based route entry for a VPN gateway.
     *  *
     * @description *   **CreateVpnRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If a VPN gateway is in the **updating** state, the destination-based route entry is being created.
     *     *   If a VPN gateway is in the **active** state, the destination-based route entry has been created.
     * *   You cannot repeatedly call **CreateVpnRouteEntry** to create a destination-based route entry for a VPN gateway within the specified period of time.
     *  *
     * @param CreateVpnRouteEntryRequest $request CreateVpnRouteEntryRequest
     *
     * @return CreateVpnRouteEntryResponse CreateVpnRouteEntryResponse
     */
    public function createVpnRouteEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVpnRouteEntryWithOptions($request, $runtime);
    }

    /**
     * @summary 冻结路由器接口
     *  *
     * @param DeactivateRouterInterfaceRequest $request DeactivateRouterInterfaceRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DeactivateRouterInterfaceResponse DeactivateRouterInterfaceResponse
     */
    public function deactivateRouterInterfaceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routerInterfaceId)) {
            $query['RouterInterfaceId'] = $request->routerInterfaceId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeactivateRouterInterface',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeactivateRouterInterfaceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 冻结路由器接口
     *  *
     * @param DeactivateRouterInterfaceRequest $request DeactivateRouterInterfaceRequest
     *
     * @return DeactivateRouterInterfaceResponse DeactivateRouterInterfaceResponse
     */
    public function deactivateRouterInterface($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deactivateRouterInterfaceWithOptions($request, $runtime);
    }

    /**
     * @summary Disables a flow log. After a flow log is disabled, the system no longer captures the traffic information about a resource.
     *  *
     * @description *   The **DeactiveFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
     *     *   If the flow log is in the **Deactivating** state, the flow log is being disabled.
     *     *   If the flow log is in the **Inactive** state, the flow log is disabled.
     * *   You cannot repeatedly call the **DeactiveFlowLog** operation to disable a flow log within the specified period of time.
     *  *
     * @param DeactiveFlowLogRequest $request DeactiveFlowLogRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return DeactiveFlowLogResponse DeactiveFlowLogResponse
     */
    public function deactiveFlowLogWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->flowLogId)) {
            $query['FlowLogId'] = $request->flowLogId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeactiveFlowLog',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeactiveFlowLogResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Disables a flow log. After a flow log is disabled, the system no longer captures the traffic information about a resource.
     *  *
     * @description *   The **DeactiveFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
     *     *   If the flow log is in the **Deactivating** state, the flow log is being disabled.
     *     *   If the flow log is in the **Inactive** state, the flow log is disabled.
     * *   You cannot repeatedly call the **DeactiveFlowLog** operation to disable a flow log within the specified period of time.
     *  *
     * @param DeactiveFlowLogRequest $request DeactiveFlowLogRequest
     *
     * @return DeactiveFlowLogResponse DeactiveFlowLogResponse
     */
    public function deactiveFlowLog($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deactiveFlowLogWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a Border Gateway Protocol (BGP) group.
     *  *
     * @param DeleteBgpGroupRequest $request DeleteBgpGroupRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteBgpGroupResponse DeleteBgpGroupResponse
     */
    public function deleteBgpGroupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bgpGroupId)) {
            $query['BgpGroupId'] = $request->bgpGroupId;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteBgpGroup',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteBgpGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a Border Gateway Protocol (BGP) group.
     *  *
     * @param DeleteBgpGroupRequest $request DeleteBgpGroupRequest
     *
     * @return DeleteBgpGroupResponse DeleteBgpGroupResponse
     */
    public function deleteBgpGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBgpGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an advertised Border Gateway Protocol (BGP) network.
     *  *
     * @param DeleteBgpNetworkRequest $request DeleteBgpNetworkRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteBgpNetworkResponse DeleteBgpNetworkResponse
     */
    public function deleteBgpNetworkWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dstCidrBlock)) {
            $query['DstCidrBlock'] = $request->dstCidrBlock;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routerId)) {
            $query['RouterId'] = $request->routerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteBgpNetwork',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteBgpNetworkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an advertised Border Gateway Protocol (BGP) network.
     *  *
     * @param DeleteBgpNetworkRequest $request DeleteBgpNetworkRequest
     *
     * @return DeleteBgpNetworkResponse DeleteBgpNetworkResponse
     */
    public function deleteBgpNetwork($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBgpNetworkWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a Border Gateway Protocol (BGP) peer.
     *  *
     * @param DeleteBgpPeerRequest $request DeleteBgpPeerRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteBgpPeerResponse DeleteBgpPeerResponse
     */
    public function deleteBgpPeerWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bgpPeerId)) {
            $query['BgpPeerId'] = $request->bgpPeerId;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteBgpPeer',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteBgpPeerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a Border Gateway Protocol (BGP) peer.
     *  *
     * @param DeleteBgpPeerRequest $request DeleteBgpPeerRequest
     *
     * @return DeleteBgpPeerResponse DeleteBgpPeerResponse
     */
    public function deleteBgpPeer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBgpPeerWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an Internet Shared Bandwidth instance.
     *  *
     * @description You cannot repeatedly call the **DeleteCommonBandwidthPackage** operation to delete an Internet Shared Bandwidth instance within the specified period of time.
     *  *
     * @param DeleteCommonBandwidthPackageRequest $request DeleteCommonBandwidthPackageRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteCommonBandwidthPackageResponse DeleteCommonBandwidthPackageResponse
     */
    public function deleteCommonBandwidthPackageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bandwidthPackageId)) {
            $query['BandwidthPackageId'] = $request->bandwidthPackageId;
        }
        if (!Utils::isUnset($request->force)) {
            $query['Force'] = $request->force;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteCommonBandwidthPackage',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteCommonBandwidthPackageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an Internet Shared Bandwidth instance.
     *  *
     * @description You cannot repeatedly call the **DeleteCommonBandwidthPackage** operation to delete an Internet Shared Bandwidth instance within the specified period of time.
     *  *
     * @param DeleteCommonBandwidthPackageRequest $request DeleteCommonBandwidthPackageRequest
     *
     * @return DeleteCommonBandwidthPackageResponse DeleteCommonBandwidthPackageResponse
     */
    public function deleteCommonBandwidthPackage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCommonBandwidthPackageWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a customer gateway.
     *  *
     * @description Before you delete a customer gateway, make sure that no IPsec-VPN connection is associated with the customer gateway. For more information about how to delete an IPsec-VPN connection, see [DeleteVpnAttachment](https://help.aliyun.com/document_detail/2526938.html) or [DeleteVpnConnection](https://help.aliyun.com/document_detail/2526948.html).
     *  *
     * @param DeleteCustomerGatewayRequest $request DeleteCustomerGatewayRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteCustomerGatewayResponse DeleteCustomerGatewayResponse
     */
    public function deleteCustomerGatewayWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->customerGatewayId)) {
            $query['CustomerGatewayId'] = $request->customerGatewayId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteCustomerGateway',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteCustomerGatewayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a customer gateway.
     *  *
     * @description Before you delete a customer gateway, make sure that no IPsec-VPN connection is associated with the customer gateway. For more information about how to delete an IPsec-VPN connection, see [DeleteVpnAttachment](https://help.aliyun.com/document_detail/2526938.html) or [DeleteVpnConnection](https://help.aliyun.com/document_detail/2526948.html).
     *  *
     * @param DeleteCustomerGatewayRequest $request DeleteCustomerGatewayRequest
     *
     * @return DeleteCustomerGatewayResponse DeleteCustomerGatewayResponse
     */
    public function deleteCustomerGateway($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCustomerGatewayWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a DHCP options set.
     *  *
     * @description ## [](#)Description
     * *   **DeleteDhcpOptionsSet** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetDhcpOptionsSet](https://help.aliyun.com/document_detail/189208.html) operation to query the status of the task.
     *     *   If the DHCP options set is in the **Deleting** state, the DHCP options set is being deleted.
     *     *   If you cannot query the DHCP options set, the DHCP options set is deleted.
     * *   You cannot repeatedly call the **DeleteDhcpOptionsSet** operation to delete a DHCP options set within the specified period of time.
     *  *
     * @param DeleteDhcpOptionsSetRequest $request DeleteDhcpOptionsSetRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteDhcpOptionsSetResponse DeleteDhcpOptionsSetResponse
     */
    public function deleteDhcpOptionsSetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dhcpOptionsSetId)) {
            $query['DhcpOptionsSetId'] = $request->dhcpOptionsSetId;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteDhcpOptionsSet',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteDhcpOptionsSetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a DHCP options set.
     *  *
     * @description ## [](#)Description
     * *   **DeleteDhcpOptionsSet** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetDhcpOptionsSet](https://help.aliyun.com/document_detail/189208.html) operation to query the status of the task.
     *     *   If the DHCP options set is in the **Deleting** state, the DHCP options set is being deleted.
     *     *   If you cannot query the DHCP options set, the DHCP options set is deleted.
     * *   You cannot repeatedly call the **DeleteDhcpOptionsSet** operation to delete a DHCP options set within the specified period of time.
     *  *
     * @param DeleteDhcpOptionsSetRequest $request DeleteDhcpOptionsSetRequest
     *
     * @return DeleteDhcpOptionsSetResponse DeleteDhcpOptionsSetResponse
     */
    public function deleteDhcpOptionsSet($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteDhcpOptionsSetWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a quality of service (QoS) policy.
     *  *
     * @param DeleteExpressConnectTrafficQosRequest $request DeleteExpressConnectTrafficQosRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteExpressConnectTrafficQosResponse DeleteExpressConnectTrafficQosResponse
     */
    public function deleteExpressConnectTrafficQosWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->qosId)) {
            $query['QosId'] = $request->qosId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteExpressConnectTrafficQos',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteExpressConnectTrafficQosResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a quality of service (QoS) policy.
     *  *
     * @param DeleteExpressConnectTrafficQosRequest $request DeleteExpressConnectTrafficQosRequest
     *
     * @return DeleteExpressConnectTrafficQosResponse DeleteExpressConnectTrafficQosResponse
     */
    public function deleteExpressConnectTrafficQos($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteExpressConnectTrafficQosWithOptions($request, $runtime);
    }

    /**
     * @summary 删除高速通道Qos队列
     *  *
     * @param DeleteExpressConnectTrafficQosQueueRequest $request DeleteExpressConnectTrafficQosQueueRequest
     * @param RuntimeOptions                             $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteExpressConnectTrafficQosQueueResponse DeleteExpressConnectTrafficQosQueueResponse
     */
    public function deleteExpressConnectTrafficQosQueueWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->qosId)) {
            $query['QosId'] = $request->qosId;
        }
        if (!Utils::isUnset($request->queueId)) {
            $query['QueueId'] = $request->queueId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteExpressConnectTrafficQosQueue',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteExpressConnectTrafficQosQueueResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 删除高速通道Qos队列
     *  *
     * @param DeleteExpressConnectTrafficQosQueueRequest $request DeleteExpressConnectTrafficQosQueueRequest
     *
     * @return DeleteExpressConnectTrafficQosQueueResponse DeleteExpressConnectTrafficQosQueueResponse
     */
    public function deleteExpressConnectTrafficQosQueue($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteExpressConnectTrafficQosQueueWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a quality of service (QoS) rule.
     *  *
     * @param DeleteExpressConnectTrafficQosRuleRequest $request DeleteExpressConnectTrafficQosRuleRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteExpressConnectTrafficQosRuleResponse DeleteExpressConnectTrafficQosRuleResponse
     */
    public function deleteExpressConnectTrafficQosRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->qosId)) {
            $query['QosId'] = $request->qosId;
        }
        if (!Utils::isUnset($request->queueId)) {
            $query['QueueId'] = $request->queueId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->ruleId)) {
            $query['RuleId'] = $request->ruleId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteExpressConnectTrafficQosRule',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteExpressConnectTrafficQosRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a quality of service (QoS) rule.
     *  *
     * @param DeleteExpressConnectTrafficQosRuleRequest $request DeleteExpressConnectTrafficQosRuleRequest
     *
     * @return DeleteExpressConnectTrafficQosRuleResponse DeleteExpressConnectTrafficQosRuleResponse
     */
    public function deleteExpressConnectTrafficQosRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteExpressConnectTrafficQosRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a failover test.
     *  *
     * @description You can delete only failover tests that are in the **Pending** or **Complete** state.
     *  *
     * @param DeleteFailoverTestJobRequest $request DeleteFailoverTestJobRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteFailoverTestJobResponse DeleteFailoverTestJobResponse
     */
    public function deleteFailoverTestJobWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->jobId)) {
            $query['JobId'] = $request->jobId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteFailoverTestJob',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteFailoverTestJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a failover test.
     *  *
     * @description You can delete only failover tests that are in the **Pending** or **Complete** state.
     *  *
     * @param DeleteFailoverTestJobRequest $request DeleteFailoverTestJobRequest
     *
     * @return DeleteFailoverTestJobResponse DeleteFailoverTestJobResponse
     */
    public function deleteFailoverTestJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteFailoverTestJobWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a flow log.
     *  *
     * @description *   The **DeleteFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
     *     *   If the flow log is in the **Deleting** state, the flow log is being deleted.
     *     *   If you cannot query the flow log, the flow log is deleted.
     * *   You cannot repeatedly call the **DeleteFlowLog** operation to delete a flow log within the specified period of time.
     *  *
     * @param DeleteFlowLogRequest $request DeleteFlowLogRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteFlowLogResponse DeleteFlowLogResponse
     */
    public function deleteFlowLogWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->flowLogId)) {
            $query['FlowLogId'] = $request->flowLogId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteFlowLog',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteFlowLogResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a flow log.
     *  *
     * @description *   The **DeleteFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
     *     *   If the flow log is in the **Deleting** state, the flow log is being deleted.
     *     *   If you cannot query the flow log, the flow log is deleted.
     * *   You cannot repeatedly call the **DeleteFlowLog** operation to delete a flow log within the specified period of time.
     *  *
     * @param DeleteFlowLogRequest $request DeleteFlowLogRequest
     *
     * @return DeleteFlowLogResponse DeleteFlowLogResponse
     */
    public function deleteFlowLog($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteFlowLogWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a DNAT entry.
     *  *
     * @description ## [](#)Description
     * *   **DeleteForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
     *     *   If the DNAT entry is in the **Deleting** state, the system is deleting the DNAT entry. In this case, you can only query the status of the DNAT entry, but cannot perform other operations.
     *     *   If the DNAT entry cannot be found, it is deleted.
     * >  If a DNAT table has DNAT entries in the **Pending** state, you cannot delete the DNAT entries.
     * *   You cannot repeatedly call the **DeleteForwardEntry** operation to delete a DNAT entry within the specified period of time.
     *  *
     * @param DeleteForwardEntryRequest $request DeleteForwardEntryRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteForwardEntryResponse DeleteForwardEntryResponse
     */
    public function deleteForwardEntryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->forwardEntryId)) {
            $query['ForwardEntryId'] = $request->forwardEntryId;
        }
        if (!Utils::isUnset($request->forwardTableId)) {
            $query['ForwardTableId'] = $request->forwardTableId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteForwardEntry',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteForwardEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a DNAT entry.
     *  *
     * @description ## [](#)Description
     * *   **DeleteForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
     *     *   If the DNAT entry is in the **Deleting** state, the system is deleting the DNAT entry. In this case, you can only query the status of the DNAT entry, but cannot perform other operations.
     *     *   If the DNAT entry cannot be found, it is deleted.
     * >  If a DNAT table has DNAT entries in the **Pending** state, you cannot delete the DNAT entries.
     * *   You cannot repeatedly call the **DeleteForwardEntry** operation to delete a DNAT entry within the specified period of time.
     *  *
     * @param DeleteForwardEntryRequest $request DeleteForwardEntryRequest
     *
     * @return DeleteForwardEntryResponse DeleteForwardEntryResponse
     */
    public function deleteForwardEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteForwardEntryWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a FULLNAT entry.
     *  *
     * @description ## [](#)Description
     * **DeleteFullNatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
     * *   If the FULLNAT entry is in the **Deleting** state, the system is deleting the FULLNAT entry. In this case, you can query the status of the FULLNAT entry, but cannot perform other operations.
     * *   If the FULLNAT entry cannot be found, the FULLNAT entry is deleted.
     * You cannot repeatedly call the **DeleteFullNatEntry** operation to delete a FULLNAT entry within the specified period of time.
     *  *
     * @param DeleteFullNatEntryRequest $request DeleteFullNatEntryRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteFullNatEntryResponse DeleteFullNatEntryResponse
     */
    public function deleteFullNatEntryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->fullNatEntryId)) {
            $query['FullNatEntryId'] = $request->fullNatEntryId;
        }
        if (!Utils::isUnset($request->fullNatTableId)) {
            $query['FullNatTableId'] = $request->fullNatTableId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteFullNatEntry',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteFullNatEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a FULLNAT entry.
     *  *
     * @description ## [](#)Description
     * **DeleteFullNatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
     * *   If the FULLNAT entry is in the **Deleting** state, the system is deleting the FULLNAT entry. In this case, you can query the status of the FULLNAT entry, but cannot perform other operations.
     * *   If the FULLNAT entry cannot be found, the FULLNAT entry is deleted.
     * You cannot repeatedly call the **DeleteFullNatEntry** operation to delete a FULLNAT entry within the specified period of time.
     *  *
     * @param DeleteFullNatEntryRequest $request DeleteFullNatEntryRequest
     *
     * @return DeleteFullNatEntryResponse DeleteFullNatEntryResponse
     */
    public function deleteFullNatEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteFullNatEntryWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a Global Accelerator (GA) instance.
     *  *
     * @description When you call this operation, take note of the following items:
     * *   You can delete only pay-as-you-go instances.
     * *   Before you can delete a dedicated instance, disassociate the backend server from the instance first.
     * *   Before you can delete a shared instance, disassociate the elastic IP address (EIP) from the instance first.
     *  *
     * @param DeleteGlobalAccelerationInstanceRequest $request DeleteGlobalAccelerationInstanceRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteGlobalAccelerationInstanceResponse DeleteGlobalAccelerationInstanceResponse
     */
    public function deleteGlobalAccelerationInstanceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->globalAccelerationInstanceId)) {
            $query['GlobalAccelerationInstanceId'] = $request->globalAccelerationInstanceId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteGlobalAccelerationInstance',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteGlobalAccelerationInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a Global Accelerator (GA) instance.
     *  *
     * @description When you call this operation, take note of the following items:
     * *   You can delete only pay-as-you-go instances.
     * *   Before you can delete a dedicated instance, disassociate the backend server from the instance first.
     * *   Before you can delete a shared instance, disassociate the elastic IP address (EIP) from the instance first.
     *  *
     * @param DeleteGlobalAccelerationInstanceRequest $request DeleteGlobalAccelerationInstanceRequest
     *
     * @return DeleteGlobalAccelerationInstanceResponse DeleteGlobalAccelerationInstanceResponse
     */
    public function deleteGlobalAccelerationInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteGlobalAccelerationInstanceWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a high-availability virtual IP address (HAVIP).
     *  *
     * @description When you call this operation, take note of the following rules:
     * *   You can delete only HAVIPs that are in the Available state.
     * *   Make sure that no route points to the HAVIP that you want to delete.
     * *   Make sure that no elastic IP address (EIP) is associated with the HAVIP that you want to delete.
     * *   The **DeleteHaVip** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HAVIP:
     *     *   If the HAVIP is in the **Deleting** state, the HAVIP is being deleted.
     *     *   If you cannot query the HAVIP, the HAVIP is deleted.
     * *   You cannot repeatedly call the **DeleteHaVip** operation to delete an HAVIP within the specified period of time.
     *  *
     * @param DeleteHaVipRequest $request DeleteHaVipRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteHaVipResponse DeleteHaVipResponse
     */
    public function deleteHaVipWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->haVipId)) {
            $query['HaVipId'] = $request->haVipId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteHaVip',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteHaVipResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a high-availability virtual IP address (HAVIP).
     *  *
     * @description When you call this operation, take note of the following rules:
     * *   You can delete only HAVIPs that are in the Available state.
     * *   Make sure that no route points to the HAVIP that you want to delete.
     * *   Make sure that no elastic IP address (EIP) is associated with the HAVIP that you want to delete.
     * *   The **DeleteHaVip** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HAVIP:
     *     *   If the HAVIP is in the **Deleting** state, the HAVIP is being deleted.
     *     *   If you cannot query the HAVIP, the HAVIP is deleted.
     * *   You cannot repeatedly call the **DeleteHaVip** operation to delete an HAVIP within the specified period of time.
     *  *
     * @param DeleteHaVipRequest $request DeleteHaVipRequest
     *
     * @return DeleteHaVipResponse DeleteHaVipResponse
     */
    public function deleteHaVip($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteHaVipWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an IPv6 Translation Service instance.
     *  *
     * @param DeleteIPv6TranslatorRequest $request DeleteIPv6TranslatorRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteIPv6TranslatorResponse DeleteIPv6TranslatorResponse
     */
    public function deleteIPv6TranslatorWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ipv6TranslatorId)) {
            $query['Ipv6TranslatorId'] = $request->ipv6TranslatorId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteIPv6Translator',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteIPv6TranslatorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an IPv6 Translation Service instance.
     *  *
     * @param DeleteIPv6TranslatorRequest $request DeleteIPv6TranslatorRequest
     *
     * @return DeleteIPv6TranslatorResponse DeleteIPv6TranslatorResponse
     */
    public function deleteIPv6Translator($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteIPv6TranslatorWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI DeleteIPv6TranslatorAclList is deprecated
     *  *
     * @summary Deletes an access control list (ACL). You can delete an ACL only when the ACL is not associated with IPv6 translation mappings.
     *  *
     * Deprecated
     *
     * @param DeleteIPv6TranslatorAclListRequest $request DeleteIPv6TranslatorAclListRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteIPv6TranslatorAclListResponse DeleteIPv6TranslatorAclListResponse
     */
    public function deleteIPv6TranslatorAclListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aclId)) {
            $query['AclId'] = $request->aclId;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteIPv6TranslatorAclList',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteIPv6TranslatorAclListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI DeleteIPv6TranslatorAclList is deprecated
     *  *
     * @summary Deletes an access control list (ACL). You can delete an ACL only when the ACL is not associated with IPv6 translation mappings.
     *  *
     * Deprecated
     *
     * @param DeleteIPv6TranslatorAclListRequest $request DeleteIPv6TranslatorAclListRequest
     *
     * @return DeleteIPv6TranslatorAclListResponse DeleteIPv6TranslatorAclListResponse
     */
    public function deleteIPv6TranslatorAclList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteIPv6TranslatorAclListWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI DeleteIPv6TranslatorEntry is deprecated
     *  *
     * @summary Deletes an IPv6 mapping entry.
     *  *
     * Deprecated
     *
     * @param DeleteIPv6TranslatorEntryRequest $request DeleteIPv6TranslatorEntryRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteIPv6TranslatorEntryResponse DeleteIPv6TranslatorEntryResponse
     */
    public function deleteIPv6TranslatorEntryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ipv6TranslatorEntryId)) {
            $query['Ipv6TranslatorEntryId'] = $request->ipv6TranslatorEntryId;
        }
        if (!Utils::isUnset($request->ipv6TranslatorId)) {
            $query['Ipv6TranslatorId'] = $request->ipv6TranslatorId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteIPv6TranslatorEntry',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteIPv6TranslatorEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI DeleteIPv6TranslatorEntry is deprecated
     *  *
     * @summary Deletes an IPv6 mapping entry.
     *  *
     * Deprecated
     *
     * @param DeleteIPv6TranslatorEntryRequest $request DeleteIPv6TranslatorEntryRequest
     *
     * @return DeleteIPv6TranslatorEntryResponse DeleteIPv6TranslatorEntryResponse
     */
    public function deleteIPv6TranslatorEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteIPv6TranslatorEntryWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an IPsec server.
     *  *
     * @description *   **DeleteIpsecServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
     *     *   If a VPN gateway is in the **updating** state, the IPsec server is being deleted.
     *     *   If a VPN gateway is in the **active** state, the IPsec server is deleted.
     * *   You cannot repeatedly call **DeleteIpsecServer** to delete an IPsec server from a VPN gateway within the specified period of time.
     *  *
     * @param DeleteIpsecServerRequest $request DeleteIpsecServerRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteIpsecServerResponse DeleteIpsecServerResponse
     */
    public function deleteIpsecServerWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ipsecServerId)) {
            $query['IpsecServerId'] = $request->ipsecServerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteIpsecServer',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteIpsecServerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an IPsec server.
     *  *
     * @description *   **DeleteIpsecServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
     *     *   If a VPN gateway is in the **updating** state, the IPsec server is being deleted.
     *     *   If a VPN gateway is in the **active** state, the IPsec server is deleted.
     * *   You cannot repeatedly call **DeleteIpsecServer** to delete an IPsec server from a VPN gateway within the specified period of time.
     *  *
     * @param DeleteIpsecServerRequest $request DeleteIpsecServerRequest
     *
     * @return DeleteIpsecServerResponse DeleteIpsecServerResponse
     */
    public function deleteIpsecServer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteIpsecServerWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an IPv4 gateway.
     *  *
     * @description ### [](#)Description
     * *   Before you delete an IPv4 gateway, make sure that no route tables are associated with the IPv4 gateway.
     * *   **DeleteIpv4Gateway** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of the task.
     *     *   If the IPv4 gateway is in the **Deleting** state, the IPv4 gateway is being deleted.
     *     *   If the IPv4 gateway cannot be queried, the IPv4 gateway is deleted.
     * *   After you call the **DeleteIpv4Gateway** operation to delete an IPv4 gateway, you cannot call the operation again to delete the IPv4 gateway until the deletion task is complete.
     *  *
     * @param DeleteIpv4GatewayRequest $request DeleteIpv4GatewayRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteIpv4GatewayResponse DeleteIpv4GatewayResponse
     */
    public function deleteIpv4GatewayWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->internetMode)) {
            $query['InternetMode'] = $request->internetMode;
        }
        if (!Utils::isUnset($request->ipv4GatewayId)) {
            $query['Ipv4GatewayId'] = $request->ipv4GatewayId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteIpv4Gateway',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteIpv4GatewayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an IPv4 gateway.
     *  *
     * @description ### [](#)Description
     * *   Before you delete an IPv4 gateway, make sure that no route tables are associated with the IPv4 gateway.
     * *   **DeleteIpv4Gateway** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of the task.
     *     *   If the IPv4 gateway is in the **Deleting** state, the IPv4 gateway is being deleted.
     *     *   If the IPv4 gateway cannot be queried, the IPv4 gateway is deleted.
     * *   After you call the **DeleteIpv4Gateway** operation to delete an IPv4 gateway, you cannot call the operation again to delete the IPv4 gateway until the deletion task is complete.
     *  *
     * @param DeleteIpv4GatewayRequest $request DeleteIpv4GatewayRequest
     *
     * @return DeleteIpv4GatewayResponse DeleteIpv4GatewayResponse
     */
    public function deleteIpv4Gateway($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteIpv4GatewayWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an egress-only rule.
     *  *
     * @description *   **DeleteIpv6EgressOnlyRule** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6EgressOnlyRules](https://help.aliyun.com/document_detail/102208.html) operation to query the status of the task.
     *     *   If the egress-only rule is in the **Deleting** state, the egress-only rule is being deleted.
     *     *   If you cannot query the egress-only rule, the egress-only rule is deleted.
     * *   You cannot call the **DeleteIpv6EgressOnlyRule** within the specified period of time.
     *  *
     * @param DeleteIpv6EgressOnlyRuleRequest $request DeleteIpv6EgressOnlyRuleRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteIpv6EgressOnlyRuleResponse DeleteIpv6EgressOnlyRuleResponse
     */
    public function deleteIpv6EgressOnlyRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ipv6EgressOnlyRuleId)) {
            $query['Ipv6EgressOnlyRuleId'] = $request->ipv6EgressOnlyRuleId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteIpv6EgressOnlyRule',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteIpv6EgressOnlyRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an egress-only rule.
     *  *
     * @description *   **DeleteIpv6EgressOnlyRule** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6EgressOnlyRules](https://help.aliyun.com/document_detail/102208.html) operation to query the status of the task.
     *     *   If the egress-only rule is in the **Deleting** state, the egress-only rule is being deleted.
     *     *   If you cannot query the egress-only rule, the egress-only rule is deleted.
     * *   You cannot call the **DeleteIpv6EgressOnlyRule** within the specified period of time.
     *  *
     * @param DeleteIpv6EgressOnlyRuleRequest $request DeleteIpv6EgressOnlyRuleRequest
     *
     * @return DeleteIpv6EgressOnlyRuleResponse DeleteIpv6EgressOnlyRuleResponse
     */
    public function deleteIpv6EgressOnlyRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteIpv6EgressOnlyRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an IPv6 gateway.
     *  *
     * @description Before you delete an IPv6 gateway, you must delete the egress-only rules of the IPv6 gateway. For more information, see [DeleteIpv6EgressOnlyRule](https://help.aliyun.com/document_detail/102201.html).
     * *   **DeleteIpv6Gateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6GatewayAttribute](https://help.aliyun.com/document_detail/102226.html) operation to query the status of the task:
     *     *   If the IPv6 gateway is in the **Deleting** state, the IPv6 gateway is being deleted.
     *     *   If you cannot query the IPv6 gateway, the IPv6 gateway is deleted.
     * *   You cannot repeatedly call the **DeleteIpv6Gateway** operation to delete an IPv6 gateway within the specified period of time.
     *  *
     * @param DeleteIpv6GatewayRequest $request DeleteIpv6GatewayRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteIpv6GatewayResponse DeleteIpv6GatewayResponse
     */
    public function deleteIpv6GatewayWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ipv6GatewayId)) {
            $query['Ipv6GatewayId'] = $request->ipv6GatewayId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteIpv6Gateway',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteIpv6GatewayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an IPv6 gateway.
     *  *
     * @description Before you delete an IPv6 gateway, you must delete the egress-only rules of the IPv6 gateway. For more information, see [DeleteIpv6EgressOnlyRule](https://help.aliyun.com/document_detail/102201.html).
     * *   **DeleteIpv6Gateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6GatewayAttribute](https://help.aliyun.com/document_detail/102226.html) operation to query the status of the task:
     *     *   If the IPv6 gateway is in the **Deleting** state, the IPv6 gateway is being deleted.
     *     *   If you cannot query the IPv6 gateway, the IPv6 gateway is deleted.
     * *   You cannot repeatedly call the **DeleteIpv6Gateway** operation to delete an IPv6 gateway within the specified period of time.
     *  *
     * @param DeleteIpv6GatewayRequest $request DeleteIpv6GatewayRequest
     *
     * @return DeleteIpv6GatewayResponse DeleteIpv6GatewayResponse
     */
    public function deleteIpv6Gateway($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteIpv6GatewayWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes Internet bandwidth.
     *  *
     * @description You cannot call the **DeleteIpv6InternetBandwidth** operation within the specified period of time.
     *  *
     * @param DeleteIpv6InternetBandwidthRequest $request DeleteIpv6InternetBandwidthRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteIpv6InternetBandwidthResponse DeleteIpv6InternetBandwidthResponse
     */
    public function deleteIpv6InternetBandwidthWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ipv6AddressId)) {
            $query['Ipv6AddressId'] = $request->ipv6AddressId;
        }
        if (!Utils::isUnset($request->ipv6InternetBandwidthId)) {
            $query['Ipv6InternetBandwidthId'] = $request->ipv6InternetBandwidthId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteIpv6InternetBandwidth',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteIpv6InternetBandwidthResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes Internet bandwidth.
     *  *
     * @description You cannot call the **DeleteIpv6InternetBandwidth** operation within the specified period of time.
     *  *
     * @param DeleteIpv6InternetBandwidthRequest $request DeleteIpv6InternetBandwidthRequest
     *
     * @return DeleteIpv6InternetBandwidthResponse DeleteIpv6InternetBandwidthResponse
     */
    public function deleteIpv6InternetBandwidth($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteIpv6InternetBandwidthWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a specified Internet NAT gateway.
     *  *
     * @description ## [](#)Description
     * *   **DeleteNatGateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNatGateways](https://help.aliyun.com/document_detail/36054.html) to query the status of the task.
     *     *   If a NAT gateway is in the **Deleting** state, the NAT gateway is being deleted. In this case, you can query the NAT gateway but you cannot perform other operations.
     *     *   If the NAT gateway cannot be found, the NAT gateway is deleted.
     *         After you delete a NAT gateway, you cannot restore the NAT gateway. Proceed with caution.
     * *   You cannot repeatedly call the **DeleteNatGateway** operation to delete a NAT gateway within the specified period of time.
     *  *
     * @param DeleteNatGatewayRequest $request DeleteNatGatewayRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteNatGatewayResponse DeleteNatGatewayResponse
     */
    public function deleteNatGatewayWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->force)) {
            $query['Force'] = $request->force;
        }
        if (!Utils::isUnset($request->natGatewayId)) {
            $query['NatGatewayId'] = $request->natGatewayId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteNatGateway',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteNatGatewayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a specified Internet NAT gateway.
     *  *
     * @description ## [](#)Description
     * *   **DeleteNatGateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNatGateways](https://help.aliyun.com/document_detail/36054.html) to query the status of the task.
     *     *   If a NAT gateway is in the **Deleting** state, the NAT gateway is being deleted. In this case, you can query the NAT gateway but you cannot perform other operations.
     *     *   If the NAT gateway cannot be found, the NAT gateway is deleted.
     *         After you delete a NAT gateway, you cannot restore the NAT gateway. Proceed with caution.
     * *   You cannot repeatedly call the **DeleteNatGateway** operation to delete a NAT gateway within the specified period of time.
     *  *
     * @param DeleteNatGatewayRequest $request DeleteNatGatewayRequest
     *
     * @return DeleteNatGatewayResponse DeleteNatGatewayResponse
     */
    public function deleteNatGateway($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteNatGatewayWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a NAT IP address.
     *  *
     * @description ## [](#)Description
     * *   **DeleteNatIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListNatIps](https://help.aliyun.com/document_detail/281979.html) operation to query the status of the task.
     *     *   If the NAT IP address is in the **Deleting** state, the NAT IP address is being deleted. In this case, you can only query the NAT IP address but cannot perform other operations.
     *     *   If the NAT IP address cannot be found, it is deleted.
     * *   You cannot repeatedly call the **DeleteNatIp** operation to delete a NAT IP address within the specified period of time.
     *  *
     * @param DeleteNatIpRequest $request DeleteNatIpRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteNatIpResponse DeleteNatIpResponse
     */
    public function deleteNatIpWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->natIpId)) {
            $query['NatIpId'] = $request->natIpId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteNatIp',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteNatIpResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a NAT IP address.
     *  *
     * @description ## [](#)Description
     * *   **DeleteNatIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListNatIps](https://help.aliyun.com/document_detail/281979.html) operation to query the status of the task.
     *     *   If the NAT IP address is in the **Deleting** state, the NAT IP address is being deleted. In this case, you can only query the NAT IP address but cannot perform other operations.
     *     *   If the NAT IP address cannot be found, it is deleted.
     * *   You cannot repeatedly call the **DeleteNatIp** operation to delete a NAT IP address within the specified period of time.
     *  *
     * @param DeleteNatIpRequest $request DeleteNatIpRequest
     *
     * @return DeleteNatIpResponse DeleteNatIpResponse
     */
    public function deleteNatIp($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteNatIpWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a NAT CIDR block.
     *  *
     * @description ## [](#)Description
     * You cannot repeatedly call the **DeleteNatIpCidr** operation to delete a NAT CIDR block within the specified period of time.
     *  *
     * @param DeleteNatIpCidrRequest $request DeleteNatIpCidrRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteNatIpCidrResponse DeleteNatIpCidrResponse
     */
    public function deleteNatIpCidrWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->natGatewayId)) {
            $query['NatGatewayId'] = $request->natGatewayId;
        }
        if (!Utils::isUnset($request->natIpCidr)) {
            $query['NatIpCidr'] = $request->natIpCidr;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteNatIpCidr',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteNatIpCidrResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a NAT CIDR block.
     *  *
     * @description ## [](#)Description
     * You cannot repeatedly call the **DeleteNatIpCidr** operation to delete a NAT CIDR block within the specified period of time.
     *  *
     * @param DeleteNatIpCidrRequest $request DeleteNatIpCidrRequest
     *
     * @return DeleteNatIpCidrResponse DeleteNatIpCidrResponse
     */
    public function deleteNatIpCidr($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteNatIpCidrWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a network access control list (ACL).
     *  *
     * @description ## [](#)Description
     * You cannot repeatedly call the **DeleteNetworkAcl** operation within the specified period of time.
     *  *
     * @param DeleteNetworkAclRequest $request DeleteNetworkAclRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteNetworkAclResponse DeleteNetworkAclResponse
     */
    public function deleteNetworkAclWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->networkAclId)) {
            $query['NetworkAclId'] = $request->networkAclId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteNetworkAcl',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteNetworkAclResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a network access control list (ACL).
     *  *
     * @description ## [](#)Description
     * You cannot repeatedly call the **DeleteNetworkAcl** operation within the specified period of time.
     *  *
     * @param DeleteNetworkAclRequest $request DeleteNetworkAclRequest
     *
     * @return DeleteNetworkAclResponse DeleteNetworkAclResponse
     */
    public function deleteNetworkAcl($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteNetworkAclWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a connection over an Express Connect circuit.
     *  *
     * @description You can only delete a connection over an Express Connect circuit that is in the **Rejected**, **Canceled**, **AllocationFailed**, or **Terminated** state.
     *  *
     * @param DeletePhysicalConnectionRequest $request DeletePhysicalConnectionRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DeletePhysicalConnectionResponse DeletePhysicalConnectionResponse
     */
    public function deletePhysicalConnectionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->physicalConnectionId)) {
            $query['PhysicalConnectionId'] = $request->physicalConnectionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeletePhysicalConnection',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeletePhysicalConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a connection over an Express Connect circuit.
     *  *
     * @description You can only delete a connection over an Express Connect circuit that is in the **Rejected**, **Canceled**, **AllocationFailed**, or **Terminated** state.
     *  *
     * @param DeletePhysicalConnectionRequest $request DeletePhysicalConnectionRequest
     *
     * @return DeletePhysicalConnectionResponse DeletePhysicalConnectionResponse
     */
    public function deletePhysicalConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deletePhysicalConnectionWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an IP address pool.
     *  *
     * @description Before you call this operation, take note of the following items:
     * *   Before you delete an IP address pool, make sure that no IP address in the pool is being used.
     * *   **DeletePublicIpAddressPool** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPools](https://help.aliyun.com/document_detail/429433.html) operation to query the status of the task.
     *     *   If the IP address pool is in the **Deleting** state, the IP address pool is being deleted. In this state. you can only query the IP address pool and cannot perform other operations.
     *     *   If you cannot query the IP address pool, the IP address pool is deleted.
     * *   You cannot repeatedly call the **DeletePublicIpAddressPool** operation to delete an IP address pool within the specified period of time.
     *  *
     * @param DeletePublicIpAddressPoolRequest $request DeletePublicIpAddressPoolRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DeletePublicIpAddressPoolResponse DeletePublicIpAddressPoolResponse
     */
    public function deletePublicIpAddressPoolWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->publicIpAddressPoolId)) {
            $query['PublicIpAddressPoolId'] = $request->publicIpAddressPoolId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeletePublicIpAddressPool',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeletePublicIpAddressPoolResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an IP address pool.
     *  *
     * @description Before you call this operation, take note of the following items:
     * *   Before you delete an IP address pool, make sure that no IP address in the pool is being used.
     * *   **DeletePublicIpAddressPool** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPools](https://help.aliyun.com/document_detail/429433.html) operation to query the status of the task.
     *     *   If the IP address pool is in the **Deleting** state, the IP address pool is being deleted. In this state. you can only query the IP address pool and cannot perform other operations.
     *     *   If you cannot query the IP address pool, the IP address pool is deleted.
     * *   You cannot repeatedly call the **DeletePublicIpAddressPool** operation to delete an IP address pool within the specified period of time.
     *  *
     * @param DeletePublicIpAddressPoolRequest $request DeletePublicIpAddressPoolRequest
     *
     * @return DeletePublicIpAddressPoolResponse DeletePublicIpAddressPoolResponse
     */
    public function deletePublicIpAddressPool($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deletePublicIpAddressPoolWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a CIDR block from an IP address pool.
     *  *
     * @description Before you call this operation, take note of the following items:
     * *   Before you delete a CIDR block, make sure that it is not being used.
     * *   **DeletePublicIpAddressPoolCidrBlock** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPoolCidrBlocks](https://help.aliyun.com/document_detail/429436.html) operation to query the status of the task.
     *     *   If the CIDR block is in the **Deleting** state, the CIDR block is being deleted. In this state, you can only query the CIDR block and cannot perform other operations.
     *     *   If you cannot query the CIDR block, the CIDR block is deleted.
     * *   You cannot repeatedly call the **DeletePublicIpAddressPoolCidrBlock** operation to delete a CIDR block within the specified period of time.
     *  *
     * @param DeletePublicIpAddressPoolCidrBlockRequest $request DeletePublicIpAddressPoolCidrBlockRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return DeletePublicIpAddressPoolCidrBlockResponse DeletePublicIpAddressPoolCidrBlockResponse
     */
    public function deletePublicIpAddressPoolCidrBlockWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->cidrBlock)) {
            $query['CidrBlock'] = $request->cidrBlock;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->publicIpAddressPoolId)) {
            $query['PublicIpAddressPoolId'] = $request->publicIpAddressPoolId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeletePublicIpAddressPoolCidrBlock',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeletePublicIpAddressPoolCidrBlockResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a CIDR block from an IP address pool.
     *  *
     * @description Before you call this operation, take note of the following items:
     * *   Before you delete a CIDR block, make sure that it is not being used.
     * *   **DeletePublicIpAddressPoolCidrBlock** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPoolCidrBlocks](https://help.aliyun.com/document_detail/429436.html) operation to query the status of the task.
     *     *   If the CIDR block is in the **Deleting** state, the CIDR block is being deleted. In this state, you can only query the CIDR block and cannot perform other operations.
     *     *   If you cannot query the CIDR block, the CIDR block is deleted.
     * *   You cannot repeatedly call the **DeletePublicIpAddressPoolCidrBlock** operation to delete a CIDR block within the specified period of time.
     *  *
     * @param DeletePublicIpAddressPoolCidrBlockRequest $request DeletePublicIpAddressPoolCidrBlockRequest
     *
     * @return DeletePublicIpAddressPoolCidrBlockResponse DeletePublicIpAddressPoolCidrBlockResponse
     */
    public function deletePublicIpAddressPoolCidrBlock($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deletePublicIpAddressPoolCidrBlockWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes multiple custom route entries at a time.
     *  *
     * @description When you call this operation, take note of the following items:
     * *   You can delete only routes that are in the **Available** state.
     * *   You cannot delete a route of a virtual private cloud (VPC) in which a vSwitch or another route is being created or deleted.
     * *   **DeleteRouteEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
     *     *   If the route is in the **Deleting** state, the route is being deleted.
     *     *   If you cannot query the route, the route is deleted.
     * *   You cannot repeatedly call **DeleteRouteEntries** within a specific period of time.
     *  *
     * @param DeleteRouteEntriesRequest $request DeleteRouteEntriesRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteRouteEntriesResponse DeleteRouteEntriesResponse
     */
    public function deleteRouteEntriesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeEntries)) {
            $query['RouteEntries'] = $request->routeEntries;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteRouteEntries',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteRouteEntriesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes multiple custom route entries at a time.
     *  *
     * @description When you call this operation, take note of the following items:
     * *   You can delete only routes that are in the **Available** state.
     * *   You cannot delete a route of a virtual private cloud (VPC) in which a vSwitch or another route is being created or deleted.
     * *   **DeleteRouteEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
     *     *   If the route is in the **Deleting** state, the route is being deleted.
     *     *   If you cannot query the route, the route is deleted.
     * *   You cannot repeatedly call **DeleteRouteEntries** within a specific period of time.
     *  *
     * @param DeleteRouteEntriesRequest $request DeleteRouteEntriesRequest
     *
     * @return DeleteRouteEntriesResponse DeleteRouteEntriesResponse
     */
    public function deleteRouteEntries($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteRouteEntriesWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a route entry from a route table of a VRouter or virtual border router (VBR).
     *  *
     * @description When you call this operation, take note of the following items:
     * *   You can delete only routes that are in the **Available** state.
     * *   You cannot delete a route entry of a virtual private cloud (VPC) in which a vSwitch or another route entry is being created or deleted.
     * *   Before you call this operation to delete a route of a VBR route table, call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the **NextHopId** of the route first.
     * *   **DeleteRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
     *     *   If the route is in the **Deleting** state, the route is being deleted.
     *     *   If you cannot query the route entry, the route entry is deleted.
     * *   You cannot repeatedly call the **DeleteRouteEntry** operation to delete a route from the route table of a vRouter or a VBR within the specified period of time.
     *  *
     * @param DeleteRouteEntryRequest $request DeleteRouteEntryRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteRouteEntryResponse DeleteRouteEntryResponse
     */
    public function deleteRouteEntryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->destinationCidrBlock)) {
            $query['DestinationCidrBlock'] = $request->destinationCidrBlock;
        }
        if (!Utils::isUnset($request->nextHopId)) {
            $query['NextHopId'] = $request->nextHopId;
        }
        if (!Utils::isUnset($request->nextHopList)) {
            $query['NextHopList'] = $request->nextHopList;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeEntryId)) {
            $query['RouteEntryId'] = $request->routeEntryId;
        }
        if (!Utils::isUnset($request->routeTableId)) {
            $query['RouteTableId'] = $request->routeTableId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteRouteEntry',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteRouteEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a route entry from a route table of a VRouter or virtual border router (VBR).
     *  *
     * @description When you call this operation, take note of the following items:
     * *   You can delete only routes that are in the **Available** state.
     * *   You cannot delete a route entry of a virtual private cloud (VPC) in which a vSwitch or another route entry is being created or deleted.
     * *   Before you call this operation to delete a route of a VBR route table, call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the **NextHopId** of the route first.
     * *   **DeleteRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
     *     *   If the route is in the **Deleting** state, the route is being deleted.
     *     *   If you cannot query the route entry, the route entry is deleted.
     * *   You cannot repeatedly call the **DeleteRouteEntry** operation to delete a route from the route table of a vRouter or a VBR within the specified period of time.
     *  *
     * @param DeleteRouteEntryRequest $request DeleteRouteEntryRequest
     *
     * @return DeleteRouteEntryResponse DeleteRouteEntryResponse
     */
    public function deleteRouteEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteRouteEntryWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a custom route table.
     *  *
     * @description ## [](#)Description
     * *   **DeleteRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteTableList](https://help.aliyun.com/document_detail/87602.html) operation to query the status of the task.
     *     *   If the custom route table is in the **Deleting** state, the custom route table is being deleted.
     *     *   If you cannot query the custom route table, the custom route table is deleted.
     * *   You cannot repeatedly call the **DeleteRouteTable** operation to delete a custom route table within the specified period of time.
     *  *
     * @param DeleteRouteTableRequest $request DeleteRouteTableRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteRouteTableResponse DeleteRouteTableResponse
     */
    public function deleteRouteTableWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeTableId)) {
            $query['RouteTableId'] = $request->routeTableId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteRouteTable',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteRouteTableResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a custom route table.
     *  *
     * @description ## [](#)Description
     * *   **DeleteRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteTableList](https://help.aliyun.com/document_detail/87602.html) operation to query the status of the task.
     *     *   If the custom route table is in the **Deleting** state, the custom route table is being deleted.
     *     *   If you cannot query the custom route table, the custom route table is deleted.
     * *   You cannot repeatedly call the **DeleteRouteTable** operation to delete a custom route table within the specified period of time.
     *  *
     * @param DeleteRouteTableRequest $request DeleteRouteTableRequest
     *
     * @return DeleteRouteTableResponse DeleteRouteTableResponse
     */
    public function deleteRouteTable($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteRouteTableWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a router interface.
     *  *
     * @description When you call this operation, take note of the following limits:
     * *   You can delete only a router interface that is in the **Idle** or **Inactive** state.
     * *   Before you delete a router interface, you must delete all custom route entries destined for the router interface.
     *  *
     * @param DeleteRouterInterfaceRequest $request DeleteRouterInterfaceRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteRouterInterfaceResponse DeleteRouterInterfaceResponse
     */
    public function deleteRouterInterfaceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routerInterfaceId)) {
            $query['RouterInterfaceId'] = $request->routerInterfaceId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteRouterInterface',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteRouterInterfaceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a router interface.
     *  *
     * @description When you call this operation, take note of the following limits:
     * *   You can delete only a router interface that is in the **Idle** or **Inactive** state.
     * *   Before you delete a router interface, you must delete all custom route entries destined for the router interface.
     *  *
     * @param DeleteRouterInterfaceRequest $request DeleteRouterInterfaceRequest
     *
     * @return DeleteRouterInterfaceResponse DeleteRouterInterfaceResponse
     */
    public function deleteRouterInterface($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteRouterInterfaceWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an SNAT entry.
     *  *
     * @description DeleteSnatEntry is an asynchronous operation. After you make a request, the ID of the request is returned but the specified SNAT entry is not deleted. The system deletes the SNAT entry in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of SNAT entries.
     * *   If the SNAT entries are in the **Deleting** state, the system is deleting the SNAT entries. In this case, you can only query the status of the SNAT entries, and cannot perform other operations.
     * *   If no SNAT entry is returned in the response, the SNAT entry is deleted.
     * If some SNAT entries are in the **Pending** state, you cannot delete these SNAT entries.
     *  *
     * @param DeleteSnatEntryRequest $request DeleteSnatEntryRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteSnatEntryResponse DeleteSnatEntryResponse
     */
    public function deleteSnatEntryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->snatEntryId)) {
            $query['SnatEntryId'] = $request->snatEntryId;
        }
        if (!Utils::isUnset($request->snatTableId)) {
            $query['SnatTableId'] = $request->snatTableId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteSnatEntry',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteSnatEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an SNAT entry.
     *  *
     * @description DeleteSnatEntry is an asynchronous operation. After you make a request, the ID of the request is returned but the specified SNAT entry is not deleted. The system deletes the SNAT entry in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of SNAT entries.
     * *   If the SNAT entries are in the **Deleting** state, the system is deleting the SNAT entries. In this case, you can only query the status of the SNAT entries, and cannot perform other operations.
     * *   If no SNAT entry is returned in the response, the SNAT entry is deleted.
     * If some SNAT entries are in the **Pending** state, you cannot delete these SNAT entries.
     *  *
     * @param DeleteSnatEntryRequest $request DeleteSnatEntryRequest
     *
     * @return DeleteSnatEntryResponse DeleteSnatEntryResponse
     */
    public function deleteSnatEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteSnatEntryWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an SSL client certificate.
     *  *
     * @description *   **DeleteSslVpnClientCert** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the SSL client certificate is being deleted.
     *     *   If the VPN gateway is in the **active** state, the SSL client certificate is deleted.
     * *   You cannot repeatedly call **DeleteSslVpnClientCert** to delete an SSL client certificate from the same VPN gateway within the specified period of time.
     *  *
     * @param DeleteSslVpnClientCertRequest $request DeleteSslVpnClientCertRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteSslVpnClientCertResponse DeleteSslVpnClientCertResponse
     */
    public function deleteSslVpnClientCertWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sslVpnClientCertId)) {
            $query['SslVpnClientCertId'] = $request->sslVpnClientCertId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteSslVpnClientCert',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteSslVpnClientCertResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an SSL client certificate.
     *  *
     * @description *   **DeleteSslVpnClientCert** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the SSL client certificate is being deleted.
     *     *   If the VPN gateway is in the **active** state, the SSL client certificate is deleted.
     * *   You cannot repeatedly call **DeleteSslVpnClientCert** to delete an SSL client certificate from the same VPN gateway within the specified period of time.
     *  *
     * @param DeleteSslVpnClientCertRequest $request DeleteSslVpnClientCertRequest
     *
     * @return DeleteSslVpnClientCertResponse DeleteSslVpnClientCertResponse
     */
    public function deleteSslVpnClientCert($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteSslVpnClientCertWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an SSL server.
     *  *
     * @description *   **DeleteSslVpnServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the SSL server is being deleted.
     *     *   If the VPN gateway is in the **active** state, the SSL server is deleted.
     * *   You cannot repeatedly call the **DeleteSslVpnServer** operation to delete an SSL server from the same VPN gateway within the specified period of time.
     *  *
     * @param DeleteSslVpnServerRequest $request DeleteSslVpnServerRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteSslVpnServerResponse DeleteSslVpnServerResponse
     */
    public function deleteSslVpnServerWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sslVpnServerId)) {
            $query['SslVpnServerId'] = $request->sslVpnServerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteSslVpnServer',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteSslVpnServerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an SSL server.
     *  *
     * @description *   **DeleteSslVpnServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the SSL server is being deleted.
     *     *   If the VPN gateway is in the **active** state, the SSL server is deleted.
     * *   You cannot repeatedly call the **DeleteSslVpnServer** operation to delete an SSL server from the same VPN gateway within the specified period of time.
     *  *
     * @param DeleteSslVpnServerRequest $request DeleteSslVpnServerRequest
     *
     * @return DeleteSslVpnServerResponse DeleteSslVpnServerResponse
     */
    public function deleteSslVpnServer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteSslVpnServerWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a filter of traffic mirroring.
     *  *
     * @description *   The **DeleteTrafficMirrorFilter** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of a filter:
     *     *   If the filter is in the **Deleting** state, the filter is being deleted.
     *     *   If you cannot query the filter, the filter is deleted.
     * *   You cannot repeatedly call the **DeleteTrafficMirrorFilter** operation to delete a filter within the specified period of time.
     *  *
     * @param DeleteTrafficMirrorFilterRequest $request DeleteTrafficMirrorFilterRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteTrafficMirrorFilterResponse DeleteTrafficMirrorFilterResponse
     */
    public function deleteTrafficMirrorFilterWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->trafficMirrorFilterId)) {
            $query['TrafficMirrorFilterId'] = $request->trafficMirrorFilterId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteTrafficMirrorFilter',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteTrafficMirrorFilterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a filter of traffic mirroring.
     *  *
     * @description *   The **DeleteTrafficMirrorFilter** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of a filter:
     *     *   If the filter is in the **Deleting** state, the filter is being deleted.
     *     *   If you cannot query the filter, the filter is deleted.
     * *   You cannot repeatedly call the **DeleteTrafficMirrorFilter** operation to delete a filter within the specified period of time.
     *  *
     * @param DeleteTrafficMirrorFilterRequest $request DeleteTrafficMirrorFilterRequest
     *
     * @return DeleteTrafficMirrorFilterResponse DeleteTrafficMirrorFilterResponse
     */
    public function deleteTrafficMirrorFilter($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteTrafficMirrorFilterWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an inbound or outbound rule of a filter for traffic mirroring.
     *  *
     * @description *   **DeleteTrafficMirrorFilterRules** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) to query the status of the task.
     *     *   If the inbound or outbound rule is in the **Deleting** state, the rule is being deleted.
     *     *   If you cannot query the rule, the rule is deleted.
     * *   You cannot repeatedly call **DeleteTrafficMirrorFilterRules** within the specified period of time.
     *  *
     * @param DeleteTrafficMirrorFilterRulesRequest $request DeleteTrafficMirrorFilterRulesRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteTrafficMirrorFilterRulesResponse DeleteTrafficMirrorFilterRulesResponse
     */
    public function deleteTrafficMirrorFilterRulesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->trafficMirrorFilterId)) {
            $query['TrafficMirrorFilterId'] = $request->trafficMirrorFilterId;
        }
        if (!Utils::isUnset($request->trafficMirrorFilterRuleIds)) {
            $query['TrafficMirrorFilterRuleIds'] = $request->trafficMirrorFilterRuleIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteTrafficMirrorFilterRules',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteTrafficMirrorFilterRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an inbound or outbound rule of a filter for traffic mirroring.
     *  *
     * @description *   **DeleteTrafficMirrorFilterRules** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) to query the status of the task.
     *     *   If the inbound or outbound rule is in the **Deleting** state, the rule is being deleted.
     *     *   If you cannot query the rule, the rule is deleted.
     * *   You cannot repeatedly call **DeleteTrafficMirrorFilterRules** within the specified period of time.
     *  *
     * @param DeleteTrafficMirrorFilterRulesRequest $request DeleteTrafficMirrorFilterRulesRequest
     *
     * @return DeleteTrafficMirrorFilterRulesResponse DeleteTrafficMirrorFilterRulesResponse
     */
    public function deleteTrafficMirrorFilterRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteTrafficMirrorFilterRulesWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a traffic mirror session.
     *  *
     * @description *   **DeleteTrafficMirrorSession** is an asynchronous operation. After you send the request, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of a traffic mirror session.
     *     *   If the traffic mirror session is in the **Deleting** state, the traffic mirror session is being deleted.
     *     *   If you cannot query the traffic mirror session, the traffic mirror session is deleted.
     * *   You cannot repeatedly call the **DeleteTrafficMirrorSession** operation to delete a traffic mirror session within the specified period of time.
     *  *
     * @param DeleteTrafficMirrorSessionRequest $request DeleteTrafficMirrorSessionRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteTrafficMirrorSessionResponse DeleteTrafficMirrorSessionResponse
     */
    public function deleteTrafficMirrorSessionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->trafficMirrorSessionId)) {
            $query['TrafficMirrorSessionId'] = $request->trafficMirrorSessionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteTrafficMirrorSession',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteTrafficMirrorSessionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a traffic mirror session.
     *  *
     * @description *   **DeleteTrafficMirrorSession** is an asynchronous operation. After you send the request, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of a traffic mirror session.
     *     *   If the traffic mirror session is in the **Deleting** state, the traffic mirror session is being deleted.
     *     *   If you cannot query the traffic mirror session, the traffic mirror session is deleted.
     * *   You cannot repeatedly call the **DeleteTrafficMirrorSession** operation to delete a traffic mirror session within the specified period of time.
     *  *
     * @param DeleteTrafficMirrorSessionRequest $request DeleteTrafficMirrorSessionRequest
     *
     * @return DeleteTrafficMirrorSessionResponse DeleteTrafficMirrorSessionResponse
     */
    public function deleteTrafficMirrorSession($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteTrafficMirrorSessionWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a vSwitch.
     *  *
     * @description When you call this operation, take note of the following limits:
     * *   Before you delete a vSwitch, you must first release or remove all virtual private cloud (VPC) resources, including vSwitches, instances, router interfaces, and high-availability virtual IP addresses (HAVIPs).
     * *   You can delete only vSwitches that are in the **Available** state.
     * *   You cannot delete a vSwitch from a VPC where a vSwitch or a route is being created or deleted.
     * *   **DeleteVSwitch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
     *     *   If the vSwitch is in the **Pending** state, the vSwitch is being deleted.
     *     *   If you cannot query the vSwitch, the vSwitch is deleted.
     * *   You cannot repeatedly call the **DeleteVSwitch** operation to delete a vSwitch within the specified period of time.
     *  *
     * @param DeleteVSwitchRequest $request DeleteVSwitchRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteVSwitchResponse DeleteVSwitchResponse
     */
    public function deleteVSwitchWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vSwitchId)) {
            $query['VSwitchId'] = $request->vSwitchId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteVSwitch',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteVSwitchResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a vSwitch.
     *  *
     * @description When you call this operation, take note of the following limits:
     * *   Before you delete a vSwitch, you must first release or remove all virtual private cloud (VPC) resources, including vSwitches, instances, router interfaces, and high-availability virtual IP addresses (HAVIPs).
     * *   You can delete only vSwitches that are in the **Available** state.
     * *   You cannot delete a vSwitch from a VPC where a vSwitch or a route is being created or deleted.
     * *   **DeleteVSwitch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
     *     *   If the vSwitch is in the **Pending** state, the vSwitch is being deleted.
     *     *   If you cannot query the vSwitch, the vSwitch is deleted.
     * *   You cannot repeatedly call the **DeleteVSwitch** operation to delete a vSwitch within the specified period of time.
     *  *
     * @param DeleteVSwitchRequest $request DeleteVSwitchRequest
     *
     * @return DeleteVSwitchResponse DeleteVSwitchResponse
     */
    public function deleteVSwitch($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVSwitchWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a reserved CIDR block of a vSwitch.
     *  *
     * @description ## [](#)Description
     * *   Before you call this operation, make sure that the IP address allocated to an elastic network interface (ENI) from the reserved CIDR block is deleted. If the IP address of the ENI is not deleted, call [UnassignPrivateIpAddresses](https://help.aliyun.com/document_detail/85919.html) or [UnassignIpv6Addresses](https://help.aliyun.com/document_detail/98611.html) to delete the IPv4 or IPv6 address.
     * *   **DeleteVSwitchCidrReservation** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListVSwitchCidrReservations](https://help.aliyun.com/document_detail/610155.html) to query the status of the task:
     *     *   If the reserved CIDR block is in the **Releasing** state, it is being released.
     *     *   If the reserved CIDR block is in the **Released** state, it is released.
     *  *
     * @param DeleteVSwitchCidrReservationRequest $request DeleteVSwitchCidrReservationRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteVSwitchCidrReservationResponse DeleteVSwitchCidrReservationResponse
     */
    public function deleteVSwitchCidrReservationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vSwitchCidrReservationId)) {
            $query['VSwitchCidrReservationId'] = $request->vSwitchCidrReservationId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteVSwitchCidrReservation',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteVSwitchCidrReservationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a reserved CIDR block of a vSwitch.
     *  *
     * @description ## [](#)Description
     * *   Before you call this operation, make sure that the IP address allocated to an elastic network interface (ENI) from the reserved CIDR block is deleted. If the IP address of the ENI is not deleted, call [UnassignPrivateIpAddresses](https://help.aliyun.com/document_detail/85919.html) or [UnassignIpv6Addresses](https://help.aliyun.com/document_detail/98611.html) to delete the IPv4 or IPv6 address.
     * *   **DeleteVSwitchCidrReservation** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListVSwitchCidrReservations](https://help.aliyun.com/document_detail/610155.html) to query the status of the task:
     *     *   If the reserved CIDR block is in the **Releasing** state, it is being released.
     *     *   If the reserved CIDR block is in the **Released** state, it is released.
     *  *
     * @param DeleteVSwitchCidrReservationRequest $request DeleteVSwitchCidrReservationRequest
     *
     * @return DeleteVSwitchCidrReservationResponse DeleteVSwitchCidrReservationResponse
     */
    public function deleteVSwitchCidrReservation($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVSwitchCidrReservationWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a virtual border router (VBR) failover group.
     *  *
     * @param DeleteVbrHaRequest $request DeleteVbrHaRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteVbrHaResponse DeleteVbrHaResponse
     */
    public function deleteVbrHaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteVbrHa',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteVbrHaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a virtual border router (VBR) failover group.
     *  *
     * @param DeleteVbrHaRequest $request DeleteVbrHaRequest
     *
     * @return DeleteVbrHaResponse DeleteVbrHaResponse
     */
    public function deleteVbrHa($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVbrHaWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a destination-based route from an IPsec-VPN connection.
     *  *
     * @description *   **DeleteVcoRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the task.
     *     *   If the IPsec-VPN connection is in the **updating** state, the route is being deleted.
     *     *   If the IPsec-VPN connection is in the **attached** state, the route is deleted.
     * *   You cannot repeatedly call the **DeleteVcoRouteEntry** operation within a specific time period.
     *  *
     * @param DeleteVcoRouteEntryRequest $request DeleteVcoRouteEntryRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteVcoRouteEntryResponse DeleteVcoRouteEntryResponse
     */
    public function deleteVcoRouteEntryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->nextHop)) {
            $query['NextHop'] = $request->nextHop;
        }
        if (!Utils::isUnset($request->overlayMode)) {
            $query['OverlayMode'] = $request->overlayMode;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeDest)) {
            $query['RouteDest'] = $request->routeDest;
        }
        if (!Utils::isUnset($request->vpnConnectionId)) {
            $query['VpnConnectionId'] = $request->vpnConnectionId;
        }
        if (!Utils::isUnset($request->weight)) {
            $query['Weight'] = $request->weight;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteVcoRouteEntry',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteVcoRouteEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a destination-based route from an IPsec-VPN connection.
     *  *
     * @description *   **DeleteVcoRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the task.
     *     *   If the IPsec-VPN connection is in the **updating** state, the route is being deleted.
     *     *   If the IPsec-VPN connection is in the **attached** state, the route is deleted.
     * *   You cannot repeatedly call the **DeleteVcoRouteEntry** operation within a specific time period.
     *  *
     * @param DeleteVcoRouteEntryRequest $request DeleteVcoRouteEntryRequest
     *
     * @return DeleteVcoRouteEntryResponse DeleteVcoRouteEntryResponse
     */
    public function deleteVcoRouteEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVcoRouteEntryWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a virtual border router (VBR).
     *  *
     * @description Before you call this operation, take note of the following limits:
     * *   Before you delete a VBR, you must delete all router interfaces of the VBR.
     * *   You can delete only a VBR in the **unconfirmed**, **active**, or **terminated** state.
     * *   The owner of an Express Connect circuit can delete a VBR that belongs to another account only if the VBR is in the **unconfirmed** state.
     *  *
     * @param DeleteVirtualBorderRouterRequest $request DeleteVirtualBorderRouterRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteVirtualBorderRouterResponse DeleteVirtualBorderRouterResponse
     */
    public function deleteVirtualBorderRouterWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vbrId)) {
            $query['VbrId'] = $request->vbrId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteVirtualBorderRouter',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteVirtualBorderRouterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a virtual border router (VBR).
     *  *
     * @description Before you call this operation, take note of the following limits:
     * *   Before you delete a VBR, you must delete all router interfaces of the VBR.
     * *   You can delete only a VBR in the **unconfirmed**, **active**, or **terminated** state.
     * *   The owner of an Express Connect circuit can delete a VBR that belongs to another account only if the VBR is in the **unconfirmed** state.
     *  *
     * @param DeleteVirtualBorderRouterRequest $request DeleteVirtualBorderRouterRequest
     *
     * @return DeleteVirtualBorderRouterResponse DeleteVirtualBorderRouterResponse
     */
    public function deleteVirtualBorderRouter($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVirtualBorderRouterWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a virtual private cloud (VPC).
     *  *
     * @description When you call this operation, take note of the following limits:
     * *   Before you delete a VPC, make sure that all resources deployed in the VPC are released or removed, such as vSwitches, instances, and high-availability virtual IP addresses (HAVIPs).
     * *   You can delete only a VPC that is in the **Available** state.
     * *   The **DeleteVpc** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a VPC:
     *     *   If the VPC is in the **Deleting** state, the VPC is being deleted.
     *     *   If you cannot query the VPC, the VPC is deleted.
     * *   You cannot repeatedly call the **DeleteVpc** operation to delete a VPC within the specified period of time.
     *  *
     * @param DeleteVpcRequest $request DeleteVpcRequest
     * @param RuntimeOptions   $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteVpcResponse DeleteVpcResponse
     */
    public function deleteVpcWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->forceDelete)) {
            $query['ForceDelete'] = $request->forceDelete;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteVpc',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteVpcResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a virtual private cloud (VPC).
     *  *
     * @description When you call this operation, take note of the following limits:
     * *   Before you delete a VPC, make sure that all resources deployed in the VPC are released or removed, such as vSwitches, instances, and high-availability virtual IP addresses (HAVIPs).
     * *   You can delete only a VPC that is in the **Available** state.
     * *   The **DeleteVpc** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a VPC:
     *     *   If the VPC is in the **Deleting** state, the VPC is being deleted.
     *     *   If you cannot query the VPC, the VPC is deleted.
     * *   You cannot repeatedly call the **DeleteVpc** operation to delete a VPC within the specified period of time.
     *  *
     * @param DeleteVpcRequest $request DeleteVpcRequest
     *
     * @return DeleteVpcResponse DeleteVpcResponse
     */
    public function deleteVpc($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVpcWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a gateway endpoint.
     *  *
     * @param DeleteVpcGatewayEndpointRequest $request DeleteVpcGatewayEndpointRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteVpcGatewayEndpointResponse DeleteVpcGatewayEndpointResponse
     */
    public function deleteVpcGatewayEndpointWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->endpointId)) {
            $query['EndpointId'] = $request->endpointId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteVpcGatewayEndpoint',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteVpcGatewayEndpointResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a gateway endpoint.
     *  *
     * @param DeleteVpcGatewayEndpointRequest $request DeleteVpcGatewayEndpointRequest
     *
     * @return DeleteVpcGatewayEndpointResponse DeleteVpcGatewayEndpointResponse
     */
    public function deleteVpcGatewayEndpoint($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVpcGatewayEndpointWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a prefix list.
     *  *
     * @description You cannot repeatedly call the **DeleteDhcpOptionsSet** operation to delete a prefix list within the specified period of time.
     *  *
     * @param DeleteVpcPrefixListRequest $request DeleteVpcPrefixListRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteVpcPrefixListResponse DeleteVpcPrefixListResponse
     */
    public function deleteVpcPrefixListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->prefixListId)) {
            $query['PrefixListId'] = $request->prefixListId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteVpcPrefixList',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteVpcPrefixListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a prefix list.
     *  *
     * @description You cannot repeatedly call the **DeleteDhcpOptionsSet** operation to delete a prefix list within the specified period of time.
     *  *
     * @param DeleteVpcPrefixListRequest $request DeleteVpcPrefixListRequest
     *
     * @return DeleteVpcPrefixListResponse DeleteVpcPrefixListResponse
     */
    public function deleteVpcPrefixList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVpcPrefixListWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an IPsec-VPN connection.
     *  *
     * @description *   If an IPsec-VPN connection is associated with a transit router, you must disassociate the transit router from the IPsec-VPN connection before you delete the IPsec-VPN connection. For more information, see [DeleteTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/468251.html).
     * *   If an IPsec-VPN connection is not associated with a resource, you can call `DeleteVpnAttachment` to directly delete the IPsec-VPN connection.
     *  *
     * @param DeleteVpnAttachmentRequest $request DeleteVpnAttachmentRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteVpnAttachmentResponse DeleteVpnAttachmentResponse
     */
    public function deleteVpnAttachmentWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vpnConnectionId)) {
            $query['VpnConnectionId'] = $request->vpnConnectionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteVpnAttachment',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteVpnAttachmentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an IPsec-VPN connection.
     *  *
     * @description *   If an IPsec-VPN connection is associated with a transit router, you must disassociate the transit router from the IPsec-VPN connection before you delete the IPsec-VPN connection. For more information, see [DeleteTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/468251.html).
     * *   If an IPsec-VPN connection is not associated with a resource, you can call `DeleteVpnAttachment` to directly delete the IPsec-VPN connection.
     *  *
     * @param DeleteVpnAttachmentRequest $request DeleteVpnAttachmentRequest
     *
     * @return DeleteVpnAttachmentResponse DeleteVpnAttachmentResponse
     */
    public function deleteVpnAttachment($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVpnAttachmentWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an IPsec-VPN connection.
     *  *
     * @description *   **DeleteVpnConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of a VPN gateway.
     *     *   If a VPN gateway is in the **updating** state, the IPsec-VPN connection is being deleted.
     *     *   If a VPN gateway is in the **active** state, the IPsec-VPN connection has been deleted.
     * *   You cannot call the **DeleteVpnConnection** operation to delete multiple IPsec-VPN connections for a VPN gateway at a time.
     * >  After an IPsec-VPN connection between a data center and Alibaba Cloud is deleted, the connection between the data center and Alibaba Cloud is closed.
     *  *
     * @param DeleteVpnConnectionRequest $request DeleteVpnConnectionRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteVpnConnectionResponse DeleteVpnConnectionResponse
     */
    public function deleteVpnConnectionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vpnConnectionId)) {
            $query['VpnConnectionId'] = $request->vpnConnectionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteVpnConnection',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteVpnConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an IPsec-VPN connection.
     *  *
     * @description *   **DeleteVpnConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of a VPN gateway.
     *     *   If a VPN gateway is in the **updating** state, the IPsec-VPN connection is being deleted.
     *     *   If a VPN gateway is in the **active** state, the IPsec-VPN connection has been deleted.
     * *   You cannot call the **DeleteVpnConnection** operation to delete multiple IPsec-VPN connections for a VPN gateway at a time.
     * >  After an IPsec-VPN connection between a data center and Alibaba Cloud is deleted, the connection between the data center and Alibaba Cloud is closed.
     *  *
     * @param DeleteVpnConnectionRequest $request DeleteVpnConnectionRequest
     *
     * @return DeleteVpnConnectionResponse DeleteVpnConnectionResponse
     */
    public function deleteVpnConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVpnConnectionWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a VPN gateway.
     *  *
     * @description >  You cannot delete a VPN gateway associated with existing IPsec-VPN connections.
     *  *
     * @param DeleteVpnGatewayRequest $request DeleteVpnGatewayRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteVpnGatewayResponse DeleteVpnGatewayResponse
     */
    public function deleteVpnGatewayWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vpnGatewayId)) {
            $query['VpnGatewayId'] = $request->vpnGatewayId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteVpnGateway',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteVpnGatewayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a VPN gateway.
     *  *
     * @description >  You cannot delete a VPN gateway associated with existing IPsec-VPN connections.
     *  *
     * @param DeleteVpnGatewayRequest $request DeleteVpnGatewayRequest
     *
     * @return DeleteVpnGatewayResponse DeleteVpnGatewayResponse
     */
    public function deleteVpnGateway($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVpnGatewayWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a policy-based route from a VPN gateway.
     *  *
     * @description *   **DeleteVpnPbrRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If a VPN gateway is in the **updating** state, the policy-based route is being deleted.
     *     *   If a VPN gateway is in the **active** state, the policy-based route has been deleted.
     * *   You cannot repeatedly call **DeleteVpnPbrRouteEntry** to delete a policy-based route within the specified period of time.
     *  *
     * @param DeleteVpnPbrRouteEntryRequest $request DeleteVpnPbrRouteEntryRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteVpnPbrRouteEntryResponse DeleteVpnPbrRouteEntryResponse
     */
    public function deleteVpnPbrRouteEntryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->nextHop)) {
            $query['NextHop'] = $request->nextHop;
        }
        if (!Utils::isUnset($request->overlayMode)) {
            $query['OverlayMode'] = $request->overlayMode;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->priority)) {
            $query['Priority'] = $request->priority;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeDest)) {
            $query['RouteDest'] = $request->routeDest;
        }
        if (!Utils::isUnset($request->routeSource)) {
            $query['RouteSource'] = $request->routeSource;
        }
        if (!Utils::isUnset($request->vpnGatewayId)) {
            $query['VpnGatewayId'] = $request->vpnGatewayId;
        }
        if (!Utils::isUnset($request->weight)) {
            $query['Weight'] = $request->weight;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteVpnPbrRouteEntry',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteVpnPbrRouteEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a policy-based route from a VPN gateway.
     *  *
     * @description *   **DeleteVpnPbrRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If a VPN gateway is in the **updating** state, the policy-based route is being deleted.
     *     *   If a VPN gateway is in the **active** state, the policy-based route has been deleted.
     * *   You cannot repeatedly call **DeleteVpnPbrRouteEntry** to delete a policy-based route within the specified period of time.
     *  *
     * @param DeleteVpnPbrRouteEntryRequest $request DeleteVpnPbrRouteEntryRequest
     *
     * @return DeleteVpnPbrRouteEntryResponse DeleteVpnPbrRouteEntryResponse
     */
    public function deleteVpnPbrRouteEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVpnPbrRouteEntryWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a destination-based route from a VPN gateway.
     *  *
     * @description *   **DeleteVpnRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If a VPN gateway is in the **updating** state, the destination-based route is being deleted.
     *     *   If the VPN gateway is in the **active** state, the destination-based route is deleted.
     * *   You cannot repeatedly call **DeleteVpnRouteEntry** to delete a destination-based route from a VPN gateway within the specified period of time.
     *  *
     * @param DeleteVpnRouteEntryRequest $request DeleteVpnRouteEntryRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteVpnRouteEntryResponse DeleteVpnRouteEntryResponse
     */
    public function deleteVpnRouteEntryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->nextHop)) {
            $query['NextHop'] = $request->nextHop;
        }
        if (!Utils::isUnset($request->overlayMode)) {
            $query['OverlayMode'] = $request->overlayMode;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeDest)) {
            $query['RouteDest'] = $request->routeDest;
        }
        if (!Utils::isUnset($request->vpnGatewayId)) {
            $query['VpnGatewayId'] = $request->vpnGatewayId;
        }
        if (!Utils::isUnset($request->weight)) {
            $query['Weight'] = $request->weight;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteVpnRouteEntry',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteVpnRouteEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a destination-based route from a VPN gateway.
     *  *
     * @description *   **DeleteVpnRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If a VPN gateway is in the **updating** state, the destination-based route is being deleted.
     *     *   If the VPN gateway is in the **active** state, the destination-based route is deleted.
     * *   You cannot repeatedly call **DeleteVpnRouteEntry** to delete a destination-based route from a VPN gateway within the specified period of time.
     *  *
     * @param DeleteVpnRouteEntryRequest $request DeleteVpnRouteEntryRequest
     *
     * @return DeleteVpnRouteEntryResponse DeleteVpnRouteEntryResponse
     */
    public function deleteVpnRouteEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVpnRouteEntryWithOptions($request, $runtime);
    }

    /**
     * @summary 设置实例删除保护功能。
     *  *
     * @description After you enable deletion protection for an instance, you cannot delete the instance. You must disable deletion protection before you can delete the instance.
     *  *
     * @param DeletionProtectionRequest $request DeletionProtectionRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DeletionProtectionResponse DeletionProtectionResponse
     */
    public function deletionProtectionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->protectionEnable)) {
            $query['ProtectionEnable'] = $request->protectionEnable;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeletionProtection',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeletionProtectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 设置实例删除保护功能。
     *  *
     * @description After you enable deletion protection for an instance, you cannot delete the instance. You must disable deletion protection before you can delete the instance.
     *  *
     * @param DeletionProtectionRequest $request DeletionProtectionRequest
     *
     * @return DeletionProtectionResponse DeletionProtectionResponse
     */
    public function deletionProtection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deletionProtectionWithOptions($request, $runtime);
    }

    /**
     * @summary Queries traffic data of a pay-by-enhanced-95th-percentile Internet Shared Bandwidth instance.
     *  *
     * @param Describe95TrafficRequest $request Describe95TrafficRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return Describe95TrafficResponse Describe95TrafficResponse
     */
    public function describe95TrafficWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->day)) {
            $query['Day'] = $request->day;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->resourceType)) {
            $query['ResourceType'] = $request->resourceType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'Describe95Traffic',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return Describe95TrafficResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries traffic data of a pay-by-enhanced-95th-percentile Internet Shared Bandwidth instance.
     *  *
     * @param Describe95TrafficRequest $request Describe95TrafficRequest
     *
     * @return Describe95TrafficResponse Describe95TrafficResponse
     */
    public function describe95Traffic($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describe95TrafficWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the access points of Express Connect circuits in a region.
     *  *
     * @param DescribeAccessPointsRequest $request DescribeAccessPointsRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAccessPointsResponse DescribeAccessPointsResponse
     */
    public function describeAccessPointsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->acceptLanguage)) {
            $query['AcceptLanguage'] = $request->acceptLanguage;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAccessPoints',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAccessPointsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the access points of Express Connect circuits in a region.
     *  *
     * @param DescribeAccessPointsRequest $request DescribeAccessPointsRequest
     *
     * @return DescribeAccessPointsResponse DescribeAccessPointsResponse
     */
    public function describeAccessPoints($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAccessPointsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries Border Gateway Protocol (BGP) groups in a region.
     *  *
     * @param DescribeBgpGroupsRequest $request DescribeBgpGroupsRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeBgpGroupsResponse DescribeBgpGroupsResponse
     */
    public function describeBgpGroupsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bgpGroupId)) {
            $query['BgpGroupId'] = $request->bgpGroupId;
        }
        if (!Utils::isUnset($request->isDefault)) {
            $query['IsDefault'] = $request->isDefault;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routerId)) {
            $query['RouterId'] = $request->routerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeBgpGroups',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeBgpGroupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries Border Gateway Protocol (BGP) groups in a region.
     *  *
     * @param DescribeBgpGroupsRequest $request DescribeBgpGroupsRequest
     *
     * @return DescribeBgpGroupsResponse DescribeBgpGroupsResponse
     */
    public function describeBgpGroups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBgpGroupsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries advertised Border Gateway Protocol (BGP) networks.
     *  *
     * @param DescribeBgpNetworksRequest $request DescribeBgpNetworksRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeBgpNetworksResponse DescribeBgpNetworksResponse
     */
    public function describeBgpNetworksWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routerId)) {
            $query['RouterId'] = $request->routerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeBgpNetworks',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeBgpNetworksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries advertised Border Gateway Protocol (BGP) networks.
     *  *
     * @param DescribeBgpNetworksRequest $request DescribeBgpNetworksRequest
     *
     * @return DescribeBgpNetworksResponse DescribeBgpNetworksResponse
     */
    public function describeBgpNetworks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBgpNetworksWithOptions($request, $runtime);
    }

    /**
     * @summary Queries Border Gateway Protocol (BGP) peers in a region.
     *  *
     * @param DescribeBgpPeersRequest $request DescribeBgpPeersRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeBgpPeersResponse DescribeBgpPeersResponse
     */
    public function describeBgpPeersWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bgpGroupId)) {
            $query['BgpGroupId'] = $request->bgpGroupId;
        }
        if (!Utils::isUnset($request->bgpPeerId)) {
            $query['BgpPeerId'] = $request->bgpPeerId;
        }
        if (!Utils::isUnset($request->isDefault)) {
            $query['IsDefault'] = $request->isDefault;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routerId)) {
            $query['RouterId'] = $request->routerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeBgpPeers',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeBgpPeersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries Border Gateway Protocol (BGP) peers in a region.
     *  *
     * @param DescribeBgpPeersRequest $request DescribeBgpPeersRequest
     *
     * @return DescribeBgpPeersResponse DescribeBgpPeersResponse
     */
    public function describeBgpPeers($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBgpPeersWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of Internet Shared Bandwidth instances in a region.
     *  *
     * @param DescribeCommonBandwidthPackagesRequest $request DescribeCommonBandwidthPackagesRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCommonBandwidthPackagesResponse DescribeCommonBandwidthPackagesResponse
     */
    public function describeCommonBandwidthPackagesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bandwidthPackageId)) {
            $query['BandwidthPackageId'] = $request->bandwidthPackageId;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->includeReservationData)) {
            $query['IncludeReservationData'] = $request->includeReservationData;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->securityProtectionEnabled)) {
            $query['SecurityProtectionEnabled'] = $request->securityProtectionEnabled;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCommonBandwidthPackages',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCommonBandwidthPackagesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of Internet Shared Bandwidth instances in a region.
     *  *
     * @param DescribeCommonBandwidthPackagesRequest $request DescribeCommonBandwidthPackagesRequest
     *
     * @return DescribeCommonBandwidthPackagesResponse DescribeCommonBandwidthPackagesResponse
     */
    public function describeCommonBandwidthPackages($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCommonBandwidthPackagesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries details of a customer gateway.
     *  *
     * @param DescribeCustomerGatewayRequest $request DescribeCustomerGatewayRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCustomerGatewayResponse DescribeCustomerGatewayResponse
     */
    public function describeCustomerGatewayWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->customerGatewayId)) {
            $query['CustomerGatewayId'] = $request->customerGatewayId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCustomerGateway',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCustomerGatewayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries details of a customer gateway.
     *  *
     * @param DescribeCustomerGatewayRequest $request DescribeCustomerGatewayRequest
     *
     * @return DescribeCustomerGatewayResponse DescribeCustomerGatewayResponse
     */
    public function describeCustomerGateway($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCustomerGatewayWithOptions($request, $runtime);
    }

    /**
     * @summary Queries customer gateways.
     *  *
     * @param DescribeCustomerGatewaysRequest $request DescribeCustomerGatewaysRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCustomerGatewaysResponse DescribeCustomerGatewaysResponse
     */
    public function describeCustomerGatewaysWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->customerGatewayId)) {
            $query['CustomerGatewayId'] = $request->customerGatewayId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCustomerGateways',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCustomerGatewaysResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries customer gateways.
     *  *
     * @param DescribeCustomerGatewaysRequest $request DescribeCustomerGatewaysRequest
     *
     * @return DescribeCustomerGatewaysResponse DescribeCustomerGatewaysResponse
     */
    public function describeCustomerGateways($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCustomerGatewaysWithOptions($request, $runtime);
    }

    /**
     * @summary Queries whether permissions on a virtual private cloud (VPC) are granted to a virtual border router (VBR).
     *  *
     * @param DescribeEcGrantRelationRequest $request DescribeEcGrantRelationRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeEcGrantRelationResponse DescribeEcGrantRelationResponse
     */
    public function describeEcGrantRelationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->instanceType)) {
            $query['InstanceType'] = $request->instanceType;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->vbrRegionNo)) {
            $query['VbrRegionNo'] = $request->vbrRegionNo;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeEcGrantRelation',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeEcGrantRelationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries whether permissions on a virtual private cloud (VPC) are granted to a virtual border router (VBR).
     *  *
     * @param DescribeEcGrantRelationRequest $request DescribeEcGrantRelationRequest
     *
     * @return DescribeEcGrantRelationResponse DescribeEcGrantRelationResponse
     */
    public function describeEcGrantRelation($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeEcGrantRelationWithOptions($request, $runtime);
    }

    /**
     * @summary Queries elastic IP addresses (EIPs) created in a region.
     *  *
     * @description You can call this operation to query information about EIPs in a region, including maximum bandwidth, billing methods, and associated instances.
     *  *
     * @param DescribeEipAddressesRequest $request DescribeEipAddressesRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeEipAddressesResponse DescribeEipAddressesResponse
     */
    public function describeEipAddressesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->allocationId)) {
            $query['AllocationId'] = $request->allocationId;
        }
        if (!Utils::isUnset($request->associatedInstanceId)) {
            $query['AssociatedInstanceId'] = $request->associatedInstanceId;
        }
        if (!Utils::isUnset($request->associatedInstanceType)) {
            $query['AssociatedInstanceType'] = $request->associatedInstanceType;
        }
        if (!Utils::isUnset($request->chargeType)) {
            $query['ChargeType'] = $request->chargeType;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->eipAddress)) {
            $query['EipAddress'] = $request->eipAddress;
        }
        if (!Utils::isUnset($request->eipName)) {
            $query['EipName'] = $request->eipName;
        }
        if (!Utils::isUnset($request->ISP)) {
            $query['ISP'] = $request->ISP;
        }
        if (!Utils::isUnset($request->includeReservationData)) {
            $query['IncludeReservationData'] = $request->includeReservationData;
        }
        if (!Utils::isUnset($request->lockReason)) {
            $query['LockReason'] = $request->lockReason;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->publicIpAddressPoolId)) {
            $query['PublicIpAddressPoolId'] = $request->publicIpAddressPoolId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->securityProtectionEnabled)) {
            $query['SecurityProtectionEnabled'] = $request->securityProtectionEnabled;
        }
        if (!Utils::isUnset($request->segmentInstanceId)) {
            $query['SegmentInstanceId'] = $request->segmentInstanceId;
        }
        if (!Utils::isUnset($request->serviceManaged)) {
            $query['ServiceManaged'] = $request->serviceManaged;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->filter)) {
            $query['Filter'] = $request->filter;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeEipAddresses',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeEipAddressesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries elastic IP addresses (EIPs) created in a region.
     *  *
     * @description You can call this operation to query information about EIPs in a region, including maximum bandwidth, billing methods, and associated instances.
     *  *
     * @param DescribeEipAddressesRequest $request DescribeEipAddressesRequest
     *
     * @return DescribeEipAddressesResponse DescribeEipAddressesResponse
     */
    public function describeEipAddresses($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeEipAddressesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the gateway and subnet mask of an elastic IP address (EIP).
     *  *
     * @description You can query only EIPs that are associated with secondary elastic network interfaces (ENIs) in multi-EIP-to-ENI mode.
     *  *
     * @param DescribeEipGatewayInfoRequest $request DescribeEipGatewayInfoRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeEipGatewayInfoResponse DescribeEipGatewayInfoResponse
     */
    public function describeEipGatewayInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeEipGatewayInfo',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeEipGatewayInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the gateway and subnet mask of an elastic IP address (EIP).
     *  *
     * @description You can query only EIPs that are associated with secondary elastic network interfaces (ENIs) in multi-EIP-to-ENI mode.
     *  *
     * @param DescribeEipGatewayInfoRequest $request DescribeEipGatewayInfoRequest
     *
     * @return DescribeEipGatewayInfoResponse DescribeEipGatewayInfoResponse
     */
    public function describeEipGatewayInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeEipGatewayInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the monitoring data of an elastic IP address (EIP). You can query monitoring data within the last 30 days, and obtain up to 400 data points in each request.
     *  *
     * @description To improve user experience in querying monitoring data, we recommend that you call the DescribeMetricList API operation provided by CloudMonitor to query EIP monitoring data. For more information, see [DescribeMetricList](https://help.aliyun.com/document_detail/51936.html) and [EIP monitoring data](https://help.aliyun.com/document_detail/162874.html).
     *  *
     * @param DescribeEipMonitorDataRequest $request DescribeEipMonitorDataRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeEipMonitorDataResponse DescribeEipMonitorDataResponse
     */
    public function describeEipMonitorDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->allocationId)) {
            $query['AllocationId'] = $request->allocationId;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->period)) {
            $query['Period'] = $request->period;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeEipMonitorData',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeEipMonitorDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the monitoring data of an elastic IP address (EIP). You can query monitoring data within the last 30 days, and obtain up to 400 data points in each request.
     *  *
     * @description To improve user experience in querying monitoring data, we recommend that you call the DescribeMetricList API operation provided by CloudMonitor to query EIP monitoring data. For more information, see [DescribeMetricList](https://help.aliyun.com/document_detail/51936.html) and [EIP monitoring data](https://help.aliyun.com/document_detail/162874.html).
     *  *
     * @param DescribeEipMonitorDataRequest $request DescribeEipMonitorDataRequest
     *
     * @return DescribeEipMonitorDataResponse DescribeEipMonitorDataResponse
     */
    public function describeEipMonitorData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeEipMonitorDataWithOptions($request, $runtime);
    }

    /**
     * @summary Queries contiguous elastic IP address (EIP) groups.
     *  *
     * @param DescribeEipSegmentRequest $request DescribeEipSegmentRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeEipSegmentResponse DescribeEipSegmentResponse
     */
    public function describeEipSegmentWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->segmentInstanceId)) {
            $query['SegmentInstanceId'] = $request->segmentInstanceId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeEipSegment',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeEipSegmentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries contiguous elastic IP address (EIP) groups.
     *  *
     * @param DescribeEipSegmentRequest $request DescribeEipSegmentRequest
     *
     * @return DescribeEipSegmentResponse DescribeEipSegmentResponse
     */
    public function describeEipSegment($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeEipSegmentWithOptions($request, $runtime);
    }

    /**
     * @summary 查询高速通道Qos
     *  *
     * @param DescribeExpressConnectTrafficQosRequest $request DescribeExpressConnectTrafficQosRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeExpressConnectTrafficQosResponse DescribeExpressConnectTrafficQosResponse
     */
    public function describeExpressConnectTrafficQosWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->maxResults)) {
            $query['MaxResults'] = $request->maxResults;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->qosIdList)) {
            $query['QosIdList'] = $request->qosIdList;
        }
        if (!Utils::isUnset($request->qosNameList)) {
            $query['QosNameList'] = $request->qosNameList;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeExpressConnectTrafficQos',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeExpressConnectTrafficQosResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询高速通道Qos
     *  *
     * @param DescribeExpressConnectTrafficQosRequest $request DescribeExpressConnectTrafficQosRequest
     *
     * @return DescribeExpressConnectTrafficQosResponse DescribeExpressConnectTrafficQosResponse
     */
    public function describeExpressConnectTrafficQos($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeExpressConnectTrafficQosWithOptions($request, $runtime);
    }

    /**
     * @summary 查询高速通道Qos队列
     *  *
     * @param DescribeExpressConnectTrafficQosQueueRequest $request DescribeExpressConnectTrafficQosQueueRequest
     * @param RuntimeOptions                               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeExpressConnectTrafficQosQueueResponse DescribeExpressConnectTrafficQosQueueResponse
     */
    public function describeExpressConnectTrafficQosQueueWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->qosId)) {
            $query['QosId'] = $request->qosId;
        }
        if (!Utils::isUnset($request->queueIdList)) {
            $query['QueueIdList'] = $request->queueIdList;
        }
        if (!Utils::isUnset($request->queueNameList)) {
            $query['QueueNameList'] = $request->queueNameList;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeExpressConnectTrafficQosQueue',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeExpressConnectTrafficQosQueueResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询高速通道Qos队列
     *  *
     * @param DescribeExpressConnectTrafficQosQueueRequest $request DescribeExpressConnectTrafficQosQueueRequest
     *
     * @return DescribeExpressConnectTrafficQosQueueResponse DescribeExpressConnectTrafficQosQueueResponse
     */
    public function describeExpressConnectTrafficQosQueue($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeExpressConnectTrafficQosQueueWithOptions($request, $runtime);
    }

    /**
     * @summary Queries quality of service (QoS) rules. Paging parameters are not supported.
     *  *
     * @param DescribeExpressConnectTrafficQosRuleRequest $request DescribeExpressConnectTrafficQosRuleRequest
     * @param RuntimeOptions                              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeExpressConnectTrafficQosRuleResponse DescribeExpressConnectTrafficQosRuleResponse
     */
    public function describeExpressConnectTrafficQosRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->qosId)) {
            $query['QosId'] = $request->qosId;
        }
        if (!Utils::isUnset($request->queueId)) {
            $query['QueueId'] = $request->queueId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->ruleIdList)) {
            $query['RuleIdList'] = $request->ruleIdList;
        }
        if (!Utils::isUnset($request->ruleNameList)) {
            $query['RuleNameList'] = $request->ruleNameList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeExpressConnectTrafficQosRule',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeExpressConnectTrafficQosRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries quality of service (QoS) rules. Paging parameters are not supported.
     *  *
     * @param DescribeExpressConnectTrafficQosRuleRequest $request DescribeExpressConnectTrafficQosRuleRequest
     *
     * @return DescribeExpressConnectTrafficQosRuleResponse DescribeExpressConnectTrafficQosRuleResponse
     */
    public function describeExpressConnectTrafficQosRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeExpressConnectTrafficQosRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Queries failover tests.
     *  *
     * @param DescribeFailoverTestJobRequest $request DescribeFailoverTestJobRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeFailoverTestJobResponse DescribeFailoverTestJobResponse
     */
    public function describeFailoverTestJobWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->jobId)) {
            $query['JobId'] = $request->jobId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeFailoverTestJob',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeFailoverTestJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries failover tests.
     *  *
     * @param DescribeFailoverTestJobRequest $request DescribeFailoverTestJobRequest
     *
     * @return DescribeFailoverTestJobResponse DescribeFailoverTestJobResponse
     */
    public function describeFailoverTestJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeFailoverTestJobWithOptions($request, $runtime);
    }

    /**
     * @summary Queries failover tests for Express Connect.
     *  *
     * @param DescribeFailoverTestJobsRequest $request DescribeFailoverTestJobsRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeFailoverTestJobsResponse DescribeFailoverTestJobsResponse
     */
    public function describeFailoverTestJobsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->filter)) {
            $query['Filter'] = $request->filter;
        }
        if (!Utils::isUnset($request->maxResults)) {
            $query['MaxResults'] = $request->maxResults;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeFailoverTestJobs',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeFailoverTestJobsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries failover tests for Express Connect.
     *  *
     * @param DescribeFailoverTestJobsRequest $request DescribeFailoverTestJobsRequest
     *
     * @return DescribeFailoverTestJobsResponse DescribeFailoverTestJobsResponse
     */
    public function describeFailoverTestJobs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeFailoverTestJobsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about flow logs.
     *  *
     * @param DescribeFlowLogsRequest $request DescribeFlowLogsRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeFlowLogsResponse DescribeFlowLogsResponse
     */
    public function describeFlowLogsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->flowLogId)) {
            $query['FlowLogId'] = $request->flowLogId;
        }
        if (!Utils::isUnset($request->flowLogName)) {
            $query['FlowLogName'] = $request->flowLogName;
        }
        if (!Utils::isUnset($request->logStoreName)) {
            $query['LogStoreName'] = $request->logStoreName;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectName)) {
            $query['ProjectName'] = $request->projectName;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceId)) {
            $query['ResourceId'] = $request->resourceId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->resourceType)) {
            $query['ResourceType'] = $request->resourceType;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->tags)) {
            $query['Tags'] = $request->tags;
        }
        if (!Utils::isUnset($request->trafficType)) {
            $query['TrafficType'] = $request->trafficType;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeFlowLogs',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeFlowLogsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about flow logs.
     *  *
     * @param DescribeFlowLogsRequest $request DescribeFlowLogsRequest
     *
     * @return DescribeFlowLogsResponse DescribeFlowLogsResponse
     */
    public function describeFlowLogs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeFlowLogsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries DNAT entries.
     *  *
     * @param DescribeForwardTableEntriesRequest $request DescribeForwardTableEntriesRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeForwardTableEntriesResponse DescribeForwardTableEntriesResponse
     */
    public function describeForwardTableEntriesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->externalIp)) {
            $query['ExternalIp'] = $request->externalIp;
        }
        if (!Utils::isUnset($request->externalPort)) {
            $query['ExternalPort'] = $request->externalPort;
        }
        if (!Utils::isUnset($request->forwardEntryId)) {
            $query['ForwardEntryId'] = $request->forwardEntryId;
        }
        if (!Utils::isUnset($request->forwardEntryName)) {
            $query['ForwardEntryName'] = $request->forwardEntryName;
        }
        if (!Utils::isUnset($request->forwardTableId)) {
            $query['ForwardTableId'] = $request->forwardTableId;
        }
        if (!Utils::isUnset($request->internalIp)) {
            $query['InternalIp'] = $request->internalIp;
        }
        if (!Utils::isUnset($request->internalPort)) {
            $query['InternalPort'] = $request->internalPort;
        }
        if (!Utils::isUnset($request->ipProtocol)) {
            $query['IpProtocol'] = $request->ipProtocol;
        }
        if (!Utils::isUnset($request->natGatewayId)) {
            $query['NatGatewayId'] = $request->natGatewayId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeForwardTableEntries',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeForwardTableEntriesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries DNAT entries.
     *  *
     * @param DescribeForwardTableEntriesRequest $request DescribeForwardTableEntriesRequest
     *
     * @return DescribeForwardTableEntriesResponse DescribeForwardTableEntriesResponse
     */
    public function describeForwardTableEntries($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeForwardTableEntriesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries Global Accelerator (GA) instances.
     *  *
     * @param DescribeGlobalAccelerationInstancesRequest $request DescribeGlobalAccelerationInstancesRequest
     * @param RuntimeOptions                             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeGlobalAccelerationInstancesResponse DescribeGlobalAccelerationInstancesResponse
     */
    public function describeGlobalAccelerationInstancesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bandwidthType)) {
            $query['BandwidthType'] = $request->bandwidthType;
        }
        if (!Utils::isUnset($request->globalAccelerationInstanceId)) {
            $query['GlobalAccelerationInstanceId'] = $request->globalAccelerationInstanceId;
        }
        if (!Utils::isUnset($request->includeReservationData)) {
            $query['IncludeReservationData'] = $request->includeReservationData;
        }
        if (!Utils::isUnset($request->ipAddress)) {
            $query['IpAddress'] = $request->ipAddress;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->serverId)) {
            $query['ServerId'] = $request->serverId;
        }
        if (!Utils::isUnset($request->serviceLocation)) {
            $query['ServiceLocation'] = $request->serviceLocation;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeGlobalAccelerationInstances',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeGlobalAccelerationInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries Global Accelerator (GA) instances.
     *  *
     * @param DescribeGlobalAccelerationInstancesRequest $request DescribeGlobalAccelerationInstancesRequest
     *
     * @return DescribeGlobalAccelerationInstancesResponse DescribeGlobalAccelerationInstancesResponse
     */
    public function describeGlobalAccelerationInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeGlobalAccelerationInstancesWithOptions($request, $runtime);
    }

    /**
     * @summary 查询指定网络实例（VPC、VBR）的云企业网跨账号授权信息
     *  *
     * @param DescribeGrantRulesToCenRequest $request DescribeGrantRulesToCenRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeGrantRulesToCenResponse DescribeGrantRulesToCenResponse
     */
    public function describeGrantRulesToCenWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->instanceType)) {
            $query['InstanceType'] = $request->instanceType;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeGrantRulesToCen',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeGrantRulesToCenResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询指定网络实例（VPC、VBR）的云企业网跨账号授权信息
     *  *
     * @param DescribeGrantRulesToCenRequest $request DescribeGrantRulesToCenRequest
     *
     * @return DescribeGrantRulesToCenResponse DescribeGrantRulesToCenResponse
     */
    public function describeGrantRulesToCen($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeGrantRulesToCenWithOptions($request, $runtime);
    }

    /**
     * @summary Queries HAVIPs in a region.
     *  *
     * @param DescribeHaVipsRequest $request DescribeHaVipsRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeHaVipsResponse DescribeHaVipsResponse
     */
    public function describeHaVipsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->filter)) {
            $query['Filter'] = $request->filter;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tags)) {
            $query['Tags'] = $request->tags;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeHaVips',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeHaVipsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries HAVIPs in a region.
     *  *
     * @param DescribeHaVipsRequest $request DescribeHaVipsRequest
     *
     * @return DescribeHaVipsResponse DescribeHaVipsResponse
     */
    public function describeHaVips($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeHaVipsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries configurations about the fine-grained monitoring feature of an elastic IP address (EIP).
     *  *
     * @param DescribeHighDefinitionMonitorLogAttributeRequest $request DescribeHighDefinitionMonitorLogAttributeRequest
     * @param RuntimeOptions                                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeHighDefinitionMonitorLogAttributeResponse DescribeHighDefinitionMonitorLogAttributeResponse
     */
    public function describeHighDefinitionMonitorLogAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->instanceType)) {
            $query['InstanceType'] = $request->instanceType;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeHighDefinitionMonitorLogAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeHighDefinitionMonitorLogAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries configurations about the fine-grained monitoring feature of an elastic IP address (EIP).
     *  *
     * @param DescribeHighDefinitionMonitorLogAttributeRequest $request DescribeHighDefinitionMonitorLogAttributeRequest
     *
     * @return DescribeHighDefinitionMonitorLogAttributeResponse DescribeHighDefinitionMonitorLogAttributeResponse
     */
    public function describeHighDefinitionMonitorLogAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeHighDefinitionMonitorLogAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of an access control list (ACL), including the specified IP addresses and associated IPv6 mapping entries.
     *  *
     * @param DescribeIPv6TranslatorAclListAttributesRequest $request DescribeIPv6TranslatorAclListAttributesRequest
     * @param RuntimeOptions                                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeIPv6TranslatorAclListAttributesResponse DescribeIPv6TranslatorAclListAttributesResponse
     */
    public function describeIPv6TranslatorAclListAttributesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aclId)) {
            $query['AclId'] = $request->aclId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeIPv6TranslatorAclListAttributes',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeIPv6TranslatorAclListAttributesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of an access control list (ACL), including the specified IP addresses and associated IPv6 mapping entries.
     *  *
     * @param DescribeIPv6TranslatorAclListAttributesRequest $request DescribeIPv6TranslatorAclListAttributesRequest
     *
     * @return DescribeIPv6TranslatorAclListAttributesResponse DescribeIPv6TranslatorAclListAttributesResponse
     */
    public function describeIPv6TranslatorAclListAttributes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeIPv6TranslatorAclListAttributesWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI DescribeIPv6TranslatorAclLists is deprecated
     *  *
     * @summary Queries access control lists (ACLs).
     *  *
     * Deprecated
     *
     * @param DescribeIPv6TranslatorAclListsRequest $request DescribeIPv6TranslatorAclListsRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeIPv6TranslatorAclListsResponse DescribeIPv6TranslatorAclListsResponse
     */
    public function describeIPv6TranslatorAclListsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aclId)) {
            $query['AclId'] = $request->aclId;
        }
        if (!Utils::isUnset($request->aclName)) {
            $query['AclName'] = $request->aclName;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeIPv6TranslatorAclLists',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeIPv6TranslatorAclListsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI DescribeIPv6TranslatorAclLists is deprecated
     *  *
     * @summary Queries access control lists (ACLs).
     *  *
     * Deprecated
     *
     * @param DescribeIPv6TranslatorAclListsRequest $request DescribeIPv6TranslatorAclListsRequest
     *
     * @return DescribeIPv6TranslatorAclListsResponse DescribeIPv6TranslatorAclListsResponse
     */
    public function describeIPv6TranslatorAclLists($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeIPv6TranslatorAclListsWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI DescribeIPv6TranslatorEntries is deprecated
     *  *
     * @summary Queries IPv6 mapping entries.
     *  *
     * Deprecated
     *
     * @param DescribeIPv6TranslatorEntriesRequest $request DescribeIPv6TranslatorEntriesRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeIPv6TranslatorEntriesResponse DescribeIPv6TranslatorEntriesResponse
     */
    public function describeIPv6TranslatorEntriesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aclId)) {
            $query['AclId'] = $request->aclId;
        }
        if (!Utils::isUnset($request->aclStatus)) {
            $query['AclStatus'] = $request->aclStatus;
        }
        if (!Utils::isUnset($request->aclType)) {
            $query['AclType'] = $request->aclType;
        }
        if (!Utils::isUnset($request->allocateIpv6Addr)) {
            $query['AllocateIpv6Addr'] = $request->allocateIpv6Addr;
        }
        if (!Utils::isUnset($request->allocateIpv6Port)) {
            $query['AllocateIpv6Port'] = $request->allocateIpv6Port;
        }
        if (!Utils::isUnset($request->backendIpv4Addr)) {
            $query['BackendIpv4Addr'] = $request->backendIpv4Addr;
        }
        if (!Utils::isUnset($request->backendIpv4Port)) {
            $query['BackendIpv4Port'] = $request->backendIpv4Port;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->entryName)) {
            $query['EntryName'] = $request->entryName;
        }
        if (!Utils::isUnset($request->ipv6TranslatorEntryId)) {
            $query['Ipv6TranslatorEntryId'] = $request->ipv6TranslatorEntryId;
        }
        if (!Utils::isUnset($request->ipv6TranslatorId)) {
            $query['Ipv6TranslatorId'] = $request->ipv6TranslatorId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->transProtocol)) {
            $query['TransProtocol'] = $request->transProtocol;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeIPv6TranslatorEntries',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeIPv6TranslatorEntriesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI DescribeIPv6TranslatorEntries is deprecated
     *  *
     * @summary Queries IPv6 mapping entries.
     *  *
     * Deprecated
     *
     * @param DescribeIPv6TranslatorEntriesRequest $request DescribeIPv6TranslatorEntriesRequest
     *
     * @return DescribeIPv6TranslatorEntriesResponse DescribeIPv6TranslatorEntriesResponse
     */
    public function describeIPv6TranslatorEntries($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeIPv6TranslatorEntriesWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI DescribeIPv6Translators is deprecated
     *  *
     * @summary Queries IPv6 Translation Service instances.
     *  *
     * Deprecated
     *
     * @param DescribeIPv6TranslatorsRequest $request DescribeIPv6TranslatorsRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeIPv6TranslatorsResponse DescribeIPv6TranslatorsResponse
     */
    public function describeIPv6TranslatorsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->allocateIpv4Addr)) {
            $query['AllocateIpv4Addr'] = $request->allocateIpv4Addr;
        }
        if (!Utils::isUnset($request->allocateIpv6Addr)) {
            $query['AllocateIpv6Addr'] = $request->allocateIpv6Addr;
        }
        if (!Utils::isUnset($request->businessStatus)) {
            $query['BusinessStatus'] = $request->businessStatus;
        }
        if (!Utils::isUnset($request->ipv6TranslatorId)) {
            $query['Ipv6TranslatorId'] = $request->ipv6TranslatorId;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->payType)) {
            $query['PayType'] = $request->payType;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->spec)) {
            $query['Spec'] = $request->spec;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeIPv6Translators',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeIPv6TranslatorsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI DescribeIPv6Translators is deprecated
     *  *
     * @summary Queries IPv6 Translation Service instances.
     *  *
     * Deprecated
     *
     * @param DescribeIPv6TranslatorsRequest $request DescribeIPv6TranslatorsRequest
     *
     * @return DescribeIPv6TranslatorsResponse DescribeIPv6TranslatorsResponse
     */
    public function describeIPv6Translators($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeIPv6TranslatorsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries IPv6 addresses in a region.
     *  *
     * @param DescribeIpv6AddressesRequest $request DescribeIpv6AddressesRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeIpv6AddressesResponse DescribeIpv6AddressesResponse
     */
    public function describeIpv6AddressesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->addressType)) {
            $query['AddressType'] = $request->addressType;
        }
        if (!Utils::isUnset($request->associatedInstanceId)) {
            $query['AssociatedInstanceId'] = $request->associatedInstanceId;
        }
        if (!Utils::isUnset($request->associatedInstanceType)) {
            $query['AssociatedInstanceType'] = $request->associatedInstanceType;
        }
        if (!Utils::isUnset($request->includeReservationData)) {
            $query['IncludeReservationData'] = $request->includeReservationData;
        }
        if (!Utils::isUnset($request->ipv6Address)) {
            $query['Ipv6Address'] = $request->ipv6Address;
        }
        if (!Utils::isUnset($request->ipv6AddressId)) {
            $query['Ipv6AddressId'] = $request->ipv6AddressId;
        }
        if (!Utils::isUnset($request->ipv6InternetBandwidthId)) {
            $query['Ipv6InternetBandwidthId'] = $request->ipv6InternetBandwidthId;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->networkType)) {
            $query['NetworkType'] = $request->networkType;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->serviceManaged)) {
            $query['ServiceManaged'] = $request->serviceManaged;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->vSwitchId)) {
            $query['VSwitchId'] = $request->vSwitchId;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeIpv6Addresses',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeIpv6AddressesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries IPv6 addresses in a region.
     *  *
     * @param DescribeIpv6AddressesRequest $request DescribeIpv6AddressesRequest
     *
     * @return DescribeIpv6AddressesResponse DescribeIpv6AddressesResponse
     */
    public function describeIpv6Addresses($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeIpv6AddressesWithOptions($request, $runtime);
    }

    /**
     * @summary 查询创建的仅主动出规则。
     *  *
     * @param DescribeIpv6EgressOnlyRulesRequest $request DescribeIpv6EgressOnlyRulesRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeIpv6EgressOnlyRulesResponse DescribeIpv6EgressOnlyRulesResponse
     */
    public function describeIpv6EgressOnlyRulesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->instanceType)) {
            $query['InstanceType'] = $request->instanceType;
        }
        if (!Utils::isUnset($request->ipv6EgressOnlyRuleId)) {
            $query['Ipv6EgressOnlyRuleId'] = $request->ipv6EgressOnlyRuleId;
        }
        if (!Utils::isUnset($request->ipv6GatewayId)) {
            $query['Ipv6GatewayId'] = $request->ipv6GatewayId;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeIpv6EgressOnlyRules',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeIpv6EgressOnlyRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询创建的仅主动出规则。
     *  *
     * @param DescribeIpv6EgressOnlyRulesRequest $request DescribeIpv6EgressOnlyRulesRequest
     *
     * @return DescribeIpv6EgressOnlyRulesResponse DescribeIpv6EgressOnlyRulesResponse
     */
    public function describeIpv6EgressOnlyRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeIpv6EgressOnlyRulesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about an IPv6 gateway, including the region, virtual private cloud (VPC), status, and billing method.
     *  *
     * @param DescribeIpv6GatewayAttributeRequest $request DescribeIpv6GatewayAttributeRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeIpv6GatewayAttributeResponse DescribeIpv6GatewayAttributeResponse
     */
    public function describeIpv6GatewayAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ipv6GatewayId)) {
            $query['Ipv6GatewayId'] = $request->ipv6GatewayId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeIpv6GatewayAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeIpv6GatewayAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about an IPv6 gateway, including the region, virtual private cloud (VPC), status, and billing method.
     *  *
     * @param DescribeIpv6GatewayAttributeRequest $request DescribeIpv6GatewayAttributeRequest
     *
     * @return DescribeIpv6GatewayAttributeResponse DescribeIpv6GatewayAttributeResponse
     */
    public function describeIpv6GatewayAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeIpv6GatewayAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Queries IPv6 gateways in a region.
     *  *
     * @param DescribeIpv6GatewaysRequest $request DescribeIpv6GatewaysRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeIpv6GatewaysResponse DescribeIpv6GatewaysResponse
     */
    public function describeIpv6GatewaysWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ipv6GatewayId)) {
            $query['Ipv6GatewayId'] = $request->ipv6GatewayId;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tags)) {
            $query['Tags'] = $request->tags;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeIpv6Gateways',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeIpv6GatewaysResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries IPv6 gateways in a region.
     *  *
     * @param DescribeIpv6GatewaysRequest $request DescribeIpv6GatewaysRequest
     *
     * @return DescribeIpv6GatewaysResponse DescribeIpv6GatewaysResponse
     */
    public function describeIpv6Gateways($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeIpv6GatewaysWithOptions($request, $runtime);
    }

    /**
     * @summary 查询NAT已绑定ENI信息
     *  *
     * @param DescribeNatGatewayAssociateNetworkInterfacesRequest $request DescribeNatGatewayAssociateNetworkInterfacesRequest
     * @param RuntimeOptions                                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeNatGatewayAssociateNetworkInterfacesResponse DescribeNatGatewayAssociateNetworkInterfacesResponse
     */
    public function describeNatGatewayAssociateNetworkInterfacesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->filter)) {
            $query['Filter'] = $request->filter;
        }
        if (!Utils::isUnset($request->maxResults)) {
            $query['MaxResults'] = $request->maxResults;
        }
        if (!Utils::isUnset($request->natGatewayId)) {
            $query['NatGatewayId'] = $request->natGatewayId;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeNatGatewayAssociateNetworkInterfaces',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeNatGatewayAssociateNetworkInterfacesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询NAT已绑定ENI信息
     *  *
     * @param DescribeNatGatewayAssociateNetworkInterfacesRequest $request DescribeNatGatewayAssociateNetworkInterfacesRequest
     *
     * @return DescribeNatGatewayAssociateNetworkInterfacesResponse DescribeNatGatewayAssociateNetworkInterfacesResponse
     */
    public function describeNatGatewayAssociateNetworkInterfaces($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeNatGatewayAssociateNetworkInterfacesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries NAT gateways that meet specific conditions in a specified region.
     *  *
     * @description You can call this operation to query both Virtual Private Cloud (VPC) NAT gateways and Internet NAT gateways. NAT gateways in this topic refer to both VPC NAT gateways and Internet NAT gateways.
     *  *
     * @param DescribeNatGatewaysRequest $request DescribeNatGatewaysRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeNatGatewaysResponse DescribeNatGatewaysResponse
     */
    public function describeNatGatewaysWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->instanceChargeType)) {
            $query['InstanceChargeType'] = $request->instanceChargeType;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->natGatewayId)) {
            $query['NatGatewayId'] = $request->natGatewayId;
        }
        if (!Utils::isUnset($request->natType)) {
            $query['NatType'] = $request->natType;
        }
        if (!Utils::isUnset($request->networkType)) {
            $query['NetworkType'] = $request->networkType;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->spec)) {
            $query['Spec'] = $request->spec;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        if (!Utils::isUnset($request->zoneId)) {
            $query['ZoneId'] = $request->zoneId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeNatGateways',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeNatGatewaysResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries NAT gateways that meet specific conditions in a specified region.
     *  *
     * @description You can call this operation to query both Virtual Private Cloud (VPC) NAT gateways and Internet NAT gateways. NAT gateways in this topic refer to both VPC NAT gateways and Internet NAT gateways.
     *  *
     * @param DescribeNatGatewaysRequest $request DescribeNatGatewaysRequest
     *
     * @return DescribeNatGatewaysResponse DescribeNatGatewaysResponse
     */
    public function describeNatGateways($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeNatGatewaysWithOptions($request, $runtime);
    }

    /**
     * @summary Queries network access control lists (ACLs).
     *  *
     * @param DescribeNetworkAclAttributesRequest $request DescribeNetworkAclAttributesRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeNetworkAclAttributesResponse DescribeNetworkAclAttributesResponse
     */
    public function describeNetworkAclAttributesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->networkAclId)) {
            $query['NetworkAclId'] = $request->networkAclId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeNetworkAclAttributes',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeNetworkAclAttributesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries network access control lists (ACLs).
     *  *
     * @param DescribeNetworkAclAttributesRequest $request DescribeNetworkAclAttributesRequest
     *
     * @return DescribeNetworkAclAttributesResponse DescribeNetworkAclAttributesResponse
     */
    public function describeNetworkAclAttributes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeNetworkAclAttributesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries network ACLs.
     *  *
     * @param DescribeNetworkAclsRequest $request DescribeNetworkAclsRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeNetworkAclsResponse DescribeNetworkAclsResponse
     */
    public function describeNetworkAclsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->networkAclId)) {
            $query['NetworkAclId'] = $request->networkAclId;
        }
        if (!Utils::isUnset($request->networkAclName)) {
            $query['NetworkAclName'] = $request->networkAclName;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceId)) {
            $query['ResourceId'] = $request->resourceId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->resourceType)) {
            $query['ResourceType'] = $request->resourceType;
        }
        if (!Utils::isUnset($request->tags)) {
            $query['Tags'] = $request->tags;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeNetworkAcls',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeNetworkAclsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries network ACLs.
     *  *
     * @param DescribeNetworkAclsRequest $request DescribeNetworkAclsRequest
     *
     * @return DescribeNetworkAclsResponse DescribeNetworkAclsResponse
     */
    public function describeNetworkAcls($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeNetworkAclsWithOptions($request, $runtime);
    }

    /**
     * @summary 查询物理专线LOA信息
     *  *
     * @param DescribePhysicalConnectionLOARequest $request DescribePhysicalConnectionLOARequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePhysicalConnectionLOAResponse DescribePhysicalConnectionLOAResponse
     */
    public function describePhysicalConnectionLOAWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePhysicalConnectionLOA',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePhysicalConnectionLOAResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询物理专线LOA信息
     *  *
     * @param DescribePhysicalConnectionLOARequest $request DescribePhysicalConnectionLOARequest
     *
     * @return DescribePhysicalConnectionLOAResponse DescribePhysicalConnectionLOAResponse
     */
    public function describePhysicalConnectionLOA($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePhysicalConnectionLOAWithOptions($request, $runtime);
    }

    /**
     * @summary Queries Express Connect circuits in a region.
     *  *
     * @description By default, the system queries information about all Express Connect circuits in the specified region. You can query Express Connect circuits that meet specific conditions by specifying filter conditions provided by the **DescribePhysicalConnections** operation. For more information about the supported filter conditions, see **Key** in the **Request parameters** section.
     *  *
     * @param DescribePhysicalConnectionsRequest $request DescribePhysicalConnectionsRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePhysicalConnectionsResponse DescribePhysicalConnectionsResponse
     */
    public function describePhysicalConnectionsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->filter)) {
            $query['Filter'] = $request->filter;
        }
        if (!Utils::isUnset($request->includeReservationData)) {
            $query['IncludeReservationData'] = $request->includeReservationData;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tags)) {
            $query['Tags'] = $request->tags;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePhysicalConnections',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePhysicalConnectionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries Express Connect circuits in a region.
     *  *
     * @description By default, the system queries information about all Express Connect circuits in the specified region. You can query Express Connect circuits that meet specific conditions by specifying filter conditions provided by the **DescribePhysicalConnections** operation. For more information about the supported filter conditions, see **Key** in the **Request parameters** section.
     *  *
     * @param DescribePhysicalConnectionsRequest $request DescribePhysicalConnectionsRequest
     *
     * @return DescribePhysicalConnectionsResponse DescribePhysicalConnectionsResponse
     */
    public function describePhysicalConnections($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePhysicalConnectionsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the public IP address range of a virtual private cloud (VPC) in a region.
     *  *
     * @description You cannot query the range of public IP addresses of a classic network by calling the **DescribePublicIpAddress** operation.
     *  *
     * @param DescribePublicIpAddressRequest $request DescribePublicIpAddressRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePublicIpAddressResponse DescribePublicIpAddressResponse
     */
    public function describePublicIpAddressWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ipVersion)) {
            $query['IpVersion'] = $request->ipVersion;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePublicIpAddress',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePublicIpAddressResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the public IP address range of a virtual private cloud (VPC) in a region.
     *  *
     * @description You cannot query the range of public IP addresses of a classic network by calling the **DescribePublicIpAddress** operation.
     *  *
     * @param DescribePublicIpAddressRequest $request DescribePublicIpAddressRequest
     *
     * @return DescribePublicIpAddressResponse DescribePublicIpAddressResponse
     */
    public function describePublicIpAddress($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePublicIpAddressWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the most recent region list.
     *  *
     * @param DescribeRegionsRequest $request DescribeRegionsRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeRegionsResponse DescribeRegionsResponse
     */
    public function describeRegionsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->acceptLanguage)) {
            $query['AcceptLanguage'] = $request->acceptLanguage;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->productType)) {
            $query['ProductType'] = $request->productType;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeRegions',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeRegionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the most recent region list.
     *  *
     * @param DescribeRegionsRequest $request DescribeRegionsRequest
     *
     * @return DescribeRegionsResponse DescribeRegionsResponse
     */
    public function describeRegions($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRegionsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about route entries in a route table.
     *  *
     * @description Before you call the [DeleteRouteEntry](https://help.aliyun.com/document_detail/36013.html) operation to delete a route, you can call this operation to query the next hop of the route that you want to delete.
     *  *
     * @param DescribeRouteEntryListRequest $request DescribeRouteEntryListRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeRouteEntryListResponse DescribeRouteEntryListResponse
     */
    public function describeRouteEntryListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->destCidrBlockList)) {
            $query['DestCidrBlockList'] = $request->destCidrBlockList;
        }
        if (!Utils::isUnset($request->destinationCidrBlock)) {
            $query['DestinationCidrBlock'] = $request->destinationCidrBlock;
        }
        if (!Utils::isUnset($request->ipVersion)) {
            $query['IpVersion'] = $request->ipVersion;
        }
        if (!Utils::isUnset($request->maxResult)) {
            $query['MaxResult'] = $request->maxResult;
        }
        if (!Utils::isUnset($request->nextHopId)) {
            $query['NextHopId'] = $request->nextHopId;
        }
        if (!Utils::isUnset($request->nextHopType)) {
            $query['NextHopType'] = $request->nextHopType;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeEntryId)) {
            $query['RouteEntryId'] = $request->routeEntryId;
        }
        if (!Utils::isUnset($request->routeEntryName)) {
            $query['RouteEntryName'] = $request->routeEntryName;
        }
        if (!Utils::isUnset($request->routeEntryType)) {
            $query['RouteEntryType'] = $request->routeEntryType;
        }
        if (!Utils::isUnset($request->routeTableId)) {
            $query['RouteTableId'] = $request->routeTableId;
        }
        if (!Utils::isUnset($request->serviceType)) {
            $query['ServiceType'] = $request->serviceType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeRouteEntryList',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeRouteEntryListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about route entries in a route table.
     *  *
     * @description Before you call the [DeleteRouteEntry](https://help.aliyun.com/document_detail/36013.html) operation to delete a route, you can call this operation to query the next hop of the route that you want to delete.
     *  *
     * @param DescribeRouteEntryListRequest $request DescribeRouteEntryListRequest
     *
     * @return DescribeRouteEntryListResponse DescribeRouteEntryListResponse
     */
    public function describeRouteEntryList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRouteEntryListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries route tables.
     *  *
     * @param DescribeRouteTableListRequest $request DescribeRouteTableListRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeRouteTableListResponse DescribeRouteTableListResponse
     */
    public function describeRouteTableListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeTableId)) {
            $query['RouteTableId'] = $request->routeTableId;
        }
        if (!Utils::isUnset($request->routeTableName)) {
            $query['RouteTableName'] = $request->routeTableName;
        }
        if (!Utils::isUnset($request->routeTableType)) {
            $query['RouteTableType'] = $request->routeTableType;
        }
        if (!Utils::isUnset($request->routerId)) {
            $query['RouterId'] = $request->routerId;
        }
        if (!Utils::isUnset($request->routerType)) {
            $query['RouterType'] = $request->routerType;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeRouteTableList',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeRouteTableListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries route tables.
     *  *
     * @param DescribeRouteTableListRequest $request DescribeRouteTableListRequest
     *
     * @return DescribeRouteTableListResponse DescribeRouteTableListResponse
     */
    public function describeRouteTableList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRouteTableListWithOptions($request, $runtime);
    }

    /**
     * @deprecated openAPI DescribeRouteTables is deprecated, please use Vpc::2016-04-28::DescribeRouteTableList instead
     *  *
     * @summary Queries route tables.
     *  *
     * Deprecated
     *
     * @param DescribeRouteTablesRequest $request DescribeRouteTablesRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeRouteTablesResponse DescribeRouteTablesResponse
     */
    public function describeRouteTablesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeTableId)) {
            $query['RouteTableId'] = $request->routeTableId;
        }
        if (!Utils::isUnset($request->routeTableName)) {
            $query['RouteTableName'] = $request->routeTableName;
        }
        if (!Utils::isUnset($request->routerId)) {
            $query['RouterId'] = $request->routerId;
        }
        if (!Utils::isUnset($request->routerType)) {
            $query['RouterType'] = $request->routerType;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->VRouterId)) {
            $query['VRouterId'] = $request->VRouterId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeRouteTables',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeRouteTablesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated openAPI DescribeRouteTables is deprecated, please use Vpc::2016-04-28::DescribeRouteTableList instead
     *  *
     * @summary Queries route tables.
     *  *
     * Deprecated
     *
     * @param DescribeRouteTablesRequest $request DescribeRouteTablesRequest
     *
     * @return DescribeRouteTablesResponse DescribeRouteTablesResponse
     */
    public function describeRouteTables($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRouteTablesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configuration of a router interface.
     *  *
     * @param DescribeRouterInterfaceAttributeRequest $request DescribeRouterInterfaceAttributeRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeRouterInterfaceAttributeResponse DescribeRouterInterfaceAttributeResponse
     */
    public function describeRouterInterfaceAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeRouterInterfaceAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeRouterInterfaceAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configuration of a router interface.
     *  *
     * @param DescribeRouterInterfaceAttributeRequest $request DescribeRouterInterfaceAttributeRequest
     *
     * @return DescribeRouterInterfaceAttributeResponse DescribeRouterInterfaceAttributeResponse
     */
    public function describeRouterInterfaceAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRouterInterfaceAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Queries router interfaces in a specified region.
     *  *
     * @param DescribeRouterInterfacesRequest $request DescribeRouterInterfacesRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeRouterInterfacesResponse DescribeRouterInterfacesResponse
     */
    public function describeRouterInterfacesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->filter)) {
            $query['Filter'] = $request->filter;
        }
        if (!Utils::isUnset($request->includeReservationData)) {
            $query['IncludeReservationData'] = $request->includeReservationData;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tags)) {
            $query['Tags'] = $request->tags;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeRouterInterfaces',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeRouterInterfacesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries router interfaces in a specified region.
     *  *
     * @param DescribeRouterInterfacesRequest $request DescribeRouterInterfacesRequest
     *
     * @return DescribeRouterInterfacesResponse DescribeRouterInterfacesResponse
     */
    public function describeRouterInterfaces($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRouterInterfacesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries Global Accelerator (GA) instances that are associated with a backend server.
     *  *
     * @description > You can call this operation to query only dedicated-bandwidth GA instances.
     *  *
     * @param DescribeServerRelatedGlobalAccelerationInstancesRequest $request DescribeServerRelatedGlobalAccelerationInstancesRequest
     * @param RuntimeOptions                                          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeServerRelatedGlobalAccelerationInstancesResponse DescribeServerRelatedGlobalAccelerationInstancesResponse
     */
    public function describeServerRelatedGlobalAccelerationInstancesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->serverId)) {
            $query['ServerId'] = $request->serverId;
        }
        if (!Utils::isUnset($request->serverType)) {
            $query['ServerType'] = $request->serverType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeServerRelatedGlobalAccelerationInstances',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeServerRelatedGlobalAccelerationInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries Global Accelerator (GA) instances that are associated with a backend server.
     *  *
     * @description > You can call this operation to query only dedicated-bandwidth GA instances.
     *  *
     * @param DescribeServerRelatedGlobalAccelerationInstancesRequest $request DescribeServerRelatedGlobalAccelerationInstancesRequest
     *
     * @return DescribeServerRelatedGlobalAccelerationInstancesResponse DescribeServerRelatedGlobalAccelerationInstancesResponse
     */
    public function describeServerRelatedGlobalAccelerationInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeServerRelatedGlobalAccelerationInstancesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries SNAT entries.
     *  *
     * @param DescribeSnatTableEntriesRequest $request DescribeSnatTableEntriesRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSnatTableEntriesResponse DescribeSnatTableEntriesResponse
     */
    public function describeSnatTableEntriesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->natGatewayId)) {
            $query['NatGatewayId'] = $request->natGatewayId;
        }
        if (!Utils::isUnset($request->networkInterfaceIds)) {
            $query['NetworkInterfaceIds'] = $request->networkInterfaceIds;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->snatEntryId)) {
            $query['SnatEntryId'] = $request->snatEntryId;
        }
        if (!Utils::isUnset($request->snatEntryName)) {
            $query['SnatEntryName'] = $request->snatEntryName;
        }
        if (!Utils::isUnset($request->snatIp)) {
            $query['SnatIp'] = $request->snatIp;
        }
        if (!Utils::isUnset($request->snatTableId)) {
            $query['SnatTableId'] = $request->snatTableId;
        }
        if (!Utils::isUnset($request->sourceCIDR)) {
            $query['SourceCIDR'] = $request->sourceCIDR;
        }
        if (!Utils::isUnset($request->sourceVSwitchId)) {
            $query['SourceVSwitchId'] = $request->sourceVSwitchId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSnatTableEntries',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSnatTableEntriesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries SNAT entries.
     *  *
     * @param DescribeSnatTableEntriesRequest $request DescribeSnatTableEntriesRequest
     *
     * @return DescribeSnatTableEntriesResponse DescribeSnatTableEntriesResponse
     */
    public function describeSnatTableEntries($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSnatTableEntriesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of an SSL client certificate.
     *  *
     * @param DescribeSslVpnClientCertRequest $request DescribeSslVpnClientCertRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSslVpnClientCertResponse DescribeSslVpnClientCertResponse
     */
    public function describeSslVpnClientCertWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sslVpnClientCertId)) {
            $query['SslVpnClientCertId'] = $request->sslVpnClientCertId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSslVpnClientCert',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSslVpnClientCertResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of an SSL client certificate.
     *  *
     * @param DescribeSslVpnClientCertRequest $request DescribeSslVpnClientCertRequest
     *
     * @return DescribeSslVpnClientCertResponse DescribeSslVpnClientCertResponse
     */
    public function describeSslVpnClientCert($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSslVpnClientCertWithOptions($request, $runtime);
    }

    /**
     * @summary Queries SSL client certificates.
     *  *
     * @param DescribeSslVpnClientCertsRequest $request DescribeSslVpnClientCertsRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSslVpnClientCertsResponse DescribeSslVpnClientCertsResponse
     */
    public function describeSslVpnClientCertsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sslVpnClientCertId)) {
            $query['SslVpnClientCertId'] = $request->sslVpnClientCertId;
        }
        if (!Utils::isUnset($request->sslVpnServerId)) {
            $query['SslVpnServerId'] = $request->sslVpnServerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSslVpnClientCerts',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSslVpnClientCertsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries SSL client certificates.
     *  *
     * @param DescribeSslVpnClientCertsRequest $request DescribeSslVpnClientCertsRequest
     *
     * @return DescribeSslVpnClientCertsResponse DescribeSslVpnClientCertsResponse
     */
    public function describeSslVpnClientCerts($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSslVpnClientCertsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the clients that have connected to a VPN gateway through SSL-VPN connections.
     *  *
     * @description If your VPN gateway was created before December 10, 2022, you must upgrade your VPN gateway to the latest version before you can view connection information about SSL clients. For more information, see [Upgrade a VPN gateway](https://help.aliyun.com/document_detail/2671058.html).
     * If your VPN gateway was created after December 10, 2022, you can view connection information about SSL clients by default.
     *  *
     * @param DescribeSslVpnClientsRequest $request DescribeSslVpnClientsRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSslVpnClientsResponse DescribeSslVpnClientsResponse
     */
    public function describeSslVpnClientsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vpnGatewayId)) {
            $query['VpnGatewayId'] = $request->vpnGatewayId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSslVpnClients',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSslVpnClientsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the clients that have connected to a VPN gateway through SSL-VPN connections.
     *  *
     * @description If your VPN gateway was created before December 10, 2022, you must upgrade your VPN gateway to the latest version before you can view connection information about SSL clients. For more information, see [Upgrade a VPN gateway](https://help.aliyun.com/document_detail/2671058.html).
     * If your VPN gateway was created after December 10, 2022, you can view connection information about SSL clients by default.
     *  *
     * @param DescribeSslVpnClientsRequest $request DescribeSslVpnClientsRequest
     *
     * @return DescribeSslVpnClientsResponse DescribeSslVpnClientsResponse
     */
    public function describeSslVpnClients($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSslVpnClientsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries one or more SSL-VPN servers.
     *  *
     * @param DescribeSslVpnServersRequest $request DescribeSslVpnServersRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSslVpnServersResponse DescribeSslVpnServersResponse
     */
    public function describeSslVpnServersWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sslVpnServerId)) {
            $query['SslVpnServerId'] = $request->sslVpnServerId;
        }
        if (!Utils::isUnset($request->vpnGatewayId)) {
            $query['VpnGatewayId'] = $request->vpnGatewayId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSslVpnServers',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSslVpnServersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries one or more SSL-VPN servers.
     *  *
     * @param DescribeSslVpnServersRequest $request DescribeSslVpnServersRequest
     *
     * @return DescribeSslVpnServersResponse DescribeSslVpnServersResponse
     */
    public function describeSslVpnServers($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSslVpnServersWithOptions($request, $runtime);
    }

    /**
     * @summary 查询标签键列表。
     *  *
     * @param DescribeTagKeysRequest $request DescribeTagKeysRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeTagKeysResponse DescribeTagKeysResponse
     */
    public function describeTagKeysWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->keyword)) {
            $query['Keyword'] = $request->keyword;
        }
        if (!Utils::isUnset($request->maxResult)) {
            $query['MaxResult'] = $request->maxResult;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceId)) {
            $query['ResourceId'] = $request->resourceId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->resourceType)) {
            $query['ResourceType'] = $request->resourceType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeTagKeys',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeTagKeysResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询标签键列表。
     *  *
     * @param DescribeTagKeysRequest $request DescribeTagKeysRequest
     *
     * @return DescribeTagKeysResponse DescribeTagKeysResponse
     */
    public function describeTagKeys($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeTagKeysWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the tags of an Express Connect circuit.
     *  *
     * @param DescribeTagKeysForExpressConnectRequest $request DescribeTagKeysForExpressConnectRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeTagKeysForExpressConnectResponse DescribeTagKeysForExpressConnectResponse
     */
    public function describeTagKeysForExpressConnectWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->keyword)) {
            $query['Keyword'] = $request->keyword;
        }
        if (!Utils::isUnset($request->maxResult)) {
            $query['MaxResult'] = $request->maxResult;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceId)) {
            $query['ResourceId'] = $request->resourceId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->resourceType)) {
            $query['ResourceType'] = $request->resourceType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeTagKeysForExpressConnect',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeTagKeysForExpressConnectResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the tags of an Express Connect circuit.
     *  *
     * @param DescribeTagKeysForExpressConnectRequest $request DescribeTagKeysForExpressConnectRequest
     *
     * @return DescribeTagKeysForExpressConnectResponse DescribeTagKeysForExpressConnectResponse
     */
    public function describeTagKeysForExpressConnect($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeTagKeysForExpressConnectWithOptions($request, $runtime);
    }

    /**
     * @summary 查询满足筛选条件的标签列表。
     *  *
     * @description *   You must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request to specify the object that you want to query.
     * *   **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified tag key are returned. If you specify only **Tag.N.Value**, an error message is returned.
     * *   If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
     * *   If you specify multiple key-value pairs, all tags that match the key-value pairs are returned.
     *  *
     * @param DescribeTagsRequest $request DescribeTagsRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeTagsResponse DescribeTagsResponse
     */
    public function describeTagsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->maxResult)) {
            $query['MaxResult'] = $request->maxResult;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceId)) {
            $query['ResourceId'] = $request->resourceId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->resourceType)) {
            $query['ResourceType'] = $request->resourceType;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeTags',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeTagsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询满足筛选条件的标签列表。
     *  *
     * @description *   You must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request to specify the object that you want to query.
     * *   **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified tag key are returned. If you specify only **Tag.N.Value**, an error message is returned.
     * *   If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
     * *   If you specify multiple key-value pairs, all tags that match the key-value pairs are returned.
     *  *
     * @param DescribeTagsRequest $request DescribeTagsRequest
     *
     * @return DescribeTagsResponse DescribeTagsResponse
     */
    public function describeTags($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeTagsWithOptions($request, $runtime);
    }

    /**
     * @summary 查询路由器列表
     *  *
     * @param DescribeVRoutersRequest $request DescribeVRoutersRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVRoutersResponse DescribeVRoutersResponse
     */
    public function describeVRoutersWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->VRouterId)) {
            $query['VRouterId'] = $request->VRouterId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVRouters',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVRoutersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询路由器列表
     *  *
     * @param DescribeVRoutersRequest $request DescribeVRoutersRequest
     *
     * @return DescribeVRoutersResponse DescribeVRoutersResponse
     */
    public function describeVRouters($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVRoutersWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the detailed information about a vSwitch.
     *  *
     * @param DescribeVSwitchAttributesRequest $request DescribeVSwitchAttributesRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVSwitchAttributesResponse DescribeVSwitchAttributesResponse
     */
    public function describeVSwitchAttributesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vSwitchId)) {
            $query['VSwitchId'] = $request->vSwitchId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVSwitchAttributes',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVSwitchAttributesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the detailed information about a vSwitch.
     *  *
     * @param DescribeVSwitchAttributesRequest $request DescribeVSwitchAttributesRequest
     *
     * @return DescribeVSwitchAttributesResponse DescribeVSwitchAttributesResponse
     */
    public function describeVSwitchAttributes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVSwitchAttributesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about available vSwitches that are used for an internal network.
     *  *
     * @param DescribeVSwitchesRequest $request DescribeVSwitchesRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVSwitchesResponse DescribeVSwitchesResponse
     */
    public function describeVSwitchesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->enableIpv6)) {
            $query['EnableIpv6'] = $request->enableIpv6;
        }
        if (!Utils::isUnset($request->isDefault)) {
            $query['IsDefault'] = $request->isDefault;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeTableId)) {
            $query['RouteTableId'] = $request->routeTableId;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->vSwitchId)) {
            $query['VSwitchId'] = $request->vSwitchId;
        }
        if (!Utils::isUnset($request->vSwitchName)) {
            $query['VSwitchName'] = $request->vSwitchName;
        }
        if (!Utils::isUnset($request->vSwitchOwnerId)) {
            $query['VSwitchOwnerId'] = $request->vSwitchOwnerId;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        if (!Utils::isUnset($request->zoneId)) {
            $query['ZoneId'] = $request->zoneId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVSwitches',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVSwitchesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about available vSwitches that are used for an internal network.
     *  *
     * @param DescribeVSwitchesRequest $request DescribeVSwitchesRequest
     *
     * @return DescribeVSwitchesResponse DescribeVSwitchesResponse
     */
    public function describeVSwitches($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVSwitchesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries virtual border router (VBR) failover groups.
     *  *
     * @param DescribeVbrHaRequest $request DescribeVbrHaRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVbrHaResponse DescribeVbrHaResponse
     */
    public function describeVbrHaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vbrHaId)) {
            $query['VbrHaId'] = $request->vbrHaId;
        }
        if (!Utils::isUnset($request->vbrId)) {
            $query['VbrId'] = $request->vbrId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVbrHa',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVbrHaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries virtual border router (VBR) failover groups.
     *  *
     * @param DescribeVbrHaRequest $request DescribeVbrHaRequest
     *
     * @return DescribeVbrHaResponse DescribeVbrHaResponse
     */
    public function describeVbrHa($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVbrHaWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the routes of an IPsec-VPN connection.
     *  *
     * @param DescribeVcoRouteEntriesRequest $request DescribeVcoRouteEntriesRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVcoRouteEntriesResponse DescribeVcoRouteEntriesResponse
     */
    public function describeVcoRouteEntriesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeEntryType)) {
            $query['RouteEntryType'] = $request->routeEntryType;
        }
        if (!Utils::isUnset($request->vpnConnectionId)) {
            $query['VpnConnectionId'] = $request->vpnConnectionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVcoRouteEntries',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVcoRouteEntriesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the routes of an IPsec-VPN connection.
     *  *
     * @param DescribeVcoRouteEntriesRequest $request DescribeVcoRouteEntriesRequest
     *
     * @return DescribeVcoRouteEntriesResponse DescribeVcoRouteEntriesResponse
     */
    public function describeVcoRouteEntries($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVcoRouteEntriesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries virtual border routers (VBRs).
     *  *
     * @param DescribeVirtualBorderRoutersRequest $request DescribeVirtualBorderRoutersRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVirtualBorderRoutersResponse DescribeVirtualBorderRoutersResponse
     */
    public function describeVirtualBorderRoutersWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->filter)) {
            $query['Filter'] = $request->filter;
        }
        if (!Utils::isUnset($request->includeCrossAccountVbr)) {
            $query['IncludeCrossAccountVbr'] = $request->includeCrossAccountVbr;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tags)) {
            $query['Tags'] = $request->tags;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVirtualBorderRouters',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVirtualBorderRoutersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries virtual border routers (VBRs).
     *  *
     * @param DescribeVirtualBorderRoutersRequest $request DescribeVirtualBorderRoutersRequest
     *
     * @return DescribeVirtualBorderRoutersResponse DescribeVirtualBorderRoutersResponse
     */
    public function describeVirtualBorderRouters($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVirtualBorderRoutersWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the virtual border routers (VBRs) that are associated with an Express Connect circuit. The VBRs can be created by the owner of the Express Connect circuit and by other Alibaba Cloud accounts.
     *  *
     * @param DescribeVirtualBorderRoutersForPhysicalConnectionRequest $request DescribeVirtualBorderRoutersForPhysicalConnectionRequest
     * @param RuntimeOptions                                           $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVirtualBorderRoutersForPhysicalConnectionResponse DescribeVirtualBorderRoutersForPhysicalConnectionResponse
     */
    public function describeVirtualBorderRoutersForPhysicalConnectionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->filter)) {
            $query['Filter'] = $request->filter;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->physicalConnectionId)) {
            $query['PhysicalConnectionId'] = $request->physicalConnectionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVirtualBorderRoutersForPhysicalConnection',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVirtualBorderRoutersForPhysicalConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the virtual border routers (VBRs) that are associated with an Express Connect circuit. The VBRs can be created by the owner of the Express Connect circuit and by other Alibaba Cloud accounts.
     *  *
     * @param DescribeVirtualBorderRoutersForPhysicalConnectionRequest $request DescribeVirtualBorderRoutersForPhysicalConnectionRequest
     *
     * @return DescribeVirtualBorderRoutersForPhysicalConnectionResponse DescribeVirtualBorderRoutersForPhysicalConnectionResponse
     */
    public function describeVirtualBorderRoutersForPhysicalConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVirtualBorderRoutersForPhysicalConnectionWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configuration of a virtual private cloud (VPC).
     *  *
     * @param DescribeVpcAttributeRequest $request DescribeVpcAttributeRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVpcAttributeResponse DescribeVpcAttributeResponse
     */
    public function describeVpcAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->isDefault)) {
            $query['IsDefault'] = $request->isDefault;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVpcAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVpcAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configuration of a virtual private cloud (VPC).
     *  *
     * @param DescribeVpcAttributeRequest $request DescribeVpcAttributeRequest
     *
     * @return DescribeVpcAttributeResponse DescribeVpcAttributeResponse
     */
    public function describeVpcAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpcAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Queries virtual private clouds (VPCs).
     *  *
     * @param DescribeVpcsRequest $request DescribeVpcsRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVpcsResponse DescribeVpcsResponse
     */
    public function describeVpcsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->dhcpOptionsSetId)) {
            $query['DhcpOptionsSetId'] = $request->dhcpOptionsSetId;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->enableIpv6)) {
            $query['EnableIpv6'] = $request->enableIpv6;
        }
        if (!Utils::isUnset($request->isDefault)) {
            $query['IsDefault'] = $request->isDefault;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        if (!Utils::isUnset($request->vpcName)) {
            $query['VpcName'] = $request->vpcName;
        }
        if (!Utils::isUnset($request->vpcOwnerId)) {
            $query['VpcOwnerId'] = $request->vpcOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVpcs',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVpcsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries virtual private clouds (VPCs).
     *  *
     * @param DescribeVpcsRequest $request DescribeVpcsRequest
     *
     * @return DescribeVpcsResponse DescribeVpcsResponse
     */
    public function describeVpcs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpcsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the IPsec-VPN connections associated with a transit router.
     *  *
     * @param DescribeVpnAttachmentsRequest $request DescribeVpnAttachmentsRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVpnAttachmentsResponse DescribeVpnAttachmentsResponse
     */
    public function describeVpnAttachmentsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->attachType)) {
            $query['AttachType'] = $request->attachType;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vpnConnectionId)) {
            $query['VpnConnectionId'] = $request->vpnConnectionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVpnAttachments',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVpnAttachmentsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the IPsec-VPN connections associated with a transit router.
     *  *
     * @param DescribeVpnAttachmentsRequest $request DescribeVpnAttachmentsRequest
     *
     * @return DescribeVpnAttachmentsResponse DescribeVpnAttachmentsResponse
     */
    public function describeVpnAttachments($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpnAttachmentsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the detailed information about an IPsec-VPN connection.
     *  *
     * @param DescribeVpnConnectionRequest $request DescribeVpnConnectionRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVpnConnectionResponse DescribeVpnConnectionResponse
     */
    public function describeVpnConnectionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vpnConnectionId)) {
            $query['VpnConnectionId'] = $request->vpnConnectionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVpnConnection',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVpnConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the detailed information about an IPsec-VPN connection.
     *  *
     * @param DescribeVpnConnectionRequest $request DescribeVpnConnectionRequest
     *
     * @return DescribeVpnConnectionResponse DescribeVpnConnectionResponse
     */
    public function describeVpnConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpnConnectionWithOptions($request, $runtime);
    }

    /**
     * @summary Queries logs of IPsec-VPN connections.
     *  *
     * @param DescribeVpnConnectionLogsRequest $request DescribeVpnConnectionLogsRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVpnConnectionLogsResponse DescribeVpnConnectionLogsResponse
     */
    public function describeVpnConnectionLogsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->minutePeriod)) {
            $query['MinutePeriod'] = $request->minutePeriod;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->to)) {
            $query['To'] = $request->to;
        }
        if (!Utils::isUnset($request->tunnelId)) {
            $query['TunnelId'] = $request->tunnelId;
        }
        if (!Utils::isUnset($request->vpnConnectionId)) {
            $query['VpnConnectionId'] = $request->vpnConnectionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVpnConnectionLogs',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVpnConnectionLogsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries logs of IPsec-VPN connections.
     *  *
     * @param DescribeVpnConnectionLogsRequest $request DescribeVpnConnectionLogsRequest
     *
     * @return DescribeVpnConnectionLogsResponse DescribeVpnConnectionLogsResponse
     */
    public function describeVpnConnectionLogs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpnConnectionLogsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries IPsec-VPN connections.
     *  *
     * @param DescribeVpnConnectionsRequest $request DescribeVpnConnectionsRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVpnConnectionsResponse DescribeVpnConnectionsResponse
     */
    public function describeVpnConnectionsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->customerGatewayId)) {
            $query['CustomerGatewayId'] = $request->customerGatewayId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->vpnConnectionId)) {
            $query['VpnConnectionId'] = $request->vpnConnectionId;
        }
        if (!Utils::isUnset($request->vpnGatewayId)) {
            $query['VpnGatewayId'] = $request->vpnGatewayId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVpnConnections',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVpnConnectionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries IPsec-VPN connections.
     *  *
     * @param DescribeVpnConnectionsRequest $request DescribeVpnConnectionsRequest
     *
     * @return DescribeVpnConnectionsResponse DescribeVpnConnectionsResponse
     */
    public function describeVpnConnections($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpnConnectionsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the cross-account authorization information about an IPsec-VPN connection.
     *  *
     * @param DescribeVpnCrossAccountAuthorizationsRequest $request DescribeVpnCrossAccountAuthorizationsRequest
     * @param RuntimeOptions                               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVpnCrossAccountAuthorizationsResponse DescribeVpnCrossAccountAuthorizationsResponse
     */
    public function describeVpnCrossAccountAuthorizationsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vpnConnectionId)) {
            $query['VpnConnectionId'] = $request->vpnConnectionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVpnCrossAccountAuthorizations',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVpnCrossAccountAuthorizationsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the cross-account authorization information about an IPsec-VPN connection.
     *  *
     * @param DescribeVpnCrossAccountAuthorizationsRequest $request DescribeVpnCrossAccountAuthorizationsRequest
     *
     * @return DescribeVpnCrossAccountAuthorizationsResponse DescribeVpnCrossAccountAuthorizationsResponse
     */
    public function describeVpnCrossAccountAuthorizations($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpnCrossAccountAuthorizationsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the detailed information about a VPN gateway.
     *  *
     * @param DescribeVpnGatewayRequest $request DescribeVpnGatewayRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVpnGatewayResponse DescribeVpnGatewayResponse
     */
    public function describeVpnGatewayWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->includeReservationData)) {
            $query['IncludeReservationData'] = $request->includeReservationData;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vpnGatewayId)) {
            $query['VpnGatewayId'] = $request->vpnGatewayId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVpnGateway',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVpnGatewayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the detailed information about a VPN gateway.
     *  *
     * @param DescribeVpnGatewayRequest $request DescribeVpnGatewayRequest
     *
     * @return DescribeVpnGatewayResponse DescribeVpnGatewayResponse
     */
    public function describeVpnGateway($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpnGatewayWithOptions($request, $runtime);
    }

    /**
     * @summary 基于地域查询可以创建双隧道VPN与IPSec连接（CEN）的可用区
     *  *
     * @param DescribeVpnGatewayAvailableZonesRequest $request DescribeVpnGatewayAvailableZonesRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVpnGatewayAvailableZonesResponse DescribeVpnGatewayAvailableZonesResponse
     */
    public function describeVpnGatewayAvailableZonesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVpnGatewayAvailableZones',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVpnGatewayAvailableZonesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 基于地域查询可以创建双隧道VPN与IPSec连接（CEN）的可用区
     *  *
     * @param DescribeVpnGatewayAvailableZonesRequest $request DescribeVpnGatewayAvailableZonesRequest
     *
     * @return DescribeVpnGatewayAvailableZonesResponse DescribeVpnGatewayAvailableZonesResponse
     */
    public function describeVpnGatewayAvailableZones($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpnGatewayAvailableZonesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries VPN gateways in a region.
     *  *
     * @param DescribeVpnGatewaysRequest $request DescribeVpnGatewaysRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVpnGatewaysResponse DescribeVpnGatewaysResponse
     */
    public function describeVpnGatewaysWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->businessStatus)) {
            $query['BusinessStatus'] = $request->businessStatus;
        }
        if (!Utils::isUnset($request->includeReservationData)) {
            $query['IncludeReservationData'] = $request->includeReservationData;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        if (!Utils::isUnset($request->vpnGatewayId)) {
            $query['VpnGatewayId'] = $request->vpnGatewayId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVpnGateways',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVpnGatewaysResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries VPN gateways in a region.
     *  *
     * @param DescribeVpnGatewaysRequest $request DescribeVpnGatewaysRequest
     *
     * @return DescribeVpnGatewaysResponse DescribeVpnGatewaysResponse
     */
    public function describeVpnGateways($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpnGatewaysWithOptions($request, $runtime);
    }

    /**
     * @summary Queries policy-based routes configured for a VPN gateway.
     *  *
     * @param DescribeVpnPbrRouteEntriesRequest $request DescribeVpnPbrRouteEntriesRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVpnPbrRouteEntriesResponse DescribeVpnPbrRouteEntriesResponse
     */
    public function describeVpnPbrRouteEntriesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vpnGatewayId)) {
            $query['VpnGatewayId'] = $request->vpnGatewayId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVpnPbrRouteEntries',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVpnPbrRouteEntriesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries policy-based routes configured for a VPN gateway.
     *  *
     * @param DescribeVpnPbrRouteEntriesRequest $request DescribeVpnPbrRouteEntriesRequest
     *
     * @return DescribeVpnPbrRouteEntriesResponse DescribeVpnPbrRouteEntriesResponse
     */
    public function describeVpnPbrRouteEntries($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpnPbrRouteEntriesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries destination-based and BGP route entries of a VPN gateway.
     *  *
     * @param DescribeVpnRouteEntriesRequest $request DescribeVpnRouteEntriesRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVpnRouteEntriesResponse DescribeVpnRouteEntriesResponse
     */
    public function describeVpnRouteEntriesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeEntryType)) {
            $query['RouteEntryType'] = $request->routeEntryType;
        }
        if (!Utils::isUnset($request->vpnGatewayId)) {
            $query['VpnGatewayId'] = $request->vpnGatewayId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVpnRouteEntries',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVpnRouteEntriesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries destination-based and BGP route entries of a VPN gateway.
     *  *
     * @param DescribeVpnRouteEntriesRequest $request DescribeVpnRouteEntriesRequest
     *
     * @return DescribeVpnRouteEntriesResponse DescribeVpnRouteEntriesResponse
     */
    public function describeVpnRouteEntries($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpnRouteEntriesWithOptions($request, $runtime);
    }

    /**
     * @param DescribeVpnSslServerLogsRequest $request DescribeVpnSslServerLogsRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVpnSslServerLogsResponse DescribeVpnSslServerLogsResponse
     */
    public function describeVpnSslServerLogsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->minutePeriod)) {
            $query['MinutePeriod'] = $request->minutePeriod;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sslVpnClientCertId)) {
            $query['SslVpnClientCertId'] = $request->sslVpnClientCertId;
        }
        if (!Utils::isUnset($request->to)) {
            $query['To'] = $request->to;
        }
        if (!Utils::isUnset($request->vpnSslServerId)) {
            $query['VpnSslServerId'] = $request->vpnSslServerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVpnSslServerLogs',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVpnSslServerLogsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param DescribeVpnSslServerLogsRequest $request DescribeVpnSslServerLogsRequest
     *
     * @return DescribeVpnSslServerLogsResponse DescribeVpnSslServerLogsResponse
     */
    public function describeVpnSslServerLogs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpnSslServerLogsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries zones in a region.
     *  *
     * @param DescribeZonesRequest $request DescribeZonesRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeZonesResponse DescribeZonesResponse
     */
    public function describeZonesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->acceptLanguage)) {
            $query['AcceptLanguage'] = $request->acceptLanguage;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->zoneType)) {
            $query['ZoneType'] = $request->zoneType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeZones',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeZonesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries zones in a region.
     *  *
     * @param DescribeZonesRequest $request DescribeZonesRequest
     *
     * @return DescribeZonesResponse DescribeZonesResponse
     */
    public function describeZones($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeZonesWithOptions($request, $runtime);
    }

    /**
     * @summary Disassociates a DHCP options set from a virtual private cloud (VPC).
     *  *
     * @description ## [](#)Description
     * *   **DetachDhcpOptionsSetFromVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task.
     *     *   If the DHCP options set is in the **Pending** state, the DHCP options set is being disassociated.
     *     *   If the DHCP options set is in the **UnUsed** state, the DHCP options set is disassociated.
     * *   You cannot repeatedly call the **DetachDhcpOptionsSetFromVpc** operation to disassociate a DHCP options set from a VPC within the specified period of time.
     *  *
     * @param DetachDhcpOptionsSetFromVpcRequest $request DetachDhcpOptionsSetFromVpcRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DetachDhcpOptionsSetFromVpcResponse DetachDhcpOptionsSetFromVpcResponse
     */
    public function detachDhcpOptionsSetFromVpcWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dhcpOptionsSetId)) {
            $query['DhcpOptionsSetId'] = $request->dhcpOptionsSetId;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DetachDhcpOptionsSetFromVpc',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DetachDhcpOptionsSetFromVpcResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Disassociates a DHCP options set from a virtual private cloud (VPC).
     *  *
     * @description ## [](#)Description
     * *   **DetachDhcpOptionsSetFromVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task.
     *     *   If the DHCP options set is in the **Pending** state, the DHCP options set is being disassociated.
     *     *   If the DHCP options set is in the **UnUsed** state, the DHCP options set is disassociated.
     * *   You cannot repeatedly call the **DetachDhcpOptionsSetFromVpc** operation to disassociate a DHCP options set from a VPC within the specified period of time.
     *  *
     * @param DetachDhcpOptionsSetFromVpcRequest $request DetachDhcpOptionsSetFromVpcRequest
     *
     * @return DetachDhcpOptionsSetFromVpcResponse DetachDhcpOptionsSetFromVpcResponse
     */
    public function detachDhcpOptionsSetFromVpc($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->detachDhcpOptionsSetFromVpcWithOptions($request, $runtime);
    }

    /**
     * @summary Diagnoses IPsec-VPN connections.
     *  *
     * @description *   If the IPsec-VPN connection is in single-tunnel mode, the request parameter `VpnConnectionIds` is required when you call the **DiagnoseVpnConnections** operation.
     * *   If the IPsec-VPN connection is in dual-tunnel mode, the request parameter `TunnelIds` is required when you call the **DiagnoseVpnConnections** operation.
     * *   After you call the **DiagnoseVpnConnections** operation, if the current IPsec-VPN connection is faulty, the operation returns the corresponding error code (**FailedReasonCode**) and log (**SourceLog**). You can troubleshoot based on the error code and log information. For more information, see [Common errors and troubleshooting methods for IPsec-VPN connections](https://help.aliyun.com/document_detail/477862.html).
     *  *
     * @param DiagnoseVpnConnectionsRequest $request DiagnoseVpnConnectionsRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DiagnoseVpnConnectionsResponse DiagnoseVpnConnectionsResponse
     */
    public function diagnoseVpnConnectionsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tunnelIds)) {
            $query['TunnelIds'] = $request->tunnelIds;
        }
        if (!Utils::isUnset($request->vpnConnectionIds)) {
            $query['VpnConnectionIds'] = $request->vpnConnectionIds;
        }
        if (!Utils::isUnset($request->vpnGatewayId)) {
            $query['VpnGatewayId'] = $request->vpnGatewayId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DiagnoseVpnConnections',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DiagnoseVpnConnectionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Diagnoses IPsec-VPN connections.
     *  *
     * @description *   If the IPsec-VPN connection is in single-tunnel mode, the request parameter `VpnConnectionIds` is required when you call the **DiagnoseVpnConnections** operation.
     * *   If the IPsec-VPN connection is in dual-tunnel mode, the request parameter `TunnelIds` is required when you call the **DiagnoseVpnConnections** operation.
     * *   After you call the **DiagnoseVpnConnections** operation, if the current IPsec-VPN connection is faulty, the operation returns the corresponding error code (**FailedReasonCode**) and log (**SourceLog**). You can troubleshoot based on the error code and log information. For more information, see [Common errors and troubleshooting methods for IPsec-VPN connections](https://help.aliyun.com/document_detail/477862.html).
     *  *
     * @param DiagnoseVpnConnectionsRequest $request DiagnoseVpnConnectionsRequest
     *
     * @return DiagnoseVpnConnectionsResponse DiagnoseVpnConnectionsResponse
     */
    public function diagnoseVpnConnections($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->diagnoseVpnConnectionsWithOptions($request, $runtime);
    }

    /**
     * @summary Diagnoses a VPN gateway.
     *  *
     * @description Only VPN gateways in specific regions support the quick diagnostics feature. For more information about the supported regions, see [Supported regions](https://help.aliyun.com/document_detail/430697.html).
     *  *
     * @param DiagnoseVpnGatewayRequest $request DiagnoseVpnGatewayRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DiagnoseVpnGatewayResponse DiagnoseVpnGatewayResponse
     */
    public function diagnoseVpnGatewayWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->IPsecExtendInfo)) {
            $query['IPsecExtendInfo'] = $request->IPsecExtendInfo;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceId)) {
            $query['ResourceId'] = $request->resourceId;
        }
        if (!Utils::isUnset($request->resourceType)) {
            $query['ResourceType'] = $request->resourceType;
        }
        if (!Utils::isUnset($request->vpnGatewayId)) {
            $query['VpnGatewayId'] = $request->vpnGatewayId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DiagnoseVpnGateway',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DiagnoseVpnGatewayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Diagnoses a VPN gateway.
     *  *
     * @description Only VPN gateways in specific regions support the quick diagnostics feature. For more information about the supported regions, see [Supported regions](https://help.aliyun.com/document_detail/430697.html).
     *  *
     * @param DiagnoseVpnGatewayRequest $request DiagnoseVpnGatewayRequest
     *
     * @return DiagnoseVpnGatewayResponse DiagnoseVpnGatewayResponse
     */
    public function diagnoseVpnGateway($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->diagnoseVpnGatewayWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI DisableNatGatewayEcsMetric is deprecated
     *  *
     * @summary Disables traffic monitoring for an Elastic Compute Service (ECS) instance.
     *  *
     * Deprecated
     *
     * @param DisableNatGatewayEcsMetricRequest $request DisableNatGatewayEcsMetricRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DisableNatGatewayEcsMetricResponse DisableNatGatewayEcsMetricResponse
     */
    public function disableNatGatewayEcsMetricWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->natGatewayId)) {
            $query['NatGatewayId'] = $request->natGatewayId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DisableNatGatewayEcsMetric',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DisableNatGatewayEcsMetricResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI DisableNatGatewayEcsMetric is deprecated
     *  *
     * @summary Disables traffic monitoring for an Elastic Compute Service (ECS) instance.
     *  *
     * Deprecated
     *
     * @param DisableNatGatewayEcsMetricRequest $request DisableNatGatewayEcsMetricRequest
     *
     * @return DisableNatGatewayEcsMetricResponse DisableNatGatewayEcsMetricResponse
     */
    public function disableNatGatewayEcsMetric($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->disableNatGatewayEcsMetricWithOptions($request, $runtime);
    }

    /**
     * @summary Disables ClassicLink for a virtual private cloud (VPC).
     *  *
     * @param DisableVpcClassicLinkRequest $request DisableVpcClassicLinkRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DisableVpcClassicLinkResponse DisableVpcClassicLinkResponse
     */
    public function disableVpcClassicLinkWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DisableVpcClassicLink',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DisableVpcClassicLinkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Disables ClassicLink for a virtual private cloud (VPC).
     *  *
     * @param DisableVpcClassicLinkRequest $request DisableVpcClassicLinkRequest
     *
     * @return DisableVpcClassicLinkResponse DisableVpcClassicLinkResponse
     */
    public function disableVpcClassicLink($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->disableVpcClassicLinkWithOptions($request, $runtime);
    }

    /**
     * @summary Disassociates a gateway route table from an IPv4 gateway.
     *  *
     * @param DissociateRouteTableFromGatewayRequest $request DissociateRouteTableFromGatewayRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DissociateRouteTableFromGatewayResponse DissociateRouteTableFromGatewayResponse
     */
    public function dissociateRouteTableFromGatewayWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->gatewayId)) {
            $query['GatewayId'] = $request->gatewayId;
        }
        if (!Utils::isUnset($request->gatewayType)) {
            $query['GatewayType'] = $request->gatewayType;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeTableId)) {
            $query['RouteTableId'] = $request->routeTableId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DissociateRouteTableFromGateway',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DissociateRouteTableFromGatewayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Disassociates a gateway route table from an IPv4 gateway.
     *  *
     * @param DissociateRouteTableFromGatewayRequest $request DissociateRouteTableFromGatewayRequest
     *
     * @return DissociateRouteTableFromGatewayResponse DissociateRouteTableFromGatewayResponse
     */
    public function dissociateRouteTableFromGateway($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dissociateRouteTableFromGatewayWithOptions($request, $runtime);
    }

    /**
     * @summary Disassociates a gateway endpoint from a route table.
     *  *
     * @param DissociateRouteTablesFromVpcGatewayEndpointRequest $request DissociateRouteTablesFromVpcGatewayEndpointRequest
     * @param RuntimeOptions                                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DissociateRouteTablesFromVpcGatewayEndpointResponse DissociateRouteTablesFromVpcGatewayEndpointResponse
     */
    public function dissociateRouteTablesFromVpcGatewayEndpointWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->endpointId)) {
            $query['EndpointId'] = $request->endpointId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeTableIds)) {
            $query['RouteTableIds'] = $request->routeTableIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DissociateRouteTablesFromVpcGatewayEndpoint',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DissociateRouteTablesFromVpcGatewayEndpointResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Disassociates a gateway endpoint from a route table.
     *  *
     * @param DissociateRouteTablesFromVpcGatewayEndpointRequest $request DissociateRouteTablesFromVpcGatewayEndpointRequest
     *
     * @return DissociateRouteTablesFromVpcGatewayEndpointResponse DissociateRouteTablesFromVpcGatewayEndpointResponse
     */
    public function dissociateRouteTablesFromVpcGatewayEndpoint($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dissociateRouteTablesFromVpcGatewayEndpointWithOptions($request, $runtime);
    }

    /**
     * @summary Disassociates a certificate from a VPN gateway.
     *  *
     * @description *   **DissociateVpnGatewayWithCertificate** is an asynchronous operation. After a request is sent, the system returns a request and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status the task.
     *     *   If the VPN gateway is in the **updating** state, the SSL certificate is being disassociated from the VPN gateway.
     *     *   If the VPN gateway is in the **active** state, the SSL certificate is disassociated from the VPN gateway.
     * *   You cannot repeatedly call **DissociateVpnGatewayWithCertificate** within a specific period of time.
     *  *
     * @param DissociateVpnGatewayWithCertificateRequest $request DissociateVpnGatewayWithCertificateRequest
     * @param RuntimeOptions                             $runtime runtime options for this request RuntimeOptions
     *
     * @return DissociateVpnGatewayWithCertificateResponse DissociateVpnGatewayWithCertificateResponse
     */
    public function dissociateVpnGatewayWithCertificateWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->certificateId)) {
            $query['CertificateId'] = $request->certificateId;
        }
        if (!Utils::isUnset($request->certificateType)) {
            $query['CertificateType'] = $request->certificateType;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->vpnGatewayId)) {
            $query['VpnGatewayId'] = $request->vpnGatewayId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DissociateVpnGatewayWithCertificate',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DissociateVpnGatewayWithCertificateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Disassociates a certificate from a VPN gateway.
     *  *
     * @description *   **DissociateVpnGatewayWithCertificate** is an asynchronous operation. After a request is sent, the system returns a request and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status the task.
     *     *   If the VPN gateway is in the **updating** state, the SSL certificate is being disassociated from the VPN gateway.
     *     *   If the VPN gateway is in the **active** state, the SSL certificate is disassociated from the VPN gateway.
     * *   You cannot repeatedly call **DissociateVpnGatewayWithCertificate** within a specific period of time.
     *  *
     * @param DissociateVpnGatewayWithCertificateRequest $request DissociateVpnGatewayWithCertificateRequest
     *
     * @return DissociateVpnGatewayWithCertificateResponse DissociateVpnGatewayWithCertificateResponse
     */
    public function dissociateVpnGatewayWithCertificate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dissociateVpnGatewayWithCertificateWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configuration of an IPsec-VPN connection.
     *  *
     * @param DownloadVpnConnectionConfigRequest $request DownloadVpnConnectionConfigRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DownloadVpnConnectionConfigResponse DownloadVpnConnectionConfigResponse
     */
    public function downloadVpnConnectionConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vpnConnectionId)) {
            $query['VpnConnectionId'] = $request->vpnConnectionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DownloadVpnConnectionConfig',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DownloadVpnConnectionConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configuration of an IPsec-VPN connection.
     *  *
     * @param DownloadVpnConnectionConfigRequest $request DownloadVpnConnectionConfigRequest
     *
     * @return DownloadVpnConnectionConfigResponse DownloadVpnConnectionConfigResponse
     */
    public function downloadVpnConnectionConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->downloadVpnConnectionConfigWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI EnableNatGatewayEcsMetric is deprecated
     *  *
     * @summary Enables Elastic Compute Service (ECS) traffic monitoring.
     *  *
     * Deprecated
     *
     * @param EnableNatGatewayEcsMetricRequest $request EnableNatGatewayEcsMetricRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return EnableNatGatewayEcsMetricResponse EnableNatGatewayEcsMetricResponse
     */
    public function enableNatGatewayEcsMetricWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->natGatewayId)) {
            $query['NatGatewayId'] = $request->natGatewayId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'EnableNatGatewayEcsMetric',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return EnableNatGatewayEcsMetricResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI EnableNatGatewayEcsMetric is deprecated
     *  *
     * @summary Enables Elastic Compute Service (ECS) traffic monitoring.
     *  *
     * Deprecated
     *
     * @param EnableNatGatewayEcsMetricRequest $request EnableNatGatewayEcsMetricRequest
     *
     * @return EnableNatGatewayEcsMetricResponse EnableNatGatewayEcsMetricResponse
     */
    public function enableNatGatewayEcsMetric($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->enableNatGatewayEcsMetricWithOptions($request, $runtime);
    }

    /**
     * @summary Enables an Express Connect circuit that is in the Confirmed state. After you perform this operation, the Express Connect circuit enters the Enabled state.
     *  *
     * @description When you call this operation, take note of the following limits:
     * *   You can enable only an Express Connect circuit that is in the **Confirmed** state.
     * *   After you enable an Express Connect circuit, it enters the **Enabled** state.
     * *   **EnablePhysicalConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribePhysicalConnections](https://help.aliyun.com/document_detail/36042.html) operation to query the status of the task.
     * *   You cannot repeatedly call **EnablePhysicalConnection** for an Express Connect circuit in the **Confirmed** state within a specific time period.
     *  *
     * @param EnablePhysicalConnectionRequest $request EnablePhysicalConnectionRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return EnablePhysicalConnectionResponse EnablePhysicalConnectionResponse
     */
    public function enablePhysicalConnectionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->byPassSp)) {
            $query['ByPassSp'] = $request->byPassSp;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->physicalConnectionId)) {
            $query['PhysicalConnectionId'] = $request->physicalConnectionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'EnablePhysicalConnection',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return EnablePhysicalConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables an Express Connect circuit that is in the Confirmed state. After you perform this operation, the Express Connect circuit enters the Enabled state.
     *  *
     * @description When you call this operation, take note of the following limits:
     * *   You can enable only an Express Connect circuit that is in the **Confirmed** state.
     * *   After you enable an Express Connect circuit, it enters the **Enabled** state.
     * *   **EnablePhysicalConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribePhysicalConnections](https://help.aliyun.com/document_detail/36042.html) operation to query the status of the task.
     * *   You cannot repeatedly call **EnablePhysicalConnection** for an Express Connect circuit in the **Confirmed** state within a specific time period.
     *  *
     * @param EnablePhysicalConnectionRequest $request EnablePhysicalConnectionRequest
     *
     * @return EnablePhysicalConnectionResponse EnablePhysicalConnectionResponse
     */
    public function enablePhysicalConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->enablePhysicalConnectionWithOptions($request, $runtime);
    }

    /**
     * @summary Enables ClassicLink for a VPC.
     *  *
     * @param EnableVpcClassicLinkRequest $request EnableVpcClassicLinkRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return EnableVpcClassicLinkResponse EnableVpcClassicLinkResponse
     */
    public function enableVpcClassicLinkWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'EnableVpcClassicLink',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return EnableVpcClassicLinkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables ClassicLink for a VPC.
     *  *
     * @param EnableVpcClassicLinkRequest $request EnableVpcClassicLinkRequest
     *
     * @return EnableVpcClassicLinkResponse EnableVpcClassicLinkResponse
     */
    public function enableVpcClassicLink($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->enableVpcClassicLinkWithOptions($request, $runtime);
    }

    /**
     * @summary Activates an IPv4 gateway.
     *  *
     * @description ## [](#)Description
     * *   **EnableVpcIpv4Gateway** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of an IPv4 gateway.
     *     *   If the IPv4 gateway is in the **Activating** state, the IPv4 gateway is being activated.
     *     *   If the IPv4 gateway is in the **Created** state, the IPv4 gateway is activated.
     * *   You cannot repeatedly call the **EnableVpcIpv4Gateway** operation to activate an IPv4 gateway within the specified period of time.
     *  *
     * @param EnableVpcIpv4GatewayRequest $request EnableVpcIpv4GatewayRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return EnableVpcIpv4GatewayResponse EnableVpcIpv4GatewayResponse
     */
    public function enableVpcIpv4GatewayWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ipv4GatewayId)) {
            $query['Ipv4GatewayId'] = $request->ipv4GatewayId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeTableList)) {
            $query['RouteTableList'] = $request->routeTableList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'EnableVpcIpv4Gateway',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return EnableVpcIpv4GatewayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Activates an IPv4 gateway.
     *  *
     * @description ## [](#)Description
     * *   **EnableVpcIpv4Gateway** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of an IPv4 gateway.
     *     *   If the IPv4 gateway is in the **Activating** state, the IPv4 gateway is being activated.
     *     *   If the IPv4 gateway is in the **Created** state, the IPv4 gateway is activated.
     * *   You cannot repeatedly call the **EnableVpcIpv4Gateway** operation to activate an IPv4 gateway within the specified period of time.
     *  *
     * @param EnableVpcIpv4GatewayRequest $request EnableVpcIpv4GatewayRequest
     *
     * @return EnableVpcIpv4GatewayResponse EnableVpcIpv4GatewayResponse
     */
    public function enableVpcIpv4Gateway($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->enableVpcIpv4GatewayWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a DHCP options set.
     *  *
     * @param GetDhcpOptionsSetRequest $request GetDhcpOptionsSetRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return GetDhcpOptionsSetResponse GetDhcpOptionsSetResponse
     */
    public function getDhcpOptionsSetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->dhcpOptionsSetId)) {
            $query['DhcpOptionsSetId'] = $request->dhcpOptionsSetId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetDhcpOptionsSet',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetDhcpOptionsSetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a DHCP options set.
     *  *
     * @param GetDhcpOptionsSetRequest $request GetDhcpOptionsSetRequest
     *
     * @return GetDhcpOptionsSetResponse GetDhcpOptionsSetResponse
     */
    public function getDhcpOptionsSet($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDhcpOptionsSetWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the status of a flow log.
     *  *
     * @param GetFlowLogServiceStatusRequest $request GetFlowLogServiceStatusRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return GetFlowLogServiceStatusResponse GetFlowLogServiceStatusResponse
     */
    public function getFlowLogServiceStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetFlowLogServiceStatus',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetFlowLogServiceStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the status of a flow log.
     *  *
     * @param GetFlowLogServiceStatusRequest $request GetFlowLogServiceStatusRequest
     *
     * @return GetFlowLogServiceStatusResponse GetFlowLogServiceStatusResponse
     */
    public function getFlowLogServiceStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFlowLogServiceStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Queries an IPv4 gateway.
     *  *
     * @param GetIpv4GatewayAttributeRequest $request GetIpv4GatewayAttributeRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return GetIpv4GatewayAttributeResponse GetIpv4GatewayAttributeResponse
     */
    public function getIpv4GatewayAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ipv4GatewayId)) {
            $query['Ipv4GatewayId'] = $request->ipv4GatewayId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetIpv4GatewayAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetIpv4GatewayAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries an IPv4 gateway.
     *  *
     * @param GetIpv4GatewayAttributeRequest $request GetIpv4GatewayAttributeRequest
     *
     * @return GetIpv4GatewayAttributeResponse GetIpv4GatewayAttributeResponse
     */
    public function getIpv4GatewayAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getIpv4GatewayAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary 查询NAT详情信息
     *  *
     * @description You can call this operation to query information about a specified Internet NAT gateway or Virtual Private Cloud (VPC) NAT gateway. In this topic, "NAT gateway" refers to both gateway types.
     *  *
     * @param GetNatGatewayAttributeRequest $request GetNatGatewayAttributeRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return GetNatGatewayAttributeResponse GetNatGatewayAttributeResponse
     */
    public function getNatGatewayAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->natGatewayId)) {
            $query['NatGatewayId'] = $request->natGatewayId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetNatGatewayAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetNatGatewayAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询NAT详情信息
     *  *
     * @description You can call this operation to query information about a specified Internet NAT gateway or Virtual Private Cloud (VPC) NAT gateway. In this topic, "NAT gateway" refers to both gateway types.
     *  *
     * @param GetNatGatewayAttributeRequest $request GetNatGatewayAttributeRequest
     *
     * @return GetNatGatewayAttributeResponse GetNatGatewayAttributeResponse
     */
    public function getNatGatewayAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getNatGatewayAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary 查询是否开通了出云流量服务
     *  *
     * @description You can call this API operation to query the status of outbound data transfer billing for the current account. For more information about outbound data transfer billing, see [Outbound data transfer billing](https://help.aliyun.com/document_detail/274385.html) and [Billing](https://help.aliyun.com/document_detail/54582.html).
     *  *
     * @param GetPhysicalConnectionServiceStatusRequest $request GetPhysicalConnectionServiceStatusRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return GetPhysicalConnectionServiceStatusResponse GetPhysicalConnectionServiceStatusResponse
     */
    public function getPhysicalConnectionServiceStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetPhysicalConnectionServiceStatus',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetPhysicalConnectionServiceStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询是否开通了出云流量服务
     *  *
     * @description You can call this API operation to query the status of outbound data transfer billing for the current account. For more information about outbound data transfer billing, see [Outbound data transfer billing](https://help.aliyun.com/document_detail/274385.html) and [Billing](https://help.aliyun.com/document_detail/54582.html).
     *  *
     * @param GetPhysicalConnectionServiceStatusRequest $request GetPhysicalConnectionServiceStatusRequest
     *
     * @return GetPhysicalConnectionServiceStatusResponse GetPhysicalConnectionServiceStatusResponse
     */
    public function getPhysicalConnectionServiceStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getPhysicalConnectionServiceStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Queries whether the IP address pool feature is enabled.
     *  *
     * @param GetPublicIpAddressPoolServiceStatusRequest $request GetPublicIpAddressPoolServiceStatusRequest
     * @param RuntimeOptions                             $runtime runtime options for this request RuntimeOptions
     *
     * @return GetPublicIpAddressPoolServiceStatusResponse GetPublicIpAddressPoolServiceStatusResponse
     */
    public function getPublicIpAddressPoolServiceStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetPublicIpAddressPoolServiceStatus',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetPublicIpAddressPoolServiceStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries whether the IP address pool feature is enabled.
     *  *
     * @param GetPublicIpAddressPoolServiceStatusRequest $request GetPublicIpAddressPoolServiceStatusRequest
     *
     * @return GetPublicIpAddressPoolServiceStatusResponse GetPublicIpAddressPoolServiceStatusResponse
     */
    public function getPublicIpAddressPoolServiceStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getPublicIpAddressPoolServiceStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the status of the traffic mirroring feature.
     *  *
     * @param GetTrafficMirrorServiceStatusRequest $request GetTrafficMirrorServiceStatusRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return GetTrafficMirrorServiceStatusResponse GetTrafficMirrorServiceStatusResponse
     */
    public function getTrafficMirrorServiceStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetTrafficMirrorServiceStatus',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetTrafficMirrorServiceStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the status of the traffic mirroring feature.
     *  *
     * @param GetTrafficMirrorServiceStatusRequest $request GetTrafficMirrorServiceStatusRequest
     *
     * @return GetTrafficMirrorServiceStatusResponse GetTrafficMirrorServiceStatusResponse
     */
    public function getTrafficMirrorServiceStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getTrafficMirrorServiceStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the usage of a prefix list.
     *  *
     * @param GetVSwitchCidrReservationUsageRequest $request GetVSwitchCidrReservationUsageRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return GetVSwitchCidrReservationUsageResponse GetVSwitchCidrReservationUsageResponse
     */
    public function getVSwitchCidrReservationUsageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->maxResults)) {
            $query['MaxResults'] = $request->maxResults;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vSwitchCidrReservationId)) {
            $query['VSwitchCidrReservationId'] = $request->vSwitchCidrReservationId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetVSwitchCidrReservationUsage',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetVSwitchCidrReservationUsageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the usage of a prefix list.
     *  *
     * @param GetVSwitchCidrReservationUsageRequest $request GetVSwitchCidrReservationUsageRequest
     *
     * @return GetVSwitchCidrReservationUsageResponse GetVSwitchCidrReservationUsageResponse
     */
    public function getVSwitchCidrReservationUsage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getVSwitchCidrReservationUsageWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the attributes of a gateway endpoint.
     *  *
     * @param GetVpcGatewayEndpointAttributeRequest $request GetVpcGatewayEndpointAttributeRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return GetVpcGatewayEndpointAttributeResponse GetVpcGatewayEndpointAttributeResponse
     */
    public function getVpcGatewayEndpointAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->endpointId)) {
            $query['EndpointId'] = $request->endpointId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetVpcGatewayEndpointAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetVpcGatewayEndpointAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the attributes of a gateway endpoint.
     *  *
     * @param GetVpcGatewayEndpointAttributeRequest $request GetVpcGatewayEndpointAttributeRequest
     *
     * @return GetVpcGatewayEndpointAttributeResponse GetVpcGatewayEndpointAttributeResponse
     */
    public function getVpcGatewayEndpointAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getVpcGatewayEndpointAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the resources that are associated with a prefix list.
     *  *
     * @param GetVpcPrefixListAssociationsRequest $request GetVpcPrefixListAssociationsRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return GetVpcPrefixListAssociationsResponse GetVpcPrefixListAssociationsResponse
     */
    public function getVpcPrefixListAssociationsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->maxResults)) {
            $query['MaxResults'] = $request->maxResults;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->prefixListId)) {
            $query['PrefixListId'] = $request->prefixListId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetVpcPrefixListAssociations',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetVpcPrefixListAssociationsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the resources that are associated with a prefix list.
     *  *
     * @param GetVpcPrefixListAssociationsRequest $request GetVpcPrefixListAssociationsRequest
     *
     * @return GetVpcPrefixListAssociationsResponse GetVpcPrefixListAssociationsResponse
     */
    public function getVpcPrefixListAssociations($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getVpcPrefixListAssociationsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a prefix list.
     *  *
     * @param GetVpcPrefixListEntriesRequest $request GetVpcPrefixListEntriesRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return GetVpcPrefixListEntriesResponse GetVpcPrefixListEntriesResponse
     */
    public function getVpcPrefixListEntriesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->maxResults)) {
            $query['MaxResults'] = $request->maxResults;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->prefixListId)) {
            $query['PrefixListId'] = $request->prefixListId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetVpcPrefixListEntries',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetVpcPrefixListEntriesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a prefix list.
     *  *
     * @param GetVpcPrefixListEntriesRequest $request GetVpcPrefixListEntriesRequest
     *
     * @return GetVpcPrefixListEntriesResponse GetVpcPrefixListEntriesResponse
     */
    public function getVpcPrefixListEntries($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getVpcPrefixListEntriesWithOptions($request, $runtime);
    }

    /**
     * @summary 查询路由类型的明细。
     *  *
     * @param GetVpcRouteEntrySummaryRequest $request GetVpcRouteEntrySummaryRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return GetVpcRouteEntrySummaryResponse GetVpcRouteEntrySummaryResponse
     */
    public function getVpcRouteEntrySummaryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeEntryType)) {
            $query['RouteEntryType'] = $request->routeEntryType;
        }
        if (!Utils::isUnset($request->routeTableId)) {
            $query['RouteTableId'] = $request->routeTableId;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetVpcRouteEntrySummary',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetVpcRouteEntrySummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询路由类型的明细。
     *  *
     * @param GetVpcRouteEntrySummaryRequest $request GetVpcRouteEntrySummaryRequest
     *
     * @return GetVpcRouteEntrySummaryResponse GetVpcRouteEntrySummaryResponse
     */
    public function getVpcRouteEntrySummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getVpcRouteEntrySummaryWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the diagnostic result of a VPN gateway.
     *  *
     * @description When you call the **GetVpnGatewayDiagnoseResult** operation, you must specify one of **DiagnoseId** and **VpnGatewayId**.
     *  *
     * @param GetVpnGatewayDiagnoseResultRequest $request GetVpnGatewayDiagnoseResultRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return GetVpnGatewayDiagnoseResultResponse GetVpnGatewayDiagnoseResultResponse
     */
    public function getVpnGatewayDiagnoseResultWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->diagnoseId)) {
            $query['DiagnoseId'] = $request->diagnoseId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->vpnGatewayId)) {
            $query['VpnGatewayId'] = $request->vpnGatewayId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetVpnGatewayDiagnoseResult',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetVpnGatewayDiagnoseResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the diagnostic result of a VPN gateway.
     *  *
     * @description When you call the **GetVpnGatewayDiagnoseResult** operation, you must specify one of **DiagnoseId** and **VpnGatewayId**.
     *  *
     * @param GetVpnGatewayDiagnoseResultRequest $request GetVpnGatewayDiagnoseResultRequest
     *
     * @return GetVpnGatewayDiagnoseResultResponse GetVpnGatewayDiagnoseResultResponse
     */
    public function getVpnGatewayDiagnoseResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getVpnGatewayDiagnoseResultWithOptions($request, $runtime);
    }

    /**
     * @summary Grants permissions to a Cloud Enterprise Network (CEN) instance.
     *  *
     * @description *   Before you can attach a network instance that belongs to another Alibaba Cloud account to your CEN instance, you must grant permissions to your CEN instance.
     * >  **GrantInstanceToCen** is a Virtual Private Cloud (VPC) operation. Therefore, you must use the `vpc.aliyuncs.com` domain name to call this operation. The API version is `2016-04-28`.
     * *   You cannot repeatedly call the **GrantInstanceToCen** operation to grant the permissions on a network instance to a CEN instance. The network instance can be a VPC, a virtual border router (VBR), or a Cloud Connect Network (CCN) instance.
     *  *
     * @param GrantInstanceToCenRequest $request GrantInstanceToCenRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return GrantInstanceToCenResponse GrantInstanceToCenResponse
     */
    public function grantInstanceToCenWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->cenId)) {
            $query['CenId'] = $request->cenId;
        }
        if (!Utils::isUnset($request->cenOwnerId)) {
            $query['CenOwnerId'] = $request->cenOwnerId;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->instanceType)) {
            $query['InstanceType'] = $request->instanceType;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GrantInstanceToCen',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GrantInstanceToCenResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Grants permissions to a Cloud Enterprise Network (CEN) instance.
     *  *
     * @description *   Before you can attach a network instance that belongs to another Alibaba Cloud account to your CEN instance, you must grant permissions to your CEN instance.
     * >  **GrantInstanceToCen** is a Virtual Private Cloud (VPC) operation. Therefore, you must use the `vpc.aliyuncs.com` domain name to call this operation. The API version is `2016-04-28`.
     * *   You cannot repeatedly call the **GrantInstanceToCen** operation to grant the permissions on a network instance to a CEN instance. The network instance can be a VPC, a virtual border router (VBR), or a Cloud Connect Network (CCN) instance.
     *  *
     * @param GrantInstanceToCenRequest $request GrantInstanceToCenRequest
     *
     * @return GrantInstanceToCenResponse GrantInstanceToCenResponse
     */
    public function grantInstanceToCen($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->grantInstanceToCenWithOptions($request, $runtime);
    }

    /**
     * @summary Grants a virtual border router (VBR) the permissions to connect to a virtual private cloud (VPC) that belongs to another Alibaba Cloud account.
     *  *
     * @description ## Usage notes
     * When you connect a VBR to a VPC that belongs to another Alibaba Cloud account, the VBR must acquire the required permissions from the VPC.
     *  *
     * @param GrantInstanceToVbrRequest $tmpReq  GrantInstanceToVbrRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return GrantInstanceToVbrResponse GrantInstanceToVbrResponse
     */
    public function grantInstanceToVbrWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new GrantInstanceToVbrShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->vbrInstanceIds)) {
            $request->vbrInstanceIdsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->vbrInstanceIds, 'VbrInstanceIds', 'simple');
        }
        $query = [];
        if (!Utils::isUnset($request->grantType)) {
            $query['GrantType'] = $request->grantType;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->vbrInstanceIdsShrink)) {
            $query['VbrInstanceIds'] = $request->vbrInstanceIdsShrink;
        }
        if (!Utils::isUnset($request->vbrOwnerUid)) {
            $query['VbrOwnerUid'] = $request->vbrOwnerUid;
        }
        if (!Utils::isUnset($request->vbrRegionNo)) {
            $query['VbrRegionNo'] = $request->vbrRegionNo;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GrantInstanceToVbr',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GrantInstanceToVbrResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Grants a virtual border router (VBR) the permissions to connect to a virtual private cloud (VPC) that belongs to another Alibaba Cloud account.
     *  *
     * @description ## Usage notes
     * When you connect a VBR to a VPC that belongs to another Alibaba Cloud account, the VBR must acquire the required permissions from the VPC.
     *  *
     * @param GrantInstanceToVbrRequest $request GrantInstanceToVbrRequest
     *
     * @return GrantInstanceToVbrResponse GrantInstanceToVbrResponse
     */
    public function grantInstanceToVbr($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->grantInstanceToVbrWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the access points of an Express Connect circuit.
     *  *
     * @param ListBusinessAccessPointsRequest $request ListBusinessAccessPointsRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return ListBusinessAccessPointsResponse ListBusinessAccessPointsResponse
     */
    public function listBusinessAccessPointsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListBusinessAccessPoints',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListBusinessAccessPointsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the access points of an Express Connect circuit.
     *  *
     * @param ListBusinessAccessPointsRequest $request ListBusinessAccessPointsRequest
     *
     * @return ListBusinessAccessPointsResponse ListBusinessAccessPointsResponse
     */
    public function listBusinessAccessPoints($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listBusinessAccessPointsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries Dynamic Host Configuration Protocol (DHCP) options sets.
     *  *
     * @param ListDhcpOptionsSetsRequest $request ListDhcpOptionsSetsRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ListDhcpOptionsSetsResponse ListDhcpOptionsSetsResponse
     */
    public function listDhcpOptionsSetsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->dhcpOptionsSetId)) {
            $query['DhcpOptionsSetId'] = $request->dhcpOptionsSetId;
        }
        if (!Utils::isUnset($request->dhcpOptionsSetName)) {
            $query['DhcpOptionsSetName'] = $request->dhcpOptionsSetName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->maxResults)) {
            $query['MaxResults'] = $request->maxResults;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tags)) {
            $query['Tags'] = $request->tags;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListDhcpOptionsSets',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListDhcpOptionsSetsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries Dynamic Host Configuration Protocol (DHCP) options sets.
     *  *
     * @param ListDhcpOptionsSetsRequest $request ListDhcpOptionsSetsRequest
     *
     * @return ListDhcpOptionsSetsResponse ListDhcpOptionsSetsResponse
     */
    public function listDhcpOptionsSets($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDhcpOptionsSetsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the zones that support NAT gateways.
     *  *
     * @description You can call this operation to query zones that support NAT gateways, including Internet NAT gateways and Virtual Private Cloud (VPC) NAT gateways.
     *  *
     * @param ListEnhanhcedNatGatewayAvailableZonesRequest $request ListEnhanhcedNatGatewayAvailableZonesRequest
     * @param RuntimeOptions                               $runtime runtime options for this request RuntimeOptions
     *
     * @return ListEnhanhcedNatGatewayAvailableZonesResponse ListEnhanhcedNatGatewayAvailableZonesResponse
     */
    public function listEnhanhcedNatGatewayAvailableZonesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->acceptLanguage)) {
            $query['AcceptLanguage'] = $request->acceptLanguage;
        }
        if (!Utils::isUnset($request->filter)) {
            $query['Filter'] = $request->filter;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListEnhanhcedNatGatewayAvailableZones',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListEnhanhcedNatGatewayAvailableZonesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the zones that support NAT gateways.
     *  *
     * @description You can call this operation to query zones that support NAT gateways, including Internet NAT gateways and Virtual Private Cloud (VPC) NAT gateways.
     *  *
     * @param ListEnhanhcedNatGatewayAvailableZonesRequest $request ListEnhanhcedNatGatewayAvailableZonesRequest
     *
     * @return ListEnhanhcedNatGatewayAvailableZonesResponse ListEnhanhcedNatGatewayAvailableZonesResponse
     */
    public function listEnhanhcedNatGatewayAvailableZones($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listEnhanhcedNatGatewayAvailableZonesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries FULLNAT entries.
     *  *
     * @param ListFullNatEntriesRequest $request ListFullNatEntriesRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ListFullNatEntriesResponse ListFullNatEntriesResponse
     */
    public function listFullNatEntriesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->fullNatEntryId)) {
            $query['FullNatEntryId'] = $request->fullNatEntryId;
        }
        if (!Utils::isUnset($request->fullNatEntryNames)) {
            $query['FullNatEntryNames'] = $request->fullNatEntryNames;
        }
        if (!Utils::isUnset($request->fullNatTableId)) {
            $query['FullNatTableId'] = $request->fullNatTableId;
        }
        if (!Utils::isUnset($request->ipProtocol)) {
            $query['IpProtocol'] = $request->ipProtocol;
        }
        if (!Utils::isUnset($request->maxResults)) {
            $query['MaxResults'] = $request->maxResults;
        }
        if (!Utils::isUnset($request->natGatewayId)) {
            $query['NatGatewayId'] = $request->natGatewayId;
        }
        if (!Utils::isUnset($request->natIp)) {
            $query['NatIp'] = $request->natIp;
        }
        if (!Utils::isUnset($request->natIpPort)) {
            $query['NatIpPort'] = $request->natIpPort;
        }
        if (!Utils::isUnset($request->networkInterfaceIds)) {
            $query['NetworkInterfaceIds'] = $request->networkInterfaceIds;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListFullNatEntries',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListFullNatEntriesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries FULLNAT entries.
     *  *
     * @param ListFullNatEntriesRequest $request ListFullNatEntriesRequest
     *
     * @return ListFullNatEntriesResponse ListFullNatEntriesResponse
     */
    public function listFullNatEntries($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listFullNatEntriesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries route entries of a gateway route table.
     *  *
     * @param ListGatewayRouteTableEntriesRequest $request ListGatewayRouteTableEntriesRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return ListGatewayRouteTableEntriesResponse ListGatewayRouteTableEntriesResponse
     */
    public function listGatewayRouteTableEntriesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->destinationCidrBlock)) {
            $query['DestinationCidrBlock'] = $request->destinationCidrBlock;
        }
        if (!Utils::isUnset($request->gatewayRouteTableId)) {
            $query['GatewayRouteTableId'] = $request->gatewayRouteTableId;
        }
        if (!Utils::isUnset($request->maxResults)) {
            $query['MaxResults'] = $request->maxResults;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListGatewayRouteTableEntries',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListGatewayRouteTableEntriesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries route entries of a gateway route table.
     *  *
     * @param ListGatewayRouteTableEntriesRequest $request ListGatewayRouteTableEntriesRequest
     *
     * @return ListGatewayRouteTableEntriesResponse ListGatewayRouteTableEntriesResponse
     */
    public function listGatewayRouteTableEntries($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listGatewayRouteTableEntriesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the most recent region list.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return ListGeographicSubRegionsResponse ListGeographicSubRegionsResponse
     */
    public function listGeographicSubRegionsWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'ListGeographicSubRegions',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListGeographicSubRegionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the most recent region list.
     *  *
     * @return ListGeographicSubRegionsResponse ListGeographicSubRegionsResponse
     */
    public function listGeographicSubRegions()
    {
        $runtime = new RuntimeOptions([]);

        return $this->listGeographicSubRegionsWithOptions($runtime);
    }

    /**
     * @param ListIpsecServerLogsRequest $request ListIpsecServerLogsRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ListIpsecServerLogsResponse ListIpsecServerLogsResponse
     */
    public function listIpsecServerLogsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->ipsecServerId)) {
            $query['IpsecServerId'] = $request->ipsecServerId;
        }
        if (!Utils::isUnset($request->minutePeriod)) {
            $query['MinutePeriod'] = $request->minutePeriod;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->to)) {
            $query['To'] = $request->to;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListIpsecServerLogs',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListIpsecServerLogsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param ListIpsecServerLogsRequest $request ListIpsecServerLogsRequest
     *
     * @return ListIpsecServerLogsResponse ListIpsecServerLogsResponse
     */
    public function listIpsecServerLogs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listIpsecServerLogsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries IPsec servers.
     *  *
     * @param ListIpsecServersRequest $request ListIpsecServersRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return ListIpsecServersResponse ListIpsecServersResponse
     */
    public function listIpsecServersWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ipsecServerId)) {
            $query['IpsecServerId'] = $request->ipsecServerId;
        }
        if (!Utils::isUnset($request->ipsecServerName)) {
            $query['IpsecServerName'] = $request->ipsecServerName;
        }
        if (!Utils::isUnset($request->maxResults)) {
            $query['MaxResults'] = $request->maxResults;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->vpnGatewayId)) {
            $query['VpnGatewayId'] = $request->vpnGatewayId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListIpsecServers',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListIpsecServersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries IPsec servers.
     *  *
     * @param ListIpsecServersRequest $request ListIpsecServersRequest
     *
     * @return ListIpsecServersResponse ListIpsecServersResponse
     */
    public function listIpsecServers($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listIpsecServersWithOptions($request, $runtime);
    }

    /**
     * @summary Queries IPv4 gateways.
     *  *
     * @param ListIpv4GatewaysRequest $request ListIpv4GatewaysRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return ListIpv4GatewaysResponse ListIpv4GatewaysResponse
     */
    public function listIpv4GatewaysWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ipv4GatewayId)) {
            $query['Ipv4GatewayId'] = $request->ipv4GatewayId;
        }
        if (!Utils::isUnset($request->ipv4GatewayName)) {
            $query['Ipv4GatewayName'] = $request->ipv4GatewayName;
        }
        if (!Utils::isUnset($request->maxResults)) {
            $query['MaxResults'] = $request->maxResults;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tags)) {
            $query['Tags'] = $request->tags;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListIpv4Gateways',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListIpv4GatewaysResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries IPv4 gateways.
     *  *
     * @param ListIpv4GatewaysRequest $request ListIpv4GatewaysRequest
     *
     * @return ListIpv4GatewaysResponse ListIpv4GatewaysResponse
     */
    public function listIpv4Gateways($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listIpv4GatewaysWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the CIDR blocks of a specified NAT gateway.
     *  *
     * @param ListNatIpCidrsRequest $request ListNatIpCidrsRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return ListNatIpCidrsResponse ListNatIpCidrsResponse
     */
    public function listNatIpCidrsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->maxResults)) {
            $query['MaxResults'] = $request->maxResults;
        }
        if (!Utils::isUnset($request->natGatewayId)) {
            $query['NatGatewayId'] = $request->natGatewayId;
        }
        if (!Utils::isUnset($request->natIpCidr)) {
            $query['NatIpCidr'] = $request->natIpCidr;
        }
        if (!Utils::isUnset($request->natIpCidrName)) {
            $query['NatIpCidrName'] = $request->natIpCidrName;
        }
        if (!Utils::isUnset($request->natIpCidrStatus)) {
            $query['NatIpCidrStatus'] = $request->natIpCidrStatus;
        }
        if (!Utils::isUnset($request->natIpCidrs)) {
            $query['NatIpCidrs'] = $request->natIpCidrs;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListNatIpCidrs',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListNatIpCidrsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the CIDR blocks of a specified NAT gateway.
     *  *
     * @param ListNatIpCidrsRequest $request ListNatIpCidrsRequest
     *
     * @return ListNatIpCidrsResponse ListNatIpCidrsResponse
     */
    public function listNatIpCidrs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listNatIpCidrsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the IP addresses on a NAT gateway.
     *  *
     * @param ListNatIpsRequest $request ListNatIpsRequest
     * @param RuntimeOptions    $runtime runtime options for this request RuntimeOptions
     *
     * @return ListNatIpsResponse ListNatIpsResponse
     */
    public function listNatIpsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->maxResults)) {
            $query['MaxResults'] = $request->maxResults;
        }
        if (!Utils::isUnset($request->natGatewayId)) {
            $query['NatGatewayId'] = $request->natGatewayId;
        }
        if (!Utils::isUnset($request->natIpCidr)) {
            $query['NatIpCidr'] = $request->natIpCidr;
        }
        if (!Utils::isUnset($request->natIpIds)) {
            $query['NatIpIds'] = $request->natIpIds;
        }
        if (!Utils::isUnset($request->natIpName)) {
            $query['NatIpName'] = $request->natIpName;
        }
        if (!Utils::isUnset($request->natIpStatus)) {
            $query['NatIpStatus'] = $request->natIpStatus;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListNatIps',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListNatIpsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the IP addresses on a NAT gateway.
     *  *
     * @param ListNatIpsRequest $request ListNatIpsRequest
     *
     * @return ListNatIpsResponse ListNatIpsResponse
     */
    public function listNatIps($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listNatIpsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries prefix lists.
     *  *
     * @param ListPrefixListsRequest $request ListPrefixListsRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return ListPrefixListsResponse ListPrefixListsResponse
     */
    public function listPrefixListsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->maxResults)) {
            $query['MaxResults'] = $request->maxResults;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->prefixListIds)) {
            $query['PrefixListIds'] = $request->prefixListIds;
        }
        if (!Utils::isUnset($request->prefixListName)) {
            $query['PrefixListName'] = $request->prefixListName;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tags)) {
            $query['Tags'] = $request->tags;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListPrefixLists',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListPrefixListsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries prefix lists.
     *  *
     * @param ListPrefixListsRequest $request ListPrefixListsRequest
     *
     * @return ListPrefixListsResponse ListPrefixListsResponse
     */
    public function listPrefixLists($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listPrefixListsWithOptions($request, $runtime);
    }

    /**
     * @param ListPublicIpAddressPoolCidrBlocksRequest $request ListPublicIpAddressPoolCidrBlocksRequest
     * @param RuntimeOptions                           $runtime runtime options for this request RuntimeOptions
     *
     * @return ListPublicIpAddressPoolCidrBlocksResponse ListPublicIpAddressPoolCidrBlocksResponse
     */
    public function listPublicIpAddressPoolCidrBlocksWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->cidrBlock)) {
            $query['CidrBlock'] = $request->cidrBlock;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->maxResults)) {
            $query['MaxResults'] = $request->maxResults;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->publicIpAddressPoolId)) {
            $query['PublicIpAddressPoolId'] = $request->publicIpAddressPoolId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListPublicIpAddressPoolCidrBlocks',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListPublicIpAddressPoolCidrBlocksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param ListPublicIpAddressPoolCidrBlocksRequest $request ListPublicIpAddressPoolCidrBlocksRequest
     *
     * @return ListPublicIpAddressPoolCidrBlocksResponse ListPublicIpAddressPoolCidrBlocksResponse
     */
    public function listPublicIpAddressPoolCidrBlocks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listPublicIpAddressPoolCidrBlocksWithOptions($request, $runtime);
    }

    /**
     * @summary Queries available IP address pools.
     *  *
     * @param ListPublicIpAddressPoolsRequest $request ListPublicIpAddressPoolsRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return ListPublicIpAddressPoolsResponse ListPublicIpAddressPoolsResponse
     */
    public function listPublicIpAddressPoolsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->isp)) {
            $query['Isp'] = $request->isp;
        }
        if (!Utils::isUnset($request->maxResults)) {
            $query['MaxResults'] = $request->maxResults;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->publicIpAddressPoolIds)) {
            $query['PublicIpAddressPoolIds'] = $request->publicIpAddressPoolIds;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->securityProtectionEnabled)) {
            $query['SecurityProtectionEnabled'] = $request->securityProtectionEnabled;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->tags)) {
            $query['Tags'] = $request->tags;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListPublicIpAddressPools',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListPublicIpAddressPoolsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries available IP address pools.
     *  *
     * @param ListPublicIpAddressPoolsRequest $request ListPublicIpAddressPoolsRequest
     *
     * @return ListPublicIpAddressPoolsResponse ListPublicIpAddressPoolsResponse
     */
    public function listPublicIpAddressPools($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listPublicIpAddressPoolsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the tags that are added to resources.
     *  *
     * @description ## Usage notes
     * *   You must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request to specify the object that you want to query.
     * *   **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified key are returned. If you specify only **Tag.N.Value**, an error message is returned.
     * *   If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
     * *   If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
     *  *
     * @param ListTagResourcesRequest $request ListTagResourcesRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return ListTagResourcesResponse ListTagResourcesResponse
     */
    public function listTagResourcesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->maxResults)) {
            $query['MaxResults'] = $request->maxResults;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceId)) {
            $query['ResourceId'] = $request->resourceId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->resourceType)) {
            $query['ResourceType'] = $request->resourceType;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListTagResources',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListTagResourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the tags that are added to resources.
     *  *
     * @description ## Usage notes
     * *   You must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request to specify the object that you want to query.
     * *   **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified key are returned. If you specify only **Tag.N.Value**, an error message is returned.
     * *   If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
     * *   If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
     *  *
     * @param ListTagResourcesRequest $request ListTagResourcesRequest
     *
     * @return ListTagResourcesResponse ListTagResourcesResponse
     */
    public function listTagResources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listTagResourcesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the tags that are added to an Express Connect circuit.
     *  *
     * @description ## [](#)
     * *   If you want to query a specific object, you must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request.
     * *   **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified key are returned. If you specify only **Tag.N.Value**, an error message is returned.
     * *   If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
     * *   If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
     *  *
     * @param ListTagResourcesForExpressConnectRequest $request ListTagResourcesForExpressConnectRequest
     * @param RuntimeOptions                           $runtime runtime options for this request RuntimeOptions
     *
     * @return ListTagResourcesForExpressConnectResponse ListTagResourcesForExpressConnectResponse
     */
    public function listTagResourcesForExpressConnectWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->maxResults)) {
            $query['MaxResults'] = $request->maxResults;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceId)) {
            $query['ResourceId'] = $request->resourceId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->resourceType)) {
            $query['ResourceType'] = $request->resourceType;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListTagResourcesForExpressConnect',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListTagResourcesForExpressConnectResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the tags that are added to an Express Connect circuit.
     *  *
     * @description ## [](#)
     * *   If you want to query a specific object, you must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request.
     * *   **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified key are returned. If you specify only **Tag.N.Value**, an error message is returned.
     * *   If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
     * *   If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
     *  *
     * @param ListTagResourcesForExpressConnectRequest $request ListTagResourcesForExpressConnectRequest
     *
     * @return ListTagResourcesForExpressConnectResponse ListTagResourcesForExpressConnectResponse
     */
    public function listTagResourcesForExpressConnect($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listTagResourcesForExpressConnectWithOptions($request, $runtime);
    }

    /**
     * @summary Queries filters for traffic mirroring.
     *  *
     * @param ListTrafficMirrorFiltersRequest $request ListTrafficMirrorFiltersRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return ListTrafficMirrorFiltersResponse ListTrafficMirrorFiltersResponse
     */
    public function listTrafficMirrorFiltersWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->maxResults)) {
            $query['MaxResults'] = $request->maxResults;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tags)) {
            $query['Tags'] = $request->tags;
        }
        if (!Utils::isUnset($request->trafficMirrorFilterIds)) {
            $query['TrafficMirrorFilterIds'] = $request->trafficMirrorFilterIds;
        }
        if (!Utils::isUnset($request->trafficMirrorFilterName)) {
            $query['TrafficMirrorFilterName'] = $request->trafficMirrorFilterName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListTrafficMirrorFilters',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListTrafficMirrorFiltersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries filters for traffic mirroring.
     *  *
     * @param ListTrafficMirrorFiltersRequest $request ListTrafficMirrorFiltersRequest
     *
     * @return ListTrafficMirrorFiltersResponse ListTrafficMirrorFiltersResponse
     */
    public function listTrafficMirrorFilters($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listTrafficMirrorFiltersWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of a traffic mirror session.
     *  *
     * @param ListTrafficMirrorSessionsRequest $request ListTrafficMirrorSessionsRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ListTrafficMirrorSessionsResponse ListTrafficMirrorSessionsResponse
     */
    public function listTrafficMirrorSessionsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->enabled)) {
            $query['Enabled'] = $request->enabled;
        }
        if (!Utils::isUnset($request->maxResults)) {
            $query['MaxResults'] = $request->maxResults;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->priority)) {
            $query['Priority'] = $request->priority;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tags)) {
            $query['Tags'] = $request->tags;
        }
        if (!Utils::isUnset($request->trafficMirrorFilterId)) {
            $query['TrafficMirrorFilterId'] = $request->trafficMirrorFilterId;
        }
        if (!Utils::isUnset($request->trafficMirrorSessionIds)) {
            $query['TrafficMirrorSessionIds'] = $request->trafficMirrorSessionIds;
        }
        if (!Utils::isUnset($request->trafficMirrorSessionName)) {
            $query['TrafficMirrorSessionName'] = $request->trafficMirrorSessionName;
        }
        if (!Utils::isUnset($request->trafficMirrorSourceId)) {
            $query['TrafficMirrorSourceId'] = $request->trafficMirrorSourceId;
        }
        if (!Utils::isUnset($request->trafficMirrorTargetId)) {
            $query['TrafficMirrorTargetId'] = $request->trafficMirrorTargetId;
        }
        if (!Utils::isUnset($request->virtualNetworkId)) {
            $query['VirtualNetworkId'] = $request->virtualNetworkId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListTrafficMirrorSessions',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListTrafficMirrorSessionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of a traffic mirror session.
     *  *
     * @param ListTrafficMirrorSessionsRequest $request ListTrafficMirrorSessionsRequest
     *
     * @return ListTrafficMirrorSessionsResponse ListTrafficMirrorSessionsResponse
     */
    public function listTrafficMirrorSessions($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listTrafficMirrorSessionsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the CIDR reservation information about vSwitches.
     *  *
     * @param ListVSwitchCidrReservationsRequest $request ListVSwitchCidrReservationsRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return ListVSwitchCidrReservationsResponse ListVSwitchCidrReservationsResponse
     */
    public function listVSwitchCidrReservationsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ipVersion)) {
            $query['IpVersion'] = $request->ipVersion;
        }
        if (!Utils::isUnset($request->maxResults)) {
            $query['MaxResults'] = $request->maxResults;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tags)) {
            $query['Tags'] = $request->tags;
        }
        if (!Utils::isUnset($request->vSwitchCidrReservationIds)) {
            $query['VSwitchCidrReservationIds'] = $request->vSwitchCidrReservationIds;
        }
        if (!Utils::isUnset($request->vSwitchCidrReservationType)) {
            $query['VSwitchCidrReservationType'] = $request->vSwitchCidrReservationType;
        }
        if (!Utils::isUnset($request->vSwitchId)) {
            $query['VSwitchId'] = $request->vSwitchId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListVSwitchCidrReservations',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListVSwitchCidrReservationsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the CIDR reservation information about vSwitches.
     *  *
     * @param ListVSwitchCidrReservationsRequest $request ListVSwitchCidrReservationsRequest
     *
     * @return ListVSwitchCidrReservationsResponse ListVSwitchCidrReservationsResponse
     */
    public function listVSwitchCidrReservations($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listVSwitchCidrReservationsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries hosted connections.
     *  *
     * @param ListVirtualPhysicalConnectionsRequest $request ListVirtualPhysicalConnectionsRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return ListVirtualPhysicalConnectionsResponse ListVirtualPhysicalConnectionsResponse
     */
    public function listVirtualPhysicalConnectionsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->isConfirmed)) {
            $query['IsConfirmed'] = $request->isConfirmed;
        }
        if (!Utils::isUnset($request->maxResults)) {
            $query['MaxResults'] = $request->maxResults;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->physicalConnectionId)) {
            $query['PhysicalConnectionId'] = $request->physicalConnectionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->tags)) {
            $query['Tags'] = $request->tags;
        }
        if (!Utils::isUnset($request->virtualPhysicalConnectionAliUids)) {
            $query['VirtualPhysicalConnectionAliUids'] = $request->virtualPhysicalConnectionAliUids;
        }
        if (!Utils::isUnset($request->virtualPhysicalConnectionBusinessStatus)) {
            $query['VirtualPhysicalConnectionBusinessStatus'] = $request->virtualPhysicalConnectionBusinessStatus;
        }
        if (!Utils::isUnset($request->virtualPhysicalConnectionIds)) {
            $query['VirtualPhysicalConnectionIds'] = $request->virtualPhysicalConnectionIds;
        }
        if (!Utils::isUnset($request->virtualPhysicalConnectionStatuses)) {
            $query['VirtualPhysicalConnectionStatuses'] = $request->virtualPhysicalConnectionStatuses;
        }
        if (!Utils::isUnset($request->vlanIds)) {
            $query['VlanIds'] = $request->vlanIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListVirtualPhysicalConnections',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListVirtualPhysicalConnectionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries hosted connections.
     *  *
     * @param ListVirtualPhysicalConnectionsRequest $request ListVirtualPhysicalConnectionsRequest
     *
     * @return ListVirtualPhysicalConnectionsResponse ListVirtualPhysicalConnectionsResponse
     */
    public function listVirtualPhysicalConnections($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listVirtualPhysicalConnectionsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries available endpoint services.
     *  *
     * @param ListVpcEndpointServicesByEndUserRequest $request ListVpcEndpointServicesByEndUserRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return ListVpcEndpointServicesByEndUserResponse ListVpcEndpointServicesByEndUserResponse
     */
    public function listVpcEndpointServicesByEndUserWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->maxResults)) {
            $query['MaxResults'] = $request->maxResults;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->serviceName)) {
            $query['ServiceName'] = $request->serviceName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListVpcEndpointServicesByEndUser',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListVpcEndpointServicesByEndUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries available endpoint services.
     *  *
     * @param ListVpcEndpointServicesByEndUserRequest $request ListVpcEndpointServicesByEndUserRequest
     *
     * @return ListVpcEndpointServicesByEndUserResponse ListVpcEndpointServicesByEndUserResponse
     */
    public function listVpcEndpointServicesByEndUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listVpcEndpointServicesByEndUserWithOptions($request, $runtime);
    }

    /**
     * @summary Queries gateway endpoints.
     *  *
     * @param ListVpcGatewayEndpointsRequest $request ListVpcGatewayEndpointsRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return ListVpcGatewayEndpointsResponse ListVpcGatewayEndpointsResponse
     */
    public function listVpcGatewayEndpointsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->endpointId)) {
            $query['EndpointId'] = $request->endpointId;
        }
        if (!Utils::isUnset($request->endpointName)) {
            $query['EndpointName'] = $request->endpointName;
        }
        if (!Utils::isUnset($request->maxResults)) {
            $query['MaxResults'] = $request->maxResults;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $query['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->serviceName)) {
            $query['ServiceName'] = $request->serviceName;
        }
        if (!Utils::isUnset($request->tags)) {
            $query['Tags'] = $request->tags;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListVpcGatewayEndpoints',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListVpcGatewayEndpointsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries gateway endpoints.
     *  *
     * @param ListVpcGatewayEndpointsRequest $request ListVpcGatewayEndpointsRequest
     *
     * @return ListVpcGatewayEndpointsResponse ListVpcGatewayEndpointsResponse
     */
    public function listVpcGatewayEndpoints($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listVpcGatewayEndpointsWithOptions($request, $runtime);
    }

    /**
     * @summary 查询路由发布情况
     *  *
     * @param ListVpcPublishedRouteEntriesRequest $request ListVpcPublishedRouteEntriesRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return ListVpcPublishedRouteEntriesResponse ListVpcPublishedRouteEntriesResponse
     */
    public function listVpcPublishedRouteEntriesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->destinationCidrBlock)) {
            $query['DestinationCidrBlock'] = $request->destinationCidrBlock;
        }
        if (!Utils::isUnset($request->maxResults)) {
            $query['MaxResults'] = $request->maxResults;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeTableId)) {
            $query['RouteTableId'] = $request->routeTableId;
        }
        if (!Utils::isUnset($request->targetInstanceId)) {
            $query['TargetInstanceId'] = $request->targetInstanceId;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListVpcPublishedRouteEntries',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListVpcPublishedRouteEntriesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询路由发布情况
     *  *
     * @param ListVpcPublishedRouteEntriesRequest $request ListVpcPublishedRouteEntriesRequest
     *
     * @return ListVpcPublishedRouteEntriesResponse ListVpcPublishedRouteEntriesResponse
     */
    public function listVpcPublishedRouteEntries($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listVpcPublishedRouteEntriesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the association between VPN gateways and certificates in a region.
     *  *
     * @description When you call **ListVpnCertificateAssociations**, take note of the following information:
     * *   If you specify only **RegionId**, the SSL certificates associated with all VPN gateways in the specified region are queried.
     * *   If you specify **RegionId** and **CertificateType**, the SSL certificates of the specified type that are associated with the VPN gateways in the specified region are queried.
     * *   If you specify **RegionId** and **VpnGatewayId**, the SSL certificates associated with the specified VPN gateway in the specified region are queried.
     * *   If you specify **RegionId** and **CertificateId**, the VPN gateways associated with the specified SSL certificate in the specified region are queried.
     *  *
     * @param ListVpnCertificateAssociationsRequest $request ListVpnCertificateAssociationsRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return ListVpnCertificateAssociationsResponse ListVpnCertificateAssociationsResponse
     */
    public function listVpnCertificateAssociationsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->certificateId)) {
            $query['CertificateId'] = $request->certificateId;
        }
        if (!Utils::isUnset($request->certificateType)) {
            $query['CertificateType'] = $request->certificateType;
        }
        if (!Utils::isUnset($request->maxResults)) {
            $query['MaxResults'] = $request->maxResults;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->vpnGatewayId)) {
            $query['VpnGatewayId'] = $request->vpnGatewayId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListVpnCertificateAssociations',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListVpnCertificateAssociationsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the association between VPN gateways and certificates in a region.
     *  *
     * @description When you call **ListVpnCertificateAssociations**, take note of the following information:
     * *   If you specify only **RegionId**, the SSL certificates associated with all VPN gateways in the specified region are queried.
     * *   If you specify **RegionId** and **CertificateType**, the SSL certificates of the specified type that are associated with the VPN gateways in the specified region are queried.
     * *   If you specify **RegionId** and **VpnGatewayId**, the SSL certificates associated with the specified VPN gateway in the specified region are queried.
     * *   If you specify **RegionId** and **CertificateId**, the VPN gateways associated with the specified SSL certificate in the specified region are queried.
     *  *
     * @param ListVpnCertificateAssociationsRequest $request ListVpnCertificateAssociationsRequest
     *
     * @return ListVpnCertificateAssociationsResponse ListVpnCertificateAssociationsResponse
     */
    public function listVpnCertificateAssociations($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listVpnCertificateAssociationsWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configuration of a Border Gateway Protocol (BGP) group.
     *  *
     * @param ModifyBgpGroupAttributeRequest $request ModifyBgpGroupAttributeRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyBgpGroupAttributeResponse ModifyBgpGroupAttributeResponse
     */
    public function modifyBgpGroupAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->authKey)) {
            $query['AuthKey'] = $request->authKey;
        }
        if (!Utils::isUnset($request->bgpGroupId)) {
            $query['BgpGroupId'] = $request->bgpGroupId;
        }
        if (!Utils::isUnset($request->clearAuthKey)) {
            $query['ClearAuthKey'] = $request->clearAuthKey;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->isFakeAsn)) {
            $query['IsFakeAsn'] = $request->isFakeAsn;
        }
        if (!Utils::isUnset($request->localAsn)) {
            $query['LocalAsn'] = $request->localAsn;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->peerAsn)) {
            $query['PeerAsn'] = $request->peerAsn;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeQuota)) {
            $query['RouteQuota'] = $request->routeQuota;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyBgpGroupAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyBgpGroupAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configuration of a Border Gateway Protocol (BGP) group.
     *  *
     * @param ModifyBgpGroupAttributeRequest $request ModifyBgpGroupAttributeRequest
     *
     * @return ModifyBgpGroupAttributeResponse ModifyBgpGroupAttributeResponse
     */
    public function modifyBgpGroupAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyBgpGroupAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configuration of a BGP peer.
     *  *
     * @param ModifyBgpPeerAttributeRequest $request ModifyBgpPeerAttributeRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyBgpPeerAttributeResponse ModifyBgpPeerAttributeResponse
     */
    public function modifyBgpPeerAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bfdMultiHop)) {
            $query['BfdMultiHop'] = $request->bfdMultiHop;
        }
        if (!Utils::isUnset($request->bgpGroupId)) {
            $query['BgpGroupId'] = $request->bgpGroupId;
        }
        if (!Utils::isUnset($request->bgpPeerId)) {
            $query['BgpPeerId'] = $request->bgpPeerId;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->enableBfd)) {
            $query['EnableBfd'] = $request->enableBfd;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->peerIpAddress)) {
            $query['PeerIpAddress'] = $request->peerIpAddress;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyBgpPeerAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyBgpPeerAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configuration of a BGP peer.
     *  *
     * @param ModifyBgpPeerAttributeRequest $request ModifyBgpPeerAttributeRequest
     *
     * @return ModifyBgpPeerAttributeResponse ModifyBgpPeerAttributeResponse
     */
    public function modifyBgpPeerAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyBgpPeerAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the name and description of an EIP bandwidth plan.
     *  *
     * @param ModifyCommonBandwidthPackageAttributeRequest $request ModifyCommonBandwidthPackageAttributeRequest
     * @param RuntimeOptions                               $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyCommonBandwidthPackageAttributeResponse ModifyCommonBandwidthPackageAttributeResponse
     */
    public function modifyCommonBandwidthPackageAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bandwidthPackageId)) {
            $query['BandwidthPackageId'] = $request->bandwidthPackageId;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyCommonBandwidthPackageAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyCommonBandwidthPackageAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the name and description of an EIP bandwidth plan.
     *  *
     * @param ModifyCommonBandwidthPackageAttributeRequest $request ModifyCommonBandwidthPackageAttributeRequest
     *
     * @return ModifyCommonBandwidthPackageAttributeResponse ModifyCommonBandwidthPackageAttributeResponse
     */
    public function modifyCommonBandwidthPackageAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyCommonBandwidthPackageAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Sets the maximum bandwidth of an EIP that is associated with an Internet Shared Bandwidth instance.
     *  *
     * @description You can call the **ModifyCommonBandwidthPackageIpBandwidth** operation to set the maximum bandwidth of an EIP that is associated with an Internet Shared Bandwidth instance. This prevents an EIP from exhausting the bandwidth resources of an Internet Shared Bandwidth instance.
     * For example, two EIPs are associated with an Internet Shared Bandwidth instance whose maximum bandwidth is 800 Mbit/s. In this case, you can set the maximum bandwidth of one EIP to 500 Mbit/s and that of the other EIP to 400 Mbit/s. After you set the maximum bandwidth values, the first EIP cannot consume bandwidth higher than 500 Mbit/s. The second EIP cannot consume bandwidth higher than 400 Mbit/s.
     * When you call this operation, take note of the following items:
     * *   This operation is valid only for EIPs that are associated with Elastic Compute Service (ECS) instances. This operation is invalid for EIPs that are associated with Server Load Balancer (SLB) instances, NAT gateways, secondary elastic network interfaces (ENIs), or high-availability virtual IP addresses (HAVIPs).
     * *   This operation is in public preview. You can call this operation to set the maximum bandwidth of EIPs only if the EIPs are associated with an Internet Shared Bandwidth instance. The feature is not supported in the console.
     * *   You cannot repeatedly call this operation to set the maximum bandwidth of an EIP within the specified period of time.
     *  *
     * @param ModifyCommonBandwidthPackageIpBandwidthRequest $request ModifyCommonBandwidthPackageIpBandwidthRequest
     * @param RuntimeOptions                                 $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyCommonBandwidthPackageIpBandwidthResponse ModifyCommonBandwidthPackageIpBandwidthResponse
     */
    public function modifyCommonBandwidthPackageIpBandwidthWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bandwidth)) {
            $query['Bandwidth'] = $request->bandwidth;
        }
        if (!Utils::isUnset($request->bandwidthPackageId)) {
            $query['BandwidthPackageId'] = $request->bandwidthPackageId;
        }
        if (!Utils::isUnset($request->eipId)) {
            $query['EipId'] = $request->eipId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyCommonBandwidthPackageIpBandwidth',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyCommonBandwidthPackageIpBandwidthResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Sets the maximum bandwidth of an EIP that is associated with an Internet Shared Bandwidth instance.
     *  *
     * @description You can call the **ModifyCommonBandwidthPackageIpBandwidth** operation to set the maximum bandwidth of an EIP that is associated with an Internet Shared Bandwidth instance. This prevents an EIP from exhausting the bandwidth resources of an Internet Shared Bandwidth instance.
     * For example, two EIPs are associated with an Internet Shared Bandwidth instance whose maximum bandwidth is 800 Mbit/s. In this case, you can set the maximum bandwidth of one EIP to 500 Mbit/s and that of the other EIP to 400 Mbit/s. After you set the maximum bandwidth values, the first EIP cannot consume bandwidth higher than 500 Mbit/s. The second EIP cannot consume bandwidth higher than 400 Mbit/s.
     * When you call this operation, take note of the following items:
     * *   This operation is valid only for EIPs that are associated with Elastic Compute Service (ECS) instances. This operation is invalid for EIPs that are associated with Server Load Balancer (SLB) instances, NAT gateways, secondary elastic network interfaces (ENIs), or high-availability virtual IP addresses (HAVIPs).
     * *   This operation is in public preview. You can call this operation to set the maximum bandwidth of EIPs only if the EIPs are associated with an Internet Shared Bandwidth instance. The feature is not supported in the console.
     * *   You cannot repeatedly call this operation to set the maximum bandwidth of an EIP within the specified period of time.
     *  *
     * @param ModifyCommonBandwidthPackageIpBandwidthRequest $request ModifyCommonBandwidthPackageIpBandwidthRequest
     *
     * @return ModifyCommonBandwidthPackageIpBandwidthResponse ModifyCommonBandwidthPackageIpBandwidthResponse
     */
    public function modifyCommonBandwidthPackageIpBandwidth($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyCommonBandwidthPackageIpBandwidthWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the maximum bandwidth of an Internet Shared Bandwidth instance.
     *  *
     * @description Before you call this operation, take note of the following items:
     * *   **ModifyCommonBandwidthPackageSpec** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](https://help.aliyun.com/document_detail/120309.html) operation to query the status of the task.
     *     *   If the Internet Shared Bandwidth instance is in the **Modifying** state, the maximum bandwidth of the Internet Shared Bandwidth instance is being modified. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
     *     *   If the Internet Shared Bandwidth instance is in the **Available** state, the maximum bandwidth of the Internet Shared Bandwidth instance is modified.
     * *   You cannot repeatedly call the **ModifyCommonBandwidthPackageSpec** operation to modify the maximum bandwidth of an Internet Shared Bandwidth instance within the specified period of time.
     *  *
     * @param ModifyCommonBandwidthPackageSpecRequest $request ModifyCommonBandwidthPackageSpecRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyCommonBandwidthPackageSpecResponse ModifyCommonBandwidthPackageSpecResponse
     */
    public function modifyCommonBandwidthPackageSpecWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bandwidth)) {
            $query['Bandwidth'] = $request->bandwidth;
        }
        if (!Utils::isUnset($request->bandwidthPackageId)) {
            $query['BandwidthPackageId'] = $request->bandwidthPackageId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyCommonBandwidthPackageSpec',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyCommonBandwidthPackageSpecResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the maximum bandwidth of an Internet Shared Bandwidth instance.
     *  *
     * @description Before you call this operation, take note of the following items:
     * *   **ModifyCommonBandwidthPackageSpec** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](https://help.aliyun.com/document_detail/120309.html) operation to query the status of the task.
     *     *   If the Internet Shared Bandwidth instance is in the **Modifying** state, the maximum bandwidth of the Internet Shared Bandwidth instance is being modified. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
     *     *   If the Internet Shared Bandwidth instance is in the **Available** state, the maximum bandwidth of the Internet Shared Bandwidth instance is modified.
     * *   You cannot repeatedly call the **ModifyCommonBandwidthPackageSpec** operation to modify the maximum bandwidth of an Internet Shared Bandwidth instance within the specified period of time.
     *  *
     * @param ModifyCommonBandwidthPackageSpecRequest $request ModifyCommonBandwidthPackageSpecRequest
     *
     * @return ModifyCommonBandwidthPackageSpecResponse ModifyCommonBandwidthPackageSpecResponse
     */
    public function modifyCommonBandwidthPackageSpec($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyCommonBandwidthPackageSpecWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configuration of a customer gateway.
     *  *
     * @description *   When you call **ModifyCustomerGatewayAttribute**, if a value is assigned to **AuthKey**, the operation is asynchronous. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If a VPN gateway is in the **updating** state, the configurations are being modified.
     *     *   If a VPN gateway is in the **active** state, the configurations are modified.
     * *   When you call **ModifyCustomerGatewayAttribute**, if no value is assigned to **AuthKey**, the operation is synchronous.
     * *   You cannot repeatedly call **ModifyCustomerGatewayAttribute** to modify the configurations of a customer gateway within the specified period of time.
     *  *
     * @param ModifyCustomerGatewayAttributeRequest $request ModifyCustomerGatewayAttributeRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyCustomerGatewayAttributeResponse ModifyCustomerGatewayAttributeResponse
     */
    public function modifyCustomerGatewayAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->authKey)) {
            $query['AuthKey'] = $request->authKey;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->customerGatewayId)) {
            $query['CustomerGatewayId'] = $request->customerGatewayId;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyCustomerGatewayAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyCustomerGatewayAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configuration of a customer gateway.
     *  *
     * @description *   When you call **ModifyCustomerGatewayAttribute**, if a value is assigned to **AuthKey**, the operation is asynchronous. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If a VPN gateway is in the **updating** state, the configurations are being modified.
     *     *   If a VPN gateway is in the **active** state, the configurations are modified.
     * *   When you call **ModifyCustomerGatewayAttribute**, if no value is assigned to **AuthKey**, the operation is synchronous.
     * *   You cannot repeatedly call **ModifyCustomerGatewayAttribute** to modify the configurations of a customer gateway within the specified period of time.
     *  *
     * @param ModifyCustomerGatewayAttributeRequest $request ModifyCustomerGatewayAttributeRequest
     *
     * @return ModifyCustomerGatewayAttributeResponse ModifyCustomerGatewayAttributeResponse
     */
    public function modifyCustomerGatewayAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyCustomerGatewayAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the name, description, and maximum bandwidth of an elastic IP address (EIP).
     *  *
     * @param ModifyEipAddressAttributeRequest $request ModifyEipAddressAttributeRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyEipAddressAttributeResponse ModifyEipAddressAttributeResponse
     */
    public function modifyEipAddressAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->allocationId)) {
            $query['AllocationId'] = $request->allocationId;
        }
        if (!Utils::isUnset($request->bandwidth)) {
            $query['Bandwidth'] = $request->bandwidth;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyEipAddressAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyEipAddressAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the name, description, and maximum bandwidth of an elastic IP address (EIP).
     *  *
     * @param ModifyEipAddressAttributeRequest $request ModifyEipAddressAttributeRequest
     *
     * @return ModifyEipAddressAttributeResponse ModifyEipAddressAttributeResponse
     */
    public function modifyEipAddressAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyEipAddressAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configuration of an Express Cloud Connect (ECC) instance.
     *  *
     * @param ModifyExpressCloudConnectionAttributeRequest $request ModifyExpressCloudConnectionAttributeRequest
     * @param RuntimeOptions                               $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyExpressCloudConnectionAttributeResponse ModifyExpressCloudConnectionAttributeResponse
     */
    public function modifyExpressCloudConnectionAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bgpAs)) {
            $query['BgpAs'] = $request->bgpAs;
        }
        if (!Utils::isUnset($request->ceIp)) {
            $query['CeIp'] = $request->ceIp;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->eccId)) {
            $query['EccId'] = $request->eccId;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->peIp)) {
            $query['PeIp'] = $request->peIp;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyExpressCloudConnectionAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyExpressCloudConnectionAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configuration of an Express Cloud Connect (ECC) instance.
     *  *
     * @param ModifyExpressCloudConnectionAttributeRequest $request ModifyExpressCloudConnectionAttributeRequest
     *
     * @return ModifyExpressCloudConnectionAttributeResponse ModifyExpressCloudConnectionAttributeResponse
     */
    public function modifyExpressCloudConnectionAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyExpressCloudConnectionAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the bandwidth of an Express Cloud Connect (ECC) instance.
     *  *
     * @param ModifyExpressCloudConnectionBandwidthRequest $request ModifyExpressCloudConnectionBandwidthRequest
     * @param RuntimeOptions                               $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyExpressCloudConnectionBandwidthResponse ModifyExpressCloudConnectionBandwidthResponse
     */
    public function modifyExpressCloudConnectionBandwidthWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bandwidth)) {
            $query['Bandwidth'] = $request->bandwidth;
        }
        if (!Utils::isUnset($request->eccId)) {
            $query['EccId'] = $request->eccId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyExpressCloudConnectionBandwidth',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyExpressCloudConnectionBandwidthResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the bandwidth of an Express Cloud Connect (ECC) instance.
     *  *
     * @param ModifyExpressCloudConnectionBandwidthRequest $request ModifyExpressCloudConnectionBandwidthRequest
     *
     * @return ModifyExpressCloudConnectionBandwidthResponse ModifyExpressCloudConnectionBandwidthResponse
     */
    public function modifyExpressCloudConnectionBandwidth($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyExpressCloudConnectionBandwidthWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies a quality of service (QoS) policy or associates a QoS policy with a dedicated Express Connect circuit.
     *  *
     * @param ModifyExpressConnectTrafficQosRequest $request ModifyExpressConnectTrafficQosRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyExpressConnectTrafficQosResponse ModifyExpressConnectTrafficQosResponse
     */
    public function modifyExpressConnectTrafficQosWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->addInstanceList)) {
            $query['AddInstanceList'] = $request->addInstanceList;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->qosDescription)) {
            $query['QosDescription'] = $request->qosDescription;
        }
        if (!Utils::isUnset($request->qosId)) {
            $query['QosId'] = $request->qosId;
        }
        if (!Utils::isUnset($request->qosName)) {
            $query['QosName'] = $request->qosName;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->removeInstanceList)) {
            $query['RemoveInstanceList'] = $request->removeInstanceList;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyExpressConnectTrafficQos',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyExpressConnectTrafficQosResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies a quality of service (QoS) policy or associates a QoS policy with a dedicated Express Connect circuit.
     *  *
     * @param ModifyExpressConnectTrafficQosRequest $request ModifyExpressConnectTrafficQosRequest
     *
     * @return ModifyExpressConnectTrafficQosResponse ModifyExpressConnectTrafficQosResponse
     */
    public function modifyExpressConnectTrafficQos($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyExpressConnectTrafficQosWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies a quality of service (QoS) queue.
     *  *
     * @param ModifyExpressConnectTrafficQosQueueRequest $request ModifyExpressConnectTrafficQosQueueRequest
     * @param RuntimeOptions                             $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyExpressConnectTrafficQosQueueResponse ModifyExpressConnectTrafficQosQueueResponse
     */
    public function modifyExpressConnectTrafficQosQueueWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bandwidthPercent)) {
            $query['BandwidthPercent'] = $request->bandwidthPercent;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->qosId)) {
            $query['QosId'] = $request->qosId;
        }
        if (!Utils::isUnset($request->queueDescription)) {
            $query['QueueDescription'] = $request->queueDescription;
        }
        if (!Utils::isUnset($request->queueId)) {
            $query['QueueId'] = $request->queueId;
        }
        if (!Utils::isUnset($request->queueName)) {
            $query['QueueName'] = $request->queueName;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyExpressConnectTrafficQosQueue',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyExpressConnectTrafficQosQueueResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies a quality of service (QoS) queue.
     *  *
     * @param ModifyExpressConnectTrafficQosQueueRequest $request ModifyExpressConnectTrafficQosQueueRequest
     *
     * @return ModifyExpressConnectTrafficQosQueueResponse ModifyExpressConnectTrafficQosQueueResponse
     */
    public function modifyExpressConnectTrafficQosQueue($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyExpressConnectTrafficQosQueueWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies a quality of service (QoS) rule.
     *  *
     * @param ModifyExpressConnectTrafficQosRuleRequest $request ModifyExpressConnectTrafficQosRuleRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyExpressConnectTrafficQosRuleResponse ModifyExpressConnectTrafficQosRuleResponse
     */
    public function modifyExpressConnectTrafficQosRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dstCidr)) {
            $query['DstCidr'] = $request->dstCidr;
        }
        if (!Utils::isUnset($request->dstIPv6Cidr)) {
            $query['DstIPv6Cidr'] = $request->dstIPv6Cidr;
        }
        if (!Utils::isUnset($request->dstPortRange)) {
            $query['DstPortRange'] = $request->dstPortRange;
        }
        if (!Utils::isUnset($request->matchDscp)) {
            $query['MatchDscp'] = $request->matchDscp;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->priority)) {
            $query['Priority'] = $request->priority;
        }
        if (!Utils::isUnset($request->protocol)) {
            $query['Protocol'] = $request->protocol;
        }
        if (!Utils::isUnset($request->qosId)) {
            $query['QosId'] = $request->qosId;
        }
        if (!Utils::isUnset($request->queueId)) {
            $query['QueueId'] = $request->queueId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->remarkingDscp)) {
            $query['RemarkingDscp'] = $request->remarkingDscp;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->ruleDescription)) {
            $query['RuleDescription'] = $request->ruleDescription;
        }
        if (!Utils::isUnset($request->ruleId)) {
            $query['RuleId'] = $request->ruleId;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $query['RuleName'] = $request->ruleName;
        }
        if (!Utils::isUnset($request->srcCidr)) {
            $query['SrcCidr'] = $request->srcCidr;
        }
        if (!Utils::isUnset($request->srcIPv6Cidr)) {
            $query['SrcIPv6Cidr'] = $request->srcIPv6Cidr;
        }
        if (!Utils::isUnset($request->srcPortRange)) {
            $query['SrcPortRange'] = $request->srcPortRange;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyExpressConnectTrafficQosRule',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyExpressConnectTrafficQosRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies a quality of service (QoS) rule.
     *  *
     * @param ModifyExpressConnectTrafficQosRuleRequest $request ModifyExpressConnectTrafficQosRuleRequest
     *
     * @return ModifyExpressConnectTrafficQosRuleResponse ModifyExpressConnectTrafficQosRuleResponse
     */
    public function modifyExpressConnectTrafficQosRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyExpressConnectTrafficQosRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the name and description of a flow log.
     *  *
     * @description *   **ModifyFlowLogAttribute** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
     *     *   If the flow log is in the **Modifying** state, the flow log is being modified.
     *     *   If the flow log is in the **Active** or **Inactive** state, the flow log is modified.
     * *   You cannot repeatedly call the **ModifyFlowLogAttribute** operation to modify a flow log within the specified period of time.
     *  *
     * @param ModifyFlowLogAttributeRequest $request ModifyFlowLogAttributeRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyFlowLogAttributeResponse ModifyFlowLogAttributeResponse
     */
    public function modifyFlowLogAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aggregationInterval)) {
            $query['AggregationInterval'] = $request->aggregationInterval;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->flowLogId)) {
            $query['FlowLogId'] = $request->flowLogId;
        }
        if (!Utils::isUnset($request->flowLogName)) {
            $query['FlowLogName'] = $request->flowLogName;
        }
        if (!Utils::isUnset($request->ipVersion)) {
            $query['IpVersion'] = $request->ipVersion;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyFlowLogAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyFlowLogAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the name and description of a flow log.
     *  *
     * @description *   **ModifyFlowLogAttribute** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
     *     *   If the flow log is in the **Modifying** state, the flow log is being modified.
     *     *   If the flow log is in the **Active** or **Inactive** state, the flow log is modified.
     * *   You cannot repeatedly call the **ModifyFlowLogAttribute** operation to modify a flow log within the specified period of time.
     *  *
     * @param ModifyFlowLogAttributeRequest $request ModifyFlowLogAttributeRequest
     *
     * @return ModifyFlowLogAttributeResponse ModifyFlowLogAttributeResponse
     */
    public function modifyFlowLogAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyFlowLogAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies a DNAT entry.
     *  *
     * @description *   **ModifyForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
     *     *   **Pending**: indicates that the system is modifying the DNAT entry. You can only query the DNAT entry, but cannot perform other operations.
     *     *   **Available**: indicates that the DNAT entry is modified.
     * *   You cannot repeatedly call the **ModifyForwardEntry** operation to modify a DNAT entry within the specified period of time.
     *  *
     * @param ModifyForwardEntryRequest $request ModifyForwardEntryRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyForwardEntryResponse ModifyForwardEntryResponse
     */
    public function modifyForwardEntryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->externalIp)) {
            $query['ExternalIp'] = $request->externalIp;
        }
        if (!Utils::isUnset($request->externalPort)) {
            $query['ExternalPort'] = $request->externalPort;
        }
        if (!Utils::isUnset($request->forwardEntryId)) {
            $query['ForwardEntryId'] = $request->forwardEntryId;
        }
        if (!Utils::isUnset($request->forwardEntryName)) {
            $query['ForwardEntryName'] = $request->forwardEntryName;
        }
        if (!Utils::isUnset($request->forwardTableId)) {
            $query['ForwardTableId'] = $request->forwardTableId;
        }
        if (!Utils::isUnset($request->internalIp)) {
            $query['InternalIp'] = $request->internalIp;
        }
        if (!Utils::isUnset($request->internalPort)) {
            $query['InternalPort'] = $request->internalPort;
        }
        if (!Utils::isUnset($request->ipProtocol)) {
            $query['IpProtocol'] = $request->ipProtocol;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->portBreak)) {
            $query['PortBreak'] = $request->portBreak;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyForwardEntry',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyForwardEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies a DNAT entry.
     *  *
     * @description *   **ModifyForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
     *     *   **Pending**: indicates that the system is modifying the DNAT entry. You can only query the DNAT entry, but cannot perform other operations.
     *     *   **Available**: indicates that the DNAT entry is modified.
     * *   You cannot repeatedly call the **ModifyForwardEntry** operation to modify a DNAT entry within the specified period of time.
     *  *
     * @param ModifyForwardEntryRequest $request ModifyForwardEntryRequest
     *
     * @return ModifyForwardEntryResponse ModifyForwardEntryResponse
     */
    public function modifyForwardEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyForwardEntryWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies a FULLNAT entry.
     *  *
     * @description ## [](#)
     * *   **ModifyFullNatEntryAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
     *     *   **Modifying**: indicates that the system is modifying the FULLNAT entry. You can query the FULLNAT entry, but cannot perform other operations.
     *     *   **Available**: indicates that the FULLNAT entry is modified.
     * *   You cannot repeatedly call the **ModifyFullNatEntryAttribute** operation to modify a FULLNAT entry within the specified period of time.
     *  *
     * @param ModifyFullNatEntryAttributeRequest $request ModifyFullNatEntryAttributeRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyFullNatEntryAttributeResponse ModifyFullNatEntryAttributeResponse
     */
    public function modifyFullNatEntryAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->accessIp)) {
            $query['AccessIp'] = $request->accessIp;
        }
        if (!Utils::isUnset($request->accessPort)) {
            $query['AccessPort'] = $request->accessPort;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->fullNatEntryDescription)) {
            $query['FullNatEntryDescription'] = $request->fullNatEntryDescription;
        }
        if (!Utils::isUnset($request->fullNatEntryId)) {
            $query['FullNatEntryId'] = $request->fullNatEntryId;
        }
        if (!Utils::isUnset($request->fullNatEntryName)) {
            $query['FullNatEntryName'] = $request->fullNatEntryName;
        }
        if (!Utils::isUnset($request->fullNatTableId)) {
            $query['FullNatTableId'] = $request->fullNatTableId;
        }
        if (!Utils::isUnset($request->ipProtocol)) {
            $query['IpProtocol'] = $request->ipProtocol;
        }
        if (!Utils::isUnset($request->natIp)) {
            $query['NatIp'] = $request->natIp;
        }
        if (!Utils::isUnset($request->natIpPort)) {
            $query['NatIpPort'] = $request->natIpPort;
        }
        if (!Utils::isUnset($request->networkInterfaceId)) {
            $query['NetworkInterfaceId'] = $request->networkInterfaceId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyFullNatEntryAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyFullNatEntryAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies a FULLNAT entry.
     *  *
     * @description ## [](#)
     * *   **ModifyFullNatEntryAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
     *     *   **Modifying**: indicates that the system is modifying the FULLNAT entry. You can query the FULLNAT entry, but cannot perform other operations.
     *     *   **Available**: indicates that the FULLNAT entry is modified.
     * *   You cannot repeatedly call the **ModifyFullNatEntryAttribute** operation to modify a FULLNAT entry within the specified period of time.
     *  *
     * @param ModifyFullNatEntryAttributeRequest $request ModifyFullNatEntryAttributeRequest
     *
     * @return ModifyFullNatEntryAttributeResponse ModifyFullNatEntryAttributeResponse
     */
    public function modifyFullNatEntryAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyFullNatEntryAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the name and description of a Global Accelerator (GA) instance.
     *  *
     * @param ModifyGlobalAccelerationInstanceAttributesRequest $request ModifyGlobalAccelerationInstanceAttributesRequest
     * @param RuntimeOptions                                    $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyGlobalAccelerationInstanceAttributesResponse ModifyGlobalAccelerationInstanceAttributesResponse
     */
    public function modifyGlobalAccelerationInstanceAttributesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->globalAccelerationInstanceId)) {
            $query['GlobalAccelerationInstanceId'] = $request->globalAccelerationInstanceId;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyGlobalAccelerationInstanceAttributes',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyGlobalAccelerationInstanceAttributesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the name and description of a Global Accelerator (GA) instance.
     *  *
     * @param ModifyGlobalAccelerationInstanceAttributesRequest $request ModifyGlobalAccelerationInstanceAttributesRequest
     *
     * @return ModifyGlobalAccelerationInstanceAttributesResponse ModifyGlobalAccelerationInstanceAttributesResponse
     */
    public function modifyGlobalAccelerationInstanceAttributes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyGlobalAccelerationInstanceAttributesWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the maximum bandwidth of a Global Accelerator (GA) instance.
     *  *
     * @description ## Usage notes
     * You cannot call this operation to modify the maximum bandwidth of a subscription GA instance.
     *  *
     * @param ModifyGlobalAccelerationInstanceSpecRequest $request ModifyGlobalAccelerationInstanceSpecRequest
     * @param RuntimeOptions                              $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyGlobalAccelerationInstanceSpecResponse ModifyGlobalAccelerationInstanceSpecResponse
     */
    public function modifyGlobalAccelerationInstanceSpecWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bandwidth)) {
            $query['Bandwidth'] = $request->bandwidth;
        }
        if (!Utils::isUnset($request->globalAccelerationInstanceId)) {
            $query['GlobalAccelerationInstanceId'] = $request->globalAccelerationInstanceId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyGlobalAccelerationInstanceSpec',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyGlobalAccelerationInstanceSpecResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the maximum bandwidth of a Global Accelerator (GA) instance.
     *  *
     * @description ## Usage notes
     * You cannot call this operation to modify the maximum bandwidth of a subscription GA instance.
     *  *
     * @param ModifyGlobalAccelerationInstanceSpecRequest $request ModifyGlobalAccelerationInstanceSpecRequest
     *
     * @return ModifyGlobalAccelerationInstanceSpecResponse ModifyGlobalAccelerationInstanceSpecResponse
     */
    public function modifyGlobalAccelerationInstanceSpec($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyGlobalAccelerationInstanceSpecWithOptions($request, $runtime);
    }

    /**
     * @description You cannot repeatedly call the **ModifyHaVipAttribute** operation to modify the name and description of an HAVIP within the specified period of time.
     *  *
     * @param ModifyHaVipAttributeRequest $request ModifyHaVipAttributeRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyHaVipAttributeResponse ModifyHaVipAttributeResponse
     */
    public function modifyHaVipAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->haVipId)) {
            $query['HaVipId'] = $request->haVipId;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyHaVipAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyHaVipAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @description You cannot repeatedly call the **ModifyHaVipAttribute** operation to modify the name and description of an HAVIP within the specified period of time.
     *  *
     * @param ModifyHaVipAttributeRequest $request ModifyHaVipAttributeRequest
     *
     * @return ModifyHaVipAttributeResponse ModifyHaVipAttributeResponse
     */
    public function modifyHaVipAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyHaVipAttributeWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI ModifyIPv6TranslatorAclAttribute is deprecated
     *  *
     * @summary Modifies the name of an access control list (ACL).
     *  *
     * Deprecated
     *
     * @param ModifyIPv6TranslatorAclAttributeRequest $request ModifyIPv6TranslatorAclAttributeRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyIPv6TranslatorAclAttributeResponse ModifyIPv6TranslatorAclAttributeResponse
     */
    public function modifyIPv6TranslatorAclAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aclId)) {
            $query['AclId'] = $request->aclId;
        }
        if (!Utils::isUnset($request->aclName)) {
            $query['AclName'] = $request->aclName;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyIPv6TranslatorAclAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyIPv6TranslatorAclAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI ModifyIPv6TranslatorAclAttribute is deprecated
     *  *
     * @summary Modifies the name of an access control list (ACL).
     *  *
     * Deprecated
     *
     * @param ModifyIPv6TranslatorAclAttributeRequest $request ModifyIPv6TranslatorAclAttributeRequest
     *
     * @return ModifyIPv6TranslatorAclAttributeResponse ModifyIPv6TranslatorAclAttributeResponse
     */
    public function modifyIPv6TranslatorAclAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyIPv6TranslatorAclAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies an IP entry in an access control list (ACL).
     *  *
     * @param ModifyIPv6TranslatorAclListEntryRequest $request ModifyIPv6TranslatorAclListEntryRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyIPv6TranslatorAclListEntryResponse ModifyIPv6TranslatorAclListEntryResponse
     */
    public function modifyIPv6TranslatorAclListEntryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aclEntryComment)) {
            $query['AclEntryComment'] = $request->aclEntryComment;
        }
        if (!Utils::isUnset($request->aclEntryId)) {
            $query['AclEntryId'] = $request->aclEntryId;
        }
        if (!Utils::isUnset($request->aclId)) {
            $query['AclId'] = $request->aclId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyIPv6TranslatorAclListEntry',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyIPv6TranslatorAclListEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies an IP entry in an access control list (ACL).
     *  *
     * @param ModifyIPv6TranslatorAclListEntryRequest $request ModifyIPv6TranslatorAclListEntryRequest
     *
     * @return ModifyIPv6TranslatorAclListEntryResponse ModifyIPv6TranslatorAclListEntryResponse
     */
    public function modifyIPv6TranslatorAclListEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyIPv6TranslatorAclListEntryWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the name and description of an IPv6 Translation Service instance.
     *  *
     * @param ModifyIPv6TranslatorAttributeRequest $request ModifyIPv6TranslatorAttributeRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyIPv6TranslatorAttributeResponse ModifyIPv6TranslatorAttributeResponse
     */
    public function modifyIPv6TranslatorAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->ipv6TranslatorId)) {
            $query['Ipv6TranslatorId'] = $request->ipv6TranslatorId;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyIPv6TranslatorAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyIPv6TranslatorAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the name and description of an IPv6 Translation Service instance.
     *  *
     * @param ModifyIPv6TranslatorAttributeRequest $request ModifyIPv6TranslatorAttributeRequest
     *
     * @return ModifyIPv6TranslatorAttributeResponse ModifyIPv6TranslatorAttributeResponse
     */
    public function modifyIPv6TranslatorAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyIPv6TranslatorAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the maximum bandwidth of an IPv6 Translation Service instance.
     *  *
     * @param ModifyIPv6TranslatorBandwidthRequest $request ModifyIPv6TranslatorBandwidthRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyIPv6TranslatorBandwidthResponse ModifyIPv6TranslatorBandwidthResponse
     */
    public function modifyIPv6TranslatorBandwidthWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->autoPay)) {
            $query['AutoPay'] = $request->autoPay;
        }
        if (!Utils::isUnset($request->bandwidth)) {
            $query['Bandwidth'] = $request->bandwidth;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ipv6TranslatorId)) {
            $query['Ipv6TranslatorId'] = $request->ipv6TranslatorId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyIPv6TranslatorBandwidth',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyIPv6TranslatorBandwidthResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the maximum bandwidth of an IPv6 Translation Service instance.
     *  *
     * @param ModifyIPv6TranslatorBandwidthRequest $request ModifyIPv6TranslatorBandwidthRequest
     *
     * @return ModifyIPv6TranslatorBandwidthResponse ModifyIPv6TranslatorBandwidthResponse
     */
    public function modifyIPv6TranslatorBandwidth($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyIPv6TranslatorBandwidthWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI ModifyIPv6TranslatorEntry is deprecated
     *  *
     * @summary Modifies an IPv6 mapping entry.
     *  *
     * Deprecated
     *
     * @param ModifyIPv6TranslatorEntryRequest $request ModifyIPv6TranslatorEntryRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyIPv6TranslatorEntryResponse ModifyIPv6TranslatorEntryResponse
     */
    public function modifyIPv6TranslatorEntryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aclId)) {
            $query['AclId'] = $request->aclId;
        }
        if (!Utils::isUnset($request->aclStatus)) {
            $query['AclStatus'] = $request->aclStatus;
        }
        if (!Utils::isUnset($request->aclType)) {
            $query['AclType'] = $request->aclType;
        }
        if (!Utils::isUnset($request->allocateIpv6Port)) {
            $query['AllocateIpv6Port'] = $request->allocateIpv6Port;
        }
        if (!Utils::isUnset($request->backendIpv4Addr)) {
            $query['BackendIpv4Addr'] = $request->backendIpv4Addr;
        }
        if (!Utils::isUnset($request->backendIpv4Port)) {
            $query['BackendIpv4Port'] = $request->backendIpv4Port;
        }
        if (!Utils::isUnset($request->entryBandwidth)) {
            $query['EntryBandwidth'] = $request->entryBandwidth;
        }
        if (!Utils::isUnset($request->entryDescription)) {
            $query['EntryDescription'] = $request->entryDescription;
        }
        if (!Utils::isUnset($request->entryName)) {
            $query['EntryName'] = $request->entryName;
        }
        if (!Utils::isUnset($request->ipv6TranslatorEntryId)) {
            $query['Ipv6TranslatorEntryId'] = $request->ipv6TranslatorEntryId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->transProtocol)) {
            $query['TransProtocol'] = $request->transProtocol;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyIPv6TranslatorEntry',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyIPv6TranslatorEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI ModifyIPv6TranslatorEntry is deprecated
     *  *
     * @summary Modifies an IPv6 mapping entry.
     *  *
     * Deprecated
     *
     * @param ModifyIPv6TranslatorEntryRequest $request ModifyIPv6TranslatorEntryRequest
     *
     * @return ModifyIPv6TranslatorEntryResponse ModifyIPv6TranslatorEntryResponse
     */
    public function modifyIPv6TranslatorEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyIPv6TranslatorEntryWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the name and description of an IPv6 address.
     *  *
     * @param ModifyIpv6AddressAttributeRequest $request ModifyIpv6AddressAttributeRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyIpv6AddressAttributeResponse ModifyIpv6AddressAttributeResponse
     */
    public function modifyIpv6AddressAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ipv6AddressId)) {
            $query['Ipv6AddressId'] = $request->ipv6AddressId;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyIpv6AddressAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyIpv6AddressAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the name and description of an IPv6 address.
     *  *
     * @param ModifyIpv6AddressAttributeRequest $request ModifyIpv6AddressAttributeRequest
     *
     * @return ModifyIpv6AddressAttributeResponse ModifyIpv6AddressAttributeResponse
     */
    public function modifyIpv6AddressAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyIpv6AddressAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the name and description of an IPv6 gateway.
     *  *
     * @param ModifyIpv6GatewayAttributeRequest $request ModifyIpv6GatewayAttributeRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyIpv6GatewayAttributeResponse ModifyIpv6GatewayAttributeResponse
     */
    public function modifyIpv6GatewayAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ipv6GatewayId)) {
            $query['Ipv6GatewayId'] = $request->ipv6GatewayId;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyIpv6GatewayAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyIpv6GatewayAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the name and description of an IPv6 gateway.
     *  *
     * @param ModifyIpv6GatewayAttributeRequest $request ModifyIpv6GatewayAttributeRequest
     *
     * @return ModifyIpv6GatewayAttributeResponse ModifyIpv6GatewayAttributeResponse
     */
    public function modifyIpv6GatewayAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyIpv6GatewayAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the Internet bandwidth value of an IPv6 address.
     *  *
     * @description You cannot repeatedly call the **ModifyIpv6InternetBandwidth** operation to modify the Internet bandwidth value of an IPv6 CIDR block within the specified period of time.
     *  *
     * @param ModifyIpv6InternetBandwidthRequest $request ModifyIpv6InternetBandwidthRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyIpv6InternetBandwidthResponse ModifyIpv6InternetBandwidthResponse
     */
    public function modifyIpv6InternetBandwidthWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bandwidth)) {
            $query['Bandwidth'] = $request->bandwidth;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ipv6AddressId)) {
            $query['Ipv6AddressId'] = $request->ipv6AddressId;
        }
        if (!Utils::isUnset($request->ipv6InternetBandwidthId)) {
            $query['Ipv6InternetBandwidthId'] = $request->ipv6InternetBandwidthId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyIpv6InternetBandwidth',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyIpv6InternetBandwidthResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the Internet bandwidth value of an IPv6 address.
     *  *
     * @description You cannot repeatedly call the **ModifyIpv6InternetBandwidth** operation to modify the Internet bandwidth value of an IPv6 CIDR block within the specified period of time.
     *  *
     * @param ModifyIpv6InternetBandwidthRequest $request ModifyIpv6InternetBandwidthRequest
     *
     * @return ModifyIpv6InternetBandwidthResponse ModifyIpv6InternetBandwidthResponse
     */
    public function modifyIpv6InternetBandwidth($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyIpv6InternetBandwidthWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the name and description of a NAT gateway.
     *  *
     * @description ## [](#)Description
     * You can call this operation to query an Internet NAT gateway or a virtual private cloud (VPC) NAT gateway. The term NAT gateway in this topic refers to both NAT gateway types.
     *  *
     * @param ModifyNatGatewayAttributeRequest $tmpReq  ModifyNatGatewayAttributeRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyNatGatewayAttributeResponse ModifyNatGatewayAttributeResponse
     */
    public function modifyNatGatewayAttributeWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new ModifyNatGatewayAttributeShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->logDelivery)) {
            $request->logDeliveryShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->logDelivery, 'LogDelivery', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->eipBindMode)) {
            $query['EipBindMode'] = $request->eipBindMode;
        }
        if (!Utils::isUnset($request->enableSessionLog)) {
            $query['EnableSessionLog'] = $request->enableSessionLog;
        }
        if (!Utils::isUnset($request->icmpReplyEnabled)) {
            $query['IcmpReplyEnabled'] = $request->icmpReplyEnabled;
        }
        if (!Utils::isUnset($request->logDeliveryShrink)) {
            $query['LogDelivery'] = $request->logDeliveryShrink;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->natGatewayId)) {
            $query['NatGatewayId'] = $request->natGatewayId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyNatGatewayAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyNatGatewayAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the name and description of a NAT gateway.
     *  *
     * @description ## [](#)Description
     * You can call this operation to query an Internet NAT gateway or a virtual private cloud (VPC) NAT gateway. The term NAT gateway in this topic refers to both NAT gateway types.
     *  *
     * @param ModifyNatGatewayAttributeRequest $request ModifyNatGatewayAttributeRequest
     *
     * @return ModifyNatGatewayAttributeResponse ModifyNatGatewayAttributeResponse
     */
    public function modifyNatGatewayAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyNatGatewayAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Upgrades a subscription Internet NAT gateway.
     *  *
     * @description - You cannot call this operation to downgrade a subscription Internet NAT gateway. You can downgrade a subscription Internet NAT gateway only in the console.
     * - When you call this operation to upgrade a subscription Internet NAT gateway, an order is generated. After you complete the payment in the order center, the Internet NAT gateway is upgraded.
     * - **ModifyNatGatewaySpec** is an asynchronous operation. After you make a request, the ID of the request is returned but the Internet NAT gateway is not upgraded. The system upgrades the NAT gateway in the background. You can call the [DescribeNatGateways](/help/en/virtual-private-cloud/latest/describenatgateways) operation to query the status of an Internet NAT gateway.    - If an Internet NAT gateway is in the **Modifying** state, the NAT gateway is being upgraded. In this case, you can only query the NAT gateway but cannot perform other operations.
     *   - If an Internet NAT gateway is in the **Available** state, the Internet NAT gateway is upgraded.
     * - You cannot repeatedly call the **ModifyNatGatewaySpec** operation to resize a pay-by-specification NAT gateway.
     * Internet NAT gateways are available in different sizes. The size of an Internet NAT gateway determines the SNAT performance, which includes the maximum number of connections and the number of new connections per second. However, the size of a NAT gateway does not affect the data throughput. The following table describes the correlations between different sizes of Internet NAT gateways and SNAT performance metrics.
     * | Size | Maximum number of connections | Number of new connections per second |
     * | ---- | ----------------------------- | ------------------------------------ |
     * | Small | 10,000 | 1,000 |
     * | Medium | 50,000 | 5,000 |
     * | Large | 200,000 | 10,000 |
     *  *
     * @param ModifyNatGatewaySpecRequest $request ModifyNatGatewaySpecRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyNatGatewaySpecResponse ModifyNatGatewaySpecResponse
     */
    public function modifyNatGatewaySpecWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->autoPay)) {
            $query['AutoPay'] = $request->autoPay;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->natGatewayId)) {
            $query['NatGatewayId'] = $request->natGatewayId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->spec)) {
            $query['Spec'] = $request->spec;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyNatGatewaySpec',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyNatGatewaySpecResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Upgrades a subscription Internet NAT gateway.
     *  *
     * @description - You cannot call this operation to downgrade a subscription Internet NAT gateway. You can downgrade a subscription Internet NAT gateway only in the console.
     * - When you call this operation to upgrade a subscription Internet NAT gateway, an order is generated. After you complete the payment in the order center, the Internet NAT gateway is upgraded.
     * - **ModifyNatGatewaySpec** is an asynchronous operation. After you make a request, the ID of the request is returned but the Internet NAT gateway is not upgraded. The system upgrades the NAT gateway in the background. You can call the [DescribeNatGateways](/help/en/virtual-private-cloud/latest/describenatgateways) operation to query the status of an Internet NAT gateway.    - If an Internet NAT gateway is in the **Modifying** state, the NAT gateway is being upgraded. In this case, you can only query the NAT gateway but cannot perform other operations.
     *   - If an Internet NAT gateway is in the **Available** state, the Internet NAT gateway is upgraded.
     * - You cannot repeatedly call the **ModifyNatGatewaySpec** operation to resize a pay-by-specification NAT gateway.
     * Internet NAT gateways are available in different sizes. The size of an Internet NAT gateway determines the SNAT performance, which includes the maximum number of connections and the number of new connections per second. However, the size of a NAT gateway does not affect the data throughput. The following table describes the correlations between different sizes of Internet NAT gateways and SNAT performance metrics.
     * | Size | Maximum number of connections | Number of new connections per second |
     * | ---- | ----------------------------- | ------------------------------------ |
     * | Small | 10,000 | 1,000 |
     * | Medium | 50,000 | 5,000 |
     * | Large | 200,000 | 10,000 |
     *  *
     * @param ModifyNatGatewaySpecRequest $request ModifyNatGatewaySpecRequest
     *
     * @return ModifyNatGatewaySpecResponse ModifyNatGatewaySpecResponse
     */
    public function modifyNatGatewaySpec($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyNatGatewaySpecWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the name and description of a NAT IP address.
     *  *
     * @description ## [](#)Description
     * You cannot repeatedly call the **ModifyNatIpAttribute** operation to modify the name and description of a NAT IP address within the specified period of time.
     *  *
     * @param ModifyNatIpAttributeRequest $request ModifyNatIpAttributeRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyNatIpAttributeResponse ModifyNatIpAttributeResponse
     */
    public function modifyNatIpAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->natIpDescription)) {
            $query['NatIpDescription'] = $request->natIpDescription;
        }
        if (!Utils::isUnset($request->natIpId)) {
            $query['NatIpId'] = $request->natIpId;
        }
        if (!Utils::isUnset($request->natIpName)) {
            $query['NatIpName'] = $request->natIpName;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyNatIpAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyNatIpAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the name and description of a NAT IP address.
     *  *
     * @description ## [](#)Description
     * You cannot repeatedly call the **ModifyNatIpAttribute** operation to modify the name and description of a NAT IP address within the specified period of time.
     *  *
     * @param ModifyNatIpAttributeRequest $request ModifyNatIpAttributeRequest
     *
     * @return ModifyNatIpAttributeResponse ModifyNatIpAttributeResponse
     */
    public function modifyNatIpAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyNatIpAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the name and description of a NAT CIDR block.
     *  *
     * @param ModifyNatIpCidrAttributeRequest $request ModifyNatIpCidrAttributeRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyNatIpCidrAttributeResponse ModifyNatIpCidrAttributeResponse
     */
    public function modifyNatIpCidrAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->natGatewayId)) {
            $query['NatGatewayId'] = $request->natGatewayId;
        }
        if (!Utils::isUnset($request->natIpCidr)) {
            $query['NatIpCidr'] = $request->natIpCidr;
        }
        if (!Utils::isUnset($request->natIpCidrDescription)) {
            $query['NatIpCidrDescription'] = $request->natIpCidrDescription;
        }
        if (!Utils::isUnset($request->natIpCidrName)) {
            $query['NatIpCidrName'] = $request->natIpCidrName;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyNatIpCidrAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyNatIpCidrAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the name and description of a NAT CIDR block.
     *  *
     * @param ModifyNatIpCidrAttributeRequest $request ModifyNatIpCidrAttributeRequest
     *
     * @return ModifyNatIpCidrAttributeResponse ModifyNatIpCidrAttributeResponse
     */
    public function modifyNatIpCidrAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyNatIpCidrAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the attributes of a network access control list (ACL).
     *  *
     * @param ModifyNetworkAclAttributesRequest $request ModifyNetworkAclAttributesRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyNetworkAclAttributesResponse ModifyNetworkAclAttributesResponse
     */
    public function modifyNetworkAclAttributesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->networkAclId)) {
            $query['NetworkAclId'] = $request->networkAclId;
        }
        if (!Utils::isUnset($request->networkAclName)) {
            $query['NetworkAclName'] = $request->networkAclName;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyNetworkAclAttributes',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyNetworkAclAttributesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the attributes of a network access control list (ACL).
     *  *
     * @param ModifyNetworkAclAttributesRequest $request ModifyNetworkAclAttributesRequest
     *
     * @return ModifyNetworkAclAttributesResponse ModifyNetworkAclAttributesResponse
     */
    public function modifyNetworkAclAttributes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyNetworkAclAttributesWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configurations of an Express Connect circuit.
     *  *
     * @description When you call this operation, take note of the following limits:
     * *   If an Express Connect circuit is in the **Initial**, **Enabled**, or **Rejected** state, you can modify the specifications of the Express Connect circuit and the ID of the redundant circuit.
     * *   If an Express Connect circuit is in the **Canceled**, **Allocating**, **AllocationFailed**, or **Terminated** state, you cannot modify the specifications of the Express Connect circuit.
     * *   After you modify the specifications of an Express Connect circuit that is in the **Rejected** state, the Express Connect circuit enters the **Initial** state.
     *  *
     * @param ModifyPhysicalConnectionAttributeRequest $request ModifyPhysicalConnectionAttributeRequest
     * @param RuntimeOptions                           $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyPhysicalConnectionAttributeResponse ModifyPhysicalConnectionAttributeResponse
     */
    public function modifyPhysicalConnectionAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->circuitCode)) {
            $query['CircuitCode'] = $request->circuitCode;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->lineOperator)) {
            $query['LineOperator'] = $request->lineOperator;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->peerLocation)) {
            $query['PeerLocation'] = $request->peerLocation;
        }
        if (!Utils::isUnset($request->physicalConnectionId)) {
            $query['PhysicalConnectionId'] = $request->physicalConnectionId;
        }
        if (!Utils::isUnset($request->portType)) {
            $query['PortType'] = $request->portType;
        }
        if (!Utils::isUnset($request->redundantPhysicalConnectionId)) {
            $query['RedundantPhysicalConnectionId'] = $request->redundantPhysicalConnectionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->bandwidth)) {
            $query['bandwidth'] = $request->bandwidth;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyPhysicalConnectionAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyPhysicalConnectionAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configurations of an Express Connect circuit.
     *  *
     * @description When you call this operation, take note of the following limits:
     * *   If an Express Connect circuit is in the **Initial**, **Enabled**, or **Rejected** state, you can modify the specifications of the Express Connect circuit and the ID of the redundant circuit.
     * *   If an Express Connect circuit is in the **Canceled**, **Allocating**, **AllocationFailed**, or **Terminated** state, you cannot modify the specifications of the Express Connect circuit.
     * *   After you modify the specifications of an Express Connect circuit that is in the **Rejected** state, the Express Connect circuit enters the **Initial** state.
     *  *
     * @param ModifyPhysicalConnectionAttributeRequest $request ModifyPhysicalConnectionAttributeRequest
     *
     * @return ModifyPhysicalConnectionAttributeResponse ModifyPhysicalConnectionAttributeResponse
     */
    public function modifyPhysicalConnectionAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyPhysicalConnectionAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the name and description of a custom route entry.
     *  *
     * @description You cannot repeatedly call the **ModifyRouteEntry** operation to modify the name and description of a custom route within the specified period of time.
     *  *
     * @param ModifyRouteEntryRequest $request ModifyRouteEntryRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyRouteEntryResponse ModifyRouteEntryResponse
     */
    public function modifyRouteEntryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->destinationCidrBlock)) {
            $query['DestinationCidrBlock'] = $request->destinationCidrBlock;
        }
        if (!Utils::isUnset($request->newNextHopId)) {
            $query['NewNextHopId'] = $request->newNextHopId;
        }
        if (!Utils::isUnset($request->newNextHopType)) {
            $query['NewNextHopType'] = $request->newNextHopType;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeEntryId)) {
            $query['RouteEntryId'] = $request->routeEntryId;
        }
        if (!Utils::isUnset($request->routeEntryName)) {
            $query['RouteEntryName'] = $request->routeEntryName;
        }
        if (!Utils::isUnset($request->routeTableId)) {
            $query['RouteTableId'] = $request->routeTableId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyRouteEntry',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyRouteEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the name and description of a custom route entry.
     *  *
     * @description You cannot repeatedly call the **ModifyRouteEntry** operation to modify the name and description of a custom route within the specified period of time.
     *  *
     * @param ModifyRouteEntryRequest $request ModifyRouteEntryRequest
     *
     * @return ModifyRouteEntryResponse ModifyRouteEntryResponse
     */
    public function modifyRouteEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyRouteEntryWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the name and description of a route table.
     *  *
     * @description You cannot repeatedly call the **ModifyRouteTableAttributes** operation to modify the name and description of a route table within the specified period of time.
     *  *
     * @param ModifyRouteTableAttributesRequest $request ModifyRouteTableAttributesRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyRouteTableAttributesResponse ModifyRouteTableAttributesResponse
     */
    public function modifyRouteTableAttributesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routePropagationEnable)) {
            $query['RoutePropagationEnable'] = $request->routePropagationEnable;
        }
        if (!Utils::isUnset($request->routeTableId)) {
            $query['RouteTableId'] = $request->routeTableId;
        }
        if (!Utils::isUnset($request->routeTableName)) {
            $query['RouteTableName'] = $request->routeTableName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyRouteTableAttributes',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyRouteTableAttributesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the name and description of a route table.
     *  *
     * @description You cannot repeatedly call the **ModifyRouteTableAttributes** operation to modify the name and description of a route table within the specified period of time.
     *  *
     * @param ModifyRouteTableAttributesRequest $request ModifyRouteTableAttributesRequest
     *
     * @return ModifyRouteTableAttributesResponse ModifyRouteTableAttributesResponse
     */
    public function modifyRouteTableAttributes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyRouteTableAttributesWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configuration of a router interface.
     *  *
     * @param ModifyRouterInterfaceAttributeRequest $request ModifyRouterInterfaceAttributeRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyRouterInterfaceAttributeResponse ModifyRouterInterfaceAttributeResponse
     */
    public function modifyRouterInterfaceAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->deleteHealthCheckIp)) {
            $query['DeleteHealthCheckIp'] = $request->deleteHealthCheckIp;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->hcRate)) {
            $query['HcRate'] = $request->hcRate;
        }
        if (!Utils::isUnset($request->hcThreshold)) {
            $query['HcThreshold'] = $request->hcThreshold;
        }
        if (!Utils::isUnset($request->healthCheckSourceIp)) {
            $query['HealthCheckSourceIp'] = $request->healthCheckSourceIp;
        }
        if (!Utils::isUnset($request->healthCheckTargetIp)) {
            $query['HealthCheckTargetIp'] = $request->healthCheckTargetIp;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->oppositeInterfaceId)) {
            $query['OppositeInterfaceId'] = $request->oppositeInterfaceId;
        }
        if (!Utils::isUnset($request->oppositeInterfaceOwnerId)) {
            $query['OppositeInterfaceOwnerId'] = $request->oppositeInterfaceOwnerId;
        }
        if (!Utils::isUnset($request->oppositeRouterId)) {
            $query['OppositeRouterId'] = $request->oppositeRouterId;
        }
        if (!Utils::isUnset($request->oppositeRouterType)) {
            $query['OppositeRouterType'] = $request->oppositeRouterType;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routerInterfaceId)) {
            $query['RouterInterfaceId'] = $request->routerInterfaceId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyRouterInterfaceAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyRouterInterfaceAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configuration of a router interface.
     *  *
     * @param ModifyRouterInterfaceAttributeRequest $request ModifyRouterInterfaceAttributeRequest
     *
     * @return ModifyRouterInterfaceAttributeResponse ModifyRouterInterfaceAttributeResponse
     */
    public function modifyRouterInterfaceAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyRouterInterfaceAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the specification of a router interface.
     *  *
     * @description After you call this operation, the router interface enters the **Activating** state. After the router interface is activated, the router interface enters the **Active** state.
     * >  You cannot modify the specification of a router interface that has overdue payments.
     *  *
     * @param ModifyRouterInterfaceSpecRequest $request ModifyRouterInterfaceSpecRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyRouterInterfaceSpecResponse ModifyRouterInterfaceSpecResponse
     */
    public function modifyRouterInterfaceSpecWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routerInterfaceId)) {
            $query['RouterInterfaceId'] = $request->routerInterfaceId;
        }
        if (!Utils::isUnset($request->spec)) {
            $query['Spec'] = $request->spec;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyRouterInterfaceSpec',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyRouterInterfaceSpecResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the specification of a router interface.
     *  *
     * @description After you call this operation, the router interface enters the **Activating** state. After the router interface is activated, the router interface enters the **Active** state.
     * >  You cannot modify the specification of a router interface that has overdue payments.
     *  *
     * @param ModifyRouterInterfaceSpecRequest $request ModifyRouterInterfaceSpecRequest
     *
     * @return ModifyRouterInterfaceSpecResponse ModifyRouterInterfaceSpecResponse
     */
    public function modifyRouterInterfaceSpec($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyRouterInterfaceSpecWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies an SNAT entry.
     *  *
     * @description ## [](#)
     * **ModifySnatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of the task.
     * *   **Pending**: indicates that the system is modifying the SNAT entry. You can only query the status of the SNAT entry, but cannot perform other operations.
     * *   **Available**: indicates that the SNAT entry is modified.
     * >  If an SNAT entry is in the **Pending** state, it indicates that you cannot modify the SNAT entry.
     * You cannot repeatedly call the **ModifySnatEntry** operation to modify an SNAT entry within a specific period of time.
     *  *
     * @param ModifySnatEntryRequest $request ModifySnatEntryRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifySnatEntryResponse ModifySnatEntryResponse
     */
    public function modifySnatEntryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->eipAffinity)) {
            $query['EipAffinity'] = $request->eipAffinity;
        }
        if (!Utils::isUnset($request->networkInterfaceId)) {
            $query['NetworkInterfaceId'] = $request->networkInterfaceId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->snatEntryId)) {
            $query['SnatEntryId'] = $request->snatEntryId;
        }
        if (!Utils::isUnset($request->snatEntryName)) {
            $query['SnatEntryName'] = $request->snatEntryName;
        }
        if (!Utils::isUnset($request->snatIp)) {
            $query['SnatIp'] = $request->snatIp;
        }
        if (!Utils::isUnset($request->snatTableId)) {
            $query['SnatTableId'] = $request->snatTableId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifySnatEntry',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifySnatEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies an SNAT entry.
     *  *
     * @description ## [](#)
     * **ModifySnatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of the task.
     * *   **Pending**: indicates that the system is modifying the SNAT entry. You can only query the status of the SNAT entry, but cannot perform other operations.
     * *   **Available**: indicates that the SNAT entry is modified.
     * >  If an SNAT entry is in the **Pending** state, it indicates that you cannot modify the SNAT entry.
     * You cannot repeatedly call the **ModifySnatEntry** operation to modify an SNAT entry within a specific period of time.
     *  *
     * @param ModifySnatEntryRequest $request ModifySnatEntryRequest
     *
     * @return ModifySnatEntryResponse ModifySnatEntryResponse
     */
    public function modifySnatEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifySnatEntryWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the name of an SSL-VPN client certificate.
     *  *
     * @param ModifySslVpnClientCertRequest $request ModifySslVpnClientCertRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifySslVpnClientCertResponse ModifySslVpnClientCertResponse
     */
    public function modifySslVpnClientCertWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sslVpnClientCertId)) {
            $query['SslVpnClientCertId'] = $request->sslVpnClientCertId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifySslVpnClientCert',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifySslVpnClientCertResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the name of an SSL-VPN client certificate.
     *  *
     * @param ModifySslVpnClientCertRequest $request ModifySslVpnClientCertRequest
     *
     * @return ModifySslVpnClientCertResponse ModifySslVpnClientCertResponse
     */
    public function modifySslVpnClientCert($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifySslVpnClientCertWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configurations of an SSL server.
     *  *
     * @description *   If you modify only the **name** of the SSL server, the operation is synchronous. If you also modify other configurations besides the **name**, the operation is asynchronous.
     * *   When **ModifySslVpnServer** is an asynchronous operation, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
     *     *   If a VPN gateway is in the **updating** state, the configurations of the SSL server are being modified.
     *     *   If a VPN gateway is in the **active** state, the configurations of the SSL server are modified.
     * *   You cannot repeatedly call **ModifySslVpnServer** to modify the configurations of an SSL server within the specified period of time.
     *  *
     * @param ModifySslVpnServerRequest $request ModifySslVpnServerRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifySslVpnServerResponse ModifySslVpnServerResponse
     */
    public function modifySslVpnServerWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->cipher)) {
            $query['Cipher'] = $request->cipher;
        }
        if (!Utils::isUnset($request->clientIpPool)) {
            $query['ClientIpPool'] = $request->clientIpPool;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->compress)) {
            $query['Compress'] = $request->compress;
        }
        if (!Utils::isUnset($request->enableMultiFactorAuth)) {
            $query['EnableMultiFactorAuth'] = $request->enableMultiFactorAuth;
        }
        if (!Utils::isUnset($request->IDaaSApplicationId)) {
            $query['IDaaSApplicationId'] = $request->IDaaSApplicationId;
        }
        if (!Utils::isUnset($request->IDaaSInstanceId)) {
            $query['IDaaSInstanceId'] = $request->IDaaSInstanceId;
        }
        if (!Utils::isUnset($request->IDaaSRegionId)) {
            $query['IDaaSRegionId'] = $request->IDaaSRegionId;
        }
        if (!Utils::isUnset($request->localSubnet)) {
            $query['LocalSubnet'] = $request->localSubnet;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->port)) {
            $query['Port'] = $request->port;
        }
        if (!Utils::isUnset($request->proto)) {
            $query['Proto'] = $request->proto;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sslVpnServerId)) {
            $query['SslVpnServerId'] = $request->sslVpnServerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifySslVpnServer',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifySslVpnServerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configurations of an SSL server.
     *  *
     * @description *   If you modify only the **name** of the SSL server, the operation is synchronous. If you also modify other configurations besides the **name**, the operation is asynchronous.
     * *   When **ModifySslVpnServer** is an asynchronous operation, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
     *     *   If a VPN gateway is in the **updating** state, the configurations of the SSL server are being modified.
     *     *   If a VPN gateway is in the **active** state, the configurations of the SSL server are modified.
     * *   You cannot repeatedly call **ModifySslVpnServer** to modify the configurations of an SSL server within the specified period of time.
     *  *
     * @param ModifySslVpnServerRequest $request ModifySslVpnServerRequest
     *
     * @return ModifySslVpnServerResponse ModifySslVpnServerResponse
     */
    public function modifySslVpnServer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifySslVpnServerWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies a VPN tunnel.
     *  *
     * @param ModifyTunnelAttributeRequest $request ModifyTunnelAttributeRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyTunnelAttributeResponse ModifyTunnelAttributeResponse
     */
    public function modifyTunnelAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->tunnelId)) {
            $query['TunnelId'] = $request->tunnelId;
        }
        if (!Utils::isUnset($request->tunnelOptionsSpecification)) {
            $query['TunnelOptionsSpecification'] = $request->tunnelOptionsSpecification;
        }
        if (!Utils::isUnset($request->vpnConnectionId)) {
            $query['VpnConnectionId'] = $request->vpnConnectionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyTunnelAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyTunnelAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies a VPN tunnel.
     *  *
     * @param ModifyTunnelAttributeRequest $request ModifyTunnelAttributeRequest
     *
     * @return ModifyTunnelAttributeResponse ModifyTunnelAttributeResponse
     */
    public function modifyTunnelAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyTunnelAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the name and description of a vRouter.
     *  *
     * @description You cannot repeatedly call the **ModifyVRouterAttribute** operation within a specific period of time.
     *  *
     * @param ModifyVRouterAttributeRequest $request ModifyVRouterAttributeRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyVRouterAttributeResponse ModifyVRouterAttributeResponse
     */
    public function modifyVRouterAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->VRouterId)) {
            $query['VRouterId'] = $request->VRouterId;
        }
        if (!Utils::isUnset($request->VRouterName)) {
            $query['VRouterName'] = $request->VRouterName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyVRouterAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyVRouterAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the name and description of a vRouter.
     *  *
     * @description You cannot repeatedly call the **ModifyVRouterAttribute** operation within a specific period of time.
     *  *
     * @param ModifyVRouterAttributeRequest $request ModifyVRouterAttributeRequest
     *
     * @return ModifyVRouterAttributeResponse ModifyVRouterAttributeResponse
     */
    public function modifyVRouterAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVRouterAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary 修改VSwitch属性
     *  *
     * @description *   **ModifyVSwitchAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
     *     *   If the vSwitch is in the **Pending** state, the name and description of the vSwitch are being modified.
     *     *   If the vSwitch is in the **Available** state, the name and description of the vSwitch are modified.
     * *   You cannot repeatedly call the **ModifyVSwitchAttribute** operation to modify the name and description of a vSwitch within the specified period of time.
     *  *
     * @param ModifyVSwitchAttributeRequest $request ModifyVSwitchAttributeRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyVSwitchAttributeResponse ModifyVSwitchAttributeResponse
     */
    public function modifyVSwitchAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->enableIPv6)) {
            $query['EnableIPv6'] = $request->enableIPv6;
        }
        if (!Utils::isUnset($request->ipv6CidrBlock)) {
            $query['Ipv6CidrBlock'] = $request->ipv6CidrBlock;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vSwitchId)) {
            $query['VSwitchId'] = $request->vSwitchId;
        }
        if (!Utils::isUnset($request->vSwitchName)) {
            $query['VSwitchName'] = $request->vSwitchName;
        }
        if (!Utils::isUnset($request->vpcIpv6CidrBlock)) {
            $query['VpcIpv6CidrBlock'] = $request->vpcIpv6CidrBlock;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyVSwitchAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyVSwitchAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 修改VSwitch属性
     *  *
     * @description *   **ModifyVSwitchAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
     *     *   If the vSwitch is in the **Pending** state, the name and description of the vSwitch are being modified.
     *     *   If the vSwitch is in the **Available** state, the name and description of the vSwitch are modified.
     * *   You cannot repeatedly call the **ModifyVSwitchAttribute** operation to modify the name and description of a vSwitch within the specified period of time.
     *  *
     * @param ModifyVSwitchAttributeRequest $request ModifyVSwitchAttributeRequest
     *
     * @return ModifyVSwitchAttributeResponse ModifyVSwitchAttributeResponse
     */
    public function modifyVSwitchAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVSwitchAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary 修改交换机预留网段的名称和描述信息。
     *  *
     * @description ## [](#)Usage notes
     * You cannot repeatedly call **ModifyVSwitchCidrReservationAttribute** within a specific time period.
     *  *
     * @param ModifyVSwitchCidrReservationAttributeRequest $request ModifyVSwitchCidrReservationAttributeRequest
     * @param RuntimeOptions                               $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyVSwitchCidrReservationAttributeResponse ModifyVSwitchCidrReservationAttributeResponse
     */
    public function modifyVSwitchCidrReservationAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vSwitchCidrReservationDescription)) {
            $query['VSwitchCidrReservationDescription'] = $request->vSwitchCidrReservationDescription;
        }
        if (!Utils::isUnset($request->vSwitchCidrReservationId)) {
            $query['VSwitchCidrReservationId'] = $request->vSwitchCidrReservationId;
        }
        if (!Utils::isUnset($request->vSwitchCidrReservationName)) {
            $query['VSwitchCidrReservationName'] = $request->vSwitchCidrReservationName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyVSwitchCidrReservationAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyVSwitchCidrReservationAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 修改交换机预留网段的名称和描述信息。
     *  *
     * @description ## [](#)Usage notes
     * You cannot repeatedly call **ModifyVSwitchCidrReservationAttribute** within a specific time period.
     *  *
     * @param ModifyVSwitchCidrReservationAttributeRequest $request ModifyVSwitchCidrReservationAttributeRequest
     *
     * @return ModifyVSwitchCidrReservationAttributeResponse ModifyVSwitchCidrReservationAttributeResponse
     */
    public function modifyVSwitchCidrReservationAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVSwitchCidrReservationAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the weight of a destination-based route for an IPsec-VPN connection.
     *  *
     * @description *   **ModifyVcoRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the associated IPsec-VPN connection and determine whether the weight of the specified destination-based route is modified.
     *     *   If the IPsec-VPN connection is in the **updating** state, the weight of the destination-based route is being modified.
     *     *   If the IPsec-VPN connection is in the **attached** state, the weight of the destination-based route is modified.
     * *   You cannot repeatedly call the **ModifyVcoRouteEntryWeight** operation for the same IPsec-VPN connection within the specified period of time.
     *  *
     * @param ModifyVcoRouteEntryWeightRequest $request ModifyVcoRouteEntryWeightRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyVcoRouteEntryWeightResponse ModifyVcoRouteEntryWeightResponse
     */
    public function modifyVcoRouteEntryWeightWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->newWeight)) {
            $query['NewWeight'] = $request->newWeight;
        }
        if (!Utils::isUnset($request->nextHop)) {
            $query['NextHop'] = $request->nextHop;
        }
        if (!Utils::isUnset($request->overlayMode)) {
            $query['OverlayMode'] = $request->overlayMode;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeDest)) {
            $query['RouteDest'] = $request->routeDest;
        }
        if (!Utils::isUnset($request->vpnConnectionId)) {
            $query['VpnConnectionId'] = $request->vpnConnectionId;
        }
        if (!Utils::isUnset($request->weight)) {
            $query['Weight'] = $request->weight;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyVcoRouteEntryWeight',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyVcoRouteEntryWeightResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the weight of a destination-based route for an IPsec-VPN connection.
     *  *
     * @description *   **ModifyVcoRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the associated IPsec-VPN connection and determine whether the weight of the specified destination-based route is modified.
     *     *   If the IPsec-VPN connection is in the **updating** state, the weight of the destination-based route is being modified.
     *     *   If the IPsec-VPN connection is in the **attached** state, the weight of the destination-based route is modified.
     * *   You cannot repeatedly call the **ModifyVcoRouteEntryWeight** operation for the same IPsec-VPN connection within the specified period of time.
     *  *
     * @param ModifyVcoRouteEntryWeightRequest $request ModifyVcoRouteEntryWeightRequest
     *
     * @return ModifyVcoRouteEntryWeightResponse ModifyVcoRouteEntryWeightResponse
     */
    public function modifyVcoRouteEntryWeight($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVcoRouteEntryWeightWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configuration of a virtual border router (VBR).
     *  *
     * @description # [](#)
     * *   Only the owner of an Express Connect circuit can modify the **VlanId** parameter.
     * *   One VLAN ID of an Express Connect circuit cannot be used only by one VBR at the same time.
     * *   The VLAN ID of a VBR in the **Terminated** state is reserved for seven days and cannot be used by other VBRs. The VLAN ID can be used by other VBRs after 7 days.
     * *   You cannot set **LocalGatewayIp**, **PeerGatewayIp**, or **PeeringSubnetMask** for VBRs that do not belong to your Alibaba Cloud account.
     * *   Set **PeeringSubnetMask** to a subnet mask with 24 to 30 bits in length (255.255.255.0～255.255.255.252).
     * *   Set **LocalGatewayIp** and **PeerGatewayIp** to IP addresses that belong to the same CIDR block. For example, you can set LocalGatewayIp to 192.168.XX.XX, PeerGatewayIp to 192.168.XX.XX, and PeeringSubnetMask to 255.255.255.248.
     *  *
     * @param ModifyVirtualBorderRouterAttributeRequest $request ModifyVirtualBorderRouterAttributeRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyVirtualBorderRouterAttributeResponse ModifyVirtualBorderRouterAttributeResponse
     */
    public function modifyVirtualBorderRouterAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->associatedPhysicalConnections)) {
            $query['AssociatedPhysicalConnections'] = $request->associatedPhysicalConnections;
        }
        if (!Utils::isUnset($request->bandwidth)) {
            $query['Bandwidth'] = $request->bandwidth;
        }
        if (!Utils::isUnset($request->circuitCode)) {
            $query['CircuitCode'] = $request->circuitCode;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->detectMultiplier)) {
            $query['DetectMultiplier'] = $request->detectMultiplier;
        }
        if (!Utils::isUnset($request->enableIpv6)) {
            $query['EnableIpv6'] = $request->enableIpv6;
        }
        if (!Utils::isUnset($request->localGatewayIp)) {
            $query['LocalGatewayIp'] = $request->localGatewayIp;
        }
        if (!Utils::isUnset($request->localIpv6GatewayIp)) {
            $query['LocalIpv6GatewayIp'] = $request->localIpv6GatewayIp;
        }
        if (!Utils::isUnset($request->minRxInterval)) {
            $query['MinRxInterval'] = $request->minRxInterval;
        }
        if (!Utils::isUnset($request->minTxInterval)) {
            $query['MinTxInterval'] = $request->minTxInterval;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->peerGatewayIp)) {
            $query['PeerGatewayIp'] = $request->peerGatewayIp;
        }
        if (!Utils::isUnset($request->peerIpv6GatewayIp)) {
            $query['PeerIpv6GatewayIp'] = $request->peerIpv6GatewayIp;
        }
        if (!Utils::isUnset($request->peeringIpv6SubnetMask)) {
            $query['PeeringIpv6SubnetMask'] = $request->peeringIpv6SubnetMask;
        }
        if (!Utils::isUnset($request->peeringSubnetMask)) {
            $query['PeeringSubnetMask'] = $request->peeringSubnetMask;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sitelinkEnable)) {
            $query['SitelinkEnable'] = $request->sitelinkEnable;
        }
        if (!Utils::isUnset($request->vbrId)) {
            $query['VbrId'] = $request->vbrId;
        }
        if (!Utils::isUnset($request->vlanId)) {
            $query['VlanId'] = $request->vlanId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyVirtualBorderRouterAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyVirtualBorderRouterAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configuration of a virtual border router (VBR).
     *  *
     * @description # [](#)
     * *   Only the owner of an Express Connect circuit can modify the **VlanId** parameter.
     * *   One VLAN ID of an Express Connect circuit cannot be used only by one VBR at the same time.
     * *   The VLAN ID of a VBR in the **Terminated** state is reserved for seven days and cannot be used by other VBRs. The VLAN ID can be used by other VBRs after 7 days.
     * *   You cannot set **LocalGatewayIp**, **PeerGatewayIp**, or **PeeringSubnetMask** for VBRs that do not belong to your Alibaba Cloud account.
     * *   Set **PeeringSubnetMask** to a subnet mask with 24 to 30 bits in length (255.255.255.0～255.255.255.252).
     * *   Set **LocalGatewayIp** and **PeerGatewayIp** to IP addresses that belong to the same CIDR block. For example, you can set LocalGatewayIp to 192.168.XX.XX, PeerGatewayIp to 192.168.XX.XX, and PeeringSubnetMask to 255.255.255.248.
     *  *
     * @param ModifyVirtualBorderRouterAttributeRequest $request ModifyVirtualBorderRouterAttributeRequest
     *
     * @return ModifyVirtualBorderRouterAttributeResponse ModifyVirtualBorderRouterAttributeResponse
     */
    public function modifyVirtualBorderRouterAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVirtualBorderRouterAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the name and description of a virtual private cloud (VPC).
     *  *
     * @description ## [](#)Description
     * You cannot repeatedly call the **ModifyVpcAttribute** operation to modify the name and description of a VPC within the specified period of time.
     *  *
     * @param ModifyVpcAttributeRequest $request ModifyVpcAttributeRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyVpcAttributeResponse ModifyVpcAttributeResponse
     */
    public function modifyVpcAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->cidrBlock)) {
            $query['CidrBlock'] = $request->cidrBlock;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->enableDnsHostname)) {
            $query['EnableDnsHostname'] = $request->enableDnsHostname;
        }
        if (!Utils::isUnset($request->enableIPv6)) {
            $query['EnableIPv6'] = $request->enableIPv6;
        }
        if (!Utils::isUnset($request->ipv6CidrBlock)) {
            $query['Ipv6CidrBlock'] = $request->ipv6CidrBlock;
        }
        if (!Utils::isUnset($request->ipv6Isp)) {
            $query['Ipv6Isp'] = $request->ipv6Isp;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        if (!Utils::isUnset($request->vpcName)) {
            $query['VpcName'] = $request->vpcName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyVpcAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyVpcAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the name and description of a virtual private cloud (VPC).
     *  *
     * @description ## [](#)Description
     * You cannot repeatedly call the **ModifyVpcAttribute** operation to modify the name and description of a VPC within the specified period of time.
     *  *
     * @param ModifyVpcAttributeRequest $request ModifyVpcAttributeRequest
     *
     * @return ModifyVpcAttributeResponse ModifyVpcAttributeResponse
     */
    public function modifyVpcAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVpcAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configuration of a prefix list.
     *  *
     * @description *   **ModifyVpcPrefixList** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPrefixLists](https://help.aliyun.com/document_detail/311535.html) to query the status of the task.
     *     *   If the prefix list is in the **Modifying** state, the configuration of the prefix list is being modified.
     *     *   If the prefix list is in the **Created** state, the configuration of the prefix list is modified.
     *     *   After the configuration of the prefix list is modified, you can call the [GetVpcPrefixListAssociations](https://help.aliyun.com/document_detail/445478.html) operation to query the information about the network instances that are associated with the prefix list and determine whether the associated network instances use the new CIDR blocks. If the association **status** of the prefix list is **Created**, the new CIDR blocks are used by the network instances that are associated with the prefix list.
     * *   You cannot repeatedly call **ModifyVpcPrefixList** to modify the configuration of a prefix list within the specified period of time.
     *  *
     * @param ModifyVpcPrefixListRequest $request ModifyVpcPrefixListRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyVpcPrefixListResponse ModifyVpcPrefixListResponse
     */
    public function modifyVpcPrefixListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->addPrefixListEntry)) {
            $query['AddPrefixListEntry'] = $request->addPrefixListEntry;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->maxEntries)) {
            $query['MaxEntries'] = $request->maxEntries;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->prefixListDescription)) {
            $query['PrefixListDescription'] = $request->prefixListDescription;
        }
        if (!Utils::isUnset($request->prefixListId)) {
            $query['PrefixListId'] = $request->prefixListId;
        }
        if (!Utils::isUnset($request->prefixListName)) {
            $query['PrefixListName'] = $request->prefixListName;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->removePrefixListEntry)) {
            $query['RemovePrefixListEntry'] = $request->removePrefixListEntry;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyVpcPrefixList',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyVpcPrefixListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configuration of a prefix list.
     *  *
     * @description *   **ModifyVpcPrefixList** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPrefixLists](https://help.aliyun.com/document_detail/311535.html) to query the status of the task.
     *     *   If the prefix list is in the **Modifying** state, the configuration of the prefix list is being modified.
     *     *   If the prefix list is in the **Created** state, the configuration of the prefix list is modified.
     *     *   After the configuration of the prefix list is modified, you can call the [GetVpcPrefixListAssociations](https://help.aliyun.com/document_detail/445478.html) operation to query the information about the network instances that are associated with the prefix list and determine whether the associated network instances use the new CIDR blocks. If the association **status** of the prefix list is **Created**, the new CIDR blocks are used by the network instances that are associated with the prefix list.
     * *   You cannot repeatedly call **ModifyVpcPrefixList** to modify the configuration of a prefix list within the specified period of time.
     *  *
     * @param ModifyVpcPrefixListRequest $request ModifyVpcPrefixListRequest
     *
     * @return ModifyVpcPrefixListResponse ModifyVpcPrefixListResponse
     */
    public function modifyVpcPrefixList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVpcPrefixListWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configuration of an IPsec-VPN connection.
     *  *
     * @description *   **ModifyVpnAttachmentAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task to modify the configuration of an IPsec-VPN connection in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the task.
     *     *   If the IPsec-VPN connection is in the **updating** state, the configuration of the IPsec-VPN connection is being modified.
     *     *   If the IPsec-VPN connection is in the **attached** state, the configuration of the IPsec-VPN connection is modified.
     * *   You cannot call the **ModifyVpnAttachmentAttribute** operation again on the same IPsec-VPN connection before the previous operation is complete.
     * *   When you call the **ModifyVpnAttachmentAttribute** operation, take note of the following items:
     *     *   If the IPsec-VPN connection is associated with a transit router, you cannot change the type of the gateway connected to the IPsec-VPN connection.
     *     *   If the IPsec-VPN connection is not associated with a resource, you cannot change the type of the gateway connected to the IPsec-VPN connection or the customer gateway connected to the IPsec-VPN connection.
     *  *
     * @param ModifyVpnAttachmentAttributeRequest $request ModifyVpnAttachmentAttributeRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyVpnAttachmentAttributeResponse ModifyVpnAttachmentAttributeResponse
     */
    public function modifyVpnAttachmentAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->autoConfigRoute)) {
            $query['AutoConfigRoute'] = $request->autoConfigRoute;
        }
        if (!Utils::isUnset($request->bgpConfig)) {
            $query['BgpConfig'] = $request->bgpConfig;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->customerGatewayId)) {
            $query['CustomerGatewayId'] = $request->customerGatewayId;
        }
        if (!Utils::isUnset($request->effectImmediately)) {
            $query['EffectImmediately'] = $request->effectImmediately;
        }
        if (!Utils::isUnset($request->enableDpd)) {
            $query['EnableDpd'] = $request->enableDpd;
        }
        if (!Utils::isUnset($request->enableNatTraversal)) {
            $query['EnableNatTraversal'] = $request->enableNatTraversal;
        }
        if (!Utils::isUnset($request->enableTunnelsBgp)) {
            $query['EnableTunnelsBgp'] = $request->enableTunnelsBgp;
        }
        if (!Utils::isUnset($request->healthCheckConfig)) {
            $query['HealthCheckConfig'] = $request->healthCheckConfig;
        }
        if (!Utils::isUnset($request->ikeConfig)) {
            $query['IkeConfig'] = $request->ikeConfig;
        }
        if (!Utils::isUnset($request->ipsecConfig)) {
            $query['IpsecConfig'] = $request->ipsecConfig;
        }
        if (!Utils::isUnset($request->localSubnet)) {
            $query['LocalSubnet'] = $request->localSubnet;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->networkType)) {
            $query['NetworkType'] = $request->networkType;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->remoteCaCert)) {
            $query['RemoteCaCert'] = $request->remoteCaCert;
        }
        if (!Utils::isUnset($request->remoteSubnet)) {
            $query['RemoteSubnet'] = $request->remoteSubnet;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vpnConnectionId)) {
            $query['VpnConnectionId'] = $request->vpnConnectionId;
        }
        $body     = [];
        $bodyFlat = [];
        if (!Utils::isUnset($request->tunnelOptionsSpecification)) {
            $bodyFlat['TunnelOptionsSpecification'] = $request->tunnelOptionsSpecification;
        }
        $body = Tea::merge($body, OpenApiUtilClient::query($bodyFlat));
        $req  = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ModifyVpnAttachmentAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyVpnAttachmentAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configuration of an IPsec-VPN connection.
     *  *
     * @description *   **ModifyVpnAttachmentAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task to modify the configuration of an IPsec-VPN connection in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the task.
     *     *   If the IPsec-VPN connection is in the **updating** state, the configuration of the IPsec-VPN connection is being modified.
     *     *   If the IPsec-VPN connection is in the **attached** state, the configuration of the IPsec-VPN connection is modified.
     * *   You cannot call the **ModifyVpnAttachmentAttribute** operation again on the same IPsec-VPN connection before the previous operation is complete.
     * *   When you call the **ModifyVpnAttachmentAttribute** operation, take note of the following items:
     *     *   If the IPsec-VPN connection is associated with a transit router, you cannot change the type of the gateway connected to the IPsec-VPN connection.
     *     *   If the IPsec-VPN connection is not associated with a resource, you cannot change the type of the gateway connected to the IPsec-VPN connection or the customer gateway connected to the IPsec-VPN connection.
     *  *
     * @param ModifyVpnAttachmentAttributeRequest $request ModifyVpnAttachmentAttributeRequest
     *
     * @return ModifyVpnAttachmentAttributeResponse ModifyVpnAttachmentAttributeResponse
     */
    public function modifyVpnAttachmentAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVpnAttachmentAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configuration of an IPsec-VPN connection.
     *  *
     * @description *   If you want to modify a IPsec-VPN connection in dual-tunnel mode, call the `ModifyVpnConnectionAttribute` operation. You can modify the required parameters and the following request parameters:
     *     **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **AutoConfigRoute**, **TunnelOptionsSpecification**, and **EnableTunnelsBgp**.
     * *   If you want to modify a IPsec-VPN connection in single-tunnel mode, call the `ModifyVpnConnectionAttribute` operation. You can modify the required parameters and the following request parameters:
     *     **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, and **RemoteCaCertificate**.
     * *   **ModifyVpnConnectionAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and modifies the configuration of the IPsec-VPN connection in the backend. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of a VPN gateway.
     *     *   If the VPN gateway is in the **updating** state, the configuration of the IPsec-VPN connection is being modified.
     *     *   If the VPN gateway is in the **active** state, the configuration of the IPsec-VPN connection is modified.
     * *   You cannot repeatedly call the **ModifyVpnConnectionAttribute** operation for the same VPN gateway within the specified period of time.
     *  *
     * @param ModifyVpnConnectionAttributeRequest $request ModifyVpnConnectionAttributeRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyVpnConnectionAttributeResponse ModifyVpnConnectionAttributeResponse
     */
    public function modifyVpnConnectionAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->autoConfigRoute)) {
            $query['AutoConfigRoute'] = $request->autoConfigRoute;
        }
        if (!Utils::isUnset($request->bgpConfig)) {
            $query['BgpConfig'] = $request->bgpConfig;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->effectImmediately)) {
            $query['EffectImmediately'] = $request->effectImmediately;
        }
        if (!Utils::isUnset($request->enableDpd)) {
            $query['EnableDpd'] = $request->enableDpd;
        }
        if (!Utils::isUnset($request->enableNatTraversal)) {
            $query['EnableNatTraversal'] = $request->enableNatTraversal;
        }
        if (!Utils::isUnset($request->enableTunnelsBgp)) {
            $query['EnableTunnelsBgp'] = $request->enableTunnelsBgp;
        }
        if (!Utils::isUnset($request->healthCheckConfig)) {
            $query['HealthCheckConfig'] = $request->healthCheckConfig;
        }
        if (!Utils::isUnset($request->ikeConfig)) {
            $query['IkeConfig'] = $request->ikeConfig;
        }
        if (!Utils::isUnset($request->ipsecConfig)) {
            $query['IpsecConfig'] = $request->ipsecConfig;
        }
        if (!Utils::isUnset($request->localSubnet)) {
            $query['LocalSubnet'] = $request->localSubnet;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->remoteCaCertificate)) {
            $query['RemoteCaCertificate'] = $request->remoteCaCertificate;
        }
        if (!Utils::isUnset($request->remoteSubnet)) {
            $query['RemoteSubnet'] = $request->remoteSubnet;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vpnConnectionId)) {
            $query['VpnConnectionId'] = $request->vpnConnectionId;
        }
        $body     = [];
        $bodyFlat = [];
        if (!Utils::isUnset($request->tunnelOptionsSpecification)) {
            $bodyFlat['TunnelOptionsSpecification'] = $request->tunnelOptionsSpecification;
        }
        $body = Tea::merge($body, OpenApiUtilClient::query($bodyFlat));
        $req  = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ModifyVpnConnectionAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyVpnConnectionAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configuration of an IPsec-VPN connection.
     *  *
     * @description *   If you want to modify a IPsec-VPN connection in dual-tunnel mode, call the `ModifyVpnConnectionAttribute` operation. You can modify the required parameters and the following request parameters:
     *     **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **AutoConfigRoute**, **TunnelOptionsSpecification**, and **EnableTunnelsBgp**.
     * *   If you want to modify a IPsec-VPN connection in single-tunnel mode, call the `ModifyVpnConnectionAttribute` operation. You can modify the required parameters and the following request parameters:
     *     **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, and **RemoteCaCertificate**.
     * *   **ModifyVpnConnectionAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and modifies the configuration of the IPsec-VPN connection in the backend. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of a VPN gateway.
     *     *   If the VPN gateway is in the **updating** state, the configuration of the IPsec-VPN connection is being modified.
     *     *   If the VPN gateway is in the **active** state, the configuration of the IPsec-VPN connection is modified.
     * *   You cannot repeatedly call the **ModifyVpnConnectionAttribute** operation for the same VPN gateway within the specified period of time.
     *  *
     * @param ModifyVpnConnectionAttributeRequest $request ModifyVpnConnectionAttributeRequest
     *
     * @return ModifyVpnConnectionAttributeResponse ModifyVpnConnectionAttributeResponse
     */
    public function modifyVpnConnectionAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVpnConnectionAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the name and description of a VPN gateway.
     *  *
     * @description *   **ModifyVpnGatewayAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the VPN gateway is being modified.
     *     *   If the VPN gateway is in the **active** state, the VPN gateway is modified.
     * *   You cannot repeatedly call **ModifyVpnGatewayAttribute** to modify a VPN gateway within the specified period of time.
     *  *
     * @param ModifyVpnGatewayAttributeRequest $request ModifyVpnGatewayAttributeRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyVpnGatewayAttributeResponse ModifyVpnGatewayAttributeResponse
     */
    public function modifyVpnGatewayAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->autoPropagate)) {
            $query['AutoPropagate'] = $request->autoPropagate;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vpnGatewayId)) {
            $query['VpnGatewayId'] = $request->vpnGatewayId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyVpnGatewayAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyVpnGatewayAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the name and description of a VPN gateway.
     *  *
     * @description *   **ModifyVpnGatewayAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the VPN gateway is being modified.
     *     *   If the VPN gateway is in the **active** state, the VPN gateway is modified.
     * *   You cannot repeatedly call **ModifyVpnGatewayAttribute** to modify a VPN gateway within the specified period of time.
     *  *
     * @param ModifyVpnGatewayAttributeRequest $request ModifyVpnGatewayAttributeRequest
     *
     * @return ModifyVpnGatewayAttributeResponse ModifyVpnGatewayAttributeResponse
     */
    public function modifyVpnGatewayAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVpnGatewayAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the weight and priority of a policy-based route.
     *  *
     * @description *   You can call the **ModifyVpnPbrRouteEntryAttribute** operation to modify the weight and priority of a policy-based route.
     *     *   If you want to modify only the weight of a policy-based route, call [ModifyVpnPbrRouteEntryWeight](https://help.aliyun.com/document_detail/127249.html).
     *     *   If you want to modify only the priority of a policy-based route, call [ModifyVpnPbrRouteEntryPriority](https://help.aliyun.com/document_detail/466870.html).
     *     *   If a policy-based route does not support priorities, you can only call [ModifyVpnPbrRouteEntryWeight](https://help.aliyun.com/document_detail/127249.html) to modify its weight.
     * *   The **ModifyVpnPbrRouteEntryAttribute** operation is asynchronous. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of a VPN gateway.
     *     *   If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
     *     *   If a VPN gateway is in the **active** state, the policy-based route entry is modified.
     * *   You cannot repeatedly call the **ModifyVpnPbrRouteEntryAttribute** operation for the same VPN gateway within the specified period of time.
     *  *
     * @param ModifyVpnPbrRouteEntryAttributeRequest $request ModifyVpnPbrRouteEntryAttributeRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyVpnPbrRouteEntryAttributeResponse ModifyVpnPbrRouteEntryAttributeResponse
     */
    public function modifyVpnPbrRouteEntryAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->newPriority)) {
            $query['NewPriority'] = $request->newPriority;
        }
        if (!Utils::isUnset($request->newWeight)) {
            $query['NewWeight'] = $request->newWeight;
        }
        if (!Utils::isUnset($request->nextHop)) {
            $query['NextHop'] = $request->nextHop;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->priority)) {
            $query['Priority'] = $request->priority;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeDest)) {
            $query['RouteDest'] = $request->routeDest;
        }
        if (!Utils::isUnset($request->routeSource)) {
            $query['RouteSource'] = $request->routeSource;
        }
        if (!Utils::isUnset($request->vpnGatewayId)) {
            $query['VpnGatewayId'] = $request->vpnGatewayId;
        }
        if (!Utils::isUnset($request->weight)) {
            $query['Weight'] = $request->weight;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyVpnPbrRouteEntryAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyVpnPbrRouteEntryAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the weight and priority of a policy-based route.
     *  *
     * @description *   You can call the **ModifyVpnPbrRouteEntryAttribute** operation to modify the weight and priority of a policy-based route.
     *     *   If you want to modify only the weight of a policy-based route, call [ModifyVpnPbrRouteEntryWeight](https://help.aliyun.com/document_detail/127249.html).
     *     *   If you want to modify only the priority of a policy-based route, call [ModifyVpnPbrRouteEntryPriority](https://help.aliyun.com/document_detail/466870.html).
     *     *   If a policy-based route does not support priorities, you can only call [ModifyVpnPbrRouteEntryWeight](https://help.aliyun.com/document_detail/127249.html) to modify its weight.
     * *   The **ModifyVpnPbrRouteEntryAttribute** operation is asynchronous. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of a VPN gateway.
     *     *   If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
     *     *   If a VPN gateway is in the **active** state, the policy-based route entry is modified.
     * *   You cannot repeatedly call the **ModifyVpnPbrRouteEntryAttribute** operation for the same VPN gateway within the specified period of time.
     *  *
     * @param ModifyVpnPbrRouteEntryAttributeRequest $request ModifyVpnPbrRouteEntryAttributeRequest
     *
     * @return ModifyVpnPbrRouteEntryAttributeResponse ModifyVpnPbrRouteEntryAttributeResponse
     */
    public function modifyVpnPbrRouteEntryAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVpnPbrRouteEntryAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the priority of a policy-based route.
     *  *
     * @description *   **ModifyVpnPbrRouteEntryPriority** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
     *     *   If the VPN gateway is in the **active** state, the policy-based route is created.
     * *   You cannot repeatedly call the **ModifyVpnPbrRouteEntryPriority** operation for the same VPN gateway within the specified period of time.
     *  *
     * @param ModifyVpnPbrRouteEntryPriorityRequest $request ModifyVpnPbrRouteEntryPriorityRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyVpnPbrRouteEntryPriorityResponse ModifyVpnPbrRouteEntryPriorityResponse
     */
    public function modifyVpnPbrRouteEntryPriorityWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->newPriority)) {
            $query['NewPriority'] = $request->newPriority;
        }
        if (!Utils::isUnset($request->nextHop)) {
            $query['NextHop'] = $request->nextHop;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->priority)) {
            $query['Priority'] = $request->priority;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeDest)) {
            $query['RouteDest'] = $request->routeDest;
        }
        if (!Utils::isUnset($request->routeSource)) {
            $query['RouteSource'] = $request->routeSource;
        }
        if (!Utils::isUnset($request->vpnGatewayId)) {
            $query['VpnGatewayId'] = $request->vpnGatewayId;
        }
        if (!Utils::isUnset($request->weight)) {
            $query['Weight'] = $request->weight;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyVpnPbrRouteEntryPriority',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyVpnPbrRouteEntryPriorityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the priority of a policy-based route.
     *  *
     * @description *   **ModifyVpnPbrRouteEntryPriority** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
     *     *   If the VPN gateway is in the **active** state, the policy-based route is created.
     * *   You cannot repeatedly call the **ModifyVpnPbrRouteEntryPriority** operation for the same VPN gateway within the specified period of time.
     *  *
     * @param ModifyVpnPbrRouteEntryPriorityRequest $request ModifyVpnPbrRouteEntryPriorityRequest
     *
     * @return ModifyVpnPbrRouteEntryPriorityResponse ModifyVpnPbrRouteEntryPriorityResponse
     */
    public function modifyVpnPbrRouteEntryPriority($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVpnPbrRouteEntryPriorityWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the weight of a policy-based route of a VPN gateway.
     *  *
     * @description *   **ModifyVpnPbrRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
     *     *   If a VPN gateway is in the **active** state, the policy-based route entry is modified.
     * *   You cannot repeatedly call the **ModifyVpnPbrRouteEntryWeight** operation for the same VPN gateway within the specified period of time.
     *  *
     * @param ModifyVpnPbrRouteEntryWeightRequest $request ModifyVpnPbrRouteEntryWeightRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyVpnPbrRouteEntryWeightResponse ModifyVpnPbrRouteEntryWeightResponse
     */
    public function modifyVpnPbrRouteEntryWeightWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->newWeight)) {
            $query['NewWeight'] = $request->newWeight;
        }
        if (!Utils::isUnset($request->nextHop)) {
            $query['NextHop'] = $request->nextHop;
        }
        if (!Utils::isUnset($request->overlayMode)) {
            $query['OverlayMode'] = $request->overlayMode;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->priority)) {
            $query['Priority'] = $request->priority;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeDest)) {
            $query['RouteDest'] = $request->routeDest;
        }
        if (!Utils::isUnset($request->routeSource)) {
            $query['RouteSource'] = $request->routeSource;
        }
        if (!Utils::isUnset($request->vpnGatewayId)) {
            $query['VpnGatewayId'] = $request->vpnGatewayId;
        }
        if (!Utils::isUnset($request->weight)) {
            $query['Weight'] = $request->weight;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyVpnPbrRouteEntryWeight',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyVpnPbrRouteEntryWeightResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the weight of a policy-based route of a VPN gateway.
     *  *
     * @description *   **ModifyVpnPbrRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
     *     *   If a VPN gateway is in the **active** state, the policy-based route entry is modified.
     * *   You cannot repeatedly call the **ModifyVpnPbrRouteEntryWeight** operation for the same VPN gateway within the specified period of time.
     *  *
     * @param ModifyVpnPbrRouteEntryWeightRequest $request ModifyVpnPbrRouteEntryWeightRequest
     *
     * @return ModifyVpnPbrRouteEntryWeightResponse ModifyVpnPbrRouteEntryWeightResponse
     */
    public function modifyVpnPbrRouteEntryWeight($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVpnPbrRouteEntryWeightWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the weight of a destination-based route.
     *  *
     * @description *   In scenarios where a VPN gateway has an active and a standby destination-based route, if you need to modify the weight of the active destination-based route, you must first delete the standby destination-based route. After you modify the active destination-based route, configure a standby destination-based route. If you need to modify the weight of the standby destination-based route, you also need to delete the active destination-based route first. After you modify the standby destination-based route, configure an active destination-based route. For more information about how to delete a destination-based route, see [DeleteVpnRouteEntry](https://help.aliyun.com/document_detail/2526961.html).
     * *   **ModifyVpnRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the weight of the destination-based route is being modified.
     *     *   If the VPN gateway is in the **active** state, the weight of the destination-based route is modified.
     * *   You cannot repeatedly call the **ModifyVpnRouteEntryWeight** operation to modify the weight of destination-based route for the same VPN gateway within the specified period of time.
     *  *
     * @param ModifyVpnRouteEntryWeightRequest $request ModifyVpnRouteEntryWeightRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyVpnRouteEntryWeightResponse ModifyVpnRouteEntryWeightResponse
     */
    public function modifyVpnRouteEntryWeightWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->newWeight)) {
            $query['NewWeight'] = $request->newWeight;
        }
        if (!Utils::isUnset($request->nextHop)) {
            $query['NextHop'] = $request->nextHop;
        }
        if (!Utils::isUnset($request->overlayMode)) {
            $query['OverlayMode'] = $request->overlayMode;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeDest)) {
            $query['RouteDest'] = $request->routeDest;
        }
        if (!Utils::isUnset($request->vpnGatewayId)) {
            $query['VpnGatewayId'] = $request->vpnGatewayId;
        }
        if (!Utils::isUnset($request->weight)) {
            $query['Weight'] = $request->weight;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyVpnRouteEntryWeight',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyVpnRouteEntryWeightResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the weight of a destination-based route.
     *  *
     * @description *   In scenarios where a VPN gateway has an active and a standby destination-based route, if you need to modify the weight of the active destination-based route, you must first delete the standby destination-based route. After you modify the active destination-based route, configure a standby destination-based route. If you need to modify the weight of the standby destination-based route, you also need to delete the active destination-based route first. After you modify the standby destination-based route, configure an active destination-based route. For more information about how to delete a destination-based route, see [DeleteVpnRouteEntry](https://help.aliyun.com/document_detail/2526961.html).
     * *   **ModifyVpnRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the weight of the destination-based route is being modified.
     *     *   If the VPN gateway is in the **active** state, the weight of the destination-based route is modified.
     * *   You cannot repeatedly call the **ModifyVpnRouteEntryWeight** operation to modify the weight of destination-based route for the same VPN gateway within the specified period of time.
     *  *
     * @param ModifyVpnRouteEntryWeightRequest $request ModifyVpnRouteEntryWeightRequest
     *
     * @return ModifyVpnRouteEntryWeightResponse ModifyVpnRouteEntryWeightResponse
     */
    public function modifyVpnRouteEntryWeight($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVpnRouteEntryWeightWithOptions($request, $runtime);
    }

    /**
     * @summary Moves a resource to another resource group.
     *  *
     * @param MoveResourceGroupRequest $request MoveResourceGroupRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return MoveResourceGroupResponse MoveResourceGroupResponse
     */
    public function moveResourceGroupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->newResourceGroupId)) {
            $query['NewResourceGroupId'] = $request->newResourceGroupId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceId)) {
            $query['ResourceId'] = $request->resourceId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->resourceType)) {
            $query['ResourceType'] = $request->resourceType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'MoveResourceGroup',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return MoveResourceGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Moves a resource to another resource group.
     *  *
     * @param MoveResourceGroupRequest $request MoveResourceGroupRequest
     *
     * @return MoveResourceGroupResponse MoveResourceGroupResponse
     */
    public function moveResourceGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->moveResourceGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Moves a VPN gateway resource to a new resource group.
     *  *
     * @param MoveVpnResourceGroupRequest $request MoveVpnResourceGroupRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return MoveVpnResourceGroupResponse MoveVpnResourceGroupResponse
     */
    public function moveVpnResourceGroupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->newResourceGroupId)) {
            $query['NewResourceGroupId'] = $request->newResourceGroupId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->resourceType)) {
            $query['ResourceType'] = $request->resourceType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'MoveVpnResourceGroup',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return MoveVpnResourceGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Moves a VPN gateway resource to a new resource group.
     *  *
     * @param MoveVpnResourceGroupRequest $request MoveVpnResourceGroupRequest
     *
     * @return MoveVpnResourceGroupResponse MoveVpnResourceGroupResponse
     */
    public function moveVpnResourceGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->moveVpnResourceGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Enables the flow log feature.
     *  *
     * @description *   You cannot repeatedly call the **OpenFlowLogService** operation within the specified period of time by using an Alibaba Cloud account.
     * *   You can call the [GetFlowLogServiceStatus](https://help.aliyun.com/document_detail/449624.html) operation to query the status of the flow log feature.
     *  *
     * @param OpenFlowLogServiceRequest $request OpenFlowLogServiceRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return OpenFlowLogServiceResponse OpenFlowLogServiceResponse
     */
    public function openFlowLogServiceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OpenFlowLogService',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OpenFlowLogServiceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables the flow log feature.
     *  *
     * @description *   You cannot repeatedly call the **OpenFlowLogService** operation within the specified period of time by using an Alibaba Cloud account.
     * *   You can call the [GetFlowLogServiceStatus](https://help.aliyun.com/document_detail/449624.html) operation to query the status of the flow log feature.
     *  *
     * @param OpenFlowLogServiceRequest $request OpenFlowLogServiceRequest
     *
     * @return OpenFlowLogServiceResponse OpenFlowLogServiceResponse
     */
    public function openFlowLogService($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->openFlowLogServiceWithOptions($request, $runtime);
    }

    /**
     * @summary Enables billing for outbound data transfer.
     *  *
     * @param OpenPhysicalConnectionServiceRequest $request OpenPhysicalConnectionServiceRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return OpenPhysicalConnectionServiceResponse OpenPhysicalConnectionServiceResponse
     */
    public function openPhysicalConnectionServiceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OpenPhysicalConnectionService',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OpenPhysicalConnectionServiceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables billing for outbound data transfer.
     *  *
     * @param OpenPhysicalConnectionServiceRequest $request OpenPhysicalConnectionServiceRequest
     *
     * @return OpenPhysicalConnectionServiceResponse OpenPhysicalConnectionServiceResponse
     */
    public function openPhysicalConnectionService($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->openPhysicalConnectionServiceWithOptions($request, $runtime);
    }

    /**
     * @summary 开通IP地址池功能。
     *  *
     * @param OpenPublicIpAddressPoolServiceRequest $request OpenPublicIpAddressPoolServiceRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return OpenPublicIpAddressPoolServiceResponse OpenPublicIpAddressPoolServiceResponse
     */
    public function openPublicIpAddressPoolServiceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OpenPublicIpAddressPoolService',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OpenPublicIpAddressPoolServiceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 开通IP地址池功能。
     *  *
     * @param OpenPublicIpAddressPoolServiceRequest $request OpenPublicIpAddressPoolServiceRequest
     *
     * @return OpenPublicIpAddressPoolServiceResponse OpenPublicIpAddressPoolServiceResponse
     */
    public function openPublicIpAddressPoolService($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->openPublicIpAddressPoolServiceWithOptions($request, $runtime);
    }

    /**
     * @summary Enables traffic mirroring.
     *  *
     * @description ## [](#)Usage notes
     * You can enable traffic mirroring for different regions. You cannot repeatedly call the **OpenTrafficMirrorService** operation to enable traffic mirroring for one region within the specified period of time.
     *  *
     * @param OpenTrafficMirrorServiceRequest $request OpenTrafficMirrorServiceRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return OpenTrafficMirrorServiceResponse OpenTrafficMirrorServiceResponse
     */
    public function openTrafficMirrorServiceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OpenTrafficMirrorService',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OpenTrafficMirrorServiceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables traffic mirroring.
     *  *
     * @description ## [](#)Usage notes
     * You can enable traffic mirroring for different regions. You cannot repeatedly call the **OpenTrafficMirrorService** operation to enable traffic mirroring for one region within the specified period of time.
     *  *
     * @param OpenTrafficMirrorServiceRequest $request OpenTrafficMirrorServiceRequest
     *
     * @return OpenTrafficMirrorServiceResponse OpenTrafficMirrorServiceResponse
     */
    public function openTrafficMirrorService($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->openTrafficMirrorServiceWithOptions($request, $runtime);
    }

    /**
     * @summary 发布VPC路由
     *  *
     * @param PublishVpcRouteEntriesRequest $request PublishVpcRouteEntriesRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return PublishVpcRouteEntriesResponse PublishVpcRouteEntriesResponse
     */
    public function publishVpcRouteEntriesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeEntries)) {
            $query['RouteEntries'] = $request->routeEntries;
        }
        if (!Utils::isUnset($request->targetInstanceId)) {
            $query['TargetInstanceId'] = $request->targetInstanceId;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'PublishVpcRouteEntries',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return PublishVpcRouteEntriesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 发布VPC路由
     *  *
     * @param PublishVpcRouteEntriesRequest $request PublishVpcRouteEntriesRequest
     *
     * @return PublishVpcRouteEntriesResponse PublishVpcRouteEntriesResponse
     */
    public function publishVpcRouteEntries($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->publishVpcRouteEntriesWithOptions($request, $runtime);
    }

    /**
     * @summary Advertises a VPN route to a VPC.
     *  *
     * @param PublishVpnRouteEntryRequest $request PublishVpnRouteEntryRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return PublishVpnRouteEntryResponse PublishVpnRouteEntryResponse
     */
    public function publishVpnRouteEntryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->nextHop)) {
            $query['NextHop'] = $request->nextHop;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->publishVpc)) {
            $query['PublishVpc'] = $request->publishVpc;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeDest)) {
            $query['RouteDest'] = $request->routeDest;
        }
        if (!Utils::isUnset($request->routeType)) {
            $query['RouteType'] = $request->routeType;
        }
        if (!Utils::isUnset($request->vpnGatewayId)) {
            $query['VpnGatewayId'] = $request->vpnGatewayId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'PublishVpnRouteEntry',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return PublishVpnRouteEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Advertises a VPN route to a VPC.
     *  *
     * @param PublishVpnRouteEntryRequest $request PublishVpnRouteEntryRequest
     *
     * @return PublishVpnRouteEntryResponse PublishVpnRouteEntryResponse
     */
    public function publishVpnRouteEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->publishVpnRouteEntryWithOptions($request, $runtime);
    }

    /**
     * @summary Resumes an Express Connect circuit.
     *  *
     * @description # [](#)Description
     * You can call this API operation to resume a suspended Express Connect circuit. You can resume only shared Express Connect circuits by calling this API operation.
     *  *
     * @param RecoverPhysicalConnectionRequest $request RecoverPhysicalConnectionRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return RecoverPhysicalConnectionResponse RecoverPhysicalConnectionResponse
     */
    public function recoverPhysicalConnectionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->token)) {
            $query['Token'] = $request->token;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'RecoverPhysicalConnection',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RecoverPhysicalConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Resumes an Express Connect circuit.
     *  *
     * @description # [](#)Description
     * You can call this API operation to resume a suspended Express Connect circuit. You can resume only shared Express Connect circuits by calling this API operation.
     *  *
     * @param RecoverPhysicalConnectionRequest $request RecoverPhysicalConnectionRequest
     *
     * @return RecoverPhysicalConnectionResponse RecoverPhysicalConnectionResponse
     */
    public function recoverPhysicalConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->recoverPhysicalConnectionWithOptions($request, $runtime);
    }

    /**
     * @summary Enables a disabled virtual border router (VBR).
     *  *
     * @description After you call this operation, the VBR changes from the **terminated** state to the **recovering** state. After the operation is performed, the VBR enters the **active** state.
     * When you call this operation, take note of the following items:
     * *   Only the owner of the Express Connect circuit can call this operation.
     * *   The Express Connect circuit to which the VBR connects must be in the **Enabled** state.
     *  *
     * @param RecoverVirtualBorderRouterRequest $request RecoverVirtualBorderRouterRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return RecoverVirtualBorderRouterResponse RecoverVirtualBorderRouterResponse
     */
    public function recoverVirtualBorderRouterWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vbrId)) {
            $query['VbrId'] = $request->vbrId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'RecoverVirtualBorderRouter',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RecoverVirtualBorderRouterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables a disabled virtual border router (VBR).
     *  *
     * @description After you call this operation, the VBR changes from the **terminated** state to the **recovering** state. After the operation is performed, the VBR enters the **active** state.
     * When you call this operation, take note of the following items:
     * *   Only the owner of the Express Connect circuit can call this operation.
     * *   The Express Connect circuit to which the VBR connects must be in the **Enabled** state.
     *  *
     * @param RecoverVirtualBorderRouterRequest $request RecoverVirtualBorderRouterRequest
     *
     * @return RecoverVirtualBorderRouterResponse RecoverVirtualBorderRouterResponse
     */
    public function recoverVirtualBorderRouter($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->recoverVirtualBorderRouterWithOptions($request, $runtime);
    }

    /**
     * @summary Releases an elastic IP address (EIP).
     *  *
     * @description Before you call this operation, take note of the following items:
     * *   Before you release an EIP, make sure that the EIP meets the following requirements:
     *     *   You can release only an EIP that is in the **Available** state.
     *     *   You can release only a pay-as-you-go EIP. You cannot release a subscription EIP.
     * *   **ReleaseEipAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task:
     *     *   If the EIP is in the **Releasing** state, the EIP is being released. In this state, you can only query the EIP and cannot perform other operations.
     *     *   If you cannot query the EIP, the EIP is released.
     * *   You cannot repeatedly call the **ReleaseEipAddress** operation to release an EIP within the specified period of time.
     *  *
     * @param ReleaseEipAddressRequest $request ReleaseEipAddressRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ReleaseEipAddressResponse ReleaseEipAddressResponse
     */
    public function releaseEipAddressWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->allocationId)) {
            $query['AllocationId'] = $request->allocationId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ReleaseEipAddress',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ReleaseEipAddressResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Releases an elastic IP address (EIP).
     *  *
     * @description Before you call this operation, take note of the following items:
     * *   Before you release an EIP, make sure that the EIP meets the following requirements:
     *     *   You can release only an EIP that is in the **Available** state.
     *     *   You can release only a pay-as-you-go EIP. You cannot release a subscription EIP.
     * *   **ReleaseEipAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task:
     *     *   If the EIP is in the **Releasing** state, the EIP is being released. In this state, you can only query the EIP and cannot perform other operations.
     *     *   If you cannot query the EIP, the EIP is released.
     * *   You cannot repeatedly call the **ReleaseEipAddress** operation to release an EIP within the specified period of time.
     *  *
     * @param ReleaseEipAddressRequest $request ReleaseEipAddressRequest
     *
     * @return ReleaseEipAddressResponse ReleaseEipAddressResponse
     */
    public function releaseEipAddress($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->releaseEipAddressWithOptions($request, $runtime);
    }

    /**
     * @summary Releases contiguous elastic IP addresses (EIPs).
     *  *
     * @description *   After you call the **ReleaseEipSegmentAddress** operation, all EIPs in the specified group are released.
     * *   **ReleaseEipSegmentAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipSegment](https://help.aliyun.com/document_detail/156063.html) operation to query the status of the task.
     *     *   If the group is in the **Releasing** state, EIPs in the group are being released. In this state, you can only query the group and cannot perform other operations.
     *     *   If you cannot query the group of contiguous EIPs, the contiguous EIPs are released.
     * *   You cannot repeatedly call the **ReleaseEipSegmentAddress** operation to release a group of contiguous EIPs within the specified period of time.
     *  *
     * @param ReleaseEipSegmentAddressRequest $request ReleaseEipSegmentAddressRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return ReleaseEipSegmentAddressResponse ReleaseEipSegmentAddressResponse
     */
    public function releaseEipSegmentAddressWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->segmentInstanceId)) {
            $query['SegmentInstanceId'] = $request->segmentInstanceId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ReleaseEipSegmentAddress',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ReleaseEipSegmentAddressResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Releases contiguous elastic IP addresses (EIPs).
     *  *
     * @description *   After you call the **ReleaseEipSegmentAddress** operation, all EIPs in the specified group are released.
     * *   **ReleaseEipSegmentAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipSegment](https://help.aliyun.com/document_detail/156063.html) operation to query the status of the task.
     *     *   If the group is in the **Releasing** state, EIPs in the group are being released. In this state, you can only query the group and cannot perform other operations.
     *     *   If you cannot query the group of contiguous EIPs, the contiguous EIPs are released.
     * *   You cannot repeatedly call the **ReleaseEipSegmentAddress** operation to release a group of contiguous EIPs within the specified period of time.
     *  *
     * @param ReleaseEipSegmentAddressRequest $request ReleaseEipSegmentAddressRequest
     *
     * @return ReleaseEipSegmentAddressResponse ReleaseEipSegmentAddressResponse
     */
    public function releaseEipSegmentAddress($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->releaseEipSegmentAddressWithOptions($request, $runtime);
    }

    /**
     * @summary Releases an idle IPv6 address.
     *  *
     * @param ReleaseIpv6AddressRequest $request ReleaseIpv6AddressRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ReleaseIpv6AddressResponse ReleaseIpv6AddressResponse
     */
    public function releaseIpv6AddressWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ipv6AddressId)) {
            $query['Ipv6AddressId'] = $request->ipv6AddressId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ReleaseIpv6Address',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ReleaseIpv6AddressResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Releases an idle IPv6 address.
     *  *
     * @param ReleaseIpv6AddressRequest $request ReleaseIpv6AddressRequest
     *
     * @return ReleaseIpv6AddressResponse ReleaseIpv6AddressResponse
     */
    public function releaseIpv6Address($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->releaseIpv6AddressWithOptions($request, $runtime);
    }

    /**
     * @summary Disassociates an EIP from an Internet Shared Bandwidth instance.
     *  *
     * @param RemoveCommonBandwidthPackageIpRequest $request RemoveCommonBandwidthPackageIpRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return RemoveCommonBandwidthPackageIpResponse RemoveCommonBandwidthPackageIpResponse
     */
    public function removeCommonBandwidthPackageIpWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bandwidthPackageId)) {
            $query['BandwidthPackageId'] = $request->bandwidthPackageId;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ipInstanceId)) {
            $query['IpInstanceId'] = $request->ipInstanceId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'RemoveCommonBandwidthPackageIp',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RemoveCommonBandwidthPackageIpResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Disassociates an EIP from an Internet Shared Bandwidth instance.
     *  *
     * @param RemoveCommonBandwidthPackageIpRequest $request RemoveCommonBandwidthPackageIpRequest
     *
     * @return RemoveCommonBandwidthPackageIpResponse RemoveCommonBandwidthPackageIpResponse
     */
    public function removeCommonBandwidthPackageIp($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->removeCommonBandwidthPackageIpWithOptions($request, $runtime);
    }

    /**
     * @param RemoveGlobalAccelerationInstanceIpRequest $request RemoveGlobalAccelerationInstanceIpRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return RemoveGlobalAccelerationInstanceIpResponse RemoveGlobalAccelerationInstanceIpResponse
     */
    public function removeGlobalAccelerationInstanceIpWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->globalAccelerationInstanceId)) {
            $query['GlobalAccelerationInstanceId'] = $request->globalAccelerationInstanceId;
        }
        if (!Utils::isUnset($request->ipInstanceId)) {
            $query['IpInstanceId'] = $request->ipInstanceId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'RemoveGlobalAccelerationInstanceIp',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RemoveGlobalAccelerationInstanceIpResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param RemoveGlobalAccelerationInstanceIpRequest $request RemoveGlobalAccelerationInstanceIpRequest
     *
     * @return RemoveGlobalAccelerationInstanceIpResponse RemoveGlobalAccelerationInstanceIpResponse
     */
    public function removeGlobalAccelerationInstanceIp($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->removeGlobalAccelerationInstanceIpWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an IP entry from an ACL.
     *  *
     * @param RemoveIPv6TranslatorAclListEntryRequest $request RemoveIPv6TranslatorAclListEntryRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return RemoveIPv6TranslatorAclListEntryResponse RemoveIPv6TranslatorAclListEntryResponse
     */
    public function removeIPv6TranslatorAclListEntryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aclEntryId)) {
            $query['AclEntryId'] = $request->aclEntryId;
        }
        if (!Utils::isUnset($request->aclId)) {
            $query['AclId'] = $request->aclId;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'RemoveIPv6TranslatorAclListEntry',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RemoveIPv6TranslatorAclListEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an IP entry from an ACL.
     *  *
     * @param RemoveIPv6TranslatorAclListEntryRequest $request RemoveIPv6TranslatorAclListEntryRequest
     *
     * @return RemoveIPv6TranslatorAclListEntryResponse RemoveIPv6TranslatorAclListEntryResponse
     */
    public function removeIPv6TranslatorAclListEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->removeIPv6TranslatorAclListEntryWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a traffic mirror source from a traffic mirror session.
     *  *
     * @description *   **RemoveSourcesFromTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
     *     *   If the traffic mirror session is in the **Modifying** state, the traffic mirror source is being deleted.
     *     *   If the traffic mirror session is in the **Created** state, the traffic mirror source is deleted.
     * *   You cannot repeatedly call **RemoveSourcesFromTrafficMirrorSession** within the specified period of time.
     *  *
     * @param RemoveSourcesFromTrafficMirrorSessionRequest $request RemoveSourcesFromTrafficMirrorSessionRequest
     * @param RuntimeOptions                               $runtime runtime options for this request RuntimeOptions
     *
     * @return RemoveSourcesFromTrafficMirrorSessionResponse RemoveSourcesFromTrafficMirrorSessionResponse
     */
    public function removeSourcesFromTrafficMirrorSessionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->trafficMirrorSessionId)) {
            $query['TrafficMirrorSessionId'] = $request->trafficMirrorSessionId;
        }
        if (!Utils::isUnset($request->trafficMirrorSourceIds)) {
            $query['TrafficMirrorSourceIds'] = $request->trafficMirrorSourceIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'RemoveSourcesFromTrafficMirrorSession',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RemoveSourcesFromTrafficMirrorSessionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a traffic mirror source from a traffic mirror session.
     *  *
     * @description *   **RemoveSourcesFromTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
     *     *   If the traffic mirror session is in the **Modifying** state, the traffic mirror source is being deleted.
     *     *   If the traffic mirror session is in the **Created** state, the traffic mirror source is deleted.
     * *   You cannot repeatedly call **RemoveSourcesFromTrafficMirrorSession** within the specified period of time.
     *  *
     * @param RemoveSourcesFromTrafficMirrorSessionRequest $request RemoveSourcesFromTrafficMirrorSessionRequest
     *
     * @return RemoveSourcesFromTrafficMirrorSessionResponse RemoveSourcesFromTrafficMirrorSessionResponse
     */
    public function removeSourcesFromTrafficMirrorSession($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->removeSourcesFromTrafficMirrorSessionWithOptions($request, $runtime);
    }

    /**
     * @summary 更改DHCP选项集与VPC的关联。
     *  *
     * @description *   The **ReplaceVpcDhcpOptionsSet** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a DHCP options set:
     *     *   If the DHCP options set is in the **Pending** state, the DHCP options set is being replaced.
     *     *   If the DHCP options set is in the **InUse** state, the DHCP options set is replaced.
     * *   You cannot repeatedly call the **ReplaceVpcDhcpOptionsSet** operation to replace the DHCP options set associated with a VPC within the specified period of time.
     *  *
     * @param ReplaceVpcDhcpOptionsSetRequest $request ReplaceVpcDhcpOptionsSetRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return ReplaceVpcDhcpOptionsSetResponse ReplaceVpcDhcpOptionsSetResponse
     */
    public function replaceVpcDhcpOptionsSetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dhcpOptionsSetId)) {
            $query['DhcpOptionsSetId'] = $request->dhcpOptionsSetId;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ReplaceVpcDhcpOptionsSet',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ReplaceVpcDhcpOptionsSetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 更改DHCP选项集与VPC的关联。
     *  *
     * @description *   The **ReplaceVpcDhcpOptionsSet** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a DHCP options set:
     *     *   If the DHCP options set is in the **Pending** state, the DHCP options set is being replaced.
     *     *   If the DHCP options set is in the **InUse** state, the DHCP options set is replaced.
     * *   You cannot repeatedly call the **ReplaceVpcDhcpOptionsSet** operation to replace the DHCP options set associated with a VPC within the specified period of time.
     *  *
     * @param ReplaceVpcDhcpOptionsSetRequest $request ReplaceVpcDhcpOptionsSetRequest
     *
     * @return ReplaceVpcDhcpOptionsSetResponse ReplaceVpcDhcpOptionsSetResponse
     */
    public function replaceVpcDhcpOptionsSet($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->replaceVpcDhcpOptionsSetWithOptions($request, $runtime);
    }

    /**
     * @summary Re-applies a prefix list.
     *  *
     * @description *   If you modify the information about a prefix list but the modification is not automatically applied to the route table that is associated with the prefix list, you can call this operation to apply the latest prefix list to the associated route table.
     * *   The **RetryVpcPrefixListAssociation** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the background. You can call the [GetVpcPrefixListAssociations](https://help.aliyun.com/document_detail/445478.html) to check whether the prefix list is re-applied.
     *     *   If the prefix list is in the **Modifying** state, the prefix list is being re-applied.
     *     *   If the prefix list is in the **ModifyFailed** state, the prefix list fails to be re-applied.
     *     *   If the prefix list is in the **Created** state, the prefix list is re-applied.
     * *   After you call the **RetryVpcPrefixListAssociation** operation to re-apply a prefix list, you cannot call the operation again until the current task is complete.
     *  *
     * @param RetryVpcPrefixListAssociationRequest $request RetryVpcPrefixListAssociationRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return RetryVpcPrefixListAssociationResponse RetryVpcPrefixListAssociationResponse
     */
    public function retryVpcPrefixListAssociationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->prefixListId)) {
            $query['PrefixListId'] = $request->prefixListId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceId)) {
            $query['ResourceId'] = $request->resourceId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->resourceType)) {
            $query['ResourceType'] = $request->resourceType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'RetryVpcPrefixListAssociation',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RetryVpcPrefixListAssociationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Re-applies a prefix list.
     *  *
     * @description *   If you modify the information about a prefix list but the modification is not automatically applied to the route table that is associated with the prefix list, you can call this operation to apply the latest prefix list to the associated route table.
     * *   The **RetryVpcPrefixListAssociation** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the background. You can call the [GetVpcPrefixListAssociations](https://help.aliyun.com/document_detail/445478.html) to check whether the prefix list is re-applied.
     *     *   If the prefix list is in the **Modifying** state, the prefix list is being re-applied.
     *     *   If the prefix list is in the **ModifyFailed** state, the prefix list fails to be re-applied.
     *     *   If the prefix list is in the **Created** state, the prefix list is re-applied.
     * *   After you call the **RetryVpcPrefixListAssociation** operation to re-apply a prefix list, you cannot call the operation again until the current task is complete.
     *  *
     * @param RetryVpcPrefixListAssociationRequest $request RetryVpcPrefixListAssociationRequest
     *
     * @return RetryVpcPrefixListAssociationResponse RetryVpcPrefixListAssociationResponse
     */
    public function retryVpcPrefixListAssociation($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->retryVpcPrefixListAssociationWithOptions($request, $runtime);
    }

    /**
     * @summary Revokes the permissions granted to a Cloud Enterprise Network (CEN) instance on a network instance.
     *  *
     * @description ## [](#)Usage notes
     * *   **RevokeInstanceFromCen** is a Virtual Private Cloud (VPC) operation. Therefore, you must use `vpc.aliyuncs.com` as the domain name when you call this operation. The API version is `2016-04-28`.
     * *   You cannot repeatedly call the **RevokeInstanceFromCen** operation to revoke the permissions on a network instance that is attached to a CEN instance within the specified period of time. The network instance can be a VPC, virtual border router (VBR), or a Cloud Connect Network (CCN) instance.
     *  *
     * @param RevokeInstanceFromCenRequest $request RevokeInstanceFromCenRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return RevokeInstanceFromCenResponse RevokeInstanceFromCenResponse
     */
    public function revokeInstanceFromCenWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->cenId)) {
            $query['CenId'] = $request->cenId;
        }
        if (!Utils::isUnset($request->cenOwnerId)) {
            $query['CenOwnerId'] = $request->cenOwnerId;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->instanceType)) {
            $query['InstanceType'] = $request->instanceType;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'RevokeInstanceFromCen',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RevokeInstanceFromCenResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Revokes the permissions granted to a Cloud Enterprise Network (CEN) instance on a network instance.
     *  *
     * @description ## [](#)Usage notes
     * *   **RevokeInstanceFromCen** is a Virtual Private Cloud (VPC) operation. Therefore, you must use `vpc.aliyuncs.com` as the domain name when you call this operation. The API version is `2016-04-28`.
     * *   You cannot repeatedly call the **RevokeInstanceFromCen** operation to revoke the permissions on a network instance that is attached to a CEN instance within the specified period of time. The network instance can be a VPC, virtual border router (VBR), or a Cloud Connect Network (CCN) instance.
     *  *
     * @param RevokeInstanceFromCenRequest $request RevokeInstanceFromCenRequest
     *
     * @return RevokeInstanceFromCenResponse RevokeInstanceFromCenResponse
     */
    public function revokeInstanceFromCen($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->revokeInstanceFromCenWithOptions($request, $runtime);
    }

    /**
     * @summary Revokes the permissions granted to a virtual border router (VBR) on a virtual private cloud (VPC).
     *  *
     * @param RevokeInstanceFromVbrRequest $tmpReq  RevokeInstanceFromVbrRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return RevokeInstanceFromVbrResponse RevokeInstanceFromVbrResponse
     */
    public function revokeInstanceFromVbrWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new RevokeInstanceFromVbrShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->vbrInstanceIds)) {
            $request->vbrInstanceIdsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->vbrInstanceIds, 'VbrInstanceIds', 'simple');
        }
        $query = [];
        if (!Utils::isUnset($request->grantType)) {
            $query['GrantType'] = $request->grantType;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->vbrInstanceIdsShrink)) {
            $query['VbrInstanceIds'] = $request->vbrInstanceIdsShrink;
        }
        if (!Utils::isUnset($request->vbrOwnerUid)) {
            $query['VbrOwnerUid'] = $request->vbrOwnerUid;
        }
        if (!Utils::isUnset($request->vbrRegionNo)) {
            $query['VbrRegionNo'] = $request->vbrRegionNo;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'RevokeInstanceFromVbr',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RevokeInstanceFromVbrResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Revokes the permissions granted to a virtual border router (VBR) on a virtual private cloud (VPC).
     *  *
     * @param RevokeInstanceFromVbrRequest $request RevokeInstanceFromVbrRequest
     *
     * @return RevokeInstanceFromVbrResponse RevokeInstanceFromVbrResponse
     */
    public function revokeInstanceFromVbr($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->revokeInstanceFromVbrWithOptions($request, $runtime);
    }

    /**
     * @summary If your application for a Letter of Authorization (LOA) by calling the ApplyPhysicalConnectionLOA operation is denied, you can call this operation to apply again.
     *  *
     * @param SecondApplyPhysicalConnectionLOARequest $request SecondApplyPhysicalConnectionLOARequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return SecondApplyPhysicalConnectionLOAResponse SecondApplyPhysicalConnectionLOAResponse
     */
    public function secondApplyPhysicalConnectionLOAWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bandwidth)) {
            $query['Bandwidth'] = $request->bandwidth;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->companyName)) {
            $query['CompanyName'] = $request->companyName;
        }
        if (!Utils::isUnset($request->constructionTime)) {
            $query['ConstructionTime'] = $request->constructionTime;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->lineType)) {
            $query['LineType'] = $request->lineType;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->PMInfo)) {
            $query['PMInfo'] = $request->PMInfo;
        }
        if (!Utils::isUnset($request->peerLocation)) {
            $query['PeerLocation'] = $request->peerLocation;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->si)) {
            $query['Si'] = $request->si;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'SecondApplyPhysicalConnectionLOA',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SecondApplyPhysicalConnectionLOAResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary If your application for a Letter of Authorization (LOA) by calling the ApplyPhysicalConnectionLOA operation is denied, you can call this operation to apply again.
     *  *
     * @param SecondApplyPhysicalConnectionLOARequest $request SecondApplyPhysicalConnectionLOARequest
     *
     * @return SecondApplyPhysicalConnectionLOAResponse SecondApplyPhysicalConnectionLOAResponse
     */
    public function secondApplyPhysicalConnectionLOA($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->secondApplyPhysicalConnectionLOAWithOptions($request, $runtime);
    }

    /**
     * @summary Configures fine-grained monitoring for an elastic IP address (EIP).
     *  *
     * @description You cannot repeatedly call **SetHighDefinitionMonitorLogStatus** within a specific period of time.
     *  *
     * @param SetHighDefinitionMonitorLogStatusRequest $request SetHighDefinitionMonitorLogStatusRequest
     * @param RuntimeOptions                           $runtime runtime options for this request RuntimeOptions
     *
     * @return SetHighDefinitionMonitorLogStatusResponse SetHighDefinitionMonitorLogStatusResponse
     */
    public function setHighDefinitionMonitorLogStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->instanceType)) {
            $query['InstanceType'] = $request->instanceType;
        }
        if (!Utils::isUnset($request->logProject)) {
            $query['LogProject'] = $request->logProject;
        }
        if (!Utils::isUnset($request->logStore)) {
            $query['LogStore'] = $request->logStore;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'SetHighDefinitionMonitorLogStatus',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SetHighDefinitionMonitorLogStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures fine-grained monitoring for an elastic IP address (EIP).
     *  *
     * @description You cannot repeatedly call **SetHighDefinitionMonitorLogStatus** within a specific period of time.
     *  *
     * @param SetHighDefinitionMonitorLogStatusRequest $request SetHighDefinitionMonitorLogStatusRequest
     *
     * @return SetHighDefinitionMonitorLogStatusResponse SetHighDefinitionMonitorLogStatusResponse
     */
    public function setHighDefinitionMonitorLogStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setHighDefinitionMonitorLogStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Performs a failover test.
     *  *
     * @description You can perform only failover tests that are in the **Pending** state.
     *  *
     * @param StartFailoverTestJobRequest $request StartFailoverTestJobRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return StartFailoverTestJobResponse StartFailoverTestJobResponse
     */
    public function startFailoverTestJobWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->jobId)) {
            $query['JobId'] = $request->jobId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'StartFailoverTestJob',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return StartFailoverTestJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Performs a failover test.
     *  *
     * @description You can perform only failover tests that are in the **Pending** state.
     *  *
     * @param StartFailoverTestJobRequest $request StartFailoverTestJobRequest
     *
     * @return StartFailoverTestJobResponse StartFailoverTestJobResponse
     */
    public function startFailoverTestJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startFailoverTestJobWithOptions($request, $runtime);
    }

    /**
     * @summary 结束故障演练任务
     *  *
     * @param StopFailoverTestJobRequest $request StopFailoverTestJobRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return StopFailoverTestJobResponse StopFailoverTestJobResponse
     */
    public function stopFailoverTestJobWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->jobId)) {
            $query['JobId'] = $request->jobId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'StopFailoverTestJob',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return StopFailoverTestJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 结束故障演练任务
     *  *
     * @param StopFailoverTestJobRequest $request StopFailoverTestJobRequest
     *
     * @return StopFailoverTestJobResponse StopFailoverTestJobResponse
     */
    public function stopFailoverTestJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopFailoverTestJobWithOptions($request, $runtime);
    }

    /**
     * @summary Creates and adds tags to resources.
     *  *
     * @description Tags are used to classify instances. Each tag consists of a key-value pair. Before you use tags, take note of the following limits:
     * *   The keys of tags that are added to the same instance must be unique.
     * *   You cannot create tags without adding them to instances. All tags must be added to instances.
     * *   Tag information is not shared across regions.
     *     For example, you cannot view the tags that are created in the China (Hangzhou) region from the China (Shanghai) region.
     * *   Virtual private clouds (VPCs), route tables, vSwitches, and elastic IP addresses (EIPs) that belong to the same Alibaba Cloud account and are deployed in the same region share tag information with each other.
     *     For example, if you added a tag to a VPC, the tag is available to vSwitches, route tables, and EIPs that belong to the same account and are deployed in the same region in which the VPC is created. You can select this tag from the editing page without the need to enter the tag again. You can modify the key and the value of a tag or remove a tag from an instance. After you delete an instance, all tags that are added to the instance are deleted.
     * *   You can add up to 20 tags to each instance. Before you add a tag to an instance, the system automatically checks the number of existing tags. An error message is returned if the maximum number of tags is reached.
     *  *
     * @param TagResourcesRequest $request TagResourcesRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return TagResourcesResponse TagResourcesResponse
     */
    public function tagResourcesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceId)) {
            $query['ResourceId'] = $request->resourceId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->resourceType)) {
            $query['ResourceType'] = $request->resourceType;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'TagResources',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return TagResourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates and adds tags to resources.
     *  *
     * @description Tags are used to classify instances. Each tag consists of a key-value pair. Before you use tags, take note of the following limits:
     * *   The keys of tags that are added to the same instance must be unique.
     * *   You cannot create tags without adding them to instances. All tags must be added to instances.
     * *   Tag information is not shared across regions.
     *     For example, you cannot view the tags that are created in the China (Hangzhou) region from the China (Shanghai) region.
     * *   Virtual private clouds (VPCs), route tables, vSwitches, and elastic IP addresses (EIPs) that belong to the same Alibaba Cloud account and are deployed in the same region share tag information with each other.
     *     For example, if you added a tag to a VPC, the tag is available to vSwitches, route tables, and EIPs that belong to the same account and are deployed in the same region in which the VPC is created. You can select this tag from the editing page without the need to enter the tag again. You can modify the key and the value of a tag or remove a tag from an instance. After you delete an instance, all tags that are added to the instance are deleted.
     * *   You can add up to 20 tags to each instance. Before you add a tag to an instance, the system automatically checks the number of existing tags. An error message is returned if the maximum number of tags is reached.
     *  *
     * @param TagResourcesRequest $request TagResourcesRequest
     *
     * @return TagResourcesResponse TagResourcesResponse
     */
    public function tagResources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->tagResourcesWithOptions($request, $runtime);
    }

    /**
     * @summary Creates tags and adds the tags to an Express Connect circuit.
     *  *
     * @description ## [](#)
     * Tags are used to classify instances. Each tag consists of a key-value pair. Before you use tags, take note of the following items:
     * *   Each tag key that is added to an instance must be unique.
     * *   You cannot create tags without adding them to instances. All tags must be added to instances.
     * *   Tag information is not shared across regions.
     *     For example, you cannot view the tags that are created in the China (Hangzhou) region from the China (Shanghai) region.
     * *   You can add up to 20 tags to each instance. Before you add a tag to an instance, the system automatically checks the number of existing tags. An error message is returned if the maximum number of tags is reached.
     *  *
     * @param TagResourcesForExpressConnectRequest $request TagResourcesForExpressConnectRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return TagResourcesForExpressConnectResponse TagResourcesForExpressConnectResponse
     */
    public function tagResourcesForExpressConnectWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceId)) {
            $query['ResourceId'] = $request->resourceId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->resourceType)) {
            $query['ResourceType'] = $request->resourceType;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'TagResourcesForExpressConnect',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return TagResourcesForExpressConnectResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates tags and adds the tags to an Express Connect circuit.
     *  *
     * @description ## [](#)
     * Tags are used to classify instances. Each tag consists of a key-value pair. Before you use tags, take note of the following items:
     * *   Each tag key that is added to an instance must be unique.
     * *   You cannot create tags without adding them to instances. All tags must be added to instances.
     * *   Tag information is not shared across regions.
     *     For example, you cannot view the tags that are created in the China (Hangzhou) region from the China (Shanghai) region.
     * *   You can add up to 20 tags to each instance. Before you add a tag to an instance, the system automatically checks the number of existing tags. An error message is returned if the maximum number of tags is reached.
     *  *
     * @param TagResourcesForExpressConnectRequest $request TagResourcesForExpressConnectRequest
     *
     * @return TagResourcesForExpressConnectResponse TagResourcesForExpressConnectResponse
     */
    public function tagResourcesForExpressConnect($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->tagResourcesForExpressConnectWithOptions($request, $runtime);
    }

    /**
     * @summary Disables an Express Connect circuit after it is enabled.
     *  *
     * @description After you call this operation, the specified Express Connect circuit changes to the **Terminating** state. After the Express Connect circuit is disabled, it changes to the **Terminated** state. When you call this operation, take note of the following limits:
     * *   You can only disable an Express Connect circuit that is in the **Enabled** state.
     * *   Before you disable an Express Connect circuit, you must delete the virtual border routers (VBRs) associated with it.
     *  *
     * @param TerminatePhysicalConnectionRequest $request TerminatePhysicalConnectionRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return TerminatePhysicalConnectionResponse TerminatePhysicalConnectionResponse
     */
    public function terminatePhysicalConnectionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->physicalConnectionId)) {
            $query['PhysicalConnectionId'] = $request->physicalConnectionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'TerminatePhysicalConnection',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return TerminatePhysicalConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Disables an Express Connect circuit after it is enabled.
     *  *
     * @description After you call this operation, the specified Express Connect circuit changes to the **Terminating** state. After the Express Connect circuit is disabled, it changes to the **Terminated** state. When you call this operation, take note of the following limits:
     * *   You can only disable an Express Connect circuit that is in the **Enabled** state.
     * *   Before you disable an Express Connect circuit, you must delete the virtual border routers (VBRs) associated with it.
     *  *
     * @param TerminatePhysicalConnectionRequest $request TerminatePhysicalConnectionRequest
     *
     * @return TerminatePhysicalConnectionResponse TerminatePhysicalConnectionResponse
     */
    public function terminatePhysicalConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->terminatePhysicalConnectionWithOptions($request, $runtime);
    }

    /**
     * @summary Terminates a virtual border router (VBR).
     *  *
     * @description After you call this operation, the VBR enters the **terminating** state from the **active** state. After the VBR is terminated, the VBR enters the **terminated** state.
     * >  Only the owner of an Express Connect circuit can call this operation.
     *  *
     * @param TerminateVirtualBorderRouterRequest $request TerminateVirtualBorderRouterRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return TerminateVirtualBorderRouterResponse TerminateVirtualBorderRouterResponse
     */
    public function terminateVirtualBorderRouterWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vbrId)) {
            $query['VbrId'] = $request->vbrId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'TerminateVirtualBorderRouter',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return TerminateVirtualBorderRouterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Terminates a virtual border router (VBR).
     *  *
     * @description After you call this operation, the VBR enters the **terminating** state from the **active** state. After the VBR is terminated, the VBR enters the **terminated** state.
     * >  Only the owner of an Express Connect circuit can call this operation.
     *  *
     * @param TerminateVirtualBorderRouterRequest $request TerminateVirtualBorderRouterRequest
     *
     * @return TerminateVirtualBorderRouterResponse TerminateVirtualBorderRouterResponse
     */
    public function terminateVirtualBorderRouter($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->terminateVirtualBorderRouterWithOptions($request, $runtime);
    }

    /**
     * @summary Removes tags from resources.
     *  *
     * @param UnTagResourcesRequest $request UnTagResourcesRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return UnTagResourcesResponse UnTagResourcesResponse
     */
    public function unTagResourcesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->all)) {
            $query['All'] = $request->all;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceId)) {
            $query['ResourceId'] = $request->resourceId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->resourceType)) {
            $query['ResourceType'] = $request->resourceType;
        }
        if (!Utils::isUnset($request->tagKey)) {
            $query['TagKey'] = $request->tagKey;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UnTagResources',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UnTagResourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Removes tags from resources.
     *  *
     * @param UnTagResourcesRequest $request UnTagResourcesRequest
     *
     * @return UnTagResourcesResponse UnTagResourcesResponse
     */
    public function unTagResources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->unTagResourcesWithOptions($request, $runtime);
    }

    /**
     * @summary Disassociates an elastic IP address (EIP) from a cloud resource.
     *  *
     * @description *   **UnassociateEipAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
     *     *   If the EIP is in the **Unassociating** state, the EIP is being disassociated. In this state, you can only query the EIP and cannot perform other operations.
     *     *   If the EIP is in the **Available** state, the EIP is disassociated.
     * *   You cannot repeatedly call the **UnassociateEipAddress** operation within the specified period of time.
     *  *
     * @param UnassociateEipAddressRequest $request UnassociateEipAddressRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return UnassociateEipAddressResponse UnassociateEipAddressResponse
     */
    public function unassociateEipAddressWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->allocationId)) {
            $query['AllocationId'] = $request->allocationId;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->force)) {
            $query['Force'] = $request->force;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->instanceType)) {
            $query['InstanceType'] = $request->instanceType;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->privateIpAddress)) {
            $query['PrivateIpAddress'] = $request->privateIpAddress;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UnassociateEipAddress',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UnassociateEipAddressResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Disassociates an elastic IP address (EIP) from a cloud resource.
     *  *
     * @description *   **UnassociateEipAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
     *     *   If the EIP is in the **Unassociating** state, the EIP is being disassociated. In this state, you can only query the EIP and cannot perform other operations.
     *     *   If the EIP is in the **Available** state, the EIP is disassociated.
     * *   You cannot repeatedly call the **UnassociateEipAddress** operation within the specified period of time.
     *  *
     * @param UnassociateEipAddressRequest $request UnassociateEipAddressRequest
     *
     * @return UnassociateEipAddressResponse UnassociateEipAddressResponse
     */
    public function unassociateEipAddress($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->unassociateEipAddressWithOptions($request, $runtime);
    }

    /**
     * @summary Disassociates a Global Accelerator (GA) instance from a backend server.
     *  *
     * @param UnassociateGlobalAccelerationInstanceRequest $request UnassociateGlobalAccelerationInstanceRequest
     * @param RuntimeOptions                               $runtime runtime options for this request RuntimeOptions
     *
     * @return UnassociateGlobalAccelerationInstanceResponse UnassociateGlobalAccelerationInstanceResponse
     */
    public function unassociateGlobalAccelerationInstanceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->globalAccelerationInstanceId)) {
            $query['GlobalAccelerationInstanceId'] = $request->globalAccelerationInstanceId;
        }
        if (!Utils::isUnset($request->instanceType)) {
            $query['InstanceType'] = $request->instanceType;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UnassociateGlobalAccelerationInstance',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UnassociateGlobalAccelerationInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Disassociates a Global Accelerator (GA) instance from a backend server.
     *  *
     * @param UnassociateGlobalAccelerationInstanceRequest $request UnassociateGlobalAccelerationInstanceRequest
     *
     * @return UnassociateGlobalAccelerationInstanceResponse UnassociateGlobalAccelerationInstanceResponse
     */
    public function unassociateGlobalAccelerationInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->unassociateGlobalAccelerationInstanceWithOptions($request, $runtime);
    }

    /**
     * @summary Disassociates a high-availability virtual IP address (HAVIP) from an Elastic Compute Service (ECS) in a virtual private cloud (VPC) or from an elastic network interface (ENI).
     *  *
     * @description ## [](#)
     * When you call this operation, take note of the following limits:
     * *   The ECS instance must be in the **Running** or **Stopped** state.
     * *   The HAVIP must be in the **Available** or **InUse** state.
     * *   **UnassociateHaVip** is an asynchronous operation. After a request is sent, the system returns a request ID and an instance ID and runs the task in the background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HAVIP:
     *     *   If the HAVIP is in the **Unassociating** state, the HAVIP is being disassociated.
     *     *   If the HAVIP is in the **Inuse** or **Available** state, the HAVIP is disassociated.
     * *   You cannot repeatedly call the **UnassociateHaVip** operation to disassociate an HAVIP within the specified period of time.
     *  *
     * @param UnassociateHaVipRequest $request UnassociateHaVipRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return UnassociateHaVipResponse UnassociateHaVipResponse
     */
    public function unassociateHaVipWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->force)) {
            $query['Force'] = $request->force;
        }
        if (!Utils::isUnset($request->haVipId)) {
            $query['HaVipId'] = $request->haVipId;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->instanceType)) {
            $query['InstanceType'] = $request->instanceType;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UnassociateHaVip',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UnassociateHaVipResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Disassociates a high-availability virtual IP address (HAVIP) from an Elastic Compute Service (ECS) in a virtual private cloud (VPC) or from an elastic network interface (ENI).
     *  *
     * @description ## [](#)
     * When you call this operation, take note of the following limits:
     * *   The ECS instance must be in the **Running** or **Stopped** state.
     * *   The HAVIP must be in the **Available** or **InUse** state.
     * *   **UnassociateHaVip** is an asynchronous operation. After a request is sent, the system returns a request ID and an instance ID and runs the task in the background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HAVIP:
     *     *   If the HAVIP is in the **Unassociating** state, the HAVIP is being disassociated.
     *     *   If the HAVIP is in the **Inuse** or **Available** state, the HAVIP is disassociated.
     * *   You cannot repeatedly call the **UnassociateHaVip** operation to disassociate an HAVIP within the specified period of time.
     *  *
     * @param UnassociateHaVipRequest $request UnassociateHaVipRequest
     *
     * @return UnassociateHaVipResponse UnassociateHaVipResponse
     */
    public function unassociateHaVip($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->unassociateHaVipWithOptions($request, $runtime);
    }

    /**
     * @summary Disassociates a network access control list (ACL) from a vSwitch.
     *  *
     * @description ## [](#)Description
     * *   **UnassociateNetworkAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
     *     *   If the network ACL is in the **UNBINDING** state, the network ACL is being disassociated from the vSwitch.
     *     *   If the network ACL is in the **UNBINDED** state, the network ACL is disassociated from the vSwitch.
     * *   You cannot repeatedly call the **UnassociateNetworkAcl** operation to disassociate a network ACL from a vSwitch within the specified period of time.
     *  *
     * @param UnassociateNetworkAclRequest $request UnassociateNetworkAclRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return UnassociateNetworkAclResponse UnassociateNetworkAclResponse
     */
    public function unassociateNetworkAclWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->networkAclId)) {
            $query['NetworkAclId'] = $request->networkAclId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resource)) {
            $query['Resource'] = $request->resource;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UnassociateNetworkAcl',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UnassociateNetworkAclResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Disassociates a network access control list (ACL) from a vSwitch.
     *  *
     * @description ## [](#)Description
     * *   **UnassociateNetworkAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
     *     *   If the network ACL is in the **UNBINDING** state, the network ACL is being disassociated from the vSwitch.
     *     *   If the network ACL is in the **UNBINDED** state, the network ACL is disassociated from the vSwitch.
     * *   You cannot repeatedly call the **UnassociateNetworkAcl** operation to disassociate a network ACL from a vSwitch within the specified period of time.
     *  *
     * @param UnassociateNetworkAclRequest $request UnassociateNetworkAclRequest
     *
     * @return UnassociateNetworkAclResponse UnassociateNetworkAclResponse
     */
    public function unassociateNetworkAcl($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->unassociateNetworkAclWithOptions($request, $runtime);
    }

    /**
     * @summary Disassociates a virtual border router (VBR) from an Express Connect circuit.
     *  *
     * @param UnassociatePhysicalConnectionFromVirtualBorderRouterRequest $request UnassociatePhysicalConnectionFromVirtualBorderRouterRequest
     * @param RuntimeOptions                                              $runtime runtime options for this request RuntimeOptions
     *
     * @return UnassociatePhysicalConnectionFromVirtualBorderRouterResponse UnassociatePhysicalConnectionFromVirtualBorderRouterResponse
     */
    public function unassociatePhysicalConnectionFromVirtualBorderRouterWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->physicalConnectionId)) {
            $query['PhysicalConnectionId'] = $request->physicalConnectionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vbrId)) {
            $query['VbrId'] = $request->vbrId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UnassociatePhysicalConnectionFromVirtualBorderRouter',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UnassociatePhysicalConnectionFromVirtualBorderRouterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Disassociates a virtual border router (VBR) from an Express Connect circuit.
     *  *
     * @param UnassociatePhysicalConnectionFromVirtualBorderRouterRequest $request UnassociatePhysicalConnectionFromVirtualBorderRouterRequest
     *
     * @return UnassociatePhysicalConnectionFromVirtualBorderRouterResponse UnassociatePhysicalConnectionFromVirtualBorderRouterResponse
     */
    public function unassociatePhysicalConnectionFromVirtualBorderRouter($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->unassociatePhysicalConnectionFromVirtualBorderRouterWithOptions($request, $runtime);
    }

    /**
     * @summary Disassociates a route table from a vSwitch.
     *  *
     * @description ## [](#)References
     * *   **UnassociateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task.
     *     *   If the vSwitch is in the **Pending** state, the route table is being disassociated.
     *     *   If the vSwitch is in the **Available** state, the route table is disassociated.
     * *   You cannot repeatedly call the **UnassociateRouteTable** operation to disassociate a route table from a vSwitch within the specified period of time.
     *  *
     * @param UnassociateRouteTableRequest $request UnassociateRouteTableRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return UnassociateRouteTableResponse UnassociateRouteTableResponse
     */
    public function unassociateRouteTableWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeTableId)) {
            $query['RouteTableId'] = $request->routeTableId;
        }
        if (!Utils::isUnset($request->vSwitchId)) {
            $query['VSwitchId'] = $request->vSwitchId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UnassociateRouteTable',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UnassociateRouteTableResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Disassociates a route table from a vSwitch.
     *  *
     * @description ## [](#)References
     * *   **UnassociateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task.
     *     *   If the vSwitch is in the **Pending** state, the route table is being disassociated.
     *     *   If the vSwitch is in the **Available** state, the route table is disassociated.
     * *   You cannot repeatedly call the **UnassociateRouteTable** operation to disassociate a route table from a vSwitch within the specified period of time.
     *  *
     * @param UnassociateRouteTableRequest $request UnassociateRouteTableRequest
     *
     * @return UnassociateRouteTableResponse UnassociateRouteTableResponse
     */
    public function unassociateRouteTable($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->unassociateRouteTableWithOptions($request, $runtime);
    }

    /**
     * @summary Removes a secondary CIDR block from a virtual private cloud (VPC).
     *  *
     * @description *   Before you delete a secondary CIDR block from a VPC, delete the vSwitch which is created with the CIDR block. For more information, see [DeleteVSwitch](https://help.aliyun.com/document_detail/35746.html).
     * *   You cannot repeatedly call the **UnassociateVpcCidrBlock** operation to delete a secondary CIDR block from a VPC within the specified period of time.
     *  *
     * @param UnassociateVpcCidrBlockRequest $request UnassociateVpcCidrBlockRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return UnassociateVpcCidrBlockResponse UnassociateVpcCidrBlockResponse
     */
    public function unassociateVpcCidrBlockWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->IPv6CidrBlock)) {
            $query['IPv6CidrBlock'] = $request->IPv6CidrBlock;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->secondaryCidrBlock)) {
            $query['SecondaryCidrBlock'] = $request->secondaryCidrBlock;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UnassociateVpcCidrBlock',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UnassociateVpcCidrBlockResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Removes a secondary CIDR block from a virtual private cloud (VPC).
     *  *
     * @description *   Before you delete a secondary CIDR block from a VPC, delete the vSwitch which is created with the CIDR block. For more information, see [DeleteVSwitch](https://help.aliyun.com/document_detail/35746.html).
     * *   You cannot repeatedly call the **UnassociateVpcCidrBlock** operation to delete a secondary CIDR block from a VPC within the specified period of time.
     *  *
     * @param UnassociateVpcCidrBlockRequest $request UnassociateVpcCidrBlockRequest
     *
     * @return UnassociateVpcCidrBlockResponse UnassociateVpcCidrBlockResponse
     */
    public function unassociateVpcCidrBlock($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->unassociateVpcCidrBlockWithOptions($request, $runtime);
    }

    /**
     * @summary Removes tags from an Express Connect circuit at a time.
     *  *
     * @param UntagResourcesForExpressConnectRequest $request UntagResourcesForExpressConnectRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return UntagResourcesForExpressConnectResponse UntagResourcesForExpressConnectResponse
     */
    public function untagResourcesForExpressConnectWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->all)) {
            $query['All'] = $request->all;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceId)) {
            $query['ResourceId'] = $request->resourceId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->resourceType)) {
            $query['ResourceType'] = $request->resourceType;
        }
        if (!Utils::isUnset($request->tagKey)) {
            $query['TagKey'] = $request->tagKey;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UntagResourcesForExpressConnect',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UntagResourcesForExpressConnectResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Removes tags from an Express Connect circuit at a time.
     *  *
     * @param UntagResourcesForExpressConnectRequest $request UntagResourcesForExpressConnectRequest
     *
     * @return UntagResourcesForExpressConnectResponse UntagResourcesForExpressConnectResponse
     */
    public function untagResourcesForExpressConnect($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->untagResourcesForExpressConnectWithOptions($request, $runtime);
    }

    /**
     * @summary 修改Dhcp选项集信息
     *  *
     * @param UpdateDhcpOptionsSetAttributeRequest $request UpdateDhcpOptionsSetAttributeRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateDhcpOptionsSetAttributeResponse UpdateDhcpOptionsSetAttributeResponse
     */
    public function updateDhcpOptionsSetAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dhcpOptionsSetDescription)) {
            $query['DhcpOptionsSetDescription'] = $request->dhcpOptionsSetDescription;
        }
        if (!Utils::isUnset($request->dhcpOptionsSetId)) {
            $query['DhcpOptionsSetId'] = $request->dhcpOptionsSetId;
        }
        if (!Utils::isUnset($request->dhcpOptionsSetName)) {
            $query['DhcpOptionsSetName'] = $request->dhcpOptionsSetName;
        }
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->domainNameServers)) {
            $query['DomainNameServers'] = $request->domainNameServers;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ipv6LeaseTime)) {
            $query['Ipv6LeaseTime'] = $request->ipv6LeaseTime;
        }
        if (!Utils::isUnset($request->leaseTime)) {
            $query['LeaseTime'] = $request->leaseTime;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateDhcpOptionsSetAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateDhcpOptionsSetAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 修改Dhcp选项集信息
     *  *
     * @param UpdateDhcpOptionsSetAttributeRequest $request UpdateDhcpOptionsSetAttributeRequest
     *
     * @return UpdateDhcpOptionsSetAttributeResponse UpdateDhcpOptionsSetAttributeResponse
     */
    public function updateDhcpOptionsSetAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateDhcpOptionsSetAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary 更新故障演练任务
     *  *
     * @param UpdateFailoverTestJobRequest $request UpdateFailoverTestJobRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateFailoverTestJobResponse UpdateFailoverTestJobResponse
     */
    public function updateFailoverTestJobWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->jobDuration)) {
            $query['JobDuration'] = $request->jobDuration;
        }
        if (!Utils::isUnset($request->jobId)) {
            $query['JobId'] = $request->jobId;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceId)) {
            $query['ResourceId'] = $request->resourceId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateFailoverTestJob',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateFailoverTestJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 更新故障演练任务
     *  *
     * @param UpdateFailoverTestJobRequest $request UpdateFailoverTestJobRequest
     *
     * @return UpdateFailoverTestJobResponse UpdateFailoverTestJobResponse
     */
    public function updateFailoverTestJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateFailoverTestJobWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the next hop type and next hop of the route entry in a gateway route table.
     *  *
     * @param UpdateGatewayRouteTableEntryAttributeRequest $request UpdateGatewayRouteTableEntryAttributeRequest
     * @param RuntimeOptions                               $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateGatewayRouteTableEntryAttributeResponse UpdateGatewayRouteTableEntryAttributeResponse
     */
    public function updateGatewayRouteTableEntryAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->destinationCidrBlock)) {
            $query['DestinationCidrBlock'] = $request->destinationCidrBlock;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->gatewayRouteTableId)) {
            $query['GatewayRouteTableId'] = $request->gatewayRouteTableId;
        }
        if (!Utils::isUnset($request->IPv4GatewayRouteTableId)) {
            $query['IPv4GatewayRouteTableId'] = $request->IPv4GatewayRouteTableId;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->nextHopId)) {
            $query['NextHopId'] = $request->nextHopId;
        }
        if (!Utils::isUnset($request->nextHopType)) {
            $query['NextHopType'] = $request->nextHopType;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateGatewayRouteTableEntryAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateGatewayRouteTableEntryAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the next hop type and next hop of the route entry in a gateway route table.
     *  *
     * @param UpdateGatewayRouteTableEntryAttributeRequest $request UpdateGatewayRouteTableEntryAttributeRequest
     *
     * @return UpdateGatewayRouteTableEntryAttributeResponse UpdateGatewayRouteTableEntryAttributeResponse
     */
    public function updateGatewayRouteTableEntryAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateGatewayRouteTableEntryAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configuration of an IPsec server.
     *  *
     * @description *   If you modify only the **IpsecServerName** parameter, this operation is synchronous. If you modify parameters other than **IpsecServerName**, this operation is asynchronous.
     * *   When the **UpdateIpsecServer** operation is asynchronous, the system returns a request ID after you send a request to call this operation and the IPsec server is being modified in the backend. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of a VPN gateway.
     *     *   If the VPN gateway is in the **updating** state, the configuration of the IPsec server is being modified.
     *     *   If the VPN gateway is in the **active** state, the configuration of the IPsec server is modified.
     * *   You cannot repeatedly call the **UpdateIpsecServer** operation for the same VPN gateway within the specified period of time.
     *  *
     * @param UpdateIpsecServerRequest $request UpdateIpsecServerRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateIpsecServerResponse UpdateIpsecServerResponse
     */
    public function updateIpsecServerWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientIpPool)) {
            $query['ClientIpPool'] = $request->clientIpPool;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->effectImmediately)) {
            $query['EffectImmediately'] = $request->effectImmediately;
        }
        if (!Utils::isUnset($request->ikeConfig)) {
            $query['IkeConfig'] = $request->ikeConfig;
        }
        if (!Utils::isUnset($request->ipsecConfig)) {
            $query['IpsecConfig'] = $request->ipsecConfig;
        }
        if (!Utils::isUnset($request->ipsecServerId)) {
            $query['IpsecServerId'] = $request->ipsecServerId;
        }
        if (!Utils::isUnset($request->ipsecServerName)) {
            $query['IpsecServerName'] = $request->ipsecServerName;
        }
        if (!Utils::isUnset($request->localSubnet)) {
            $query['LocalSubnet'] = $request->localSubnet;
        }
        if (!Utils::isUnset($request->psk)) {
            $query['Psk'] = $request->psk;
        }
        if (!Utils::isUnset($request->pskEnabled)) {
            $query['PskEnabled'] = $request->pskEnabled;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateIpsecServer',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateIpsecServerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configuration of an IPsec server.
     *  *
     * @description *   If you modify only the **IpsecServerName** parameter, this operation is synchronous. If you modify parameters other than **IpsecServerName**, this operation is asynchronous.
     * *   When the **UpdateIpsecServer** operation is asynchronous, the system returns a request ID after you send a request to call this operation and the IPsec server is being modified in the backend. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of a VPN gateway.
     *     *   If the VPN gateway is in the **updating** state, the configuration of the IPsec server is being modified.
     *     *   If the VPN gateway is in the **active** state, the configuration of the IPsec server is modified.
     * *   You cannot repeatedly call the **UpdateIpsecServer** operation for the same VPN gateway within the specified period of time.
     *  *
     * @param UpdateIpsecServerRequest $request UpdateIpsecServerRequest
     *
     * @return UpdateIpsecServerResponse UpdateIpsecServerResponse
     */
    public function updateIpsecServer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateIpsecServerWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the description or name of an IPv4 gateway.
     *  *
     * @description You cannot repeatedly call the **UpdateIpv4GatewayAttribute** operation to modify the name or description of an IPv4 gateway within the specified period of time.
     *  *
     * @param UpdateIpv4GatewayAttributeRequest $request UpdateIpv4GatewayAttributeRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateIpv4GatewayAttributeResponse UpdateIpv4GatewayAttributeResponse
     */
    public function updateIpv4GatewayAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ipv4GatewayDescription)) {
            $query['Ipv4GatewayDescription'] = $request->ipv4GatewayDescription;
        }
        if (!Utils::isUnset($request->ipv4GatewayId)) {
            $query['Ipv4GatewayId'] = $request->ipv4GatewayId;
        }
        if (!Utils::isUnset($request->ipv4GatewayName)) {
            $query['Ipv4GatewayName'] = $request->ipv4GatewayName;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateIpv4GatewayAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateIpv4GatewayAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the description or name of an IPv4 gateway.
     *  *
     * @description You cannot repeatedly call the **UpdateIpv4GatewayAttribute** operation to modify the name or description of an IPv4 gateway within the specified period of time.
     *  *
     * @param UpdateIpv4GatewayAttributeRequest $request UpdateIpv4GatewayAttributeRequest
     *
     * @return UpdateIpv4GatewayAttributeResponse UpdateIpv4GatewayAttributeResponse
     */
    public function updateIpv4GatewayAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateIpv4GatewayAttributeWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI UpdateNatGatewayNatType is deprecated
     *  *
     * @summary Upgrades a standard NAT gateway to an enhanced NAT gateway.
     *  *
     * @description Before you call this operation, take note of the following limits:
     * *   **UpdateNatGatewayNatType** is an asynchronous operation. After you send a request to call this operation, the system returns a request ID and the NAT gateway is still being upgraded in the backend. You can call the GetNatGatewayConvertStatus operation to query the upgrade progress of a NAT gateway. For more information, see [GetNatGatewayConvertStatus](https://help.aliyun.com/document_detail/184744.html).
     *     *   If the NAT gateway is in the **processing** state, the NAT gateway is being upgraded. You can only query the status of the NAT gateway but cannot perform other operations.
     *     *   If the NAT gateway is in the **successful** state, the NAT gateway is upgraded.
     *     *   If the NAT gateway is in the **failed** state, the system failed to upgrade the NAT gateway.
     * *   You cannot repeatedly call the **UpdateNatGatewayNatType** operation for the same VPN gateway within the specified period of time.
     * *   The billing method and billable items remain the same after the upgrade.
     * *   It takes about five minutes to upgrade a standard NAT gateway to an enhanced NAT gateway. During the upgrade, transient connection errors may occur once or twice. The service can be recovered by reconnection. You can determine whether to enable automatic reconnection or use manual reconnection based on your business requirements.
     * *   You can only upgrade standard NAT gateways to enhanced NAT gateways. You are not allowed to downgrade enhanced NAT gateways to standard NAT gateways.
     *  *
     * Deprecated
     *
     * @param UpdateNatGatewayNatTypeRequest $request UpdateNatGatewayNatTypeRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateNatGatewayNatTypeResponse UpdateNatGatewayNatTypeResponse
     */
    public function updateNatGatewayNatTypeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->natGatewayId)) {
            $query['NatGatewayId'] = $request->natGatewayId;
        }
        if (!Utils::isUnset($request->natType)) {
            $query['NatType'] = $request->natType;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->vSwitchId)) {
            $query['VSwitchId'] = $request->vSwitchId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateNatGatewayNatType',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateNatGatewayNatTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI UpdateNatGatewayNatType is deprecated
     *  *
     * @summary Upgrades a standard NAT gateway to an enhanced NAT gateway.
     *  *
     * @description Before you call this operation, take note of the following limits:
     * *   **UpdateNatGatewayNatType** is an asynchronous operation. After you send a request to call this operation, the system returns a request ID and the NAT gateway is still being upgraded in the backend. You can call the GetNatGatewayConvertStatus operation to query the upgrade progress of a NAT gateway. For more information, see [GetNatGatewayConvertStatus](https://help.aliyun.com/document_detail/184744.html).
     *     *   If the NAT gateway is in the **processing** state, the NAT gateway is being upgraded. You can only query the status of the NAT gateway but cannot perform other operations.
     *     *   If the NAT gateway is in the **successful** state, the NAT gateway is upgraded.
     *     *   If the NAT gateway is in the **failed** state, the system failed to upgrade the NAT gateway.
     * *   You cannot repeatedly call the **UpdateNatGatewayNatType** operation for the same VPN gateway within the specified period of time.
     * *   The billing method and billable items remain the same after the upgrade.
     * *   It takes about five minutes to upgrade a standard NAT gateway to an enhanced NAT gateway. During the upgrade, transient connection errors may occur once or twice. The service can be recovered by reconnection. You can determine whether to enable automatic reconnection or use manual reconnection based on your business requirements.
     * *   You can only upgrade standard NAT gateways to enhanced NAT gateways. You are not allowed to downgrade enhanced NAT gateways to standard NAT gateways.
     *  *
     * Deprecated
     *
     * @param UpdateNatGatewayNatTypeRequest $request UpdateNatGatewayNatTypeRequest
     *
     * @return UpdateNatGatewayNatTypeResponse UpdateNatGatewayNatTypeResponse
     */
    public function updateNatGatewayNatType($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateNatGatewayNatTypeWithOptions($request, $runtime);
    }

    /**
     * @summary Updates the rules of a network access control list (ACL).
     *  *
     * @description *   **UpdateNetworkAclEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of a network ACL:
     *     *   If the network ACL is in the **Modifying** state, the rules of the network ACL are being updated.
     *     *   If the network ACL is in the **Available** state, the rules of the network ACL are updated.
     * *   You cannot repeatedly call the **UpdateNetworkAclEntries** operation to update the rules of a network ACL within the specified period of time.
     *  *
     * @param UpdateNetworkAclEntriesRequest $request UpdateNetworkAclEntriesRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateNetworkAclEntriesResponse UpdateNetworkAclEntriesResponse
     */
    public function updateNetworkAclEntriesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->egressAclEntries)) {
            $query['EgressAclEntries'] = $request->egressAclEntries;
        }
        if (!Utils::isUnset($request->ingressAclEntries)) {
            $query['IngressAclEntries'] = $request->ingressAclEntries;
        }
        if (!Utils::isUnset($request->networkAclId)) {
            $query['NetworkAclId'] = $request->networkAclId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->updateEgressAclEntries)) {
            $query['UpdateEgressAclEntries'] = $request->updateEgressAclEntries;
        }
        if (!Utils::isUnset($request->updateIngressAclEntries)) {
            $query['UpdateIngressAclEntries'] = $request->updateIngressAclEntries;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateNetworkAclEntries',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateNetworkAclEntriesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates the rules of a network access control list (ACL).
     *  *
     * @description *   **UpdateNetworkAclEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of a network ACL:
     *     *   If the network ACL is in the **Modifying** state, the rules of the network ACL are being updated.
     *     *   If the network ACL is in the **Available** state, the rules of the network ACL are updated.
     * *   You cannot repeatedly call the **UpdateNetworkAclEntries** operation to update the rules of a network ACL within the specified period of time.
     *  *
     * @param UpdateNetworkAclEntriesRequest $request UpdateNetworkAclEntriesRequest
     *
     * @return UpdateNetworkAclEntriesResponse UpdateNetworkAclEntriesResponse
     */
    public function updateNetworkAclEntries($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateNetworkAclEntriesWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the attributes of an IP address pool.
     *  *
     * @description You cannot repeatedly call the **UpdatePublicIpAddressPoolAttribute** operation to modify the attributes of an IP address pool within the specified period of time.
     *  *
     * @param UpdatePublicIpAddressPoolAttributeRequest $request UpdatePublicIpAddressPoolAttributeRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdatePublicIpAddressPoolAttributeResponse UpdatePublicIpAddressPoolAttributeResponse
     */
    public function updatePublicIpAddressPoolAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->publicIpAddressPoolId)) {
            $query['PublicIpAddressPoolId'] = $request->publicIpAddressPoolId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdatePublicIpAddressPoolAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdatePublicIpAddressPoolAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the attributes of an IP address pool.
     *  *
     * @description You cannot repeatedly call the **UpdatePublicIpAddressPoolAttribute** operation to modify the attributes of an IP address pool within the specified period of time.
     *  *
     * @param UpdatePublicIpAddressPoolAttributeRequest $request UpdatePublicIpAddressPoolAttributeRequest
     *
     * @return UpdatePublicIpAddressPoolAttributeResponse UpdatePublicIpAddressPoolAttributeResponse
     */
    public function updatePublicIpAddressPoolAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updatePublicIpAddressPoolAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configuration of a filter for traffic mirroring.
     *  *
     * @description You cannot repeatedly call the **UpdateTrafficMirrorFilterAttribute** operation to modify the configuration of a filter for traffic mirroring within the specified period of time.
     *  *
     * @param UpdateTrafficMirrorFilterAttributeRequest $request UpdateTrafficMirrorFilterAttributeRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateTrafficMirrorFilterAttributeResponse UpdateTrafficMirrorFilterAttributeResponse
     */
    public function updateTrafficMirrorFilterAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->trafficMirrorFilterDescription)) {
            $query['TrafficMirrorFilterDescription'] = $request->trafficMirrorFilterDescription;
        }
        if (!Utils::isUnset($request->trafficMirrorFilterId)) {
            $query['TrafficMirrorFilterId'] = $request->trafficMirrorFilterId;
        }
        if (!Utils::isUnset($request->trafficMirrorFilterName)) {
            $query['TrafficMirrorFilterName'] = $request->trafficMirrorFilterName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateTrafficMirrorFilterAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateTrafficMirrorFilterAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configuration of a filter for traffic mirroring.
     *  *
     * @description You cannot repeatedly call the **UpdateTrafficMirrorFilterAttribute** operation to modify the configuration of a filter for traffic mirroring within the specified period of time.
     *  *
     * @param UpdateTrafficMirrorFilterAttributeRequest $request UpdateTrafficMirrorFilterAttributeRequest
     *
     * @return UpdateTrafficMirrorFilterAttributeResponse UpdateTrafficMirrorFilterAttributeResponse
     */
    public function updateTrafficMirrorFilterAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateTrafficMirrorFilterAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configuration of an inbound or outbound rule for traffic mirroring.
     *  *
     * @description *   The **UpdateTrafficMirrorFilterRuleAttribute** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of an inbound or outbound rule:
     *     *   If the rule is in the **Modifying** state, the rule is being modified.
     *     *   If the rule is in the **Created** state, the rule is modified.
     * *   You cannot repeatedly call the **UpdateTrafficMirrorFilterRuleAttribute** operation to modify an inbound or outbound rule within the specified period of time.
     *  *
     * @param UpdateTrafficMirrorFilterRuleAttributeRequest $request UpdateTrafficMirrorFilterRuleAttributeRequest
     * @param RuntimeOptions                                $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateTrafficMirrorFilterRuleAttributeResponse UpdateTrafficMirrorFilterRuleAttributeResponse
     */
    public function updateTrafficMirrorFilterRuleAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->destinationCidrBlock)) {
            $query['DestinationCidrBlock'] = $request->destinationCidrBlock;
        }
        if (!Utils::isUnset($request->destinationPortRange)) {
            $query['DestinationPortRange'] = $request->destinationPortRange;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->priority)) {
            $query['Priority'] = $request->priority;
        }
        if (!Utils::isUnset($request->protocol)) {
            $query['Protocol'] = $request->protocol;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->ruleAction)) {
            $query['RuleAction'] = $request->ruleAction;
        }
        if (!Utils::isUnset($request->sourceCidrBlock)) {
            $query['SourceCidrBlock'] = $request->sourceCidrBlock;
        }
        if (!Utils::isUnset($request->sourcePortRange)) {
            $query['SourcePortRange'] = $request->sourcePortRange;
        }
        if (!Utils::isUnset($request->trafficMirrorFilterRuleId)) {
            $query['TrafficMirrorFilterRuleId'] = $request->trafficMirrorFilterRuleId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateTrafficMirrorFilterRuleAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateTrafficMirrorFilterRuleAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configuration of an inbound or outbound rule for traffic mirroring.
     *  *
     * @description *   The **UpdateTrafficMirrorFilterRuleAttribute** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of an inbound or outbound rule:
     *     *   If the rule is in the **Modifying** state, the rule is being modified.
     *     *   If the rule is in the **Created** state, the rule is modified.
     * *   You cannot repeatedly call the **UpdateTrafficMirrorFilterRuleAttribute** operation to modify an inbound or outbound rule within the specified period of time.
     *  *
     * @param UpdateTrafficMirrorFilterRuleAttributeRequest $request UpdateTrafficMirrorFilterRuleAttributeRequest
     *
     * @return UpdateTrafficMirrorFilterRuleAttributeResponse UpdateTrafficMirrorFilterRuleAttributeResponse
     */
    public function updateTrafficMirrorFilterRuleAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateTrafficMirrorFilterRuleAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configuration of a traffic mirror session.
     *  *
     * @description ## Usage notes
     * *   **UpdateTrafficMirrorSessionAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
     *     *   If the traffic mirror session is in the **Modifying** state, the configuration of the traffic mirror session is being modified.
     *     *   If the traffic mirror session is in the **Created** state, the configuration of the traffic mirror session is modified.
     * *   You cannot repeatedly call the **UpdateTrafficMirrorSessionAttribute** operation within a specific period of time.
     *  *
     * @param UpdateTrafficMirrorSessionAttributeRequest $request UpdateTrafficMirrorSessionAttributeRequest
     * @param RuntimeOptions                             $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateTrafficMirrorSessionAttributeResponse UpdateTrafficMirrorSessionAttributeResponse
     */
    public function updateTrafficMirrorSessionAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->enabled)) {
            $query['Enabled'] = $request->enabled;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->packetLength)) {
            $query['PacketLength'] = $request->packetLength;
        }
        if (!Utils::isUnset($request->priority)) {
            $query['Priority'] = $request->priority;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->trafficMirrorFilterId)) {
            $query['TrafficMirrorFilterId'] = $request->trafficMirrorFilterId;
        }
        if (!Utils::isUnset($request->trafficMirrorSessionDescription)) {
            $query['TrafficMirrorSessionDescription'] = $request->trafficMirrorSessionDescription;
        }
        if (!Utils::isUnset($request->trafficMirrorSessionId)) {
            $query['TrafficMirrorSessionId'] = $request->trafficMirrorSessionId;
        }
        if (!Utils::isUnset($request->trafficMirrorSessionName)) {
            $query['TrafficMirrorSessionName'] = $request->trafficMirrorSessionName;
        }
        if (!Utils::isUnset($request->trafficMirrorTargetId)) {
            $query['TrafficMirrorTargetId'] = $request->trafficMirrorTargetId;
        }
        if (!Utils::isUnset($request->trafficMirrorTargetType)) {
            $query['TrafficMirrorTargetType'] = $request->trafficMirrorTargetType;
        }
        if (!Utils::isUnset($request->virtualNetworkId)) {
            $query['VirtualNetworkId'] = $request->virtualNetworkId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateTrafficMirrorSessionAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateTrafficMirrorSessionAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configuration of a traffic mirror session.
     *  *
     * @description ## Usage notes
     * *   **UpdateTrafficMirrorSessionAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
     *     *   If the traffic mirror session is in the **Modifying** state, the configuration of the traffic mirror session is being modified.
     *     *   If the traffic mirror session is in the **Created** state, the configuration of the traffic mirror session is modified.
     * *   You cannot repeatedly call the **UpdateTrafficMirrorSessionAttribute** operation within a specific period of time.
     *  *
     * @param UpdateTrafficMirrorSessionAttributeRequest $request UpdateTrafficMirrorSessionAttributeRequest
     *
     * @return UpdateTrafficMirrorSessionAttributeResponse UpdateTrafficMirrorSessionAttributeResponse
     */
    public function updateTrafficMirrorSessionAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateTrafficMirrorSessionAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary Updates the maximum bandwidth value of outbound data transfer for a virtual border router (VBR).
     *  *
     * @param UpdateVirtualBorderBandwidthRequest $request UpdateVirtualBorderBandwidthRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateVirtualBorderBandwidthResponse UpdateVirtualBorderBandwidthResponse
     */
    public function updateVirtualBorderBandwidthWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bandwidth)) {
            $query['Bandwidth'] = $request->bandwidth;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->virtualBorderRouterId)) {
            $query['VirtualBorderRouterId'] = $request->virtualBorderRouterId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateVirtualBorderBandwidth',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateVirtualBorderBandwidthResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates the maximum bandwidth value of outbound data transfer for a virtual border router (VBR).
     *  *
     * @param UpdateVirtualBorderBandwidthRequest $request UpdateVirtualBorderBandwidthRequest
     *
     * @return UpdateVirtualBorderBandwidthResponse UpdateVirtualBorderBandwidthResponse
     */
    public function updateVirtualBorderBandwidth($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateVirtualBorderBandwidthWithOptions($request, $runtime);
    }

    /**
     * @summary Changes the virtual local area network (VLAN) ID of a hosted connection over Express Connect circuit.
     *  *
     * @param UpdateVirtualPhysicalConnectionRequest $request UpdateVirtualPhysicalConnectionRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateVirtualPhysicalConnectionResponse UpdateVirtualPhysicalConnectionResponse
     */
    public function updateVirtualPhysicalConnectionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->expectSpec)) {
            $query['ExpectSpec'] = $request->expectSpec;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->token)) {
            $query['Token'] = $request->token;
        }
        if (!Utils::isUnset($request->vlanId)) {
            $query['VlanId'] = $request->vlanId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateVirtualPhysicalConnection',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateVirtualPhysicalConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Changes the virtual local area network (VLAN) ID of a hosted connection over Express Connect circuit.
     *  *
     * @param UpdateVirtualPhysicalConnectionRequest $request UpdateVirtualPhysicalConnectionRequest
     *
     * @return UpdateVirtualPhysicalConnectionResponse UpdateVirtualPhysicalConnectionResponse
     */
    public function updateVirtualPhysicalConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateVirtualPhysicalConnectionWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configuration of a gateway endpoint.
     *  *
     * @description *   **UpdateVpcGatewayEndpointAttribute** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetVpcGatewayEndpointAttribute](https://help.aliyun.com/document_detail/311017.html) operation to query the status of the task.
     *     *   If the gateway endpoint is in the **Updating** state, it is being modified.
     *     *   If the gateway endpoint is in the **Created** state, it is modified.
     * *   You cannot call the **UpdateVpcGatewayEndpointAttribute** operation within a specific period of time.
     *  *
     * @param UpdateVpcGatewayEndpointAttributeRequest $request UpdateVpcGatewayEndpointAttributeRequest
     * @param RuntimeOptions                           $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateVpcGatewayEndpointAttributeResponse UpdateVpcGatewayEndpointAttributeResponse
     */
    public function updateVpcGatewayEndpointAttributeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->endpointDescription)) {
            $query['EndpointDescription'] = $request->endpointDescription;
        }
        if (!Utils::isUnset($request->endpointId)) {
            $query['EndpointId'] = $request->endpointId;
        }
        if (!Utils::isUnset($request->endpointName)) {
            $query['EndpointName'] = $request->endpointName;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->policyDocument)) {
            $query['PolicyDocument'] = $request->policyDocument;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateVpcGatewayEndpointAttribute',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateVpcGatewayEndpointAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configuration of a gateway endpoint.
     *  *
     * @description *   **UpdateVpcGatewayEndpointAttribute** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetVpcGatewayEndpointAttribute](https://help.aliyun.com/document_detail/311017.html) operation to query the status of the task.
     *     *   If the gateway endpoint is in the **Updating** state, it is being modified.
     *     *   If the gateway endpoint is in the **Created** state, it is modified.
     * *   You cannot call the **UpdateVpcGatewayEndpointAttribute** operation within a specific period of time.
     *  *
     * @param UpdateVpcGatewayEndpointAttributeRequest $request UpdateVpcGatewayEndpointAttributeRequest
     *
     * @return UpdateVpcGatewayEndpointAttributeResponse UpdateVpcGatewayEndpointAttributeResponse
     */
    public function updateVpcGatewayEndpointAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateVpcGatewayEndpointAttributeWithOptions($request, $runtime);
    }

    /**
     * @summary 查看eni quota
     *  *
     * @description Before you call this operation, make sure that a VPC NAT gateway is created. For more information, see [CreateNatGateway](https://help.aliyun.com/document_detail/120219.html).
     *  *
     * @param VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest $request VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest
     * @param RuntimeOptions                                       $runtime runtime options for this request RuntimeOptions
     *
     * @return VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse
     */
    public function vpcDescribeVpcNatGatewayNetworkInterfaceQuotaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->natGatewayId)) {
            $query['NatGatewayId'] = $request->natGatewayId;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->resourceUid)) {
            $query['ResourceUid'] = $request->resourceUid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'VpcDescribeVpcNatGatewayNetworkInterfaceQuota',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查看eni quota
     *  *
     * @description Before you call this operation, make sure that a VPC NAT gateway is created. For more information, see [CreateNatGateway](https://help.aliyun.com/document_detail/120219.html).
     *  *
     * @param VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest $request VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest
     *
     * @return VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse
     */
    public function vpcDescribeVpcNatGatewayNetworkInterfaceQuota($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->vpcDescribeVpcNatGatewayNetworkInterfaceQuotaWithOptions($request, $runtime);
    }

    /**
     * @summary 撤回VPC已发布路由
     *  *
     * @param WithdrawVpcPublishedRouteEntriesRequest $request WithdrawVpcPublishedRouteEntriesRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return WithdrawVpcPublishedRouteEntriesResponse WithdrawVpcPublishedRouteEntriesResponse
     */
    public function withdrawVpcPublishedRouteEntriesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->dryRun)) {
            $query['DryRun'] = $request->dryRun;
        }
        if (!Utils::isUnset($request->ownerAccount)) {
            $query['OwnerAccount'] = $request->ownerAccount;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceOwnerAccount)) {
            $query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->routeEntries)) {
            $query['RouteEntries'] = $request->routeEntries;
        }
        if (!Utils::isUnset($request->targetInstanceId)) {
            $query['TargetInstanceId'] = $request->targetInstanceId;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'WithdrawVpcPublishedRouteEntries',
            'version'     => '2016-04-28',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return WithdrawVpcPublishedRouteEntriesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 撤回VPC已发布路由
     *  *
     * @param WithdrawVpcPublishedRouteEntriesRequest $request WithdrawVpcPublishedRouteEntriesRequest
     *
     * @return WithdrawVpcPublishedRouteEntriesResponse WithdrawVpcPublishedRouteEntriesResponse
     */
    public function withdrawVpcPublishedRouteEntries($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->withdrawVpcPublishedRouteEntriesWithOptions($request, $runtime);
    }
}
