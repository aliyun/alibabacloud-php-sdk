<?php

// This file is auto-generated, don't edit it. Thanks.

namespace AlibabaCloud\SDK\Vpc\V20160428;

use AlibabaCloud\Dara\Models\RuntimeOptions;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ActivateRouterInterfaceRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ActivateRouterInterfaceResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ActiveFlowLogRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ActiveFlowLogResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AddBgpNetworkRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AddBgpNetworkResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AddCommonBandwidthPackageIpRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AddCommonBandwidthPackageIpResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AddCommonBandwidthPackageIpsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AddCommonBandwidthPackageIpsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AddGlobalAccelerationInstanceIpRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AddGlobalAccelerationInstanceIpResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AddIPv6TranslatorAclListEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AddIPv6TranslatorAclListEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AddPublicIpAddressPoolCidrBlockRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AddPublicIpAddressPoolCidrBlockResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AddSourcesToTrafficMirrorSessionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AddSourcesToTrafficMirrorSessionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AllocateEipAddressProRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AllocateEipAddressProResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AllocateEipAddressRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AllocateEipAddressResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AllocateEipSegmentAddressRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AllocateEipSegmentAddressResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AllocateIpv6AddressRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AllocateIpv6AddressResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AllocateIpv6InternetBandwidthRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AllocateIpv6InternetBandwidthResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AllocateVpcIpv6CidrRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AllocateVpcIpv6CidrResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ApplyPhysicalConnectionLOARequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ApplyPhysicalConnectionLOAResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateEipAddressBatchRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateEipAddressBatchResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateEipAddressRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateEipAddressResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateHaVipRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateHaVipResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateNetworkAclRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateNetworkAclResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociatePhysicalConnectionToVirtualBorderRouterRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociatePhysicalConnectionToVirtualBorderRouterResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateRouteTableRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateRouteTableResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateRouteTablesWithVpcGatewayEndpointRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateRouteTablesWithVpcGatewayEndpointResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateRouteTableWithGatewayRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateRouteTableWithGatewayResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateVpcCidrBlockRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateVpcCidrBlockResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateVpnGatewayWithCertificateRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AssociateVpnGatewayWithCertificateResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AttachDhcpOptionsSetToVpcRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AttachDhcpOptionsSetToVpcResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AttachVbrToVpconnRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\AttachVbrToVpconnResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CancelCommonBandwidthPackageIpBandwidthRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CancelCommonBandwidthPackageIpBandwidthResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CancelPhysicalConnectionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CancelPhysicalConnectionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ChangeResourceGroupRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ChangeResourceGroupResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CheckCanAllocateVpcPrivateIpAddressRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CheckCanAllocateVpcPrivateIpAddressResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CheckVpnBgpEnabledRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CheckVpnBgpEnabledResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CompletePhysicalConnectionLOARequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CompletePhysicalConnectionLOAResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ConfirmPhysicalConnectionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ConfirmPhysicalConnectionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ConnectRouterInterfaceRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ConnectRouterInterfaceResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ConvertBandwidthPackageRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ConvertBandwidthPackageResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CopyNetworkAclEntriesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CopyNetworkAclEntriesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateBgpGroupRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateBgpGroupResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateBgpPeerRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateBgpPeerResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateCommonBandwidthPackageRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateCommonBandwidthPackageResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateCustomerGatewayRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateCustomerGatewayResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateDefaultVpcRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateDefaultVpcResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateDefaultVSwitchRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateDefaultVSwitchResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateDhcpOptionsSetRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateDhcpOptionsSetResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateExpressCloudConnectionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateExpressCloudConnectionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateExpressConnectTrafficQosQueueRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateExpressConnectTrafficQosQueueResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateExpressConnectTrafficQosRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateExpressConnectTrafficQosResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateExpressConnectTrafficQosRuleRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateExpressConnectTrafficQosRuleResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateFailoverTestJobRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateFailoverTestJobResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateFlowLogRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateFlowLogResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateForwardEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateForwardEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateFullNatEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateFullNatEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateGlobalAccelerationInstanceRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateGlobalAccelerationInstanceResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateHaVipRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateHaVipResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateHighReliablePhysicalConnectionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateHighReliablePhysicalConnectionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateIpsecServerRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateIpsecServerResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateIpv4GatewayRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateIpv4GatewayResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateIpv6EgressOnlyRuleRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateIpv6EgressOnlyRuleResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateIpv6GatewayRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateIpv6GatewayResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateIPv6TranslatorAclListRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateIPv6TranslatorAclListResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateIPv6TranslatorEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateIPv6TranslatorEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateIPv6TranslatorRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateIPv6TranslatorResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateNatGatewayRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateNatGatewayResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateNatGatewayShrinkRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateNatIpCidrRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateNatIpCidrResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateNatIpRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateNatIpResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateNetworkAclRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateNetworkAclResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreatePhysicalConnectionOccupancyOrderRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreatePhysicalConnectionOccupancyOrderResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreatePhysicalConnectionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreatePhysicalConnectionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreatePhysicalConnectionSetupOrderRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreatePhysicalConnectionSetupOrderResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreatePublicIpAddressPoolRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreatePublicIpAddressPoolResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateRouteEntriesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateRouteEntriesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateRouteEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateRouteEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateRouterInterfaceRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateRouterInterfaceResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateRouteTableRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateRouteTableResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateSnatEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateSnatEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateSslVpnClientCertRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateSslVpnClientCertResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateSslVpnServerRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateSslVpnServerResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateTrafficMirrorFilterRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateTrafficMirrorFilterResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateTrafficMirrorFilterRulesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateTrafficMirrorFilterRulesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateTrafficMirrorSessionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateTrafficMirrorSessionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVbrHaRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVbrHaResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVcoRouteEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVcoRouteEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVirtualBorderRouterRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVirtualBorderRouterResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVirtualPhysicalConnectionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVirtualPhysicalConnectionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpcGatewayEndpointRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpcGatewayEndpointResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpconnFromVbrRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpconnFromVbrResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpcPrefixListRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpcPrefixListResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpcRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpcResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpnAttachmentRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpnAttachmentResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpnConnectionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpnConnectionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpnGatewayRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpnGatewayResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpnPbrRouteEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpnPbrRouteEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpnRouteEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVpnRouteEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVSwitchCidrReservationRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVSwitchCidrReservationResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVSwitchRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\CreateVSwitchResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeactivateRouterInterfaceRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeactivateRouterInterfaceResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeactiveFlowLogRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeactiveFlowLogResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteBgpGroupRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteBgpGroupResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteBgpNetworkRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteBgpNetworkResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteBgpPeerRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteBgpPeerResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteCommonBandwidthPackageRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteCommonBandwidthPackageResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteCustomerGatewayRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteCustomerGatewayResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteDhcpOptionsSetRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteDhcpOptionsSetResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteExpressConnectRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteExpressConnectResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteExpressConnectTrafficQosQueueRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteExpressConnectTrafficQosQueueResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteExpressConnectTrafficQosRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteExpressConnectTrafficQosResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteExpressConnectTrafficQosRuleRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteExpressConnectTrafficQosRuleResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteFailoverTestJobRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteFailoverTestJobResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteFlowLogRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteFlowLogResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteForwardEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteForwardEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteFullNatEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteFullNatEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteGlobalAccelerationInstanceRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteGlobalAccelerationInstanceResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteHaVipRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteHaVipResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteIpsecServerRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteIpsecServerResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteIpv4GatewayRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteIpv4GatewayResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteIpv6EgressOnlyRuleRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteIpv6EgressOnlyRuleResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteIpv6GatewayRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteIpv6GatewayResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteIpv6InternetBandwidthRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteIpv6InternetBandwidthResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteIPv6TranslatorAclListRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteIPv6TranslatorAclListResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteIPv6TranslatorEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteIPv6TranslatorEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteIPv6TranslatorRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteIPv6TranslatorResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteNatGatewayRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteNatGatewayResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteNatIpCidrRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteNatIpCidrResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteNatIpRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteNatIpResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteNetworkAclRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteNetworkAclResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeletePhysicalConnectionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeletePhysicalConnectionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeletePublicIpAddressPoolCidrBlockRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeletePublicIpAddressPoolCidrBlockResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeletePublicIpAddressPoolRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeletePublicIpAddressPoolResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteRouteEntriesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteRouteEntriesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteRouteEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteRouteEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteRouterInterfaceRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteRouterInterfaceResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteRouteTableRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteRouteTableResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteSnatEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteSnatEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteSslVpnClientCertRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteSslVpnClientCertResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteSslVpnServerRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteSslVpnServerResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteTrafficMirrorFilterRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteTrafficMirrorFilterResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteTrafficMirrorFilterRulesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteTrafficMirrorFilterRulesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteTrafficMirrorSessionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteTrafficMirrorSessionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVbrHaRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVbrHaResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVcoRouteEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVcoRouteEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVirtualBorderRouterRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVirtualBorderRouterResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVpcGatewayEndpointRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVpcGatewayEndpointResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVpcPrefixListRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVpcPrefixListResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVpcRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVpcResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVpnAttachmentRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVpnAttachmentResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVpnConnectionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVpnConnectionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVpnGatewayRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVpnGatewayResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVpnPbrRouteEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVpnPbrRouteEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVpnRouteEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVpnRouteEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVSwitchCidrReservationRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVSwitchCidrReservationResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVSwitchRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeleteVSwitchResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeletionProtectionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DeletionProtectionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\Describe95TrafficRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\Describe95TrafficResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeAccessPointsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeAccessPointsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeBgpGroupsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeBgpGroupsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeBgpNetworksRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeBgpNetworksResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeBgpPeersRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeBgpPeersResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeCommonBandwidthPackagesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeCommonBandwidthPackagesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeCustomerGatewayRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeCustomerGatewayResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeCustomerGatewaysRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeCustomerGatewaysResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeEcGrantRelationRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeEcGrantRelationResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeEipAddressesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeEipAddressesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeEipGatewayInfoRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeEipGatewayInfoResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeEipMonitorDataRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeEipMonitorDataResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeEipSegmentRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeEipSegmentResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeExpressConnectTrafficQosQueueRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeExpressConnectTrafficQosQueueResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeExpressConnectTrafficQosRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeExpressConnectTrafficQosResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeExpressConnectTrafficQosRuleRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeExpressConnectTrafficQosRuleResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeFailoverTestJobRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeFailoverTestJobResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeFailoverTestJobsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeFailoverTestJobsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeFlowLogsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeFlowLogsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeForwardTableEntriesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeForwardTableEntriesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeGlobalAccelerationInstancesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeGlobalAccelerationInstancesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeGrantRulesToCenRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeGrantRulesToCenResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeGrantRulesToEcrRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeGrantRulesToEcrResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeHaVipsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeHaVipsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeHighDefinitionMonitorLogAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeHighDefinitionMonitorLogAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeIpv6AddressesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeIpv6AddressesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeIpv6EgressOnlyRulesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeIpv6EgressOnlyRulesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeIpv6GatewayAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeIpv6GatewayAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeIpv6GatewaysRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeIpv6GatewaysResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeIPv6TranslatorAclListAttributesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeIPv6TranslatorAclListAttributesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeIPv6TranslatorAclListsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeIPv6TranslatorAclListsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeIPv6TranslatorEntriesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeIPv6TranslatorEntriesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeIPv6TranslatorsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeIPv6TranslatorsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeNatGatewayAssociateNetworkInterfacesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeNatGatewayAssociateNetworkInterfacesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeNatGatewaysRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeNatGatewaysResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeNetworkAclAttributesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeNetworkAclAttributesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeNetworkAclsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeNetworkAclsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribePhysicalConnectionLOARequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribePhysicalConnectionLOAResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribePhysicalConnectionsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribePhysicalConnectionsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribePublicIpAddressRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribePublicIpAddressResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeRegionsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeRegionsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeRouteEntryListRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeRouteEntryListResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeRouterInterfaceAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeRouterInterfaceAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeRouterInterfacesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeRouterInterfacesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeRouteTableListRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeRouteTableListResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeRouteTablesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeRouteTablesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeServerRelatedGlobalAccelerationInstancesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeServerRelatedGlobalAccelerationInstancesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeSnatTableEntriesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeSnatTableEntriesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeSslVpnClientCertRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeSslVpnClientCertResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeSslVpnClientCertsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeSslVpnClientCertsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeSslVpnClientsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeSslVpnClientsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeSslVpnServersRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeSslVpnServersResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeTagKeysForExpressConnectRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeTagKeysForExpressConnectResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeTagKeysRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeTagKeysResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeTagsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeTagsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVbrHaRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVbrHaResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVcoRouteEntriesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVcoRouteEntriesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVirtualBorderRoutersForPhysicalConnectionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVirtualBorderRoutersForPhysicalConnectionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVirtualBorderRoutersRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVirtualBorderRoutersResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpcAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpcAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpcGrantRulesToEcrRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpcGrantRulesToEcrResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpcsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpcsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnAttachmentsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnAttachmentsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnConnectionLogsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnConnectionLogsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnConnectionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnConnectionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnConnectionsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnConnectionsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnCrossAccountAuthorizationsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnCrossAccountAuthorizationsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnGatewayAvailableZonesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnGatewayAvailableZonesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnGatewayRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnGatewayResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnGatewaysRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnGatewaysResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnPbrRouteEntriesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnPbrRouteEntriesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnRouteEntriesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnRouteEntriesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnSslServerLogsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVpnSslServerLogsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVRoutersRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVRoutersResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVSwitchAttributesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVSwitchAttributesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVSwitchesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeVSwitchesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeZonesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DescribeZonesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DetachDhcpOptionsSetFromVpcRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DetachDhcpOptionsSetFromVpcResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DiagnoseVpnConnectionsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DiagnoseVpnConnectionsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DiagnoseVpnGatewayRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DiagnoseVpnGatewayResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DisableNatGatewayEcsMetricRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DisableNatGatewayEcsMetricResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DisableVpcClassicLinkRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DisableVpcClassicLinkResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DissociateRouteTableFromGatewayRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DissociateRouteTableFromGatewayResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DissociateRouteTablesFromVpcGatewayEndpointRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DissociateRouteTablesFromVpcGatewayEndpointResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DissociateVpnGatewayWithCertificateRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DissociateVpnGatewayWithCertificateResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DownloadVpnConnectionConfigRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\DownloadVpnConnectionConfigResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\EnableNatGatewayEcsMetricRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\EnableNatGatewayEcsMetricResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\EnablePhysicalConnectionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\EnablePhysicalConnectionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\EnableVpcClassicLinkRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\EnableVpcClassicLinkResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\EnableVpcIpv4GatewayRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\EnableVpcIpv4GatewayResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetDhcpOptionsSetRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetDhcpOptionsSetResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetFlowLogServiceStatusRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetFlowLogServiceStatusResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetIpv4GatewayAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetIpv4GatewayAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetNatGatewayAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetNatGatewayAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetPhysicalConnectionServiceStatusRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetPhysicalConnectionServiceStatusResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetPublicIpAddressPoolServiceStatusRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetPublicIpAddressPoolServiceStatusResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetTrafficMirrorServiceStatusRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetTrafficMirrorServiceStatusResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetVpcGatewayEndpointAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetVpcGatewayEndpointAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetVpcPrefixListAssociationsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetVpcPrefixListAssociationsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetVpcPrefixListEntriesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetVpcPrefixListEntriesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetVpcRouteEntrySummaryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetVpcRouteEntrySummaryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetVpnGatewayDiagnoseResultRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetVpnGatewayDiagnoseResultResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetVSwitchCidrReservationUsageRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GetVSwitchCidrReservationUsageResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GrantInstanceToCenRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GrantInstanceToCenResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GrantInstanceToVbrRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GrantInstanceToVbrResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\GrantInstanceToVbrShrinkRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListBusinessAccessPointsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListBusinessAccessPointsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListBusinessRegionsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListBusinessRegionsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListDhcpOptionsSetsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListDhcpOptionsSetsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListEnhanhcedNatGatewayAvailableZonesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListEnhanhcedNatGatewayAvailableZonesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListFullNatEntriesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListFullNatEntriesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListGatewayRouteTableEntriesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListGatewayRouteTableEntriesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListGeographicSubRegionsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListIpsecServerLogsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListIpsecServerLogsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListIpsecServersRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListIpsecServersResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListIpv4GatewaysRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListIpv4GatewaysResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListNatIpCidrsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListNatIpCidrsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListNatIpsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListNatIpsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListPhysicalConnectionFeaturesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListPhysicalConnectionFeaturesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListPrefixListsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListPrefixListsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListPublicIpAddressPoolCidrBlocksRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListPublicIpAddressPoolCidrBlocksResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListPublicIpAddressPoolsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListPublicIpAddressPoolsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListTagResourcesForExpressConnectRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListTagResourcesForExpressConnectResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListTagResourcesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListTagResourcesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListTrafficMirrorFiltersRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListTrafficMirrorFiltersResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListTrafficMirrorSessionsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListTrafficMirrorSessionsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListVirtualPhysicalConnectionsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListVirtualPhysicalConnectionsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListVpcEndpointServicesByEndUserRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListVpcEndpointServicesByEndUserResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListVpcGatewayEndpointsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListVpcGatewayEndpointsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListVpcPublishedRouteEntriesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListVpcPublishedRouteEntriesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListVpnCertificateAssociationsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListVpnCertificateAssociationsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListVSwitchCidrReservationsRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ListVSwitchCidrReservationsResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyBgpGroupAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyBgpGroupAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyBgpPeerAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyBgpPeerAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyCommonBandwidthPackageAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyCommonBandwidthPackageAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyCommonBandwidthPackageIpBandwidthRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyCommonBandwidthPackageIpBandwidthResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyCommonBandwidthPackageSpecRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyCommonBandwidthPackageSpecResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyCustomerGatewayAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyCustomerGatewayAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyEipAddressAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyEipAddressAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyEipForwardModeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyEipForwardModeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyExpressCloudConnectionAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyExpressCloudConnectionAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyExpressCloudConnectionBandwidthRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyExpressCloudConnectionBandwidthResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyExpressConnectTrafficQosQueueRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyExpressConnectTrafficQosQueueResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyExpressConnectTrafficQosRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyExpressConnectTrafficQosResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyExpressConnectTrafficQosRuleRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyExpressConnectTrafficQosRuleResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyFlowLogAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyFlowLogAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyForwardEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyForwardEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyFullNatEntryAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyFullNatEntryAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyGlobalAccelerationInstanceAttributesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyGlobalAccelerationInstanceAttributesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyGlobalAccelerationInstanceSpecRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyGlobalAccelerationInstanceSpecResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyHaVipAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyHaVipAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyIpv6AddressAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyIpv6AddressAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyIpv6GatewayAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyIpv6GatewayAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyIpv6InternetBandwidthRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyIpv6InternetBandwidthResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyIPv6TranslatorAclAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyIPv6TranslatorAclAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyIPv6TranslatorAclListEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyIPv6TranslatorAclListEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyIPv6TranslatorAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyIPv6TranslatorAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyIPv6TranslatorBandwidthRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyIPv6TranslatorBandwidthResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyIPv6TranslatorEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyIPv6TranslatorEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyNatGatewayAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyNatGatewayAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyNatGatewayAttributeShrinkRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyNatGatewaySpecRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyNatGatewaySpecResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyNatIpAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyNatIpAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyNatIpCidrAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyNatIpCidrAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyNetworkAclAttributesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyNetworkAclAttributesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyPhysicalConnectionAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyPhysicalConnectionAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyRouteEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyRouteEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyRouterInterfaceAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyRouterInterfaceAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyRouterInterfaceSpecRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyRouterInterfaceSpecResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyRouteTableAttributesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyRouteTableAttributesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifySnatEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifySnatEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifySslVpnClientCertRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifySslVpnClientCertResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifySslVpnServerRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifySslVpnServerResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyTunnelAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyTunnelAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVcoRouteEntryWeightRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVcoRouteEntryWeightResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVirtualBorderRouterAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVirtualBorderRouterAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpcAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpcAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpcPrefixListRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpcPrefixListResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpnAttachmentAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpnAttachmentAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpnConnectionAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpnConnectionAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpnGatewayAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpnGatewayAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpnPbrRouteEntryAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpnPbrRouteEntryAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpnPbrRouteEntryPriorityRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpnPbrRouteEntryPriorityResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpnPbrRouteEntryWeightRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpnPbrRouteEntryWeightResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpnRouteEntryWeightRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVpnRouteEntryWeightResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVRouterAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVRouterAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVSwitchAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVSwitchAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVSwitchCidrReservationAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ModifyVSwitchCidrReservationAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\MoveResourceGroupRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\MoveResourceGroupResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\MoveVpnResourceGroupRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\MoveVpnResourceGroupResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\OpenFlowLogServiceRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\OpenFlowLogServiceResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\OpenPhysicalConnectionServiceRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\OpenPhysicalConnectionServiceResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\OpenPublicIpAddressPoolServiceRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\OpenPublicIpAddressPoolServiceResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\OpenTrafficMirrorServiceRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\OpenTrafficMirrorServiceResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\PublishVpcRouteEntriesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\PublishVpcRouteEntriesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\PublishVpnRouteEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\PublishVpnRouteEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RecoverPhysicalConnectionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RecoverPhysicalConnectionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RecoverVirtualBorderRouterRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RecoverVirtualBorderRouterResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ReleaseEipAddressRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ReleaseEipAddressResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ReleaseEipSegmentAddressRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ReleaseEipSegmentAddressResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ReleaseIpv6AddressRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ReleaseIpv6AddressResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RemoveCommonBandwidthPackageIpRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RemoveCommonBandwidthPackageIpResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RemoveGlobalAccelerationInstanceIpRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RemoveGlobalAccelerationInstanceIpResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RemoveIPv6TranslatorAclListEntryRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RemoveIPv6TranslatorAclListEntryResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RemoveSourcesFromTrafficMirrorSessionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RemoveSourcesFromTrafficMirrorSessionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ReplaceVpcDhcpOptionsSetRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\ReplaceVpcDhcpOptionsSetResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RetryVpcPrefixListAssociationRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RetryVpcPrefixListAssociationResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RevokeInstanceFromCenRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RevokeInstanceFromCenResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RevokeInstanceFromVbrRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RevokeInstanceFromVbrResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\RevokeInstanceFromVbrShrinkRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\SecondApplyPhysicalConnectionLOARequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\SecondApplyPhysicalConnectionLOAResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\SetHighDefinitionMonitorLogStatusRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\SetHighDefinitionMonitorLogStatusResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\StartFailoverTestJobRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\StartFailoverTestJobResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\StopFailoverTestJobRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\StopFailoverTestJobResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\TagResourcesForExpressConnectRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\TagResourcesForExpressConnectResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\TagResourcesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\TagResourcesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\TerminatePhysicalConnectionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\TerminatePhysicalConnectionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\TerminateVirtualBorderRouterRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\TerminateVirtualBorderRouterResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\TransformEipSegmentToPublicIpAddressPoolRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\TransformEipSegmentToPublicIpAddressPoolResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UnassociateEipAddressRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UnassociateEipAddressResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UnassociateGlobalAccelerationInstanceRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UnassociateGlobalAccelerationInstanceResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UnassociateHaVipRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UnassociateHaVipResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UnassociateNetworkAclRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UnassociateNetworkAclResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UnassociatePhysicalConnectionFromVirtualBorderRouterRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UnassociatePhysicalConnectionFromVirtualBorderRouterResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UnassociateRouteTableRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UnassociateRouteTableResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UnassociateVpcCidrBlockRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UnassociateVpcCidrBlockResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UntagResourcesForExpressConnectRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UntagResourcesForExpressConnectResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UnTagResourcesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UnTagResourcesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateDhcpOptionsSetAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateDhcpOptionsSetAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateFailoverTestJobRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateFailoverTestJobResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateGatewayRouteTableEntryAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateGatewayRouteTableEntryAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateIpsecServerRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateIpsecServerResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateIpv4GatewayAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateIpv4GatewayAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateNatGatewayNatTypeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateNatGatewayNatTypeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateNetworkAclEntriesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateNetworkAclEntriesResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdatePublicIpAddressPoolAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdatePublicIpAddressPoolAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateTrafficMirrorFilterAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateTrafficMirrorFilterAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateTrafficMirrorFilterRuleAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateTrafficMirrorFilterRuleAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateTrafficMirrorSessionAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateTrafficMirrorSessionAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateVirtualBorderBandwidthRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateVirtualBorderBandwidthResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateVirtualPhysicalConnectionRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateVirtualPhysicalConnectionResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateVpcGatewayEndpointAttributeRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\UpdateVpcGatewayEndpointAttributeResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse;
use AlibabaCloud\SDK\Vpc\V20160428\Models\WithdrawVpcPublishedRouteEntriesRequest;
use AlibabaCloud\SDK\Vpc\V20160428\Models\WithdrawVpcPublishedRouteEntriesResponse;
use Darabonba\OpenApi\Models\OpenApiRequest;
use Darabonba\OpenApi\Models\Params;
use Darabonba\OpenApi\OpenApiClient;
use Darabonba\OpenApi\Utils;

class Vpc extends OpenApiClient
{
    public function __construct($config)
    {
        parent::__construct($config);
        $this->_endpointRule = 'regional';
        $this->_endpointMap = [
            'cn-hangzhou' => 'vpc.aliyuncs.com',
            'cn-shanghai-finance-1' => 'vpc.aliyuncs.com',
            'cn-shenzhen-finance-1' => 'vpc.aliyuncs.com',
            'cn-north-2-gov-1' => 'vpc.aliyuncs.com',
            'ap-northeast-2-pop' => 'vpc.aliyuncs.com',
            'cn-beijing-finance-pop' => 'vpc.aliyuncs.com',
            'cn-beijing-gov-1' => 'vpc.aliyuncs.com',
            'cn-beijing-nu16-b01' => 'vpc.aliyuncs.com',
            'cn-edge-1' => 'vpc-nebula.cn-qingdao-nebula.aliyuncs.com',
            'cn-fujian' => 'vpc.aliyuncs.com',
            'cn-haidian-cm12-c01' => 'vpc.aliyuncs.com',
            'cn-hangzhou-bj-b01' => 'vpc.aliyuncs.com',
            'cn-hangzhou-finance' => 'vpc.aliyuncs.com',
            'cn-hangzhou-internal-prod-1' => 'vpc.aliyuncs.com',
            'cn-hangzhou-internal-test-1' => 'vpc-pre.cn-hangzhou.aliyuncs.com',
            'cn-hangzhou-internal-test-2' => 'vpc-inner-pre.cn-hangzhou.aliyuncs.com',
            'cn-hangzhou-internal-test-3' => 'vpc-pre.cn-hangzhou.aliyuncs.com',
            'cn-hangzhou-test-306' => 'vpc-pre.cn-hangzhou.aliyuncs.com',
            'cn-hongkong-finance-pop' => 'vpc.aliyuncs.com',
            'cn-huhehaote-nebula-1' => 'vpc-nebula.cn-qingdao-nebula.aliyuncs.com',
            'cn-qingdao-nebula' => 'vpc-nebula.cn-qingdao-nebula.aliyuncs.com',
            'cn-shanghai-et15-b01' => 'vpc-pre.cn-hangzhou.aliyuncs.com',
            'cn-shanghai-et2-b01' => 'vpc.aliyuncs.com',
            'cn-shanghai-inner' => 'vpc.aliyuncs.com',
            'cn-shanghai-internal-test-1' => 'vpc-pre.cn-hangzhou.aliyuncs.com',
            'cn-shenzhen-inner' => 'vpc.aliyuncs.com',
            'cn-shenzhen-st4-d01' => 'vpc.aliyuncs.com',
            'cn-shenzhen-su18-b01' => 'vpc.aliyuncs.com',
            'cn-wuhan' => 'vpc.aliyuncs.com',
            'cn-yushanfang' => 'vpc.aliyuncs.com',
            'cn-zhangbei' => 'vpc.aliyuncs.com',
            'cn-zhangbei-na61-b01' => 'vpc.aliyuncs.com',
            'cn-zhangjiakou-na62-a01' => 'vpc.cn-zhangjiakou.aliyuncs.com',
            'cn-zhengzhou-nebula-1' => 'vpc-nebula.cn-qingdao-nebula.aliyuncs.com',
            'eu-west-1-oxs' => 'vpc-nebula.cn-shenzhen-cloudstone.aliyuncs.com',
            'rus-west-1-pop' => 'vpc.aliyuncs.com',
        ];
        $this->checkConfig($config);
        $this->_endpoint = $this->getEndpoint('vpc', $this->_regionId, $this->_endpointRule, $this->_network, $this->_suffix, $this->_endpointMap, $this->_endpoint);
    }

    /**
     * @param string   $productId
     * @param string   $regionId
     * @param string   $endpointRule
     * @param string   $network
     * @param string   $suffix
     * @param string[] $endpointMap
     * @param string   $endpoint
     *
     * @return string
     */
    public function getEndpoint($productId, $regionId, $endpointRule, $network, $suffix, $endpointMap, $endpoint)
    {
        if (null !== $endpoint) {
            return $endpoint;
        }

        if (null !== $endpointMap && null !== @$endpointMap[$regionId]) {
            return @$endpointMap[$regionId];
        }

        return Utils::getEndpointRules($productId, $regionId, $endpointRule, $network, $suffix);
    }

    /**
     * Activates a router interface that is in the Inactive state.
     *
     * @remarks
     * After you call this operation, the router interface enters the **Activating** state. After the router interface is activated, it enters the **Active** state.
     * >  You cannot activate a router interface that has overdue payments.
     *
     * @param request - ActivateRouterInterfaceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ActivateRouterInterfaceResponse
     *
     * @param ActivateRouterInterfaceRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ActivateRouterInterfaceResponse
     */
    public function activateRouterInterfaceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routerInterfaceId) {
            @$query['RouterInterfaceId'] = $request->routerInterfaceId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ActivateRouterInterface',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ActivateRouterInterfaceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Activates a router interface that is in the Inactive state.
     *
     * @remarks
     * After you call this operation, the router interface enters the **Activating** state. After the router interface is activated, it enters the **Active** state.
     * >  You cannot activate a router interface that has overdue payments.
     *
     * @param request - ActivateRouterInterfaceRequest
     *
     * @returns ActivateRouterInterfaceResponse
     *
     * @param ActivateRouterInterfaceRequest $request
     *
     * @return ActivateRouterInterfaceResponse
     */
    public function activateRouterInterface($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->activateRouterInterfaceWithOptions($request, $runtime);
    }

    /**
     * Enables a flow log. After the flow log is enabled, traffic information about a resource is captured.
     *
     * @remarks
     *   The **ActiveFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
     *     *   If the flow log is in the **Activating** state, the flow log is being started.
     *     *   If the flow log is in the **Active** state, the flow log is started.
     * *   You cannot repeatedly call the **ActiveFlowLog** operation to start a flow log within the specified period of time.
     *
     * @param request - ActiveFlowLogRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ActiveFlowLogResponse
     *
     * @param ActiveFlowLogRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return ActiveFlowLogResponse
     */
    public function activeFlowLogWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->flowLogId) {
            @$query['FlowLogId'] = $request->flowLogId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ActiveFlowLog',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ActiveFlowLogResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables a flow log. After the flow log is enabled, traffic information about a resource is captured.
     *
     * @remarks
     *   The **ActiveFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
     *     *   If the flow log is in the **Activating** state, the flow log is being started.
     *     *   If the flow log is in the **Active** state, the flow log is started.
     * *   You cannot repeatedly call the **ActiveFlowLog** operation to start a flow log within the specified period of time.
     *
     * @param request - ActiveFlowLogRequest
     *
     * @returns ActiveFlowLogResponse
     *
     * @param ActiveFlowLogRequest $request
     *
     * @return ActiveFlowLogResponse
     */
    public function activeFlowLog($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->activeFlowLogWithOptions($request, $runtime);
    }

    /**
     * Advertises a Border Gateway Protocol (BGP) network.
     *
     * @param request - AddBgpNetworkRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddBgpNetworkResponse
     *
     * @param AddBgpNetworkRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return AddBgpNetworkResponse
     */
    public function addBgpNetworkWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dstCidrBlock) {
            @$query['DstCidrBlock'] = $request->dstCidrBlock;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routerId) {
            @$query['RouterId'] = $request->routerId;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddBgpNetwork',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddBgpNetworkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Advertises a Border Gateway Protocol (BGP) network.
     *
     * @param request - AddBgpNetworkRequest
     *
     * @returns AddBgpNetworkResponse
     *
     * @param AddBgpNetworkRequest $request
     *
     * @return AddBgpNetworkResponse
     */
    public function addBgpNetwork($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addBgpNetworkWithOptions($request, $runtime);
    }

    /**
     * Associates an elastic IP address (EIP) with an Internet Shared Bandwidth instance.
     *
     * @remarks
     * Before you call this operation, take note of the following items:
     * *   When you call this operation to associate an EIP with an Internet Shared Bandwidth instance, make sure that the EIP meets the following requirements:
     *     *   The EIP uses the pay-as-you-go billing method.
     *     *   The EIP and the Internet Shared Bandwidth instance belong to the same region.
     *     *   The line type of the EIPs is the same as that of the Internet Shared Bandwidth instance.
     * *   **AddCommonBandwidthPackageIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](https://help.aliyun.com/document_detail/120309.html) operation to query the status of the operation.
     *     *   If the Internet Shared Bandwidth instance is in the **BINDING** state, the EIP is being associated with the Internet Shared Bandwidth instance. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
     *     *   If the Internet Shared Bandwidth instance is in the **BINDED** state, the EIP is associated with the Internet Shared Bandwidth instance.
     *
     * @param request - AddCommonBandwidthPackageIpRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddCommonBandwidthPackageIpResponse
     *
     * @param AddCommonBandwidthPackageIpRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return AddCommonBandwidthPackageIpResponse
     */
    public function addCommonBandwidthPackageIpWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bandwidthPackageId) {
            @$query['BandwidthPackageId'] = $request->bandwidthPackageId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ipInstanceId) {
            @$query['IpInstanceId'] = $request->ipInstanceId;
        }

        if (null !== $request->ipType) {
            @$query['IpType'] = $request->ipType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddCommonBandwidthPackageIp',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddCommonBandwidthPackageIpResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Associates an elastic IP address (EIP) with an Internet Shared Bandwidth instance.
     *
     * @remarks
     * Before you call this operation, take note of the following items:
     * *   When you call this operation to associate an EIP with an Internet Shared Bandwidth instance, make sure that the EIP meets the following requirements:
     *     *   The EIP uses the pay-as-you-go billing method.
     *     *   The EIP and the Internet Shared Bandwidth instance belong to the same region.
     *     *   The line type of the EIPs is the same as that of the Internet Shared Bandwidth instance.
     * *   **AddCommonBandwidthPackageIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](https://help.aliyun.com/document_detail/120309.html) operation to query the status of the operation.
     *     *   If the Internet Shared Bandwidth instance is in the **BINDING** state, the EIP is being associated with the Internet Shared Bandwidth instance. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
     *     *   If the Internet Shared Bandwidth instance is in the **BINDED** state, the EIP is associated with the Internet Shared Bandwidth instance.
     *
     * @param request - AddCommonBandwidthPackageIpRequest
     *
     * @returns AddCommonBandwidthPackageIpResponse
     *
     * @param AddCommonBandwidthPackageIpRequest $request
     *
     * @return AddCommonBandwidthPackageIpResponse
     */
    public function addCommonBandwidthPackageIp($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addCommonBandwidthPackageIpWithOptions($request, $runtime);
    }

    /**
     * Associates multiple elastic IP addresses (EIPs) with an Internet Shared Bandwidth instance.
     *
     * @remarks
     *   When you call this operation to associate EIPs with an Internet Shared Bandwidth instance, make sure that the EIPs meet the following requirements:
     *     *   The EIPs use the pay-as-you-go billing method.
     *     *   The EIP and the Internet Shared Bandwidth instance belong to the same region.
     *     *   The line type of the EIPs is the same as that of the Internet Shared Bandwidth instance.
     * *   **AddCommonBandwidthPackageIps** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](~~DescribeCommonBandwidthPackages~~) operation to query the status of the task.
     *     *   If the Internet Shared Bandwidth instance is in the **BINDING** state, the EIP is being associated with the Internet Shared Bandwidth instance. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
     *     *   If the Internet Shared Bandwidth instance is in the **BINDED** state, the EIP is associated with the Internet Shared Bandwidth instance.
     *
     * @param request - AddCommonBandwidthPackageIpsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddCommonBandwidthPackageIpsResponse
     *
     * @param AddCommonBandwidthPackageIpsRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return AddCommonBandwidthPackageIpsResponse
     */
    public function addCommonBandwidthPackageIpsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bandwidthPackageId) {
            @$query['BandwidthPackageId'] = $request->bandwidthPackageId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ipInstanceIds) {
            @$query['IpInstanceIds'] = $request->ipInstanceIds;
        }

        if (null !== $request->ipType) {
            @$query['IpType'] = $request->ipType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddCommonBandwidthPackageIps',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddCommonBandwidthPackageIpsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Associates multiple elastic IP addresses (EIPs) with an Internet Shared Bandwidth instance.
     *
     * @remarks
     *   When you call this operation to associate EIPs with an Internet Shared Bandwidth instance, make sure that the EIPs meet the following requirements:
     *     *   The EIPs use the pay-as-you-go billing method.
     *     *   The EIP and the Internet Shared Bandwidth instance belong to the same region.
     *     *   The line type of the EIPs is the same as that of the Internet Shared Bandwidth instance.
     * *   **AddCommonBandwidthPackageIps** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](~~DescribeCommonBandwidthPackages~~) operation to query the status of the task.
     *     *   If the Internet Shared Bandwidth instance is in the **BINDING** state, the EIP is being associated with the Internet Shared Bandwidth instance. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
     *     *   If the Internet Shared Bandwidth instance is in the **BINDED** state, the EIP is associated with the Internet Shared Bandwidth instance.
     *
     * @param request - AddCommonBandwidthPackageIpsRequest
     *
     * @returns AddCommonBandwidthPackageIpsResponse
     *
     * @param AddCommonBandwidthPackageIpsRequest $request
     *
     * @return AddCommonBandwidthPackageIpsResponse
     */
    public function addCommonBandwidthPackageIps($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addCommonBandwidthPackageIpsWithOptions($request, $runtime);
    }

    /**
     * Associates an elastic IP address (EIP) with a shared-bandwidth Global Accelerator (GA) instance.
     *
     * @param request - AddGlobalAccelerationInstanceIpRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddGlobalAccelerationInstanceIpResponse
     *
     * @param AddGlobalAccelerationInstanceIpRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return AddGlobalAccelerationInstanceIpResponse
     */
    public function addGlobalAccelerationInstanceIpWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->globalAccelerationInstanceId) {
            @$query['GlobalAccelerationInstanceId'] = $request->globalAccelerationInstanceId;
        }

        if (null !== $request->ipInstanceId) {
            @$query['IpInstanceId'] = $request->ipInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddGlobalAccelerationInstanceIp',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddGlobalAccelerationInstanceIpResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Associates an elastic IP address (EIP) with a shared-bandwidth Global Accelerator (GA) instance.
     *
     * @param request - AddGlobalAccelerationInstanceIpRequest
     *
     * @returns AddGlobalAccelerationInstanceIpResponse
     *
     * @param AddGlobalAccelerationInstanceIpRequest $request
     *
     * @return AddGlobalAccelerationInstanceIpResponse
     */
    public function addGlobalAccelerationInstanceIp($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addGlobalAccelerationInstanceIpWithOptions($request, $runtime);
    }

    /**
     * Adds an IP entry to an access control list (ACL).
     *
     * @deprecated OpenAPI AddIPv6TranslatorAclListEntry is deprecated
     *
     * @param request - AddIPv6TranslatorAclListEntryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddIPv6TranslatorAclListEntryResponse
     *
     * @param AddIPv6TranslatorAclListEntryRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return AddIPv6TranslatorAclListEntryResponse
     */
    public function addIPv6TranslatorAclListEntryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aclEntryComment) {
            @$query['AclEntryComment'] = $request->aclEntryComment;
        }

        if (null !== $request->aclEntryIp) {
            @$query['AclEntryIp'] = $request->aclEntryIp;
        }

        if (null !== $request->aclId) {
            @$query['AclId'] = $request->aclId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddIPv6TranslatorAclListEntry',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddIPv6TranslatorAclListEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Adds an IP entry to an access control list (ACL).
     *
     * @deprecated OpenAPI AddIPv6TranslatorAclListEntry is deprecated
     *
     * @param request - AddIPv6TranslatorAclListEntryRequest
     *
     * @returns AddIPv6TranslatorAclListEntryResponse
     *
     * @param AddIPv6TranslatorAclListEntryRequest $request
     *
     * @return AddIPv6TranslatorAclListEntryResponse
     */
    public function addIPv6TranslatorAclListEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addIPv6TranslatorAclListEntryWithOptions($request, $runtime);
    }

    /**
     * Adds a CIDR block to an IP address pool.
     *
     * @remarks
     * Before you call this operation, take note of the following limits:
     * *   The CIDR block and the IP address pool must belong to the same region.
     * *   The CIDR block and the IP address pool must use the same line type.
     * *   **AddPublicIpAddressPoolCidrBlock** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPoolCidrBlocks](https://help.aliyun.com/document_detail/429436.html) operation to query the status of the task.
     *     *   If the CIDR block is in the **Modifying** state, the CIDR block is being added. In this state, you can only query the CIDR block and cannot perform other operations.
     *     *   If the CIDR block is in the **Created** state, the CIDR block is added.
     * *   You cannot repeatedly call the **AddPublicIpAddressPoolCidrBlock** operation to add a CIDR block to an IP address pool within the specified period of time.
     *
     * @param request - AddPublicIpAddressPoolCidrBlockRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddPublicIpAddressPoolCidrBlockResponse
     *
     * @param AddPublicIpAddressPoolCidrBlockRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return AddPublicIpAddressPoolCidrBlockResponse
     */
    public function addPublicIpAddressPoolCidrBlockWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->cidrBlock) {
            @$query['CidrBlock'] = $request->cidrBlock;
        }

        if (null !== $request->cidrMask) {
            @$query['CidrMask'] = $request->cidrMask;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->publicIpAddressPoolId) {
            @$query['PublicIpAddressPoolId'] = $request->publicIpAddressPoolId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddPublicIpAddressPoolCidrBlock',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddPublicIpAddressPoolCidrBlockResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds a CIDR block to an IP address pool.
     *
     * @remarks
     * Before you call this operation, take note of the following limits:
     * *   The CIDR block and the IP address pool must belong to the same region.
     * *   The CIDR block and the IP address pool must use the same line type.
     * *   **AddPublicIpAddressPoolCidrBlock** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPoolCidrBlocks](https://help.aliyun.com/document_detail/429436.html) operation to query the status of the task.
     *     *   If the CIDR block is in the **Modifying** state, the CIDR block is being added. In this state, you can only query the CIDR block and cannot perform other operations.
     *     *   If the CIDR block is in the **Created** state, the CIDR block is added.
     * *   You cannot repeatedly call the **AddPublicIpAddressPoolCidrBlock** operation to add a CIDR block to an IP address pool within the specified period of time.
     *
     * @param request - AddPublicIpAddressPoolCidrBlockRequest
     *
     * @returns AddPublicIpAddressPoolCidrBlockResponse
     *
     * @param AddPublicIpAddressPoolCidrBlockRequest $request
     *
     * @return AddPublicIpAddressPoolCidrBlockResponse
     */
    public function addPublicIpAddressPoolCidrBlock($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addPublicIpAddressPoolCidrBlockWithOptions($request, $runtime);
    }

    /**
     * Adds a traffic mirror source to a traffic mirror session.
     *
     * @remarks
     *   **AddSourcesToTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
     *     *   If the traffic mirror session is in the **Modifying** state, the traffic mirror source is being added to the traffic mirror session.
     *     *   If the traffic mirror session is in the **Created** state, the traffic mirror source is added to the traffic mirror session.
     * *   You cannot repeatedly call the **AddSourcesToTrafficMirrorSession** operation to add a traffic mirror source to a traffic mirror session within the specified period of time.
     *
     * @param request - AddSourcesToTrafficMirrorSessionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddSourcesToTrafficMirrorSessionResponse
     *
     * @param AddSourcesToTrafficMirrorSessionRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return AddSourcesToTrafficMirrorSessionResponse
     */
    public function addSourcesToTrafficMirrorSessionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->trafficMirrorSessionId) {
            @$query['TrafficMirrorSessionId'] = $request->trafficMirrorSessionId;
        }

        if (null !== $request->trafficMirrorSourceIds) {
            @$query['TrafficMirrorSourceIds'] = $request->trafficMirrorSourceIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddSourcesToTrafficMirrorSession',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddSourcesToTrafficMirrorSessionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds a traffic mirror source to a traffic mirror session.
     *
     * @remarks
     *   **AddSourcesToTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
     *     *   If the traffic mirror session is in the **Modifying** state, the traffic mirror source is being added to the traffic mirror session.
     *     *   If the traffic mirror session is in the **Created** state, the traffic mirror source is added to the traffic mirror session.
     * *   You cannot repeatedly call the **AddSourcesToTrafficMirrorSession** operation to add a traffic mirror source to a traffic mirror session within the specified period of time.
     *
     * @param request - AddSourcesToTrafficMirrorSessionRequest
     *
     * @returns AddSourcesToTrafficMirrorSessionResponse
     *
     * @param AddSourcesToTrafficMirrorSessionRequest $request
     *
     * @return AddSourcesToTrafficMirrorSessionResponse
     */
    public function addSourcesToTrafficMirrorSession($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addSourcesToTrafficMirrorSessionWithOptions($request, $runtime);
    }

    /**
     * Applies for an elastic IP address (EIP).
     *
     * @remarks
     * Before you call this operation, make sure that you are familiar with the billing methods and pricing of EIPs. For more information, see [Billing overview](https://help.aliyun.com/document_detail/122035.html).
     * After you call this operation, the system randomly allocates an EIP that is in the **Available** state in the specified region. EIPs support only the ICMP, TCP, and UDP transport layer protocols. The IGMP and SCTP protocols are not supported.
     *
     * @param request - AllocateEipAddressRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AllocateEipAddressResponse
     *
     * @param AllocateEipAddressRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return AllocateEipAddressResponse
     */
    public function allocateEipAddressWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->activityId) {
            @$query['ActivityId'] = $request->activityId;
        }

        if (null !== $request->autoPay) {
            @$query['AutoPay'] = $request->autoPay;
        }

        if (null !== $request->bandwidth) {
            @$query['Bandwidth'] = $request->bandwidth;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->ISP) {
            @$query['ISP'] = $request->ISP;
        }

        if (null !== $request->instanceChargeType) {
            @$query['InstanceChargeType'] = $request->instanceChargeType;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->internetChargeType) {
            @$query['InternetChargeType'] = $request->internetChargeType;
        }

        if (null !== $request->ipAddress) {
            @$query['IpAddress'] = $request->ipAddress;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->netmode) {
            @$query['Netmode'] = $request->netmode;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->period) {
            @$query['Period'] = $request->period;
        }

        if (null !== $request->pricingCycle) {
            @$query['PricingCycle'] = $request->pricingCycle;
        }

        if (null !== $request->publicIpAddressPoolId) {
            @$query['PublicIpAddressPoolId'] = $request->publicIpAddressPoolId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->securityProtectionTypes) {
            @$query['SecurityProtectionTypes'] = $request->securityProtectionTypes;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->zone) {
            @$query['Zone'] = $request->zone;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AllocateEipAddress',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AllocateEipAddressResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Applies for an elastic IP address (EIP).
     *
     * @remarks
     * Before you call this operation, make sure that you are familiar with the billing methods and pricing of EIPs. For more information, see [Billing overview](https://help.aliyun.com/document_detail/122035.html).
     * After you call this operation, the system randomly allocates an EIP that is in the **Available** state in the specified region. EIPs support only the ICMP, TCP, and UDP transport layer protocols. The IGMP and SCTP protocols are not supported.
     *
     * @param request - AllocateEipAddressRequest
     *
     * @returns AllocateEipAddressResponse
     *
     * @param AllocateEipAddressRequest $request
     *
     * @return AllocateEipAddressResponse
     */
    public function allocateEipAddress($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->allocateEipAddressWithOptions($request, $runtime);
    }

    /**
     * Requests a specified elastic IP address (EIP).
     *
     * @param request - AllocateEipAddressProRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AllocateEipAddressProResponse
     *
     * @param AllocateEipAddressProRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return AllocateEipAddressProResponse
     */
    public function allocateEipAddressProWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->autoPay) {
            @$query['AutoPay'] = $request->autoPay;
        }

        if (null !== $request->bandwidth) {
            @$query['Bandwidth'] = $request->bandwidth;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ISP) {
            @$query['ISP'] = $request->ISP;
        }

        if (null !== $request->instanceChargeType) {
            @$query['InstanceChargeType'] = $request->instanceChargeType;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->internetChargeType) {
            @$query['InternetChargeType'] = $request->internetChargeType;
        }

        if (null !== $request->ipAddress) {
            @$query['IpAddress'] = $request->ipAddress;
        }

        if (null !== $request->netmode) {
            @$query['Netmode'] = $request->netmode;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->period) {
            @$query['Period'] = $request->period;
        }

        if (null !== $request->pricingCycle) {
            @$query['PricingCycle'] = $request->pricingCycle;
        }

        if (null !== $request->publicIpAddressPoolId) {
            @$query['PublicIpAddressPoolId'] = $request->publicIpAddressPoolId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->securityProtectionTypes) {
            @$query['SecurityProtectionTypes'] = $request->securityProtectionTypes;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AllocateEipAddressPro',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AllocateEipAddressProResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Requests a specified elastic IP address (EIP).
     *
     * @param request - AllocateEipAddressProRequest
     *
     * @returns AllocateEipAddressProResponse
     *
     * @param AllocateEipAddressProRequest $request
     *
     * @return AllocateEipAddressProResponse
     */
    public function allocateEipAddressPro($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->allocateEipAddressProWithOptions($request, $runtime);
    }

    /**
     * Applies for contiguous elastic IP addresses (EIPs).
     *
     * @remarks
     * *AllocateEipSegmentAddress** is an asynchronous operation. After a request is sent, the system returns the ID of a contiguous EIP group and runs the task in the background. You can call the [DescribeEipSegment](https://help.aliyun.com/document_detail/156063.html) operation to query the status of the task.
     * *   If the contiguous EIP group is in the **Allocating** state, the EIPs are being allocated. In this case, you can only perform the query operation and cannot perform other operations.
     * *   If the contiguous EIP group is in the **Allocated** state, the EIPs are allocated.
     *
     * @deprecated OpenAPI AllocateEipSegmentAddress is deprecated
     *
     * @param request - AllocateEipSegmentAddressRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AllocateEipSegmentAddressResponse
     *
     * @param AllocateEipSegmentAddressRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return AllocateEipSegmentAddressResponse
     */
    public function allocateEipSegmentAddressWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bandwidth) {
            @$query['Bandwidth'] = $request->bandwidth;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->eipMask) {
            @$query['EipMask'] = $request->eipMask;
        }

        if (null !== $request->internetChargeType) {
            @$query['InternetChargeType'] = $request->internetChargeType;
        }

        if (null !== $request->isp) {
            @$query['Isp'] = $request->isp;
        }

        if (null !== $request->netmode) {
            @$query['Netmode'] = $request->netmode;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->zone) {
            @$query['Zone'] = $request->zone;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AllocateEipSegmentAddress',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AllocateEipSegmentAddressResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Applies for contiguous elastic IP addresses (EIPs).
     *
     * @remarks
     * *AllocateEipSegmentAddress** is an asynchronous operation. After a request is sent, the system returns the ID of a contiguous EIP group and runs the task in the background. You can call the [DescribeEipSegment](https://help.aliyun.com/document_detail/156063.html) operation to query the status of the task.
     * *   If the contiguous EIP group is in the **Allocating** state, the EIPs are being allocated. In this case, you can only perform the query operation and cannot perform other operations.
     * *   If the contiguous EIP group is in the **Allocated** state, the EIPs are allocated.
     *
     * @deprecated OpenAPI AllocateEipSegmentAddress is deprecated
     *
     * @param request - AllocateEipSegmentAddressRequest
     *
     * @returns AllocateEipSegmentAddressResponse
     *
     * @param AllocateEipSegmentAddressRequest $request
     *
     * @return AllocateEipSegmentAddressResponse
     */
    public function allocateEipSegmentAddress($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->allocateEipSegmentAddressWithOptions($request, $runtime);
    }

    /**
     * Assigns an IPv6 address.
     *
     * @param request - AllocateIpv6AddressRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AllocateIpv6AddressResponse
     *
     * @param AllocateIpv6AddressRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return AllocateIpv6AddressResponse
     */
    public function allocateIpv6AddressWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->addressType) {
            @$query['AddressType'] = $request->addressType;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ipv6Address) {
            @$query['Ipv6Address'] = $request->ipv6Address;
        }

        if (null !== $request->ipv6AddressDescription) {
            @$query['Ipv6AddressDescription'] = $request->ipv6AddressDescription;
        }

        if (null !== $request->ipv6AddressName) {
            @$query['Ipv6AddressName'] = $request->ipv6AddressName;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AllocateIpv6Address',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AllocateIpv6AddressResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Assigns an IPv6 address.
     *
     * @param request - AllocateIpv6AddressRequest
     *
     * @returns AllocateIpv6AddressResponse
     *
     * @param AllocateIpv6AddressRequest $request
     *
     * @return AllocateIpv6AddressResponse
     */
    public function allocateIpv6Address($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->allocateIpv6AddressWithOptions($request, $runtime);
    }

    /**
     * Default IPv6 gateways support only private communication. You can call the AllocateIpv6InternetBandwidth operation to purchase Internet bandwidth resources for an IPv6 address. This way, ECS instances in a VPC can access the Internet through the IPv6 address. IPv6 clients can also access the ECS instances over the Internet.
     *
     * @remarks
     *   Before you call this operation, make sure that an ECS instance that supports IPv6 is created in a VPC that has an IPv6 CIDR block. For more information, see [Create a VPC with an IPv6 CIDR block](https://help.aliyun.com/document_detail/100540.html).
     * *   You cannot repeatedly call **AllocateIpv6InternetBandwidth** within the specified period of time.
     *
     * @param request - AllocateIpv6InternetBandwidthRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AllocateIpv6InternetBandwidthResponse
     *
     * @param AllocateIpv6InternetBandwidthRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return AllocateIpv6InternetBandwidthResponse
     */
    public function allocateIpv6InternetBandwidthWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bandwidth) {
            @$query['Bandwidth'] = $request->bandwidth;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->internetChargeType) {
            @$query['InternetChargeType'] = $request->internetChargeType;
        }

        if (null !== $request->ipv6AddressId) {
            @$query['Ipv6AddressId'] = $request->ipv6AddressId;
        }

        if (null !== $request->ipv6GatewayId) {
            @$query['Ipv6GatewayId'] = $request->ipv6GatewayId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AllocateIpv6InternetBandwidth',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AllocateIpv6InternetBandwidthResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Default IPv6 gateways support only private communication. You can call the AllocateIpv6InternetBandwidth operation to purchase Internet bandwidth resources for an IPv6 address. This way, ECS instances in a VPC can access the Internet through the IPv6 address. IPv6 clients can also access the ECS instances over the Internet.
     *
     * @remarks
     *   Before you call this operation, make sure that an ECS instance that supports IPv6 is created in a VPC that has an IPv6 CIDR block. For more information, see [Create a VPC with an IPv6 CIDR block](https://help.aliyun.com/document_detail/100540.html).
     * *   You cannot repeatedly call **AllocateIpv6InternetBandwidth** within the specified period of time.
     *
     * @param request - AllocateIpv6InternetBandwidthRequest
     *
     * @returns AllocateIpv6InternetBandwidthResponse
     *
     * @param AllocateIpv6InternetBandwidthRequest $request
     *
     * @return AllocateIpv6InternetBandwidthResponse
     */
    public function allocateIpv6InternetBandwidth($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->allocateIpv6InternetBandwidthWithOptions($request, $runtime);
    }

    /**
     * Reserves an IPv6 CIDR block.
     *
     * @remarks
     * # [](#)
     * The following section describes how to allocate an IPv6 CIDR block to a virtual private cloud (VPC):
     * 1.  Call the AllocateVpcIpv6Cidr operation to reserve the IPv6 CIDR block.
     * 2.  To allocate an IPv6 CIDR block to an existing VPC, call the [AssociateVpcCidrBlock](https://help.aliyun.com/document_detail/146745.html) operation. Set **RegionId**, **VpcId**, and **IPv6CidrBlock** to the IPv6 CIDR bock, and set **IpVersion** to **ipv6**. To allocate an IPv6 CIDR block when you create a VPC, call the [CreateVpc](https://help.aliyun.com/document_detail/35737.html) operation. Set **RegionId** and **Ipv6CidrBlock** to the IPv6 CIDR block, and set **EnableIpv6** to **true**.
     *
     * @param request - AllocateVpcIpv6CidrRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AllocateVpcIpv6CidrResponse
     *
     * @param AllocateVpcIpv6CidrRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return AllocateVpcIpv6CidrResponse
     */
    public function allocateVpcIpv6CidrWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->addressPoolType) {
            @$query['AddressPoolType'] = $request->addressPoolType;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ipv6CidrBlock) {
            @$query['Ipv6CidrBlock'] = $request->ipv6CidrBlock;
        }

        if (null !== $request->ipv6Isp) {
            @$query['Ipv6Isp'] = $request->ipv6Isp;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AllocateVpcIpv6Cidr',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AllocateVpcIpv6CidrResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Reserves an IPv6 CIDR block.
     *
     * @remarks
     * # [](#)
     * The following section describes how to allocate an IPv6 CIDR block to a virtual private cloud (VPC):
     * 1.  Call the AllocateVpcIpv6Cidr operation to reserve the IPv6 CIDR block.
     * 2.  To allocate an IPv6 CIDR block to an existing VPC, call the [AssociateVpcCidrBlock](https://help.aliyun.com/document_detail/146745.html) operation. Set **RegionId**, **VpcId**, and **IPv6CidrBlock** to the IPv6 CIDR bock, and set **IpVersion** to **ipv6**. To allocate an IPv6 CIDR block when you create a VPC, call the [CreateVpc](https://help.aliyun.com/document_detail/35737.html) operation. Set **RegionId** and **Ipv6CidrBlock** to the IPv6 CIDR block, and set **EnableIpv6** to **true**.
     *
     * @param request - AllocateVpcIpv6CidrRequest
     *
     * @returns AllocateVpcIpv6CidrResponse
     *
     * @param AllocateVpcIpv6CidrRequest $request
     *
     * @return AllocateVpcIpv6CidrResponse
     */
    public function allocateVpcIpv6Cidr($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->allocateVpcIpv6CidrWithOptions($request, $runtime);
    }

    /**
     * Applies for a Letter of Authorization (LOA) for an Express Connect circuit.
     *
     * @param request - ApplyPhysicalConnectionLOARequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ApplyPhysicalConnectionLOAResponse
     *
     * @param ApplyPhysicalConnectionLOARequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return ApplyPhysicalConnectionLOAResponse
     */
    public function applyPhysicalConnectionLOAWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bandwidth) {
            @$query['Bandwidth'] = $request->bandwidth;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->companyName) {
            @$query['CompanyName'] = $request->companyName;
        }

        if (null !== $request->constructionTime) {
            @$query['ConstructionTime'] = $request->constructionTime;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->lineType) {
            @$query['LineType'] = $request->lineType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->PMInfo) {
            @$query['PMInfo'] = $request->PMInfo;
        }

        if (null !== $request->peerLocation) {
            @$query['PeerLocation'] = $request->peerLocation;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->si) {
            @$query['Si'] = $request->si;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ApplyPhysicalConnectionLOA',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ApplyPhysicalConnectionLOAResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Applies for a Letter of Authorization (LOA) for an Express Connect circuit.
     *
     * @param request - ApplyPhysicalConnectionLOARequest
     *
     * @returns ApplyPhysicalConnectionLOAResponse
     *
     * @param ApplyPhysicalConnectionLOARequest $request
     *
     * @return ApplyPhysicalConnectionLOAResponse
     */
    public function applyPhysicalConnectionLOA($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->applyPhysicalConnectionLOAWithOptions($request, $runtime);
    }

    /**
     * Associates an elastic IP address (EIP) with an instance in the same region.
     *
     * @remarks
     *   You can associate an EIP with an Elastic Compute Service (ECS) instance, a Classic Load Balancer (CLB) instance, a secondary elastic network interface (ENI), a NAT gateway, or a high-availability virtual IP address (HAVIP) in the same region. The ECS instance and CLB instance must be deployed in a virtual private cloud (VPC).
     * *   **AssociateEipAddress** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
     *     *   If the EIP is in the **Associating** state, the EIP is being associated. In this state, you can only query the EIP and cannot perform other operations.
     *     *   If the EIP is in the **InUse** state, the EIP is associated.
     * *   You cannot call the **AssociateEipAddress** operation to associate an EIP with multiple instances at a time.
     *
     * @param request - AssociateEipAddressRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AssociateEipAddressResponse
     *
     * @param AssociateEipAddressRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return AssociateEipAddressResponse
     */
    public function associateEipAddressWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->allocationId) {
            @$query['AllocationId'] = $request->allocationId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->instanceRegionId) {
            @$query['InstanceRegionId'] = $request->instanceRegionId;
        }

        if (null !== $request->instanceType) {
            @$query['InstanceType'] = $request->instanceType;
        }

        if (null !== $request->mode) {
            @$query['Mode'] = $request->mode;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->privateIpAddress) {
            @$query['PrivateIpAddress'] = $request->privateIpAddress;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AssociateEipAddress',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AssociateEipAddressResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Associates an elastic IP address (EIP) with an instance in the same region.
     *
     * @remarks
     *   You can associate an EIP with an Elastic Compute Service (ECS) instance, a Classic Load Balancer (CLB) instance, a secondary elastic network interface (ENI), a NAT gateway, or a high-availability virtual IP address (HAVIP) in the same region. The ECS instance and CLB instance must be deployed in a virtual private cloud (VPC).
     * *   **AssociateEipAddress** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
     *     *   If the EIP is in the **Associating** state, the EIP is being associated. In this state, you can only query the EIP and cannot perform other operations.
     *     *   If the EIP is in the **InUse** state, the EIP is associated.
     * *   You cannot call the **AssociateEipAddress** operation to associate an EIP with multiple instances at a time.
     *
     * @param request - AssociateEipAddressRequest
     *
     * @returns AssociateEipAddressResponse
     *
     * @param AssociateEipAddressRequest $request
     *
     * @return AssociateEipAddressResponse
     */
    public function associateEipAddress($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->associateEipAddressWithOptions($request, $runtime);
    }

    /**
     * Associates multiple elastic IP addresses (EIPs) with an instance in the same region.
     *
     * @remarks
     *   You can call the **AssociateEipAddressBatch** operation to associate EIPs with an instance in the same region. The instance must be a NAT gateway or a secondary elastic network interface (ENI). For more information about how to associate EIPs with other instances, see [AssociateEipAddress](https://help.aliyun.com/document_detail/120195.html).
     * *   **AssociateEipAddressBatch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
     *     *   If the EIP is in the **Associating** state, the EIP is being associated. You can only query the EIP and cannot perform other operations.
     *     *   If the EIP is in the **InUse** state, the EIP is associated.
     * *   You cannot call the **AssociateEipAddressBatch** operation to associate an EIP with multiple instances at a time.
     *
     * @param request - AssociateEipAddressBatchRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AssociateEipAddressBatchResponse
     *
     * @param AssociateEipAddressBatchRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return AssociateEipAddressBatchResponse
     */
    public function associateEipAddressBatchWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bindedInstanceId) {
            @$query['BindedInstanceId'] = $request->bindedInstanceId;
        }

        if (null !== $request->bindedInstanceType) {
            @$query['BindedInstanceType'] = $request->bindedInstanceType;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->instanceIds) {
            @$query['InstanceIds'] = $request->instanceIds;
        }

        if (null !== $request->mode) {
            @$query['Mode'] = $request->mode;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AssociateEipAddressBatch',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AssociateEipAddressBatchResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Associates multiple elastic IP addresses (EIPs) with an instance in the same region.
     *
     * @remarks
     *   You can call the **AssociateEipAddressBatch** operation to associate EIPs with an instance in the same region. The instance must be a NAT gateway or a secondary elastic network interface (ENI). For more information about how to associate EIPs with other instances, see [AssociateEipAddress](https://help.aliyun.com/document_detail/120195.html).
     * *   **AssociateEipAddressBatch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
     *     *   If the EIP is in the **Associating** state, the EIP is being associated. You can only query the EIP and cannot perform other operations.
     *     *   If the EIP is in the **InUse** state, the EIP is associated.
     * *   You cannot call the **AssociateEipAddressBatch** operation to associate an EIP with multiple instances at a time.
     *
     * @param request - AssociateEipAddressBatchRequest
     *
     * @returns AssociateEipAddressBatchResponse
     *
     * @param AssociateEipAddressBatchRequest $request
     *
     * @return AssociateEipAddressBatchResponse
     */
    public function associateEipAddressBatch($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->associateEipAddressBatchWithOptions($request, $runtime);
    }

    /**
     * Associates a high-availability virtual IP address (HaVip) with an Elastic Compute Service (ECS) instance or an elastic network interface (ENI).
     *
     * @remarks
     * When you call this operation, take note of the following limits:
     * *   An HaVip immediately takes effect after it is associated. You do not need to restart the ECS instance. However, you must associate the HaVip with the ENI of the ECS instance.
     * *   The HaVip and ECS instance must belong to the same vSwitch.
     * *   You can associate an HaVip with at most two ECS instances.
     * *   The ECS instance must be in the **Running** or **Stopped** state.
     * *   The HaVip must be in the **Available** or **InUse** state.
     * *   The **AssociateHaVip** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HaVip:
     *     *   If the HaVip is in the **Associating** state, the HaVip is being associated.
     *     *   If the HaVip is in the **InUse** state, the HaVip is associated.
     * *   You cannot repeatedly call the **AssociateHaVip** operation to associate an HaVip within the specified period of time.
     *
     * @param request - AssociateHaVipRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AssociateHaVipResponse
     *
     * @param AssociateHaVipRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return AssociateHaVipResponse
     */
    public function associateHaVipWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->haVipId) {
            @$query['HaVipId'] = $request->haVipId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->instanceType) {
            @$query['InstanceType'] = $request->instanceType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AssociateHaVip',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AssociateHaVipResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Associates a high-availability virtual IP address (HaVip) with an Elastic Compute Service (ECS) instance or an elastic network interface (ENI).
     *
     * @remarks
     * When you call this operation, take note of the following limits:
     * *   An HaVip immediately takes effect after it is associated. You do not need to restart the ECS instance. However, you must associate the HaVip with the ENI of the ECS instance.
     * *   The HaVip and ECS instance must belong to the same vSwitch.
     * *   You can associate an HaVip with at most two ECS instances.
     * *   The ECS instance must be in the **Running** or **Stopped** state.
     * *   The HaVip must be in the **Available** or **InUse** state.
     * *   The **AssociateHaVip** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HaVip:
     *     *   If the HaVip is in the **Associating** state, the HaVip is being associated.
     *     *   If the HaVip is in the **InUse** state, the HaVip is associated.
     * *   You cannot repeatedly call the **AssociateHaVip** operation to associate an HaVip within the specified period of time.
     *
     * @param request - AssociateHaVipRequest
     *
     * @returns AssociateHaVipResponse
     *
     * @param AssociateHaVipRequest $request
     *
     * @return AssociateHaVipResponse
     */
    public function associateHaVip($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->associateHaVipWithOptions($request, $runtime);
    }

    /**
     * Associates a network access control list (ACL) with a vSwitch.
     *
     * @remarks
     * ## [](#)Description
     * *   **AssociateNetworkAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
     *     *   If the network ACL is in the **BINDING** state, the network ACL is being associated.
     *     *   If the network ACL is in the **BINDED** state, the network ACL is associated.
     * *   You cannot repeatedly call the **AssociateNetworkAcl** operation to associate a network ACL within the specified period of time.
     *
     * @param request - AssociateNetworkAclRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AssociateNetworkAclResponse
     *
     * @param AssociateNetworkAclRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return AssociateNetworkAclResponse
     */
    public function associateNetworkAclWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->networkAclId) {
            @$query['NetworkAclId'] = $request->networkAclId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resource) {
            @$query['Resource'] = $request->resource;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AssociateNetworkAcl',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AssociateNetworkAclResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Associates a network access control list (ACL) with a vSwitch.
     *
     * @remarks
     * ## [](#)Description
     * *   **AssociateNetworkAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
     *     *   If the network ACL is in the **BINDING** state, the network ACL is being associated.
     *     *   If the network ACL is in the **BINDED** state, the network ACL is associated.
     * *   You cannot repeatedly call the **AssociateNetworkAcl** operation to associate a network ACL within the specified period of time.
     *
     * @param request - AssociateNetworkAclRequest
     *
     * @returns AssociateNetworkAclResponse
     *
     * @param AssociateNetworkAclRequest $request
     *
     * @return AssociateNetworkAclResponse
     */
    public function associateNetworkAcl($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->associateNetworkAclWithOptions($request, $runtime);
    }

    /**
     * Associates a virtual border router (VBR) with a specified Express Connect circuit.
     *
     * @param request - AssociatePhysicalConnectionToVirtualBorderRouterRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AssociatePhysicalConnectionToVirtualBorderRouterResponse
     *
     * @param AssociatePhysicalConnectionToVirtualBorderRouterRequest $request
     * @param RuntimeOptions                                          $runtime
     *
     * @return AssociatePhysicalConnectionToVirtualBorderRouterResponse
     */
    public function associatePhysicalConnectionToVirtualBorderRouterWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->circuitCode) {
            @$query['CircuitCode'] = $request->circuitCode;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->enableIpv6) {
            @$query['EnableIpv6'] = $request->enableIpv6;
        }

        if (null !== $request->localGatewayIp) {
            @$query['LocalGatewayIp'] = $request->localGatewayIp;
        }

        if (null !== $request->localIpv6GatewayIp) {
            @$query['LocalIpv6GatewayIp'] = $request->localIpv6GatewayIp;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->peerGatewayIp) {
            @$query['PeerGatewayIp'] = $request->peerGatewayIp;
        }

        if (null !== $request->peerIpv6GatewayIp) {
            @$query['PeerIpv6GatewayIp'] = $request->peerIpv6GatewayIp;
        }

        if (null !== $request->peeringIpv6SubnetMask) {
            @$query['PeeringIpv6SubnetMask'] = $request->peeringIpv6SubnetMask;
        }

        if (null !== $request->peeringSubnetMask) {
            @$query['PeeringSubnetMask'] = $request->peeringSubnetMask;
        }

        if (null !== $request->physicalConnectionId) {
            @$query['PhysicalConnectionId'] = $request->physicalConnectionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vbrId) {
            @$query['VbrId'] = $request->vbrId;
        }

        if (null !== $request->vlanId) {
            @$query['VlanId'] = $request->vlanId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AssociatePhysicalConnectionToVirtualBorderRouter',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AssociatePhysicalConnectionToVirtualBorderRouterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Associates a virtual border router (VBR) with a specified Express Connect circuit.
     *
     * @param request - AssociatePhysicalConnectionToVirtualBorderRouterRequest
     *
     * @returns AssociatePhysicalConnectionToVirtualBorderRouterResponse
     *
     * @param AssociatePhysicalConnectionToVirtualBorderRouterRequest $request
     *
     * @return AssociatePhysicalConnectionToVirtualBorderRouterResponse
     */
    public function associatePhysicalConnectionToVirtualBorderRouter($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->associatePhysicalConnectionToVirtualBorderRouterWithOptions($request, $runtime);
    }

    /**
     * Associates a custom route table with a vSwitch in the same VPC.
     *
     * @remarks
     * *AssociateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
     * *   If the vSwitch is in the **Pending** state, the route table is being associated with the vSwitch.
     * *   If the vSwitch is in the **Available** state, the route table is associated with the vSwitch.
     *
     * @param request - AssociateRouteTableRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AssociateRouteTableResponse
     *
     * @param AssociateRouteTableRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return AssociateRouteTableResponse
     */
    public function associateRouteTableWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeTableId) {
            @$query['RouteTableId'] = $request->routeTableId;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AssociateRouteTable',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AssociateRouteTableResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Associates a custom route table with a vSwitch in the same VPC.
     *
     * @remarks
     * *AssociateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
     * *   If the vSwitch is in the **Pending** state, the route table is being associated with the vSwitch.
     * *   If the vSwitch is in the **Available** state, the route table is associated with the vSwitch.
     *
     * @param request - AssociateRouteTableRequest
     *
     * @returns AssociateRouteTableResponse
     *
     * @param AssociateRouteTableRequest $request
     *
     * @return AssociateRouteTableResponse
     */
    public function associateRouteTable($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->associateRouteTableWithOptions($request, $runtime);
    }

    /**
     * Associates a gateway route table with an IPv4 gateway in the same virtual private cloud (VPC).
     *
     * @param request - AssociateRouteTableWithGatewayRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AssociateRouteTableWithGatewayResponse
     *
     * @param AssociateRouteTableWithGatewayRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return AssociateRouteTableWithGatewayResponse
     */
    public function associateRouteTableWithGatewayWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->gatewayId) {
            @$query['GatewayId'] = $request->gatewayId;
        }

        if (null !== $request->gatewayType) {
            @$query['GatewayType'] = $request->gatewayType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeTableId) {
            @$query['RouteTableId'] = $request->routeTableId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AssociateRouteTableWithGateway',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AssociateRouteTableWithGatewayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Associates a gateway route table with an IPv4 gateway in the same virtual private cloud (VPC).
     *
     * @param request - AssociateRouteTableWithGatewayRequest
     *
     * @returns AssociateRouteTableWithGatewayResponse
     *
     * @param AssociateRouteTableWithGatewayRequest $request
     *
     * @return AssociateRouteTableWithGatewayResponse
     */
    public function associateRouteTableWithGateway($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->associateRouteTableWithGatewayWithOptions($request, $runtime);
    }

    /**
     * Associates a route table with a gateway endpoint.
     *
     * @remarks
     * When you call this operation, take note of the following limits:
     * *   The gateway endpoint to be associated with the route table cannot be in one of the following states: **Creating**, **Modifying**, **Associating**, **Dissociating**, or **Deleting**.
     * *   The route table cannot be in one of the following states: **Creating**, **Modifying**, **Associating**, **Dissociating**, or **Deleting**.
     * *   The gateway endpoint and route table must belong to the same virtual private cloud (VPC).
     * *   The route table cannot be shared.
     * *   You cannot associate a gateway endpoint with a virtual border router (VBR) route table.
     * *   You can associate a gateway endpoint with at most 20 route tables at a time.
     * *   **AssociateRouteTablesWithVpcGatewayEndpoint** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetVpcGatewayEndpointAttribute](https://help.aliyun.com/document_detail/311017.html) operation to query whether a route table is associated with a gateway endpoint.
     *     *   If the **Associating** status is returned, the route table is being associated with the gateway endpoint.
     *     *   If the **Created** status is returned, the route table is associated with the gateway endpoint.
     * *   You cannot repeatedly call the **AssociateRouteTablesWithVpcGatewayEndpoint** operation within a specific period of time.
     *
     * @param request - AssociateRouteTablesWithVpcGatewayEndpointRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AssociateRouteTablesWithVpcGatewayEndpointResponse
     *
     * @param AssociateRouteTablesWithVpcGatewayEndpointRequest $request
     * @param RuntimeOptions                                    $runtime
     *
     * @return AssociateRouteTablesWithVpcGatewayEndpointResponse
     */
    public function associateRouteTablesWithVpcGatewayEndpointWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->endpointId) {
            @$query['EndpointId'] = $request->endpointId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeTableIds) {
            @$query['RouteTableIds'] = $request->routeTableIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AssociateRouteTablesWithVpcGatewayEndpoint',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AssociateRouteTablesWithVpcGatewayEndpointResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Associates a route table with a gateway endpoint.
     *
     * @remarks
     * When you call this operation, take note of the following limits:
     * *   The gateway endpoint to be associated with the route table cannot be in one of the following states: **Creating**, **Modifying**, **Associating**, **Dissociating**, or **Deleting**.
     * *   The route table cannot be in one of the following states: **Creating**, **Modifying**, **Associating**, **Dissociating**, or **Deleting**.
     * *   The gateway endpoint and route table must belong to the same virtual private cloud (VPC).
     * *   The route table cannot be shared.
     * *   You cannot associate a gateway endpoint with a virtual border router (VBR) route table.
     * *   You can associate a gateway endpoint with at most 20 route tables at a time.
     * *   **AssociateRouteTablesWithVpcGatewayEndpoint** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetVpcGatewayEndpointAttribute](https://help.aliyun.com/document_detail/311017.html) operation to query whether a route table is associated with a gateway endpoint.
     *     *   If the **Associating** status is returned, the route table is being associated with the gateway endpoint.
     *     *   If the **Created** status is returned, the route table is associated with the gateway endpoint.
     * *   You cannot repeatedly call the **AssociateRouteTablesWithVpcGatewayEndpoint** operation within a specific period of time.
     *
     * @param request - AssociateRouteTablesWithVpcGatewayEndpointRequest
     *
     * @returns AssociateRouteTablesWithVpcGatewayEndpointResponse
     *
     * @param AssociateRouteTablesWithVpcGatewayEndpointRequest $request
     *
     * @return AssociateRouteTablesWithVpcGatewayEndpointResponse
     */
    public function associateRouteTablesWithVpcGatewayEndpoint($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->associateRouteTablesWithVpcGatewayEndpointWithOptions($request, $runtime);
    }

    /**
     * Adds a secondary CIDR block to a virtual private cloud (VPC).
     *
     * @remarks
     * ## [](#)
     * *   Take note of the following limits:
     *     *   Each VPC can contain up to five secondary IPv4 CIDR blocks.
     *     *   Each VPC can contain up to five secondary IPv6 CIDR blocks.
     * *   You cannot repeatedly call the **AssociateVpcCidrBlock** operation to add secondary CIDR blocks to a VPC within the specified period of time.
     *
     * @param request - AssociateVpcCidrBlockRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AssociateVpcCidrBlockResponse
     *
     * @param AssociateVpcCidrBlockRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return AssociateVpcCidrBlockResponse
     */
    public function associateVpcCidrBlockWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->IPv6CidrBlock) {
            @$query['IPv6CidrBlock'] = $request->IPv6CidrBlock;
        }

        if (null !== $request->ipVersion) {
            @$query['IpVersion'] = $request->ipVersion;
        }

        if (null !== $request->ipamPoolId) {
            @$query['IpamPoolId'] = $request->ipamPoolId;
        }

        if (null !== $request->ipv6CidrMask) {
            @$query['Ipv6CidrMask'] = $request->ipv6CidrMask;
        }

        if (null !== $request->ipv6Isp) {
            @$query['Ipv6Isp'] = $request->ipv6Isp;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->secondaryCidrBlock) {
            @$query['SecondaryCidrBlock'] = $request->secondaryCidrBlock;
        }

        if (null !== $request->secondaryCidrMask) {
            @$query['SecondaryCidrMask'] = $request->secondaryCidrMask;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AssociateVpcCidrBlock',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AssociateVpcCidrBlockResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds a secondary CIDR block to a virtual private cloud (VPC).
     *
     * @remarks
     * ## [](#)
     * *   Take note of the following limits:
     *     *   Each VPC can contain up to five secondary IPv4 CIDR blocks.
     *     *   Each VPC can contain up to five secondary IPv6 CIDR blocks.
     * *   You cannot repeatedly call the **AssociateVpcCidrBlock** operation to add secondary CIDR blocks to a VPC within the specified period of time.
     *
     * @param request - AssociateVpcCidrBlockRequest
     *
     * @returns AssociateVpcCidrBlockResponse
     *
     * @param AssociateVpcCidrBlockRequest $request
     *
     * @return AssociateVpcCidrBlockResponse
     */
    public function associateVpcCidrBlock($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->associateVpcCidrBlockWithOptions($request, $runtime);
    }

    /**
     * Associates a VPN gateway with a certificate.
     *
     * @remarks
     * Before you associate a VPN gateway with an SSL certificate, take note of the following items:
     * *   You can associate only VPN gateways of the ShangMi (SM) type with SSL certificates. You need to associate a VPN gateway of the SM type with two SSL certificates, one as the encryption certificate and the other as the signature certificate.
     * *   The SSL certificates must use the SM algorithm.
     * *   You cannot specify one SSL certificate as both the encryption certificate and signature certificate for one VPN gateway.
     * *   **AssociateVpnGatewayWithCertificate** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the SSL certificate is being associated.
     *     *   If the VPN gateway is in the **active** state, the SSL certificate is being associated.
     * *   You cannot call **AssociateVpnGatewayWithCertificate** within a specific period of time.
     * ### [](#)Prerequisites
     * Make sure that you have two SSL certificates that use the SM algorithm in the Certificate Management Service console. For more information about SSL certificates, see [What is Certificate Management Service?](https://help.aliyun.com/document_detail/28535.html).
     *
     * @param request - AssociateVpnGatewayWithCertificateRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AssociateVpnGatewayWithCertificateResponse
     *
     * @param AssociateVpnGatewayWithCertificateRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return AssociateVpnGatewayWithCertificateResponse
     */
    public function associateVpnGatewayWithCertificateWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->certificateId) {
            @$query['CertificateId'] = $request->certificateId;
        }

        if (null !== $request->certificateType) {
            @$query['CertificateType'] = $request->certificateType;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->vpnGatewayId) {
            @$query['VpnGatewayId'] = $request->vpnGatewayId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AssociateVpnGatewayWithCertificate',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AssociateVpnGatewayWithCertificateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Associates a VPN gateway with a certificate.
     *
     * @remarks
     * Before you associate a VPN gateway with an SSL certificate, take note of the following items:
     * *   You can associate only VPN gateways of the ShangMi (SM) type with SSL certificates. You need to associate a VPN gateway of the SM type with two SSL certificates, one as the encryption certificate and the other as the signature certificate.
     * *   The SSL certificates must use the SM algorithm.
     * *   You cannot specify one SSL certificate as both the encryption certificate and signature certificate for one VPN gateway.
     * *   **AssociateVpnGatewayWithCertificate** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the SSL certificate is being associated.
     *     *   If the VPN gateway is in the **active** state, the SSL certificate is being associated.
     * *   You cannot call **AssociateVpnGatewayWithCertificate** within a specific period of time.
     * ### [](#)Prerequisites
     * Make sure that you have two SSL certificates that use the SM algorithm in the Certificate Management Service console. For more information about SSL certificates, see [What is Certificate Management Service?](https://help.aliyun.com/document_detail/28535.html).
     *
     * @param request - AssociateVpnGatewayWithCertificateRequest
     *
     * @returns AssociateVpnGatewayWithCertificateResponse
     *
     * @param AssociateVpnGatewayWithCertificateRequest $request
     *
     * @return AssociateVpnGatewayWithCertificateResponse
     */
    public function associateVpnGatewayWithCertificate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->associateVpnGatewayWithCertificateWithOptions($request, $runtime);
    }

    /**
     * DHCPVPC.
     *
     * @remarks
     *   The **AttachDhcpOptionsSetToVpc** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a DHCP options set:
     *     *   If the DHCP options set is in the **Pending** state, the DHCP options set is being associated.
     *     *   If the DHCP options set is in the **InUse** state, the DHCP options set is associated.
     * *   You cannot repeatedly call the **AttachDhcpOptionsSetToVpc** operation to associate DHCP options sets with a VPC within the specified period of time.
     *
     * @param request - AttachDhcpOptionsSetToVpcRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AttachDhcpOptionsSetToVpcResponse
     *
     * @param AttachDhcpOptionsSetToVpcRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return AttachDhcpOptionsSetToVpcResponse
     */
    public function attachDhcpOptionsSetToVpcWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dhcpOptionsSetId) {
            @$query['DhcpOptionsSetId'] = $request->dhcpOptionsSetId;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AttachDhcpOptionsSetToVpc',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AttachDhcpOptionsSetToVpcResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * DHCPVPC.
     *
     * @remarks
     *   The **AttachDhcpOptionsSetToVpc** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a DHCP options set:
     *     *   If the DHCP options set is in the **Pending** state, the DHCP options set is being associated.
     *     *   If the DHCP options set is in the **InUse** state, the DHCP options set is associated.
     * *   You cannot repeatedly call the **AttachDhcpOptionsSetToVpc** operation to associate DHCP options sets with a VPC within the specified period of time.
     *
     * @param request - AttachDhcpOptionsSetToVpcRequest
     *
     * @returns AttachDhcpOptionsSetToVpcResponse
     *
     * @param AttachDhcpOptionsSetToVpcRequest $request
     *
     * @return AttachDhcpOptionsSetToVpcResponse
     */
    public function attachDhcpOptionsSetToVpc($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->attachDhcpOptionsSetToVpcWithOptions($request, $runtime);
    }

    /**
     * Associates a virtual border router (VBR) with a hosted connection.
     *
     * @param request - AttachVbrToVpconnRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AttachVbrToVpconnResponse
     *
     * @param AttachVbrToVpconnRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return AttachVbrToVpconnResponse
     */
    public function attachVbrToVpconnWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->token) {
            @$query['Token'] = $request->token;
        }

        if (null !== $request->vbrId) {
            @$query['VbrId'] = $request->vbrId;
        }

        if (null !== $request->vpconnId) {
            @$query['VpconnId'] = $request->vpconnId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AttachVbrToVpconn',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AttachVbrToVpconnResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Associates a virtual border router (VBR) with a hosted connection.
     *
     * @param request - AttachVbrToVpconnRequest
     *
     * @returns AttachVbrToVpconnResponse
     *
     * @param AttachVbrToVpconnRequest $request
     *
     * @return AttachVbrToVpconnResponse
     */
    public function attachVbrToVpconn($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->attachVbrToVpconnWithOptions($request, $runtime);
    }

    /**
     * Cancels the maximum bandwidth configured for an elastic IP address (EIP) that is associated with an Internet Shared Bandwidth instance.
     *
     * @remarks
     * Before you call this operation, take note of the following items:
     * *   After this operation is performed, the maximum bandwidth of the EIP equals that of the Internet Shared Bandwidth instance.
     * *   You cannot repeatedly call the **CancelCommonBandwidthPackageIpBandwidth** operation within a specific time period.
     *
     * @param request - CancelCommonBandwidthPackageIpBandwidthRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CancelCommonBandwidthPackageIpBandwidthResponse
     *
     * @param CancelCommonBandwidthPackageIpBandwidthRequest $request
     * @param RuntimeOptions                                 $runtime
     *
     * @return CancelCommonBandwidthPackageIpBandwidthResponse
     */
    public function cancelCommonBandwidthPackageIpBandwidthWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bandwidthPackageId) {
            @$query['BandwidthPackageId'] = $request->bandwidthPackageId;
        }

        if (null !== $request->eipId) {
            @$query['EipId'] = $request->eipId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CancelCommonBandwidthPackageIpBandwidth',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CancelCommonBandwidthPackageIpBandwidthResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Cancels the maximum bandwidth configured for an elastic IP address (EIP) that is associated with an Internet Shared Bandwidth instance.
     *
     * @remarks
     * Before you call this operation, take note of the following items:
     * *   After this operation is performed, the maximum bandwidth of the EIP equals that of the Internet Shared Bandwidth instance.
     * *   You cannot repeatedly call the **CancelCommonBandwidthPackageIpBandwidth** operation within a specific time period.
     *
     * @param request - CancelCommonBandwidthPackageIpBandwidthRequest
     *
     * @returns CancelCommonBandwidthPackageIpBandwidthResponse
     *
     * @param CancelCommonBandwidthPackageIpBandwidthRequest $request
     *
     * @return CancelCommonBandwidthPackageIpBandwidthResponse
     */
    public function cancelCommonBandwidthPackageIpBandwidth($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->cancelCommonBandwidthPackageIpBandwidthWithOptions($request, $runtime);
    }

    /**
     * Cancels an Express Connect circuit before it is enabled. After you perform this operation, the Express Connect circuit enters the Canceled state.
     *
     * @remarks
     * You can cancel only an Express Connect circuit that is in the **Initial**, **Approved**, **Allocated**, or **Confirmed** state.
     *
     * @param request - CancelPhysicalConnectionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CancelPhysicalConnectionResponse
     *
     * @param CancelPhysicalConnectionRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return CancelPhysicalConnectionResponse
     */
    public function cancelPhysicalConnectionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->physicalConnectionId) {
            @$query['PhysicalConnectionId'] = $request->physicalConnectionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CancelPhysicalConnection',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CancelPhysicalConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Cancels an Express Connect circuit before it is enabled. After you perform this operation, the Express Connect circuit enters the Canceled state.
     *
     * @remarks
     * You can cancel only an Express Connect circuit that is in the **Initial**, **Approved**, **Allocated**, or **Confirmed** state.
     *
     * @param request - CancelPhysicalConnectionRequest
     *
     * @returns CancelPhysicalConnectionResponse
     *
     * @param CancelPhysicalConnectionRequest $request
     *
     * @return CancelPhysicalConnectionResponse
     */
    public function cancelPhysicalConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->cancelPhysicalConnectionWithOptions($request, $runtime);
    }

    /**
     * Moves an Express Connect circuit to a new resource group.
     *
     * @remarks
     * ## [](#)
     * You cannot repeatedly call the **ChangeResourceGroup** operation to modify the resource group of the same Express Connect circuit.
     *
     * @param request - ChangeResourceGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ChangeResourceGroupResponse
     *
     * @param ChangeResourceGroupRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ChangeResourceGroupResponse
     */
    public function changeResourceGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->newResourceGroupId) {
            @$query['NewResourceGroupId'] = $request->newResourceGroupId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ChangeResourceGroup',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ChangeResourceGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Moves an Express Connect circuit to a new resource group.
     *
     * @remarks
     * ## [](#)
     * You cannot repeatedly call the **ChangeResourceGroup** operation to modify the resource group of the same Express Connect circuit.
     *
     * @param request - ChangeResourceGroupRequest
     *
     * @returns ChangeResourceGroupResponse
     *
     * @param ChangeResourceGroupRequest $request
     *
     * @return ChangeResourceGroupResponse
     */
    public function changeResourceGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->changeResourceGroupWithOptions($request, $runtime);
    }

    /**
     * Checks whether a private IP address in a specified vSwitch is available.
     *
     * @param request - CheckCanAllocateVpcPrivateIpAddressRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CheckCanAllocateVpcPrivateIpAddressResponse
     *
     * @param CheckCanAllocateVpcPrivateIpAddressRequest $request
     * @param RuntimeOptions                             $runtime
     *
     * @return CheckCanAllocateVpcPrivateIpAddressResponse
     */
    public function checkCanAllocateVpcPrivateIpAddressWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ipVersion) {
            @$query['IpVersion'] = $request->ipVersion;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->privateIpAddress) {
            @$query['PrivateIpAddress'] = $request->privateIpAddress;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CheckCanAllocateVpcPrivateIpAddress',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CheckCanAllocateVpcPrivateIpAddressResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Checks whether a private IP address in a specified vSwitch is available.
     *
     * @param request - CheckCanAllocateVpcPrivateIpAddressRequest
     *
     * @returns CheckCanAllocateVpcPrivateIpAddressResponse
     *
     * @param CheckCanAllocateVpcPrivateIpAddressRequest $request
     *
     * @return CheckCanAllocateVpcPrivateIpAddressResponse
     */
    public function checkCanAllocateVpcPrivateIpAddress($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkCanAllocateVpcPrivateIpAddressWithOptions($request, $runtime);
    }

    /**
     * Checks whether the region of an IPsec-VPN connection supports BGP.
     *
     * @param request - CheckVpnBgpEnabledRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CheckVpnBgpEnabledResponse
     *
     * @param CheckVpnBgpEnabledRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return CheckVpnBgpEnabledResponse
     */
    public function checkVpnBgpEnabledWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CheckVpnBgpEnabled',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CheckVpnBgpEnabledResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Checks whether the region of an IPsec-VPN connection supports BGP.
     *
     * @param request - CheckVpnBgpEnabledRequest
     *
     * @returns CheckVpnBgpEnabledResponse
     *
     * @param CheckVpnBgpEnabledRequest $request
     *
     * @return CheckVpnBgpEnabledResponse
     */
    public function checkVpnBgpEnabled($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkVpnBgpEnabledWithOptions($request, $runtime);
    }

    /**
     * Generates a report for an installed Express Connect circuit.
     *
     * @param request - CompletePhysicalConnectionLOARequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CompletePhysicalConnectionLOAResponse
     *
     * @param CompletePhysicalConnectionLOARequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return CompletePhysicalConnectionLOAResponse
     */
    public function completePhysicalConnectionLOAWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->finishWork) {
            @$query['FinishWork'] = $request->finishWork;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->lineCode) {
            @$query['LineCode'] = $request->lineCode;
        }

        if (null !== $request->lineLabel) {
            @$query['LineLabel'] = $request->lineLabel;
        }

        if (null !== $request->lineSPContactInfo) {
            @$query['LineSPContactInfo'] = $request->lineSPContactInfo;
        }

        if (null !== $request->lineServiceProvider) {
            @$query['LineServiceProvider'] = $request->lineServiceProvider;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CompletePhysicalConnectionLOA',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CompletePhysicalConnectionLOAResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Generates a report for an installed Express Connect circuit.
     *
     * @param request - CompletePhysicalConnectionLOARequest
     *
     * @returns CompletePhysicalConnectionLOAResponse
     *
     * @param CompletePhysicalConnectionLOARequest $request
     *
     * @return CompletePhysicalConnectionLOAResponse
     */
    public function completePhysicalConnectionLOA($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->completePhysicalConnectionLOAWithOptions($request, $runtime);
    }

    /**
     * Changes the status of an Express Connect circuit to Confirmed.
     *
     * @param request - ConfirmPhysicalConnectionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ConfirmPhysicalConnectionResponse
     *
     * @param ConfirmPhysicalConnectionRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return ConfirmPhysicalConnectionResponse
     */
    public function confirmPhysicalConnectionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->physicalConnectionId) {
            @$query['PhysicalConnectionId'] = $request->physicalConnectionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ConfirmPhysicalConnection',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ConfirmPhysicalConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the status of an Express Connect circuit to Confirmed.
     *
     * @param request - ConfirmPhysicalConnectionRequest
     *
     * @returns ConfirmPhysicalConnectionResponse
     *
     * @param ConfirmPhysicalConnectionRequest $request
     *
     * @return ConfirmPhysicalConnectionResponse
     */
    public function confirmPhysicalConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->confirmPhysicalConnectionWithOptions($request, $runtime);
    }

    /**
     * Initiates a connection from the router interface of an initiator to the router interface of an accepter.
     *
     * @remarks
     * After you call this operation, the router interface enters the **Connecting** state. When the connection is established, it enters the **Active** state.
     * When you call this operation, take note of the following items:
     * *   Only an initiator router interface in the **Idle** state can initiate a connection.
     * *   You can create only one pair of connected router interfaces between two routers.
     * *   You cannot initiate a connection if your Alibaba Cloud account has a router interface with overdue payments.
     *
     * @param request - ConnectRouterInterfaceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ConnectRouterInterfaceResponse
     *
     * @param ConnectRouterInterfaceRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return ConnectRouterInterfaceResponse
     */
    public function connectRouterInterfaceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routerInterfaceId) {
            @$query['RouterInterfaceId'] = $request->routerInterfaceId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ConnectRouterInterface',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ConnectRouterInterfaceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Initiates a connection from the router interface of an initiator to the router interface of an accepter.
     *
     * @remarks
     * After you call this operation, the router interface enters the **Connecting** state. When the connection is established, it enters the **Active** state.
     * When you call this operation, take note of the following items:
     * *   Only an initiator router interface in the **Idle** state can initiate a connection.
     * *   You can create only one pair of connected router interfaces between two routers.
     * *   You cannot initiate a connection if your Alibaba Cloud account has a router interface with overdue payments.
     *
     * @param request - ConnectRouterInterfaceRequest
     *
     * @returns ConnectRouterInterfaceResponse
     *
     * @param ConnectRouterInterfaceRequest $request
     *
     * @return ConnectRouterInterfaceResponse
     */
    public function connectRouterInterface($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->connectRouterInterfaceWithOptions($request, $runtime);
    }

    /**
     * Converts a NAT service plan to an Internet Shared Bandwidth instance.
     *
     * @remarks
     * Before you convert a NAT service plan to an Internet Shared Bandwidth instance, take note of the following limits:
     * *   You are not charged for the conversion.
     * *   When you convert a NAT service plan to an Internet Shared Bandwidth instance, you can continue to use the SNAT and DNAT features of the NAT gateway, and your workloads are not affected. However, we recommend that you convert your NAT service plan during off-peak hours.
     * *   After the NAT service plan is converted to an Internet Shared Bandwidth instance, the public IP addresses in the NAT service plan are converted to elastic IP addresses (EIPs). The maximum bandwidth and billing method of the Internet Shared Bandwidth instance are the same as those of the NAT service plan.
     *
     * @deprecated OpenAPI ConvertBandwidthPackage is deprecated
     *
     * @param request - ConvertBandwidthPackageRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ConvertBandwidthPackageResponse
     *
     * @param ConvertBandwidthPackageRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ConvertBandwidthPackageResponse
     */
    public function convertBandwidthPackageWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bandwidthPackageId) {
            @$query['BandwidthPackageId'] = $request->bandwidthPackageId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ConvertBandwidthPackage',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ConvertBandwidthPackageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Converts a NAT service plan to an Internet Shared Bandwidth instance.
     *
     * @remarks
     * Before you convert a NAT service plan to an Internet Shared Bandwidth instance, take note of the following limits:
     * *   You are not charged for the conversion.
     * *   When you convert a NAT service plan to an Internet Shared Bandwidth instance, you can continue to use the SNAT and DNAT features of the NAT gateway, and your workloads are not affected. However, we recommend that you convert your NAT service plan during off-peak hours.
     * *   After the NAT service plan is converted to an Internet Shared Bandwidth instance, the public IP addresses in the NAT service plan are converted to elastic IP addresses (EIPs). The maximum bandwidth and billing method of the Internet Shared Bandwidth instance are the same as those of the NAT service plan.
     *
     * @deprecated OpenAPI ConvertBandwidthPackage is deprecated
     *
     * @param request - ConvertBandwidthPackageRequest
     *
     * @returns ConvertBandwidthPackageResponse
     *
     * @param ConvertBandwidthPackageRequest $request
     *
     * @return ConvertBandwidthPackageResponse
     */
    public function convertBandwidthPackage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->convertBandwidthPackageWithOptions($request, $runtime);
    }

    /**
     * Copies rules of a network access control list (ACL).
     *
     * @remarks
     * ## [](#)Description
     * *   **CopyNetworkAclEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
     *     *   If the network ACL is in the **Modifying** state, the rules of the network ACL are being copied.
     *     *   If the network ACL is in the **Available** state, the rules of the network ACL are copied.
     * *   You cannot repeatedly call the **CopyNetworkAclEntries** operation within the specified period of time.
     *
     * @param request - CopyNetworkAclEntriesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CopyNetworkAclEntriesResponse
     *
     * @param CopyNetworkAclEntriesRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return CopyNetworkAclEntriesResponse
     */
    public function copyNetworkAclEntriesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->networkAclId) {
            @$query['NetworkAclId'] = $request->networkAclId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceNetworkAclId) {
            @$query['SourceNetworkAclId'] = $request->sourceNetworkAclId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CopyNetworkAclEntries',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CopyNetworkAclEntriesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Copies rules of a network access control list (ACL).
     *
     * @remarks
     * ## [](#)Description
     * *   **CopyNetworkAclEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
     *     *   If the network ACL is in the **Modifying** state, the rules of the network ACL are being copied.
     *     *   If the network ACL is in the **Available** state, the rules of the network ACL are copied.
     * *   You cannot repeatedly call the **CopyNetworkAclEntries** operation within the specified period of time.
     *
     * @param request - CopyNetworkAclEntriesRequest
     *
     * @returns CopyNetworkAclEntriesResponse
     *
     * @param CopyNetworkAclEntriesRequest $request
     *
     * @return CopyNetworkAclEntriesResponse
     */
    public function copyNetworkAclEntries($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->copyNetworkAclEntriesWithOptions($request, $runtime);
    }

    /**
     * Creates a BGP group for a virtual border router (VBR).
     *
     * @remarks
     * You can connect a VBR to a data center through BGP. Each BGP group is associated with a VBR. You can add a BGP peer that needs to communicate with a VBR to a BGP group and advertise the BGP network in the VBR.
     * BGP groups are used to simplify BGP configurations. You can add BGP peers that use the same configurations to one BGP group. Before you start, you must create a BGP group with the requested autonomous system number (ASN).
     * When you call this operation, take note of the following limits:
     * *   You can specify only the data center that is connected to the VBR through an Express Connect circuit as a BGP peer.
     * *   VBRs support only BGP-4.
     * *   You can create at most eight BGP peers for each VBR.
     * *   Each BGP peer supports at most 110 dynamic routes.
     * *   The ASN of Alibaba Cloud is 45104. You can specify a 2-byte or 4-byte ASN for the data center.
     *
     * @param request - CreateBgpGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateBgpGroupResponse
     *
     * @param CreateBgpGroupRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return CreateBgpGroupResponse
     */
    public function createBgpGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->authKey) {
            @$query['AuthKey'] = $request->authKey;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->ipVersion) {
            @$query['IpVersion'] = $request->ipVersion;
        }

        if (null !== $request->isFakeAsn) {
            @$query['IsFakeAsn'] = $request->isFakeAsn;
        }

        if (null !== $request->localAsn) {
            @$query['LocalAsn'] = $request->localAsn;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->peerAsn) {
            @$query['PeerAsn'] = $request->peerAsn;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeQuota) {
            @$query['RouteQuota'] = $request->routeQuota;
        }

        if (null !== $request->routerId) {
            @$query['RouterId'] = $request->routerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateBgpGroup',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateBgpGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a BGP group for a virtual border router (VBR).
     *
     * @remarks
     * You can connect a VBR to a data center through BGP. Each BGP group is associated with a VBR. You can add a BGP peer that needs to communicate with a VBR to a BGP group and advertise the BGP network in the VBR.
     * BGP groups are used to simplify BGP configurations. You can add BGP peers that use the same configurations to one BGP group. Before you start, you must create a BGP group with the requested autonomous system number (ASN).
     * When you call this operation, take note of the following limits:
     * *   You can specify only the data center that is connected to the VBR through an Express Connect circuit as a BGP peer.
     * *   VBRs support only BGP-4.
     * *   You can create at most eight BGP peers for each VBR.
     * *   Each BGP peer supports at most 110 dynamic routes.
     * *   The ASN of Alibaba Cloud is 45104. You can specify a 2-byte or 4-byte ASN for the data center.
     *
     * @param request - CreateBgpGroupRequest
     *
     * @returns CreateBgpGroupResponse
     *
     * @param CreateBgpGroupRequest $request
     *
     * @return CreateBgpGroupResponse
     */
    public function createBgpGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createBgpGroupWithOptions($request, $runtime);
    }

    /**
     * Adds a Border Gateway Protocol (BGP) peer to a BGP group.
     *
     * @param request - CreateBgpPeerRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateBgpPeerResponse
     *
     * @param CreateBgpPeerRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return CreateBgpPeerResponse
     */
    public function createBgpPeerWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bfdMultiHop) {
            @$query['BfdMultiHop'] = $request->bfdMultiHop;
        }

        if (null !== $request->bgpGroupId) {
            @$query['BgpGroupId'] = $request->bgpGroupId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->enableBfd) {
            @$query['EnableBfd'] = $request->enableBfd;
        }

        if (null !== $request->ipVersion) {
            @$query['IpVersion'] = $request->ipVersion;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->peerIpAddress) {
            @$query['PeerIpAddress'] = $request->peerIpAddress;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateBgpPeer',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateBgpPeerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds a Border Gateway Protocol (BGP) peer to a BGP group.
     *
     * @param request - CreateBgpPeerRequest
     *
     * @returns CreateBgpPeerResponse
     *
     * @param CreateBgpPeerRequest $request
     *
     * @return CreateBgpPeerResponse
     */
    public function createBgpPeer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createBgpPeerWithOptions($request, $runtime);
    }

    /**
     * Creates an Internet Shared Bandwidth instance.
     *
     * @param request - CreateCommonBandwidthPackageRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateCommonBandwidthPackageResponse
     *
     * @param CreateCommonBandwidthPackageRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return CreateCommonBandwidthPackageResponse
     */
    public function createCommonBandwidthPackageWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bandwidth) {
            @$query['Bandwidth'] = $request->bandwidth;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->ISP) {
            @$query['ISP'] = $request->ISP;
        }

        if (null !== $request->internetChargeType) {
            @$query['InternetChargeType'] = $request->internetChargeType;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->ratio) {
            @$query['Ratio'] = $request->ratio;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->securityProtectionTypes) {
            @$query['SecurityProtectionTypes'] = $request->securityProtectionTypes;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->zone) {
            @$query['Zone'] = $request->zone;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateCommonBandwidthPackage',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateCommonBandwidthPackageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an Internet Shared Bandwidth instance.
     *
     * @param request - CreateCommonBandwidthPackageRequest
     *
     * @returns CreateCommonBandwidthPackageResponse
     *
     * @param CreateCommonBandwidthPackageRequest $request
     *
     * @return CreateCommonBandwidthPackageResponse
     */
    public function createCommonBandwidthPackage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createCommonBandwidthPackageWithOptions($request, $runtime);
    }

    /**
     * Creates a customer gateway.
     *
     * @param request - CreateCustomerGatewayRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateCustomerGatewayResponse
     *
     * @param CreateCustomerGatewayRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return CreateCustomerGatewayResponse
     */
    public function createCustomerGatewayWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->asn) {
            @$query['Asn'] = $request->asn;
        }

        if (null !== $request->authKey) {
            @$query['AuthKey'] = $request->authKey;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->ipAddress) {
            @$query['IpAddress'] = $request->ipAddress;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateCustomerGateway',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateCustomerGatewayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a customer gateway.
     *
     * @param request - CreateCustomerGatewayRequest
     *
     * @returns CreateCustomerGatewayResponse
     *
     * @param CreateCustomerGatewayRequest $request
     *
     * @return CreateCustomerGatewayResponse
     */
    public function createCustomerGateway($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createCustomerGatewayWithOptions($request, $runtime);
    }

    /**
     * Creates a default vSwitch.
     *
     * @remarks
     * When you call this operation, take note of the following limits:
     * *   The first IP address and last three IP addresses of a vSwitch CIDR block are reserved. For example, if the CIDR block of a vSwitch is 192.168.1.0/24, the IP addresses 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255 are reserved.
     * *   The number of instances in the default vSwitch cannot exceed the remaining number of instances supported by the VPC (15,000 minus the number of existing instances).
     * *   Default vSwitches do not support multicasting or broadcasting.
     * *   After you create a default vSwitch, you cannot modify its CIDR block.
     * *   **CreateDefaultVSwitch** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of a default vSwitch:
     *     *   If a default vSwitch is in the **Pending** state, it is being configured.
     *     *   If a default vSwitch is in the **Available** state, it is available.
     * *   If a default vSwitch already exists in a region, you cannot call this operation to create a default vSwitch in this region.
     * *   Before you create a default vSwitch, make sure that a default VPC is created. You can call the [CreateDefaultVpc](https://help.aliyun.com/document_detail/609152.html) operation to create a default VPC.
     *
     * @param request - CreateDefaultVSwitchRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateDefaultVSwitchResponse
     *
     * @param CreateDefaultVSwitchRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return CreateDefaultVSwitchResponse
     */
    public function createDefaultVSwitchWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ipv6CidrBlock) {
            @$query['Ipv6CidrBlock'] = $request->ipv6CidrBlock;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->zoneId) {
            @$query['ZoneId'] = $request->zoneId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateDefaultVSwitch',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateDefaultVSwitchResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a default vSwitch.
     *
     * @remarks
     * When you call this operation, take note of the following limits:
     * *   The first IP address and last three IP addresses of a vSwitch CIDR block are reserved. For example, if the CIDR block of a vSwitch is 192.168.1.0/24, the IP addresses 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255 are reserved.
     * *   The number of instances in the default vSwitch cannot exceed the remaining number of instances supported by the VPC (15,000 minus the number of existing instances).
     * *   Default vSwitches do not support multicasting or broadcasting.
     * *   After you create a default vSwitch, you cannot modify its CIDR block.
     * *   **CreateDefaultVSwitch** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of a default vSwitch:
     *     *   If a default vSwitch is in the **Pending** state, it is being configured.
     *     *   If a default vSwitch is in the **Available** state, it is available.
     * *   If a default vSwitch already exists in a region, you cannot call this operation to create a default vSwitch in this region.
     * *   Before you create a default vSwitch, make sure that a default VPC is created. You can call the [CreateDefaultVpc](https://help.aliyun.com/document_detail/609152.html) operation to create a default VPC.
     *
     * @param request - CreateDefaultVSwitchRequest
     *
     * @returns CreateDefaultVSwitchResponse
     *
     * @param CreateDefaultVSwitchRequest $request
     *
     * @return CreateDefaultVSwitchResponse
     */
    public function createDefaultVSwitch($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDefaultVSwitchWithOptions($request, $runtime);
    }

    /**
     * Creates a default virtual private cloud (VPC).
     *
     * @remarks
     * ## Usage notes
     * When you call this operation, take note of the following items:
     * *   After you create a default VPC, you cannot change its CIDR block. However, you can add secondary IPv4 CIDR blocks to it.
     * *   In each default VPC, cloud services can use a maximum of 60,000 private IP addresses. You cannot increase the quota.
     * *   After you create a default VPC, a vRouter and a route table are automatically created for the VPC.
     * *   At most three user CIDR blocks can be added to a VPC. If a user CIDR block includes another user CIDR block, the one with the shorter subnet mask takes effect. For example, if 10.0.0.0/8 and 10.1.0.0/16 are specified, only 10.0.0.0/8 takes effect.
     * *   **CreateDefaultVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task:
     *     *   If the default VPC is in the **Pending** state, the VPC is being configured.
     *     *   If the default VPC is in the **Available** state, the VPC is available.
     * *   You cannot repeatedly call the **CreateDefaultVpc** operation within a specific time period.
     * *   You can create only one default VPC in each region.
     *
     * @param request - CreateDefaultVpcRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateDefaultVpcResponse
     *
     * @param CreateDefaultVpcRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return CreateDefaultVpcResponse
     */
    public function createDefaultVpcWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->enableIpv6) {
            @$query['EnableIpv6'] = $request->enableIpv6;
        }

        if (null !== $request->ipv6CidrBlock) {
            @$query['Ipv6CidrBlock'] = $request->ipv6CidrBlock;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateDefaultVpc',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateDefaultVpcResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a default virtual private cloud (VPC).
     *
     * @remarks
     * ## Usage notes
     * When you call this operation, take note of the following items:
     * *   After you create a default VPC, you cannot change its CIDR block. However, you can add secondary IPv4 CIDR blocks to it.
     * *   In each default VPC, cloud services can use a maximum of 60,000 private IP addresses. You cannot increase the quota.
     * *   After you create a default VPC, a vRouter and a route table are automatically created for the VPC.
     * *   At most three user CIDR blocks can be added to a VPC. If a user CIDR block includes another user CIDR block, the one with the shorter subnet mask takes effect. For example, if 10.0.0.0/8 and 10.1.0.0/16 are specified, only 10.0.0.0/8 takes effect.
     * *   **CreateDefaultVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task:
     *     *   If the default VPC is in the **Pending** state, the VPC is being configured.
     *     *   If the default VPC is in the **Available** state, the VPC is available.
     * *   You cannot repeatedly call the **CreateDefaultVpc** operation within a specific time period.
     * *   You can create only one default VPC in each region.
     *
     * @param request - CreateDefaultVpcRequest
     *
     * @returns CreateDefaultVpcResponse
     *
     * @param CreateDefaultVpcRequest $request
     *
     * @return CreateDefaultVpcResponse
     */
    public function createDefaultVpc($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDefaultVpcWithOptions($request, $runtime);
    }

    /**
     * Creates a DHCP options set.
     *
     * @remarks
     *   **CreateDhcpOptionsSet** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [GetDhcpOptionsSet](https://help.aliyun.com/document_detail/448820.html) to query the status of the task.
     *     *   If the vSwitch is in the **Pending** state, the DHCP options set is being configured.
     *     *   If the vSwitch is in the **Available** state, the DHCP options set is available.
     *
     * @param request - CreateDhcpOptionsSetRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateDhcpOptionsSetResponse
     *
     * @param CreateDhcpOptionsSetRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return CreateDhcpOptionsSetResponse
     */
    public function createDhcpOptionsSetWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dhcpOptionsSetDescription) {
            @$query['DhcpOptionsSetDescription'] = $request->dhcpOptionsSetDescription;
        }

        if (null !== $request->dhcpOptionsSetName) {
            @$query['DhcpOptionsSetName'] = $request->dhcpOptionsSetName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->domainNameServers) {
            @$query['DomainNameServers'] = $request->domainNameServers;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ipv6LeaseTime) {
            @$query['Ipv6LeaseTime'] = $request->ipv6LeaseTime;
        }

        if (null !== $request->leaseTime) {
            @$query['LeaseTime'] = $request->leaseTime;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateDhcpOptionsSet',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateDhcpOptionsSetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a DHCP options set.
     *
     * @remarks
     *   **CreateDhcpOptionsSet** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [GetDhcpOptionsSet](https://help.aliyun.com/document_detail/448820.html) to query the status of the task.
     *     *   If the vSwitch is in the **Pending** state, the DHCP options set is being configured.
     *     *   If the vSwitch is in the **Available** state, the DHCP options set is available.
     *
     * @param request - CreateDhcpOptionsSetRequest
     *
     * @returns CreateDhcpOptionsSetResponse
     *
     * @param CreateDhcpOptionsSetRequest $request
     *
     * @return CreateDhcpOptionsSetResponse
     */
    public function createDhcpOptionsSet($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDhcpOptionsSetWithOptions($request, $runtime);
    }

    /**
     * Creates an Express Cloud Connect (ECC) instance.
     *
     * @param request - CreateExpressCloudConnectionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateExpressCloudConnectionResponse
     *
     * @param CreateExpressCloudConnectionRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return CreateExpressCloudConnectionResponse
     */
    public function createExpressCloudConnectionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bandwidth) {
            @$query['Bandwidth'] = $request->bandwidth;
        }

        if (null !== $request->contactMail) {
            @$query['ContactMail'] = $request->contactMail;
        }

        if (null !== $request->contactTel) {
            @$query['ContactTel'] = $request->contactTel;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->IDCardNo) {
            @$query['IDCardNo'] = $request->IDCardNo;
        }

        if (null !== $request->idcSP) {
            @$query['IdcSP'] = $request->idcSP;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->peerCity) {
            @$query['PeerCity'] = $request->peerCity;
        }

        if (null !== $request->peerLocation) {
            @$query['PeerLocation'] = $request->peerLocation;
        }

        if (null !== $request->portType) {
            @$query['PortType'] = $request->portType;
        }

        if (null !== $request->redundantEccId) {
            @$query['RedundantEccId'] = $request->redundantEccId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateExpressCloudConnection',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateExpressCloudConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an Express Cloud Connect (ECC) instance.
     *
     * @param request - CreateExpressCloudConnectionRequest
     *
     * @returns CreateExpressCloudConnectionResponse
     *
     * @param CreateExpressCloudConnectionRequest $request
     *
     * @return CreateExpressCloudConnectionResponse
     */
    public function createExpressCloudConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createExpressCloudConnectionWithOptions($request, $runtime);
    }

    /**
     * Creates a quality of service (QoS) policy.
     *
     * @param request - CreateExpressConnectTrafficQosRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateExpressConnectTrafficQosResponse
     *
     * @param CreateExpressConnectTrafficQosRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return CreateExpressConnectTrafficQosResponse
     */
    public function createExpressConnectTrafficQosWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->qosDescription) {
            @$query['QosDescription'] = $request->qosDescription;
        }

        if (null !== $request->qosName) {
            @$query['QosName'] = $request->qosName;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateExpressConnectTrafficQos',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateExpressConnectTrafficQosResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a quality of service (QoS) policy.
     *
     * @param request - CreateExpressConnectTrafficQosRequest
     *
     * @returns CreateExpressConnectTrafficQosResponse
     *
     * @param CreateExpressConnectTrafficQosRequest $request
     *
     * @return CreateExpressConnectTrafficQosResponse
     */
    public function createExpressConnectTrafficQos($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createExpressConnectTrafficQosWithOptions($request, $runtime);
    }

    /**
     * Creates a quality of service (QoS) queue.
     *
     * @param request - CreateExpressConnectTrafficQosQueueRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateExpressConnectTrafficQosQueueResponse
     *
     * @param CreateExpressConnectTrafficQosQueueRequest $request
     * @param RuntimeOptions                             $runtime
     *
     * @return CreateExpressConnectTrafficQosQueueResponse
     */
    public function createExpressConnectTrafficQosQueueWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bandwidthPercent) {
            @$query['BandwidthPercent'] = $request->bandwidthPercent;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->qosId) {
            @$query['QosId'] = $request->qosId;
        }

        if (null !== $request->queueDescription) {
            @$query['QueueDescription'] = $request->queueDescription;
        }

        if (null !== $request->queueName) {
            @$query['QueueName'] = $request->queueName;
        }

        if (null !== $request->queueType) {
            @$query['QueueType'] = $request->queueType;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateExpressConnectTrafficQosQueue',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateExpressConnectTrafficQosQueueResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a quality of service (QoS) queue.
     *
     * @param request - CreateExpressConnectTrafficQosQueueRequest
     *
     * @returns CreateExpressConnectTrafficQosQueueResponse
     *
     * @param CreateExpressConnectTrafficQosQueueRequest $request
     *
     * @return CreateExpressConnectTrafficQosQueueResponse
     */
    public function createExpressConnectTrafficQosQueue($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createExpressConnectTrafficQosQueueWithOptions($request, $runtime);
    }

    /**
     * Creates a quality of service (QoS) rule.
     *
     * @param request - CreateExpressConnectTrafficQosRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateExpressConnectTrafficQosRuleResponse
     *
     * @param CreateExpressConnectTrafficQosRuleRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return CreateExpressConnectTrafficQosRuleResponse
     */
    public function createExpressConnectTrafficQosRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dstCidr) {
            @$query['DstCidr'] = $request->dstCidr;
        }

        if (null !== $request->dstIPv6Cidr) {
            @$query['DstIPv6Cidr'] = $request->dstIPv6Cidr;
        }

        if (null !== $request->dstPortRange) {
            @$query['DstPortRange'] = $request->dstPortRange;
        }

        if (null !== $request->matchDscp) {
            @$query['MatchDscp'] = $request->matchDscp;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->priority) {
            @$query['Priority'] = $request->priority;
        }

        if (null !== $request->protocol) {
            @$query['Protocol'] = $request->protocol;
        }

        if (null !== $request->qosId) {
            @$query['QosId'] = $request->qosId;
        }

        if (null !== $request->queueId) {
            @$query['QueueId'] = $request->queueId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->remarkingDscp) {
            @$query['RemarkingDscp'] = $request->remarkingDscp;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->ruleDescription) {
            @$query['RuleDescription'] = $request->ruleDescription;
        }

        if (null !== $request->ruleName) {
            @$query['RuleName'] = $request->ruleName;
        }

        if (null !== $request->srcCidr) {
            @$query['SrcCidr'] = $request->srcCidr;
        }

        if (null !== $request->srcIPv6Cidr) {
            @$query['SrcIPv6Cidr'] = $request->srcIPv6Cidr;
        }

        if (null !== $request->srcPortRange) {
            @$query['SrcPortRange'] = $request->srcPortRange;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateExpressConnectTrafficQosRule',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateExpressConnectTrafficQosRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a quality of service (QoS) rule.
     *
     * @param request - CreateExpressConnectTrafficQosRuleRequest
     *
     * @returns CreateExpressConnectTrafficQosRuleResponse
     *
     * @param CreateExpressConnectTrafficQosRuleRequest $request
     *
     * @return CreateExpressConnectTrafficQosRuleResponse
     */
    public function createExpressConnectTrafficQosRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createExpressConnectTrafficQosRuleWithOptions($request, $runtime);
    }

    /**
     * Creates a failover test.
     *
     * @remarks
     * You cannot create a failover test in the following scenarios:
     * *   You have created a failover test in the region and its type is StartNow.
     * *   The Express Connect circuit or hosted connection has pending orders or overdue payments.
     * *   A failover test is already performed on the Express Connect circuit or hosted connection.
     * *   More than one hosted connection is created over the Express Connect circuit.
     * *   More than one cross-account VBR is created on the Express Connect circuit.
     * *   No VBR is associated with the hosted connection.
     * *   The VLAN ID of the hosted connection is set to 0.
     *
     * @param request - CreateFailoverTestJobRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateFailoverTestJobResponse
     *
     * @param CreateFailoverTestJobRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return CreateFailoverTestJobResponse
     */
    public function createFailoverTestJobWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->jobDuration) {
            @$query['JobDuration'] = $request->jobDuration;
        }

        if (null !== $request->jobType) {
            @$query['JobType'] = $request->jobType;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateFailoverTestJob',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateFailoverTestJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a failover test.
     *
     * @remarks
     * You cannot create a failover test in the following scenarios:
     * *   You have created a failover test in the region and its type is StartNow.
     * *   The Express Connect circuit or hosted connection has pending orders or overdue payments.
     * *   A failover test is already performed on the Express Connect circuit or hosted connection.
     * *   More than one hosted connection is created over the Express Connect circuit.
     * *   More than one cross-account VBR is created on the Express Connect circuit.
     * *   No VBR is associated with the hosted connection.
     * *   The VLAN ID of the hosted connection is set to 0.
     *
     * @param request - CreateFailoverTestJobRequest
     *
     * @returns CreateFailoverTestJobResponse
     *
     * @param CreateFailoverTestJobRequest $request
     *
     * @return CreateFailoverTestJobResponse
     */
    public function createFailoverTestJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createFailoverTestJobWithOptions($request, $runtime);
    }

    /**
     * Creates a flow log.
     *
     * @remarks
     * *CreateFlowLog** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of the flow log.
     * *   If the flow log is in the **Activating** state, the flow log is being created.
     * *   If the flow log is in the **Active** state, the flow log is created and started.
     *
     * @param request - CreateFlowLogRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateFlowLogResponse
     *
     * @param CreateFlowLogRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return CreateFlowLogResponse
     */
    public function createFlowLogWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aggregationInterval) {
            @$query['AggregationInterval'] = $request->aggregationInterval;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->flowLogName) {
            @$query['FlowLogName'] = $request->flowLogName;
        }

        if (null !== $request->ipVersion) {
            @$query['IpVersion'] = $request->ipVersion;
        }

        if (null !== $request->logStoreName) {
            @$query['LogStoreName'] = $request->logStoreName;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->projectName) {
            @$query['ProjectName'] = $request->projectName;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->trafficPath) {
            @$query['TrafficPath'] = $request->trafficPath;
        }

        if (null !== $request->trafficType) {
            @$query['TrafficType'] = $request->trafficType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateFlowLog',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateFlowLogResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a flow log.
     *
     * @remarks
     * *CreateFlowLog** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of the flow log.
     * *   If the flow log is in the **Activating** state, the flow log is being created.
     * *   If the flow log is in the **Active** state, the flow log is created and started.
     *
     * @param request - CreateFlowLogRequest
     *
     * @returns CreateFlowLogResponse
     *
     * @param CreateFlowLogRequest $request
     *
     * @return CreateFlowLogResponse
     */
    public function createFlowLog($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createFlowLogWithOptions($request, $runtime);
    }

    /**
     * Adds a DNAT entry to a DNAT table.
     *
     * @remarks
     * ## [](#)
     * Each DNAT entry consists of the following parameters: **ExternalIp**, **ExternalPort**, **IpProtocol**, **InternalIp**, and **InternalPort**. After you add a DNAT entry, the NAT gateway forwards packets over the specified protocol from **ExternalIp:ExternalPort** to **InternalIp:InternalPort** and sends responses back through the same route.
     * When you call this operation, take note of the following limits:
     * *   **CreateForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
     *     *   If the DNAT entry is in the **Pending** state, the system is adding the DNAT entry. You can only query the DNAT entry, but cannot perform other operations.
     *     *   If the DNAT entry is in the **Available** state, the DNAT entry is added.
     * *   You cannot repeatedly call the **CreateForwardEntry** operation to add a DNAT entry within a specific period of time.
     * *   All combinations of **ExternalIp**, **ExternalPort**, and **IpProtocol** used in DNAT entries must be unique. You cannot distribute requests to more than one Elastic Compute Service (ECS) instance if these requests are initiated from the same source IP address, received on the same port, and use the same protocol.
     * *   The combinations of **IpProtocol**, **InternalIp**, and **InternalPort** must be unique.
     * *   If one or more DNAT entries in the DNAT table are in the **Pending** or **Modifying** state, you cannot add DNAT entries to the DNAT table.
     * *   You can add at most 100 DNAT entries to a DNAT table.
     * *   For an elastic IP address (EIP) used by an Internet NAT gateway or a NAT IP address used by a Virtual Private Cloud (VPC) NAT gateway, take note of the following limit: If the IP address has IP mapping enabled and is specified in a DNAT entry, the IP address cannot be used by another DNAT or SNAT entry.
     *
     * @param request - CreateForwardEntryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateForwardEntryResponse
     *
     * @param CreateForwardEntryRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return CreateForwardEntryResponse
     */
    public function createForwardEntryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->externalIp) {
            @$query['ExternalIp'] = $request->externalIp;
        }

        if (null !== $request->externalPort) {
            @$query['ExternalPort'] = $request->externalPort;
        }

        if (null !== $request->forwardEntryName) {
            @$query['ForwardEntryName'] = $request->forwardEntryName;
        }

        if (null !== $request->forwardTableId) {
            @$query['ForwardTableId'] = $request->forwardTableId;
        }

        if (null !== $request->internalIp) {
            @$query['InternalIp'] = $request->internalIp;
        }

        if (null !== $request->internalPort) {
            @$query['InternalPort'] = $request->internalPort;
        }

        if (null !== $request->ipProtocol) {
            @$query['IpProtocol'] = $request->ipProtocol;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->portBreak) {
            @$query['PortBreak'] = $request->portBreak;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateForwardEntry',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateForwardEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds a DNAT entry to a DNAT table.
     *
     * @remarks
     * ## [](#)
     * Each DNAT entry consists of the following parameters: **ExternalIp**, **ExternalPort**, **IpProtocol**, **InternalIp**, and **InternalPort**. After you add a DNAT entry, the NAT gateway forwards packets over the specified protocol from **ExternalIp:ExternalPort** to **InternalIp:InternalPort** and sends responses back through the same route.
     * When you call this operation, take note of the following limits:
     * *   **CreateForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
     *     *   If the DNAT entry is in the **Pending** state, the system is adding the DNAT entry. You can only query the DNAT entry, but cannot perform other operations.
     *     *   If the DNAT entry is in the **Available** state, the DNAT entry is added.
     * *   You cannot repeatedly call the **CreateForwardEntry** operation to add a DNAT entry within a specific period of time.
     * *   All combinations of **ExternalIp**, **ExternalPort**, and **IpProtocol** used in DNAT entries must be unique. You cannot distribute requests to more than one Elastic Compute Service (ECS) instance if these requests are initiated from the same source IP address, received on the same port, and use the same protocol.
     * *   The combinations of **IpProtocol**, **InternalIp**, and **InternalPort** must be unique.
     * *   If one or more DNAT entries in the DNAT table are in the **Pending** or **Modifying** state, you cannot add DNAT entries to the DNAT table.
     * *   You can add at most 100 DNAT entries to a DNAT table.
     * *   For an elastic IP address (EIP) used by an Internet NAT gateway or a NAT IP address used by a Virtual Private Cloud (VPC) NAT gateway, take note of the following limit: If the IP address has IP mapping enabled and is specified in a DNAT entry, the IP address cannot be used by another DNAT or SNAT entry.
     *
     * @param request - CreateForwardEntryRequest
     *
     * @returns CreateForwardEntryResponse
     *
     * @param CreateForwardEntryRequest $request
     *
     * @return CreateForwardEntryResponse
     */
    public function createForwardEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createForwardEntryWithOptions($request, $runtime);
    }

    /**
     * Adds a FULLNAT entry to the FULLNAT table.
     *
     * @remarks
     *   **CreateFullNatEntry** is an asynchronous operation. After you send a request to call this operation, the system returns a FULLNAT entry and the FULLNAT entry is being added in the backend. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
     *     *   If the FULLNAT entry is in the **Creating** state, the system is adding the FULLNAT entry. You can only query the status of the FULLNAT entry, but cannot perform other operations.
     *     *   If the FULLNAT entry is in the **Available** state, the FULLNAT entry is added.
     * *   You cannot repeatedly call the **CreateFullNatEntry** operation for the same VPN gateway within the specified period of time.
     *
     * @param request - CreateFullNatEntryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateFullNatEntryResponse
     *
     * @param CreateFullNatEntryRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return CreateFullNatEntryResponse
     */
    public function createFullNatEntryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accessIp) {
            @$query['AccessIp'] = $request->accessIp;
        }

        if (null !== $request->accessPort) {
            @$query['AccessPort'] = $request->accessPort;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->fullNatEntryDescription) {
            @$query['FullNatEntryDescription'] = $request->fullNatEntryDescription;
        }

        if (null !== $request->fullNatEntryName) {
            @$query['FullNatEntryName'] = $request->fullNatEntryName;
        }

        if (null !== $request->fullNatTableId) {
            @$query['FullNatTableId'] = $request->fullNatTableId;
        }

        if (null !== $request->ipProtocol) {
            @$query['IpProtocol'] = $request->ipProtocol;
        }

        if (null !== $request->natIp) {
            @$query['NatIp'] = $request->natIp;
        }

        if (null !== $request->natIpPort) {
            @$query['NatIpPort'] = $request->natIpPort;
        }

        if (null !== $request->networkInterfaceId) {
            @$query['NetworkInterfaceId'] = $request->networkInterfaceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateFullNatEntry',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateFullNatEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds a FULLNAT entry to the FULLNAT table.
     *
     * @remarks
     *   **CreateFullNatEntry** is an asynchronous operation. After you send a request to call this operation, the system returns a FULLNAT entry and the FULLNAT entry is being added in the backend. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
     *     *   If the FULLNAT entry is in the **Creating** state, the system is adding the FULLNAT entry. You can only query the status of the FULLNAT entry, but cannot perform other operations.
     *     *   If the FULLNAT entry is in the **Available** state, the FULLNAT entry is added.
     * *   You cannot repeatedly call the **CreateFullNatEntry** operation for the same VPN gateway within the specified period of time.
     *
     * @param request - CreateFullNatEntryRequest
     *
     * @returns CreateFullNatEntryResponse
     *
     * @param CreateFullNatEntryRequest $request
     *
     * @return CreateFullNatEntryResponse
     */
    public function createFullNatEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createFullNatEntryWithOptions($request, $runtime);
    }

    /**
     * Creates a Global Accelerator (GA) instance.
     *
     * @remarks
     * ## Usage notes
     * You can call this operation to create only pay-as-you-go GA instances.
     *
     * @deprecated OpenAPI CreateGlobalAccelerationInstance is deprecated
     *
     * @param request - CreateGlobalAccelerationInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateGlobalAccelerationInstanceResponse
     *
     * @param CreateGlobalAccelerationInstanceRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return CreateGlobalAccelerationInstanceResponse
     */
    public function createGlobalAccelerationInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bandwidth) {
            @$query['Bandwidth'] = $request->bandwidth;
        }

        if (null !== $request->bandwidthType) {
            @$query['BandwidthType'] = $request->bandwidthType;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->serviceLocation) {
            @$query['ServiceLocation'] = $request->serviceLocation;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateGlobalAccelerationInstance',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateGlobalAccelerationInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Creates a Global Accelerator (GA) instance.
     *
     * @remarks
     * ## Usage notes
     * You can call this operation to create only pay-as-you-go GA instances.
     *
     * @deprecated OpenAPI CreateGlobalAccelerationInstance is deprecated
     *
     * @param request - CreateGlobalAccelerationInstanceRequest
     *
     * @returns CreateGlobalAccelerationInstanceResponse
     *
     * @param CreateGlobalAccelerationInstanceRequest $request
     *
     * @return CreateGlobalAccelerationInstanceResponse
     */
    public function createGlobalAccelerationInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createGlobalAccelerationInstanceWithOptions($request, $runtime);
    }

    /**
     * Creates a high-availability virtual IP address (HaVip).
     *
     * @remarks
     * *CreateHaVip** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of the task:
     * *   If the HaVip is in the **Creating** state, the HaVip is being created.
     * *   If the HaVip is in the **Available** state, the HaVip is created.
     *
     * @param request - CreateHaVipRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateHaVipResponse
     *
     * @param CreateHaVipRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return CreateHaVipResponse
     */
    public function createHaVipWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->ipAddress) {
            @$query['IpAddress'] = $request->ipAddress;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateHaVip',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateHaVipResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a high-availability virtual IP address (HaVip).
     *
     * @remarks
     * *CreateHaVip** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of the task:
     * *   If the HaVip is in the **Creating** state, the HaVip is being created.
     * *   If the HaVip is in the **Available** state, the HaVip is created.
     *
     * @param request - CreateHaVipRequest
     *
     * @returns CreateHaVipResponse
     *
     * @param CreateHaVipRequest $request
     *
     * @return CreateHaVipResponse
     */
    public function createHaVip($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createHaVipWithOptions($request, $runtime);
    }

    /**
     * Creates Express Connect circuits in high reliability mode. This improves the stability of multiple Express Connect circuits and prevents service interruptions caused by single points of failures (SPOFs).
     *
     * @param request - CreateHighReliablePhysicalConnectionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateHighReliablePhysicalConnectionResponse
     *
     * @param CreateHighReliablePhysicalConnectionRequest $request
     * @param RuntimeOptions                              $runtime
     *
     * @return CreateHighReliablePhysicalConnectionResponse
     */
    public function createHighReliablePhysicalConnectionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceptLanguage) {
            @$query['AcceptLanguage'] = $request->acceptLanguage;
        }

        if (null !== $request->apList) {
            @$query['ApList'] = $request->apList;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->deviceAdvancedCapacity) {
            @$query['DeviceAdvancedCapacity'] = $request->deviceAdvancedCapacity;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->highReliableType) {
            @$query['HighReliableType'] = $request->highReliableType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->portType) {
            @$query['PortType'] = $request->portType;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateHighReliablePhysicalConnection',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateHighReliablePhysicalConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates Express Connect circuits in high reliability mode. This improves the stability of multiple Express Connect circuits and prevents service interruptions caused by single points of failures (SPOFs).
     *
     * @param request - CreateHighReliablePhysicalConnectionRequest
     *
     * @returns CreateHighReliablePhysicalConnectionResponse
     *
     * @param CreateHighReliablePhysicalConnectionRequest $request
     *
     * @return CreateHighReliablePhysicalConnectionResponse
     */
    public function createHighReliablePhysicalConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createHighReliablePhysicalConnectionWithOptions($request, $runtime);
    }

    /**
     * Creates an IPv6 Translation Service instance.
     *
     * @deprecated OpenAPI CreateIPv6Translator is deprecated
     *
     * @param request - CreateIPv6TranslatorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateIPv6TranslatorResponse
     *
     * @param CreateIPv6TranslatorRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return CreateIPv6TranslatorResponse
     */
    public function createIPv6TranslatorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->autoPay) {
            @$query['AutoPay'] = $request->autoPay;
        }

        if (null !== $request->bandwidth) {
            @$query['Bandwidth'] = $request->bandwidth;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->duration) {
            @$query['Duration'] = $request->duration;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->payType) {
            @$query['PayType'] = $request->payType;
        }

        if (null !== $request->pricingCycle) {
            @$query['PricingCycle'] = $request->pricingCycle;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->spec) {
            @$query['Spec'] = $request->spec;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateIPv6Translator',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateIPv6TranslatorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Creates an IPv6 Translation Service instance.
     *
     * @deprecated OpenAPI CreateIPv6Translator is deprecated
     *
     * @param request - CreateIPv6TranslatorRequest
     *
     * @returns CreateIPv6TranslatorResponse
     *
     * @param CreateIPv6TranslatorRequest $request
     *
     * @return CreateIPv6TranslatorResponse
     */
    public function createIPv6Translator($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createIPv6TranslatorWithOptions($request, $runtime);
    }

    /**
     * Creates an access control list (ACL).
     *
     * @deprecated OpenAPI CreateIPv6TranslatorAclList is deprecated
     *
     * @param request - CreateIPv6TranslatorAclListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateIPv6TranslatorAclListResponse
     *
     * @param CreateIPv6TranslatorAclListRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return CreateIPv6TranslatorAclListResponse
     */
    public function createIPv6TranslatorAclListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aclName) {
            @$query['AclName'] = $request->aclName;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateIPv6TranslatorAclList',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateIPv6TranslatorAclListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Creates an access control list (ACL).
     *
     * @deprecated OpenAPI CreateIPv6TranslatorAclList is deprecated
     *
     * @param request - CreateIPv6TranslatorAclListRequest
     *
     * @returns CreateIPv6TranslatorAclListResponse
     *
     * @param CreateIPv6TranslatorAclListRequest $request
     *
     * @return CreateIPv6TranslatorAclListResponse
     */
    public function createIPv6TranslatorAclList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createIPv6TranslatorAclListWithOptions($request, $runtime);
    }

    /**
     * Adds an IPv6 mapping entry to an IPv6 Translation Service instance.
     *
     * @deprecated OpenAPI CreateIPv6TranslatorEntry is deprecated
     *
     * @param request - CreateIPv6TranslatorEntryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateIPv6TranslatorEntryResponse
     *
     * @param CreateIPv6TranslatorEntryRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return CreateIPv6TranslatorEntryResponse
     */
    public function createIPv6TranslatorEntryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aclId) {
            @$query['AclId'] = $request->aclId;
        }

        if (null !== $request->aclStatus) {
            @$query['AclStatus'] = $request->aclStatus;
        }

        if (null !== $request->aclType) {
            @$query['AclType'] = $request->aclType;
        }

        if (null !== $request->allocateIpv6Port) {
            @$query['AllocateIpv6Port'] = $request->allocateIpv6Port;
        }

        if (null !== $request->backendIpv4Addr) {
            @$query['BackendIpv4Addr'] = $request->backendIpv4Addr;
        }

        if (null !== $request->backendIpv4Port) {
            @$query['BackendIpv4Port'] = $request->backendIpv4Port;
        }

        if (null !== $request->entryBandwidth) {
            @$query['EntryBandwidth'] = $request->entryBandwidth;
        }

        if (null !== $request->entryDescription) {
            @$query['EntryDescription'] = $request->entryDescription;
        }

        if (null !== $request->entryName) {
            @$query['EntryName'] = $request->entryName;
        }

        if (null !== $request->ipv6TranslatorId) {
            @$query['Ipv6TranslatorId'] = $request->ipv6TranslatorId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->transProtocol) {
            @$query['TransProtocol'] = $request->transProtocol;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateIPv6TranslatorEntry',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateIPv6TranslatorEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Adds an IPv6 mapping entry to an IPv6 Translation Service instance.
     *
     * @deprecated OpenAPI CreateIPv6TranslatorEntry is deprecated
     *
     * @param request - CreateIPv6TranslatorEntryRequest
     *
     * @returns CreateIPv6TranslatorEntryResponse
     *
     * @param CreateIPv6TranslatorEntryRequest $request
     *
     * @return CreateIPv6TranslatorEntryResponse
     */
    public function createIPv6TranslatorEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createIPv6TranslatorEntryWithOptions($request, $runtime);
    }

    /**
     * Creates an IPsec server.
     *
     * @remarks
     *   Before you create an IPsec server, you must create a VPN gateway and enable the SSL-VPN feature for the VPN gateway. For more information, see [CreateVpnGateway](https://help.aliyun.com/document_detail/2794049.html).
     * *   Before you create an IPsec server, make sure that no IPsec-VPN connection exists on the VPN gateway. For more information, see [DeleteVpnConnection](https://help.aliyun.com/document_detail/2526948.html).
     * *   **CreateIpsecServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the IPsec server is being created.
     *     *   If the VPN gateway is in the **active** state, the IPsec server is created.
     * *   You cannot repeatedly call **CreateIpsecServer** within the specified period of time.
     *
     * @param request - CreateIpsecServerRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateIpsecServerResponse
     *
     * @param CreateIpsecServerRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return CreateIpsecServerResponse
     */
    public function createIpsecServerWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientIpPool) {
            @$query['ClientIpPool'] = $request->clientIpPool;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->effectImmediately) {
            @$query['EffectImmediately'] = $request->effectImmediately;
        }

        if (null !== $request->ikeConfig) {
            @$query['IkeConfig'] = $request->ikeConfig;
        }

        if (null !== $request->ipSecServerName) {
            @$query['IpSecServerName'] = $request->ipSecServerName;
        }

        if (null !== $request->ipsecConfig) {
            @$query['IpsecConfig'] = $request->ipsecConfig;
        }

        if (null !== $request->localSubnet) {
            @$query['LocalSubnet'] = $request->localSubnet;
        }

        if (null !== $request->psk) {
            @$query['Psk'] = $request->psk;
        }

        if (null !== $request->pskEnabled) {
            @$query['PskEnabled'] = $request->pskEnabled;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->vpnGatewayId) {
            @$query['VpnGatewayId'] = $request->vpnGatewayId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateIpsecServer',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateIpsecServerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an IPsec server.
     *
     * @remarks
     *   Before you create an IPsec server, you must create a VPN gateway and enable the SSL-VPN feature for the VPN gateway. For more information, see [CreateVpnGateway](https://help.aliyun.com/document_detail/2794049.html).
     * *   Before you create an IPsec server, make sure that no IPsec-VPN connection exists on the VPN gateway. For more information, see [DeleteVpnConnection](https://help.aliyun.com/document_detail/2526948.html).
     * *   **CreateIpsecServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the IPsec server is being created.
     *     *   If the VPN gateway is in the **active** state, the IPsec server is created.
     * *   You cannot repeatedly call **CreateIpsecServer** within the specified period of time.
     *
     * @param request - CreateIpsecServerRequest
     *
     * @returns CreateIpsecServerResponse
     *
     * @param CreateIpsecServerRequest $request
     *
     * @return CreateIpsecServerResponse
     */
    public function createIpsecServer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createIpsecServerWithOptions($request, $runtime);
    }

    /**
     * IPv4
     *
     * @remarks
     *   **CreateIpv4Gateway** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of an IPv4 gateway:
     *     *   If the IPv4 gateway is in the **Creating** state, the IPv4 gateway is being created.
     *     *   If the IPv4 gateway is in the **Created** state, the IPv4 gateway is created.
     * *   You cannot repeatedly call the **CreateIpv4Gateway** operation to create IPv4 gateways in a virtual private cloud (VPC) within the specified period of time.
     *
     * @param request - CreateIpv4GatewayRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateIpv4GatewayResponse
     *
     * @param CreateIpv4GatewayRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return CreateIpv4GatewayResponse
     */
    public function createIpv4GatewayWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ipv4GatewayDescription) {
            @$query['Ipv4GatewayDescription'] = $request->ipv4GatewayDescription;
        }

        if (null !== $request->ipv4GatewayName) {
            @$query['Ipv4GatewayName'] = $request->ipv4GatewayName;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateIpv4Gateway',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateIpv4GatewayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * IPv4
     *
     * @remarks
     *   **CreateIpv4Gateway** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of an IPv4 gateway:
     *     *   If the IPv4 gateway is in the **Creating** state, the IPv4 gateway is being created.
     *     *   If the IPv4 gateway is in the **Created** state, the IPv4 gateway is created.
     * *   You cannot repeatedly call the **CreateIpv4Gateway** operation to create IPv4 gateways in a virtual private cloud (VPC) within the specified period of time.
     *
     * @param request - CreateIpv4GatewayRequest
     *
     * @returns CreateIpv4GatewayResponse
     *
     * @param CreateIpv4GatewayRequest $request
     *
     * @return CreateIpv4GatewayResponse
     */
    public function createIpv4Gateway($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createIpv4GatewayWithOptions($request, $runtime);
    }

    /**
     * You can call CreateIpv6EgressOnlyRule to create egress-only rules to enable ECS instances in VPCs that have IPv6 enabled to access IPv6 clients. However, IPv6 clients cannot access the ECS instances over the Internet.
     *
     * @remarks
     *   **CreateIpv6EgressOnlyRule** is an asynchronous operation. After a request is sent, the system returns a request ID and creates the rule in the background. You can call the [DescribeIpv6EgressOnlyRules](https://help.aliyun.com/document_detail/102208.html) operation to query the status of the task.
     *     *   If the egress-only rule is in the **Creating** state, the egress-only rule is being created.
     *     *   If the egress-only rule is in the **Created** state, the egress-only rule is created.
     * *   You cannot repeatedly call the **CreateIpv6EgressOnlyRule** operation to add egress-only rules for an IPv6 address within the specified period of time.
     *
     * @param request - CreateIpv6EgressOnlyRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateIpv6EgressOnlyRuleResponse
     *
     * @param CreateIpv6EgressOnlyRuleRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return CreateIpv6EgressOnlyRuleResponse
     */
    public function createIpv6EgressOnlyRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->instanceType) {
            @$query['InstanceType'] = $request->instanceType;
        }

        if (null !== $request->ipv6GatewayId) {
            @$query['Ipv6GatewayId'] = $request->ipv6GatewayId;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateIpv6EgressOnlyRule',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateIpv6EgressOnlyRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * You can call CreateIpv6EgressOnlyRule to create egress-only rules to enable ECS instances in VPCs that have IPv6 enabled to access IPv6 clients. However, IPv6 clients cannot access the ECS instances over the Internet.
     *
     * @remarks
     *   **CreateIpv6EgressOnlyRule** is an asynchronous operation. After a request is sent, the system returns a request ID and creates the rule in the background. You can call the [DescribeIpv6EgressOnlyRules](https://help.aliyun.com/document_detail/102208.html) operation to query the status of the task.
     *     *   If the egress-only rule is in the **Creating** state, the egress-only rule is being created.
     *     *   If the egress-only rule is in the **Created** state, the egress-only rule is created.
     * *   You cannot repeatedly call the **CreateIpv6EgressOnlyRule** operation to add egress-only rules for an IPv6 address within the specified period of time.
     *
     * @param request - CreateIpv6EgressOnlyRuleRequest
     *
     * @returns CreateIpv6EgressOnlyRuleResponse
     *
     * @param CreateIpv6EgressOnlyRuleRequest $request
     *
     * @return CreateIpv6EgressOnlyRuleResponse
     */
    public function createIpv6EgressOnlyRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createIpv6EgressOnlyRuleWithOptions($request, $runtime);
    }

    /**
     * IPv6 gateways are used to control the IPv6 traffic of virtual private clouds (VPCs). You can call the CreateIpv6Gateway operation to create IPv6 gateways.
     *
     * @remarks
     *   **CreateIpv6Gateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6GatewayAttribute](https://help.aliyun.com/document_detail/102226.html) operation to query the status of the task.
     *     *   If the IPv6 gateway is in the **Creating** state, the IPv6 gateway is being created.
     *     *   If the IPv6 gateway is in the **Created** state, the IPv6 gateway is created.
     * *   You cannot repeatedly call the **CreateIpv6Gateway** operation within a specific time period.
     *
     * @param request - CreateIpv6GatewayRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateIpv6GatewayResponse
     *
     * @param CreateIpv6GatewayRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return CreateIpv6GatewayResponse
     */
    public function createIpv6GatewayWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateIpv6Gateway',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateIpv6GatewayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * IPv6 gateways are used to control the IPv6 traffic of virtual private clouds (VPCs). You can call the CreateIpv6Gateway operation to create IPv6 gateways.
     *
     * @remarks
     *   **CreateIpv6Gateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6GatewayAttribute](https://help.aliyun.com/document_detail/102226.html) operation to query the status of the task.
     *     *   If the IPv6 gateway is in the **Creating** state, the IPv6 gateway is being created.
     *     *   If the IPv6 gateway is in the **Created** state, the IPv6 gateway is created.
     * *   You cannot repeatedly call the **CreateIpv6Gateway** operation within a specific time period.
     *
     * @param request - CreateIpv6GatewayRequest
     *
     * @returns CreateIpv6GatewayResponse
     *
     * @param CreateIpv6GatewayRequest $request
     *
     * @return CreateIpv6GatewayResponse
     */
    public function createIpv6Gateway($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createIpv6GatewayWithOptions($request, $runtime);
    }

    /**
     * Creates an enhanced Internet NAT gateway or a Virtual Private Cloud (VPC) NAT gateway.
     *
     * @remarks
     * ## Usage notes
     * Before you call this operation, take note of the following items:
     * *   When you create an enhanced NAT gateway for the first time, the system automatically creates the service-linked role AliyunServiceRoleForNatgw. Then, the system attaches the permission policy AliyunServiceRolePolicyForNatgw to the role. This allows the NAT gateway to access other resources on Alibaba Cloud. For more information, see [Service-linked roles](https://help.aliyun.com/document_detail/174251.html).
     * *   After you create an enhanced Internet NAT gateway, a route entry is automatically added to the route table of the VPC. The destination CIDR block of the route entry is 0.0.0.0/0 and the next hop is the NAT gateway. This ensures that traffic is routed to the NAT gateway.
     * *   **CreateNatGateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNatGateways](https://help.aliyun.com/document_detail/36054.html) operation to query the status of the task.
     *     *   If a NAT gateway is in the **Creating** state, the NAT gateway is being created. In this case, you can query the NAT gateway but cannot perform other operations.
     *     *   If a NAT gateway is in the **Available** state, the NAT gateway is created.
     * It takes 1 to 3 minutes to create a NAT gateway.
     *
     * @param tmpReq - CreateNatGatewayRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateNatGatewayResponse
     *
     * @param CreateNatGatewayRequest $tmpReq
     * @param RuntimeOptions          $runtime
     *
     * @return CreateNatGatewayResponse
     */
    public function createNatGatewayWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new CreateNatGatewayShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->accessMode) {
            $request->accessModeShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->accessMode, 'AccessMode', 'json');
        }

        $query = [];
        if (null !== $request->accessModeShrink) {
            @$query['AccessMode'] = $request->accessModeShrink;
        }

        if (null !== $request->autoPay) {
            @$query['AutoPay'] = $request->autoPay;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->duration) {
            @$query['Duration'] = $request->duration;
        }

        if (null !== $request->eipBindMode) {
            @$query['EipBindMode'] = $request->eipBindMode;
        }

        if (null !== $request->icmpReplyEnabled) {
            @$query['IcmpReplyEnabled'] = $request->icmpReplyEnabled;
        }

        if (null !== $request->instanceChargeType) {
            @$query['InstanceChargeType'] = $request->instanceChargeType;
        }

        if (null !== $request->internetChargeType) {
            @$query['InternetChargeType'] = $request->internetChargeType;
        }

        if (null !== $request->ipv4Prefix) {
            @$query['Ipv4Prefix'] = $request->ipv4Prefix;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->natIp) {
            @$query['NatIp'] = $request->natIp;
        }

        if (null !== $request->natType) {
            @$query['NatType'] = $request->natType;
        }

        if (null !== $request->networkType) {
            @$query['NetworkType'] = $request->networkType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pricingCycle) {
            @$query['PricingCycle'] = $request->pricingCycle;
        }

        if (null !== $request->privateLinkEnabled) {
            @$query['PrivateLinkEnabled'] = $request->privateLinkEnabled;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->securityProtectionEnabled) {
            @$query['SecurityProtectionEnabled'] = $request->securityProtectionEnabled;
        }

        if (null !== $request->spec) {
            @$query['Spec'] = $request->spec;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateNatGateway',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateNatGatewayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an enhanced Internet NAT gateway or a Virtual Private Cloud (VPC) NAT gateway.
     *
     * @remarks
     * ## Usage notes
     * Before you call this operation, take note of the following items:
     * *   When you create an enhanced NAT gateway for the first time, the system automatically creates the service-linked role AliyunServiceRoleForNatgw. Then, the system attaches the permission policy AliyunServiceRolePolicyForNatgw to the role. This allows the NAT gateway to access other resources on Alibaba Cloud. For more information, see [Service-linked roles](https://help.aliyun.com/document_detail/174251.html).
     * *   After you create an enhanced Internet NAT gateway, a route entry is automatically added to the route table of the VPC. The destination CIDR block of the route entry is 0.0.0.0/0 and the next hop is the NAT gateway. This ensures that traffic is routed to the NAT gateway.
     * *   **CreateNatGateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNatGateways](https://help.aliyun.com/document_detail/36054.html) operation to query the status of the task.
     *     *   If a NAT gateway is in the **Creating** state, the NAT gateway is being created. In this case, you can query the NAT gateway but cannot perform other operations.
     *     *   If a NAT gateway is in the **Available** state, the NAT gateway is created.
     * It takes 1 to 3 minutes to create a NAT gateway.
     *
     * @param request - CreateNatGatewayRequest
     *
     * @returns CreateNatGatewayResponse
     *
     * @param CreateNatGatewayRequest $request
     *
     * @return CreateNatGatewayResponse
     */
    public function createNatGateway($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createNatGatewayWithOptions($request, $runtime);
    }

    /**
     * Creates a NAT IP address.
     *
     * @remarks
     * ## [](#)
     * **CreateNatIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListNatIps](https://help.aliyun.com/document_detail/287000.html) operation to query the status of the task.
     * *   If a NAT IP address is in the **Creating** state, the NAT IP address is being created. In this case, you can only query the NAT IP address and cannot perform other operations.
     * *   If a NAT IP address is in the **Available** state, the NAT IP address is created.
     * You cannot repeatedly call the **CreateNatIp** operation to create a NAT IP address within a specific period of time.
     *
     * @param request - CreateNatIpRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateNatIpResponse
     *
     * @param CreateNatIpRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return CreateNatIpResponse
     */
    public function createNatIpWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ipv4Prefix) {
            @$query['Ipv4Prefix'] = $request->ipv4Prefix;
        }

        if (null !== $request->ipv4PrefixCount) {
            @$query['Ipv4PrefixCount'] = $request->ipv4PrefixCount;
        }

        if (null !== $request->natGatewayId) {
            @$query['NatGatewayId'] = $request->natGatewayId;
        }

        if (null !== $request->natIp) {
            @$query['NatIp'] = $request->natIp;
        }

        if (null !== $request->natIpCidr) {
            @$query['NatIpCidr'] = $request->natIpCidr;
        }

        if (null !== $request->natIpDescription) {
            @$query['NatIpDescription'] = $request->natIpDescription;
        }

        if (null !== $request->natIpName) {
            @$query['NatIpName'] = $request->natIpName;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateNatIp',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateNatIpResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a NAT IP address.
     *
     * @remarks
     * ## [](#)
     * **CreateNatIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListNatIps](https://help.aliyun.com/document_detail/287000.html) operation to query the status of the task.
     * *   If a NAT IP address is in the **Creating** state, the NAT IP address is being created. In this case, you can only query the NAT IP address and cannot perform other operations.
     * *   If a NAT IP address is in the **Available** state, the NAT IP address is created.
     * You cannot repeatedly call the **CreateNatIp** operation to create a NAT IP address within a specific period of time.
     *
     * @param request - CreateNatIpRequest
     *
     * @returns CreateNatIpResponse
     *
     * @param CreateNatIpRequest $request
     *
     * @return CreateNatIpResponse
     */
    public function createNatIp($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createNatIpWithOptions($request, $runtime);
    }

    /**
     * Creates a NAT CIDR block.
     *
     * @remarks
     * ## [](#)Description
     * You cannot repeatedly call the **CreateNatIpCidr** operation to create a NAT CIDR block within the specified period of time.
     *
     * @param request - CreateNatIpCidrRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateNatIpCidrResponse
     *
     * @param CreateNatIpCidrRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return CreateNatIpCidrResponse
     */
    public function createNatIpCidrWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->natGatewayId) {
            @$query['NatGatewayId'] = $request->natGatewayId;
        }

        if (null !== $request->natIpCidr) {
            @$query['NatIpCidr'] = $request->natIpCidr;
        }

        if (null !== $request->natIpCidrDescription) {
            @$query['NatIpCidrDescription'] = $request->natIpCidrDescription;
        }

        if (null !== $request->natIpCidrName) {
            @$query['NatIpCidrName'] = $request->natIpCidrName;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateNatIpCidr',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateNatIpCidrResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a NAT CIDR block.
     *
     * @remarks
     * ## [](#)Description
     * You cannot repeatedly call the **CreateNatIpCidr** operation to create a NAT CIDR block within the specified period of time.
     *
     * @param request - CreateNatIpCidrRequest
     *
     * @returns CreateNatIpCidrResponse
     *
     * @param CreateNatIpCidrRequest $request
     *
     * @return CreateNatIpCidrResponse
     */
    public function createNatIpCidr($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createNatIpCidrWithOptions($request, $runtime);
    }

    /**
     * Creates a network ACL.
     *
     * @param request - CreateNetworkAclRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateNetworkAclResponse
     *
     * @param CreateNetworkAclRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return CreateNetworkAclResponse
     */
    public function createNetworkAclWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->networkAclName) {
            @$query['NetworkAclName'] = $request->networkAclName;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateNetworkAcl',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateNetworkAclResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a network ACL.
     *
     * @param request - CreateNetworkAclRequest
     *
     * @returns CreateNetworkAclResponse
     *
     * @param CreateNetworkAclRequest $request
     *
     * @return CreateNetworkAclResponse
     */
    public function createNetworkAcl($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createNetworkAclWithOptions($request, $runtime);
    }

    /**
     * Applies for an Express Connect circuit.
     *
     * @remarks
     * You can apply for a dedicated Express Connect circuit for yourself or create a hosted connection for a tenant. After your application is approved, the Express Connect circuit changes to the **Initial** state. You can contact the connectivity provider to start construction.
     * When you call this operation, take note of the following limits:
     * *   If your Alibaba Cloud account has more than five Express Connect circuits that are not in the **Enabled** state, you cannot apply for another Express Connect circuit.
     * *   If your Alibaba Cloud account has an Express Connect circuit with overdue payments, you cannot apply for another Express Connect circuit.
     *
     * @param request - CreatePhysicalConnectionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreatePhysicalConnectionResponse
     *
     * @param CreatePhysicalConnectionRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return CreatePhysicalConnectionResponse
     */
    public function createPhysicalConnectionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accessPointId) {
            @$query['AccessPointId'] = $request->accessPointId;
        }

        if (null !== $request->circuitCode) {
            @$query['CircuitCode'] = $request->circuitCode;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->deviceAdvancedCapacity) {
            @$query['DeviceAdvancedCapacity'] = $request->deviceAdvancedCapacity;
        }

        if (null !== $request->lineOperator) {
            @$query['LineOperator'] = $request->lineOperator;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->opticalModuleModel) {
            @$query['OpticalModuleModel'] = $request->opticalModuleModel;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->peerLocation) {
            @$query['PeerLocation'] = $request->peerLocation;
        }

        if (null !== $request->portType) {
            @$query['PortType'] = $request->portType;
        }

        if (null !== $request->redundantPhysicalConnectionId) {
            @$query['RedundantPhysicalConnectionId'] = $request->redundantPhysicalConnectionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        if (null !== $request->bandwidth) {
            @$query['bandwidth'] = $request->bandwidth;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreatePhysicalConnection',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreatePhysicalConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Applies for an Express Connect circuit.
     *
     * @remarks
     * You can apply for a dedicated Express Connect circuit for yourself or create a hosted connection for a tenant. After your application is approved, the Express Connect circuit changes to the **Initial** state. You can contact the connectivity provider to start construction.
     * When you call this operation, take note of the following limits:
     * *   If your Alibaba Cloud account has more than five Express Connect circuits that are not in the **Enabled** state, you cannot apply for another Express Connect circuit.
     * *   If your Alibaba Cloud account has an Express Connect circuit with overdue payments, you cannot apply for another Express Connect circuit.
     *
     * @param request - CreatePhysicalConnectionRequest
     *
     * @returns CreatePhysicalConnectionResponse
     *
     * @param CreatePhysicalConnectionRequest $request
     *
     * @return CreatePhysicalConnectionResponse
     */
    public function createPhysicalConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createPhysicalConnectionWithOptions($request, $runtime);
    }

    /**
     * Creates an order for resource occupation of an Express Connect circuit.
     *
     * @remarks
     * >  You can call this operation only when the Express Connect circuit is in the **Complete** state.
     *
     * @param request - CreatePhysicalConnectionOccupancyOrderRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreatePhysicalConnectionOccupancyOrderResponse
     *
     * @param CreatePhysicalConnectionOccupancyOrderRequest $request
     * @param RuntimeOptions                                $runtime
     *
     * @return CreatePhysicalConnectionOccupancyOrderResponse
     */
    public function createPhysicalConnectionOccupancyOrderWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->autoPay) {
            @$query['AutoPay'] = $request->autoPay;
        }

        if (null !== $request->autoRenew) {
            @$query['AutoRenew'] = $request->autoRenew;
        }

        if (null !== $request->autoRenewDuration) {
            @$query['AutoRenewDuration'] = $request->autoRenewDuration;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->instanceChargeType) {
            @$query['InstanceChargeType'] = $request->instanceChargeType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->period) {
            @$query['Period'] = $request->period;
        }

        if (null !== $request->physicalConnectionId) {
            @$query['PhysicalConnectionId'] = $request->physicalConnectionId;
        }

        if (null !== $request->pricingCycle) {
            @$query['PricingCycle'] = $request->pricingCycle;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreatePhysicalConnectionOccupancyOrder',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreatePhysicalConnectionOccupancyOrderResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an order for resource occupation of an Express Connect circuit.
     *
     * @remarks
     * >  You can call this operation only when the Express Connect circuit is in the **Complete** state.
     *
     * @param request - CreatePhysicalConnectionOccupancyOrderRequest
     *
     * @returns CreatePhysicalConnectionOccupancyOrderResponse
     *
     * @param CreatePhysicalConnectionOccupancyOrderRequest $request
     *
     * @return CreatePhysicalConnectionOccupancyOrderResponse
     */
    public function createPhysicalConnectionOccupancyOrder($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createPhysicalConnectionOccupancyOrderWithOptions($request, $runtime);
    }

    /**
     * Creates an order for initial installation of an Express Connect circuit.
     *
     * @param request - CreatePhysicalConnectionSetupOrderRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreatePhysicalConnectionSetupOrderResponse
     *
     * @param CreatePhysicalConnectionSetupOrderRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return CreatePhysicalConnectionSetupOrderResponse
     */
    public function createPhysicalConnectionSetupOrderWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accessPointId) {
            @$query['AccessPointId'] = $request->accessPointId;
        }

        if (null !== $request->autoPay) {
            @$query['AutoPay'] = $request->autoPay;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->lineOperator) {
            @$query['LineOperator'] = $request->lineOperator;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->portType) {
            @$query['PortType'] = $request->portType;
        }

        if (null !== $request->redundantPhysicalConnectionId) {
            @$query['RedundantPhysicalConnectionId'] = $request->redundantPhysicalConnectionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreatePhysicalConnectionSetupOrder',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreatePhysicalConnectionSetupOrderResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an order for initial installation of an Express Connect circuit.
     *
     * @param request - CreatePhysicalConnectionSetupOrderRequest
     *
     * @returns CreatePhysicalConnectionSetupOrderResponse
     *
     * @param CreatePhysicalConnectionSetupOrderRequest $request
     *
     * @return CreatePhysicalConnectionSetupOrderResponse
     */
    public function createPhysicalConnectionSetupOrder($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createPhysicalConnectionSetupOrderWithOptions($request, $runtime);
    }

    /**
     * Creates an IP address pool.
     *
     * @remarks
     * By default, the IP address pool feature is unavailable. You can apply for the privilege to use the **IP address pool feature** in the Quota Center console. For more information, see the "Request a quota increase in the Quota Center console" section in the [Manage EIP quotas](https://help.aliyun.com/document_detail/108213.html) topic.
     *
     * @param request - CreatePublicIpAddressPoolRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreatePublicIpAddressPoolResponse
     *
     * @param CreatePublicIpAddressPoolRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return CreatePublicIpAddressPoolResponse
     */
    public function createPublicIpAddressPoolWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bizType) {
            @$query['BizType'] = $request->bizType;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->isp) {
            @$query['Isp'] = $request->isp;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->securityProtectionTypes) {
            @$query['SecurityProtectionTypes'] = $request->securityProtectionTypes;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->zones) {
            @$query['Zones'] = $request->zones;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreatePublicIpAddressPool',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreatePublicIpAddressPoolResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an IP address pool.
     *
     * @remarks
     * By default, the IP address pool feature is unavailable. You can apply for the privilege to use the **IP address pool feature** in the Quota Center console. For more information, see the "Request a quota increase in the Quota Center console" section in the [Manage EIP quotas](https://help.aliyun.com/document_detail/108213.html) topic.
     *
     * @param request - CreatePublicIpAddressPoolRequest
     *
     * @returns CreatePublicIpAddressPoolResponse
     *
     * @param CreatePublicIpAddressPoolRequest $request
     *
     * @return CreatePublicIpAddressPoolResponse
     */
    public function createPublicIpAddressPool($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createPublicIpAddressPoolWithOptions($request, $runtime);
    }

    /**
     * Adds custom route entries to the route table of a vRouter in a virtual private cloud (VPC).
     *
     * @remarks
     * ## [](#)References
     * *   **CreateRouteEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
     *     *   If the route entry is in the **Creating** state, the route entry is being created.
     *     *   If the route entry is in the **Created** state, the route entry is created.
     * *   You cannot repeatedly call the **CreateRouteEntries** operation to create the same route entry within the specified period of time.
     * **When you call this operation to add custom route entries to the route table of a vRouter, take note of the following items:**
     * *   A route table can contain up to 200 custom route entries.
     * *   The destination CIDR block (**DstCidrBlock**) of a custom route entry cannot be the same as or overlap with the CIDR block of a vSwitch in the VPC.
     * *   The destination CIDR block (**DstCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or its subnets.
     * *   The destination CIDR blocks (**DstCidrBlock**) of route entries in the same route table must be unique.
     * *   If you do not include the mask length when you specify the destination CIDR block (**DstCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
     * *   Multiple custom route entries can point to the same next hop (**NextHop**).
     * *   The next hop (**NextHop**) of a custom route entry must belong to the same VPC as the route table.
     *
     * @param request - CreateRouteEntriesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateRouteEntriesResponse
     *
     * @param CreateRouteEntriesRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return CreateRouteEntriesResponse
     */
    public function createRouteEntriesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeEntries) {
            @$query['RouteEntries'] = $request->routeEntries;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateRouteEntries',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateRouteEntriesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds custom route entries to the route table of a vRouter in a virtual private cloud (VPC).
     *
     * @remarks
     * ## [](#)References
     * *   **CreateRouteEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
     *     *   If the route entry is in the **Creating** state, the route entry is being created.
     *     *   If the route entry is in the **Created** state, the route entry is created.
     * *   You cannot repeatedly call the **CreateRouteEntries** operation to create the same route entry within the specified period of time.
     * **When you call this operation to add custom route entries to the route table of a vRouter, take note of the following items:**
     * *   A route table can contain up to 200 custom route entries.
     * *   The destination CIDR block (**DstCidrBlock**) of a custom route entry cannot be the same as or overlap with the CIDR block of a vSwitch in the VPC.
     * *   The destination CIDR block (**DstCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or its subnets.
     * *   The destination CIDR blocks (**DstCidrBlock**) of route entries in the same route table must be unique.
     * *   If you do not include the mask length when you specify the destination CIDR block (**DstCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
     * *   Multiple custom route entries can point to the same next hop (**NextHop**).
     * *   The next hop (**NextHop**) of a custom route entry must belong to the same VPC as the route table.
     *
     * @param request - CreateRouteEntriesRequest
     *
     * @returns CreateRouteEntriesResponse
     *
     * @param CreateRouteEntriesRequest $request
     *
     * @return CreateRouteEntriesResponse
     */
    public function createRouteEntries($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createRouteEntriesWithOptions($request, $runtime);
    }

    /**
     * Creates a custom route entry in the route table of a VRouter or virtual border router (VBR).
     *
     * @remarks
     *   **CreateRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task:
     *     *   If a route is in the **Creating** state, the route is being added.
     *     *   If a route is in the **Created** state, the route is added.
     * *   You cannot repeatedly call **CreateRouteEntry** within a specific period of time.
     * **When you call this operation to add a custom route entry to the route table of a vRouter, take note of the following limits:**
     * >  When you add a route entry from a prefix list, the quota usage is calculated by adding the number of existing route entries and the maximum number of route entries of the prefix list.
     * *   A route table can contain up to 200 custom route entries.
     * *   The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be the same as or be a subset of the CIDR block of a vSwitch in the virtual private cloud (VPC). The destination CIDR block can contain the CIDR block of a vSwitch.
     * *   The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or a subset of it.
     * *   The destination CIDR blocks (**DestinationCidrBlock**) of route entries in the same route table must be unique.
     * *   If you do not include the mask length when you specify the destination CIDR block (**DestinationCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
     * *   Multiple custom route entries can point to the same next hop (**NextHopId**).
     * *   The next hop (**NextHopId**) of a custom route entry must in the same VPC as the route table.
     * *   Equal-cost multi-path (ECMP) routing can be configured by specifying the **NextHopList** parameter.
     *     *   When you add non-ECMP route entries, you must specify **DestinationCidrBlock**, **NextHopType**, and **NextHopId**, and you must not specify **NextHopList**.
     *     *   When you add route entries for ECMP routing, you must specify **DestinationCidrBlock** and **NextHopList**, and you must not specify **NextHopType** or **NextHopId**.
     * **When you call this operation to add a custom route entry to the route table of a VBR, take note of the following limits:**
     * *   A route table can contain up to 200 custom route entries.
     * *   **NextHopList** is not supported.
     * *   The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or a subset of it.
     * *   The destination CIDR blocks (**DestinationCidrBlock**) of route entries in the same route table must be unique.
     * *   If you do not include the mask length when you specify the destination CIDR block (**DestinationCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
     * *   Multiple custom route entries can point to the same next hop (**NextHopId**).
     * *   The next hop (**NextHopId**) of a custom route entry must be a router interface associated with the VBR.
     * *   You can add route entries only when the VBR is in the **Active** state, and the Express Connect circuit associated with the VBR is in the **Enabled** state and is not locked due to overdue payments.
     * *   Only non-ECMP route entries are supported. When you add non-ECMP route entries, you must specify **DestinationCidrBlock**, **NextHopType**, and **NextHopId**, and you cannot specify **NextHopList**.
     *
     * @param request - CreateRouteEntryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateRouteEntryResponse
     *
     * @param CreateRouteEntryRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return CreateRouteEntryResponse
     */
    public function createRouteEntryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->destinationCidrBlock) {
            @$query['DestinationCidrBlock'] = $request->destinationCidrBlock;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->nextHopId) {
            @$query['NextHopId'] = $request->nextHopId;
        }

        if (null !== $request->nextHopList) {
            @$query['NextHopList'] = $request->nextHopList;
        }

        if (null !== $request->nextHopType) {
            @$query['NextHopType'] = $request->nextHopType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeEntryName) {
            @$query['RouteEntryName'] = $request->routeEntryName;
        }

        if (null !== $request->routeTableId) {
            @$query['RouteTableId'] = $request->routeTableId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateRouteEntry',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateRouteEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a custom route entry in the route table of a VRouter or virtual border router (VBR).
     *
     * @remarks
     *   **CreateRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task:
     *     *   If a route is in the **Creating** state, the route is being added.
     *     *   If a route is in the **Created** state, the route is added.
     * *   You cannot repeatedly call **CreateRouteEntry** within a specific period of time.
     * **When you call this operation to add a custom route entry to the route table of a vRouter, take note of the following limits:**
     * >  When you add a route entry from a prefix list, the quota usage is calculated by adding the number of existing route entries and the maximum number of route entries of the prefix list.
     * *   A route table can contain up to 200 custom route entries.
     * *   The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be the same as or be a subset of the CIDR block of a vSwitch in the virtual private cloud (VPC). The destination CIDR block can contain the CIDR block of a vSwitch.
     * *   The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or a subset of it.
     * *   The destination CIDR blocks (**DestinationCidrBlock**) of route entries in the same route table must be unique.
     * *   If you do not include the mask length when you specify the destination CIDR block (**DestinationCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
     * *   Multiple custom route entries can point to the same next hop (**NextHopId**).
     * *   The next hop (**NextHopId**) of a custom route entry must in the same VPC as the route table.
     * *   Equal-cost multi-path (ECMP) routing can be configured by specifying the **NextHopList** parameter.
     *     *   When you add non-ECMP route entries, you must specify **DestinationCidrBlock**, **NextHopType**, and **NextHopId**, and you must not specify **NextHopList**.
     *     *   When you add route entries for ECMP routing, you must specify **DestinationCidrBlock** and **NextHopList**, and you must not specify **NextHopType** or **NextHopId**.
     * **When you call this operation to add a custom route entry to the route table of a VBR, take note of the following limits:**
     * *   A route table can contain up to 200 custom route entries.
     * *   **NextHopList** is not supported.
     * *   The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or a subset of it.
     * *   The destination CIDR blocks (**DestinationCidrBlock**) of route entries in the same route table must be unique.
     * *   If you do not include the mask length when you specify the destination CIDR block (**DestinationCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
     * *   Multiple custom route entries can point to the same next hop (**NextHopId**).
     * *   The next hop (**NextHopId**) of a custom route entry must be a router interface associated with the VBR.
     * *   You can add route entries only when the VBR is in the **Active** state, and the Express Connect circuit associated with the VBR is in the **Enabled** state and is not locked due to overdue payments.
     * *   Only non-ECMP route entries are supported. When you add non-ECMP route entries, you must specify **DestinationCidrBlock**, **NextHopType**, and **NextHopId**, and you cannot specify **NextHopList**.
     *
     * @param request - CreateRouteEntryRequest
     *
     * @returns CreateRouteEntryResponse
     *
     * @param CreateRouteEntryRequest $request
     *
     * @return CreateRouteEntryResponse
     */
    public function createRouteEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createRouteEntryWithOptions($request, $runtime);
    }

    /**
     * Creates a custom route table.
     *
     * @remarks
     *   **CreateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the operation in the background. You can call the [DescribeRouteTableList](https://help.aliyun.com/document_detail/87602.html) operation to query the status of the task.
     *     *   If the custom route table is in the **Creating** state, the custom route table is being created.
     *     *   If the custom route table is in the **Created** state, the custom route table is created.
     * *   You cannot repeatedly call the **CreateRouteTable** operation within the specified period of time.
     *
     * @param request - CreateRouteTableRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateRouteTableResponse
     *
     * @param CreateRouteTableRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return CreateRouteTableResponse
     */
    public function createRouteTableWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->associateType) {
            @$query['AssociateType'] = $request->associateType;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeTableName) {
            @$query['RouteTableName'] = $request->routeTableName;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateRouteTable',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateRouteTableResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a custom route table.
     *
     * @remarks
     *   **CreateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the operation in the background. You can call the [DescribeRouteTableList](https://help.aliyun.com/document_detail/87602.html) operation to query the status of the task.
     *     *   If the custom route table is in the **Creating** state, the custom route table is being created.
     *     *   If the custom route table is in the **Created** state, the custom route table is created.
     * *   You cannot repeatedly call the **CreateRouteTable** operation within the specified period of time.
     *
     * @param request - CreateRouteTableRequest
     *
     * @returns CreateRouteTableResponse
     *
     * @param CreateRouteTableRequest $request
     *
     * @return CreateRouteTableResponse
     */
    public function createRouteTable($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createRouteTableWithOptions($request, $runtime);
    }

    /**
     * Creates a router interface.
     *
     * @remarks
     * When you call this operation, take note of the following limits:
     * *   You can create only one pair of interfaces to be connected between two routers.
     * *   You can create a maximum of five router interfaces for a router.
     * *   If your Alibaba Cloud account has a router interface with overdue payments, you cannot create new router interfaces.
     * *   Each destination CIDR block of route entries in the same route table must be unique.
     * *   A virtual border router (VBR) can serve only as a requester. The VBR must be in the Activated state.
     * *   You can call this operation to create subscription and pay-as-you-go router interfaces.
     *
     * @param request - CreateRouterInterfaceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateRouterInterfaceResponse
     *
     * @param CreateRouterInterfaceRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return CreateRouterInterfaceResponse
     */
    public function createRouterInterfaceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accessPointId) {
            @$query['AccessPointId'] = $request->accessPointId;
        }

        if (null !== $request->autoPay) {
            @$query['AutoPay'] = $request->autoPay;
        }

        if (null !== $request->autoRenew) {
            @$query['AutoRenew'] = $request->autoRenew;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->fastLinkMode) {
            @$query['FastLinkMode'] = $request->fastLinkMode;
        }

        if (null !== $request->healthCheckSourceIp) {
            @$query['HealthCheckSourceIp'] = $request->healthCheckSourceIp;
        }

        if (null !== $request->healthCheckTargetIp) {
            @$query['HealthCheckTargetIp'] = $request->healthCheckTargetIp;
        }

        if (null !== $request->instanceChargeType) {
            @$query['InstanceChargeType'] = $request->instanceChargeType;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->oppositeAccessPointId) {
            @$query['OppositeAccessPointId'] = $request->oppositeAccessPointId;
        }

        if (null !== $request->oppositeInterfaceId) {
            @$query['OppositeInterfaceId'] = $request->oppositeInterfaceId;
        }

        if (null !== $request->oppositeInterfaceOwnerId) {
            @$query['OppositeInterfaceOwnerId'] = $request->oppositeInterfaceOwnerId;
        }

        if (null !== $request->oppositeRegionId) {
            @$query['OppositeRegionId'] = $request->oppositeRegionId;
        }

        if (null !== $request->oppositeRouterId) {
            @$query['OppositeRouterId'] = $request->oppositeRouterId;
        }

        if (null !== $request->oppositeRouterType) {
            @$query['OppositeRouterType'] = $request->oppositeRouterType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->period) {
            @$query['Period'] = $request->period;
        }

        if (null !== $request->pricingCycle) {
            @$query['PricingCycle'] = $request->pricingCycle;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->role) {
            @$query['Role'] = $request->role;
        }

        if (null !== $request->routerId) {
            @$query['RouterId'] = $request->routerId;
        }

        if (null !== $request->routerType) {
            @$query['RouterType'] = $request->routerType;
        }

        if (null !== $request->spec) {
            @$query['Spec'] = $request->spec;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateRouterInterface',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateRouterInterfaceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a router interface.
     *
     * @remarks
     * When you call this operation, take note of the following limits:
     * *   You can create only one pair of interfaces to be connected between two routers.
     * *   You can create a maximum of five router interfaces for a router.
     * *   If your Alibaba Cloud account has a router interface with overdue payments, you cannot create new router interfaces.
     * *   Each destination CIDR block of route entries in the same route table must be unique.
     * *   A virtual border router (VBR) can serve only as a requester. The VBR must be in the Activated state.
     * *   You can call this operation to create subscription and pay-as-you-go router interfaces.
     *
     * @param request - CreateRouterInterfaceRequest
     *
     * @returns CreateRouterInterfaceResponse
     *
     * @param CreateRouterInterfaceRequest $request
     *
     * @return CreateRouterInterfaceResponse
     */
    public function createRouterInterface($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createRouterInterfaceWithOptions($request, $runtime);
    }

    /**
     * Adds an SNAT entry to an SNAT table.
     *
     * @remarks
     * You can call this operation to add SNAT entries to Internet NAT gateways and Virtual Private Cloud (VPC) NAT gateways. In this topic, a **NAT** gateway refers to both gateway types.
     * Before you call this operation, take note of the following limits:
     * *   **CreateSnatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of the task.
     *     *   If the SNAT entry is in the **Pending** state, the system is adding the SNAT entry. You can only query the status of the SNAT entry, and cannot perform other operations.
     *     *   If the SNAT entry is in the **Available** state, the SNAT entry is added.
     * *   You cannot repeatedly call the **CreateSnatEntry** operation to add an SNAT entry to an SNAT table within the specified period of time.
     * *   The vSwitch and Elastic Compute Service (ECS) instance specified in an SNAT entry must be created in the VPC where the NAT gateway is deployed.
     * *   Each vSwitch or ECS instance can be specified in only one SNAT entry.
     * *   If a high-availability virtual IP address (HAVIP) exists in a vSwitch, you cannot create SNAT entries.
     *
     * @param request - CreateSnatEntryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateSnatEntryResponse
     *
     * @param CreateSnatEntryRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return CreateSnatEntryResponse
     */
    public function createSnatEntryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->eipAffinity) {
            @$query['EipAffinity'] = $request->eipAffinity;
        }

        if (null !== $request->networkInterfaceId) {
            @$query['NetworkInterfaceId'] = $request->networkInterfaceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->snatEntryName) {
            @$query['SnatEntryName'] = $request->snatEntryName;
        }

        if (null !== $request->snatIp) {
            @$query['SnatIp'] = $request->snatIp;
        }

        if (null !== $request->snatTableId) {
            @$query['SnatTableId'] = $request->snatTableId;
        }

        if (null !== $request->sourceCIDR) {
            @$query['SourceCIDR'] = $request->sourceCIDR;
        }

        if (null !== $request->sourceVSwitchId) {
            @$query['SourceVSwitchId'] = $request->sourceVSwitchId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateSnatEntry',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateSnatEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds an SNAT entry to an SNAT table.
     *
     * @remarks
     * You can call this operation to add SNAT entries to Internet NAT gateways and Virtual Private Cloud (VPC) NAT gateways. In this topic, a **NAT** gateway refers to both gateway types.
     * Before you call this operation, take note of the following limits:
     * *   **CreateSnatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of the task.
     *     *   If the SNAT entry is in the **Pending** state, the system is adding the SNAT entry. You can only query the status of the SNAT entry, and cannot perform other operations.
     *     *   If the SNAT entry is in the **Available** state, the SNAT entry is added.
     * *   You cannot repeatedly call the **CreateSnatEntry** operation to add an SNAT entry to an SNAT table within the specified period of time.
     * *   The vSwitch and Elastic Compute Service (ECS) instance specified in an SNAT entry must be created in the VPC where the NAT gateway is deployed.
     * *   Each vSwitch or ECS instance can be specified in only one SNAT entry.
     * *   If a high-availability virtual IP address (HAVIP) exists in a vSwitch, you cannot create SNAT entries.
     *
     * @param request - CreateSnatEntryRequest
     *
     * @returns CreateSnatEntryResponse
     *
     * @param CreateSnatEntryRequest $request
     *
     * @return CreateSnatEntryResponse
     */
    public function createSnatEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createSnatEntryWithOptions($request, $runtime);
    }

    /**
     * Creates an SSL client certificate.
     *
     * @remarks
     * Before you create an SSL client certificate, make sure that an SSL server is created on the VPN gateway. For more information, see [CreateSslVpnServer](https://help.aliyun.com/document_detail/2794075.html).
     *
     * @param request - CreateSslVpnClientCertRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateSslVpnClientCertResponse
     *
     * @param CreateSslVpnClientCertRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return CreateSslVpnClientCertResponse
     */
    public function createSslVpnClientCertWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sslVpnServerId) {
            @$query['SslVpnServerId'] = $request->sslVpnServerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateSslVpnClientCert',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateSslVpnClientCertResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an SSL client certificate.
     *
     * @remarks
     * Before you create an SSL client certificate, make sure that an SSL server is created on the VPN gateway. For more information, see [CreateSslVpnServer](https://help.aliyun.com/document_detail/2794075.html).
     *
     * @param request - CreateSslVpnClientCertRequest
     *
     * @returns CreateSslVpnClientCertResponse
     *
     * @param CreateSslVpnClientCertRequest $request
     *
     * @return CreateSslVpnClientCertResponse
     */
    public function createSslVpnClientCert($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createSslVpnClientCertWithOptions($request, $runtime);
    }

    /**
     * Creates an SSL server.
     *
     * @remarks
     *   **CreateSslVpnServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the SSL server is being created.
     *     *   If the VPN gateway is in the **active** state, the SSL server is created.
     * *   You cannot repeatedly call the **CreateSslVpnServer** operation within the specified period of time.
     * ### [](#prerequisite)[](#)Prerequisite
     * *   A VPN gateway is created, and the SSL-VPN feature is enabled for the VPN gateway. For more information, see [CreateVpnGateway](https://help.aliyun.com/document_detail/2794049.html) .
     * *   If you want to enable two-factor authentication for the SSL server, make sure that the VPN gateway supports two-factor authentication. You may need to upgrade the VPN gateway. For more information, see [Two-factor authentication supports IDaaS EIAM 2.0](https://help.aliyun.com/document_detail/2785320.html).
     *
     * @param request - CreateSslVpnServerRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateSslVpnServerResponse
     *
     * @param CreateSslVpnServerRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return CreateSslVpnServerResponse
     */
    public function createSslVpnServerWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->cipher) {
            @$query['Cipher'] = $request->cipher;
        }

        if (null !== $request->clientIpPool) {
            @$query['ClientIpPool'] = $request->clientIpPool;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->compress) {
            @$query['Compress'] = $request->compress;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->enableMultiFactorAuth) {
            @$query['EnableMultiFactorAuth'] = $request->enableMultiFactorAuth;
        }

        if (null !== $request->IDaaSApplicationId) {
            @$query['IDaaSApplicationId'] = $request->IDaaSApplicationId;
        }

        if (null !== $request->IDaaSInstanceId) {
            @$query['IDaaSInstanceId'] = $request->IDaaSInstanceId;
        }

        if (null !== $request->IDaaSRegionId) {
            @$query['IDaaSRegionId'] = $request->IDaaSRegionId;
        }

        if (null !== $request->localSubnet) {
            @$query['LocalSubnet'] = $request->localSubnet;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->port) {
            @$query['Port'] = $request->port;
        }

        if (null !== $request->proto) {
            @$query['Proto'] = $request->proto;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vpnGatewayId) {
            @$query['VpnGatewayId'] = $request->vpnGatewayId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateSslVpnServer',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateSslVpnServerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an SSL server.
     *
     * @remarks
     *   **CreateSslVpnServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the SSL server is being created.
     *     *   If the VPN gateway is in the **active** state, the SSL server is created.
     * *   You cannot repeatedly call the **CreateSslVpnServer** operation within the specified period of time.
     * ### [](#prerequisite)[](#)Prerequisite
     * *   A VPN gateway is created, and the SSL-VPN feature is enabled for the VPN gateway. For more information, see [CreateVpnGateway](https://help.aliyun.com/document_detail/2794049.html) .
     * *   If you want to enable two-factor authentication for the SSL server, make sure that the VPN gateway supports two-factor authentication. You may need to upgrade the VPN gateway. For more information, see [Two-factor authentication supports IDaaS EIAM 2.0](https://help.aliyun.com/document_detail/2785320.html).
     *
     * @param request - CreateSslVpnServerRequest
     *
     * @returns CreateSslVpnServerResponse
     *
     * @param CreateSslVpnServerRequest $request
     *
     * @return CreateSslVpnServerResponse
     */
    public function createSslVpnServer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createSslVpnServerWithOptions($request, $runtime);
    }

    /**
     * Creates a filter for traffic mirror.
     *
     * @remarks
     * *CreateTrafficMirrorFilter** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of the task.
     * *   If the filter is in the **Creating** state, the filter is being created.
     * *   If the filter is in the **Created** state, the filter is created.
     *
     * @param request - CreateTrafficMirrorFilterRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateTrafficMirrorFilterResponse
     *
     * @param CreateTrafficMirrorFilterRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return CreateTrafficMirrorFilterResponse
     */
    public function createTrafficMirrorFilterWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->egressRules) {
            @$query['EgressRules'] = $request->egressRules;
        }

        if (null !== $request->ingressRules) {
            @$query['IngressRules'] = $request->ingressRules;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->trafficMirrorFilterDescription) {
            @$query['TrafficMirrorFilterDescription'] = $request->trafficMirrorFilterDescription;
        }

        if (null !== $request->trafficMirrorFilterName) {
            @$query['TrafficMirrorFilterName'] = $request->trafficMirrorFilterName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateTrafficMirrorFilter',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateTrafficMirrorFilterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a filter for traffic mirror.
     *
     * @remarks
     * *CreateTrafficMirrorFilter** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of the task.
     * *   If the filter is in the **Creating** state, the filter is being created.
     * *   If the filter is in the **Created** state, the filter is created.
     *
     * @param request - CreateTrafficMirrorFilterRequest
     *
     * @returns CreateTrafficMirrorFilterResponse
     *
     * @param CreateTrafficMirrorFilterRequest $request
     *
     * @return CreateTrafficMirrorFilterResponse
     */
    public function createTrafficMirrorFilter($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createTrafficMirrorFilterWithOptions($request, $runtime);
    }

    /**
     * Creates an inbound or outbound rule for traffic mirror.
     *
     * @remarks
     *   **CreateTrafficMirrorFilterRules** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) to query the status of the task.
     *     *   If the inbound or outbound rule is in the **Creating** state, the rule is being created.
     *     *   If the inbound or outbound rule is in the **Created** state, the rule is created.
     * *   You cannot call **CreateTrafficMirrorFilterRules** within the specified period of time.
     *
     * @param request - CreateTrafficMirrorFilterRulesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateTrafficMirrorFilterRulesResponse
     *
     * @param CreateTrafficMirrorFilterRulesRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return CreateTrafficMirrorFilterRulesResponse
     */
    public function createTrafficMirrorFilterRulesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->egressRules) {
            @$query['EgressRules'] = $request->egressRules;
        }

        if (null !== $request->ingressRules) {
            @$query['IngressRules'] = $request->ingressRules;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->trafficMirrorFilterId) {
            @$query['TrafficMirrorFilterId'] = $request->trafficMirrorFilterId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateTrafficMirrorFilterRules',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateTrafficMirrorFilterRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an inbound or outbound rule for traffic mirror.
     *
     * @remarks
     *   **CreateTrafficMirrorFilterRules** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) to query the status of the task.
     *     *   If the inbound or outbound rule is in the **Creating** state, the rule is being created.
     *     *   If the inbound or outbound rule is in the **Created** state, the rule is created.
     * *   You cannot call **CreateTrafficMirrorFilterRules** within the specified period of time.
     *
     * @param request - CreateTrafficMirrorFilterRulesRequest
     *
     * @returns CreateTrafficMirrorFilterRulesResponse
     *
     * @param CreateTrafficMirrorFilterRulesRequest $request
     *
     * @return CreateTrafficMirrorFilterRulesResponse
     */
    public function createTrafficMirrorFilterRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createTrafficMirrorFilterRulesWithOptions($request, $runtime);
    }

    /**
     * Creates a traffic mirror session.
     *
     * @remarks
     * *CreateTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) to query the status of the task.
     * *   If the traffic mirror session is in the **Creating** state, it is being created.
     * *   If the traffic mirror session is in the **Created** state, it is created.
     *
     * @param request - CreateTrafficMirrorSessionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateTrafficMirrorSessionResponse
     *
     * @param CreateTrafficMirrorSessionRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return CreateTrafficMirrorSessionResponse
     */
    public function createTrafficMirrorSessionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->enabled) {
            @$query['Enabled'] = $request->enabled;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->packetLength) {
            @$query['PacketLength'] = $request->packetLength;
        }

        if (null !== $request->priority) {
            @$query['Priority'] = $request->priority;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->trafficMirrorFilterId) {
            @$query['TrafficMirrorFilterId'] = $request->trafficMirrorFilterId;
        }

        if (null !== $request->trafficMirrorSessionDescription) {
            @$query['TrafficMirrorSessionDescription'] = $request->trafficMirrorSessionDescription;
        }

        if (null !== $request->trafficMirrorSessionName) {
            @$query['TrafficMirrorSessionName'] = $request->trafficMirrorSessionName;
        }

        if (null !== $request->trafficMirrorSourceIds) {
            @$query['TrafficMirrorSourceIds'] = $request->trafficMirrorSourceIds;
        }

        if (null !== $request->trafficMirrorTargetId) {
            @$query['TrafficMirrorTargetId'] = $request->trafficMirrorTargetId;
        }

        if (null !== $request->trafficMirrorTargetType) {
            @$query['TrafficMirrorTargetType'] = $request->trafficMirrorTargetType;
        }

        if (null !== $request->virtualNetworkId) {
            @$query['VirtualNetworkId'] = $request->virtualNetworkId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateTrafficMirrorSession',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateTrafficMirrorSessionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a traffic mirror session.
     *
     * @remarks
     * *CreateTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) to query the status of the task.
     * *   If the traffic mirror session is in the **Creating** state, it is being created.
     * *   If the traffic mirror session is in the **Created** state, it is created.
     *
     * @param request - CreateTrafficMirrorSessionRequest
     *
     * @returns CreateTrafficMirrorSessionResponse
     *
     * @param CreateTrafficMirrorSessionRequest $request
     *
     * @return CreateTrafficMirrorSessionResponse
     */
    public function createTrafficMirrorSession($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createTrafficMirrorSessionWithOptions($request, $runtime);
    }

    /**
     * 
     *
     * @remarks
     * When you call this operation, take note of the following limits:
     * *   You can create at most 150 vSwitches in a virtual private cloud (VPC).
     * *   The first IP address and last three IP addresses of each vSwitch CIDR block are reserved. For example, if the CIDR block of a vSwitch is 192.168.1.0/24, the IP addresses 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255 are reserved.
     * *   The number of instances in a vSwitch cannot exceed the remaining capacity of the VPC. The remaining capacity is the difference between 15,000 and the current number of instances.
     * *   Each instance can belong to only one vSwitch.
     * *   vSwitches do not support multicast or broadcast.
     * *   After you create a vSwitch, you cannot modify its CIDR block.
     * *   **CreateVSwitch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) to query the status of the task.
     *     *   If the vSwitch is in the **Pending** state, the vSwitch is being configured.
     *     *   If the vSwitch is in the **Available** state, the vSwitch is available.
     * *   You cannot repeatedly call the **CreateVSwitch** operation to create a vSwitch in a VPC within the specified period of time.
     *
     * @param request - CreateVSwitchRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateVSwitchResponse
     *
     * @param CreateVSwitchRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return CreateVSwitchResponse
     */
    public function createVSwitchWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->cidrBlock) {
            @$query['CidrBlock'] = $request->cidrBlock;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->ipv6CidrBlock) {
            @$query['Ipv6CidrBlock'] = $request->ipv6CidrBlock;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->vSwitchName) {
            @$query['VSwitchName'] = $request->vSwitchName;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        if (null !== $request->vpcIpv6CidrBlock) {
            @$query['VpcIpv6CidrBlock'] = $request->vpcIpv6CidrBlock;
        }

        if (null !== $request->zoneId) {
            @$query['ZoneId'] = $request->zoneId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateVSwitch',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateVSwitchResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 
     *
     * @remarks
     * When you call this operation, take note of the following limits:
     * *   You can create at most 150 vSwitches in a virtual private cloud (VPC).
     * *   The first IP address and last three IP addresses of each vSwitch CIDR block are reserved. For example, if the CIDR block of a vSwitch is 192.168.1.0/24, the IP addresses 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255 are reserved.
     * *   The number of instances in a vSwitch cannot exceed the remaining capacity of the VPC. The remaining capacity is the difference between 15,000 and the current number of instances.
     * *   Each instance can belong to only one vSwitch.
     * *   vSwitches do not support multicast or broadcast.
     * *   After you create a vSwitch, you cannot modify its CIDR block.
     * *   **CreateVSwitch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) to query the status of the task.
     *     *   If the vSwitch is in the **Pending** state, the vSwitch is being configured.
     *     *   If the vSwitch is in the **Available** state, the vSwitch is available.
     * *   You cannot repeatedly call the **CreateVSwitch** operation to create a vSwitch in a VPC within the specified period of time.
     *
     * @param request - CreateVSwitchRequest
     *
     * @returns CreateVSwitchResponse
     *
     * @param CreateVSwitchRequest $request
     *
     * @return CreateVSwitchResponse
     */
    public function createVSwitch($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVSwitchWithOptions($request, $runtime);
    }

    /**
     * Creates a reserved CIDR block for a vSwitch.
     *
     * @remarks
     * ## [](#)Description
     * Take note of the following items:
     * *   You can create at most 10 reserved IPv4 CIDR blocks and 10 reserved IPv6 CIDR blocks for each vSwitch in a virtual private cloud (VPC).
     * *   After you create a reserved CIDR block for a vSwitch, the CIDR block cannot contain the IP address of the subnet gateway of the VPC to which the vSwitch belongs.
     * *   **CreateVSwitchCidrReservation** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListVSwitchCidrReservations](https://help.aliyun.com/document_detail/610155.html) to query the status of the task:
     *     *   If the vSwitch is in the **Assigning** state, the reserved CIDR block is being created.
     *     *   If the vSwitch is in the **Assigned** state, the reserved CIDR block is created.
     * *   When you create a reserved IPv4 CIDR block for a vSwitch, the first IP address and the last three IP addresses of the vSwitch are reserved by the system. The four IP addresses will not be allocated.
     * *   When you create a reserved IPv6 CIDR block for a vSwitch, the first IP address and the last nine IP addresses of the vSwitch are reserved by the system. The 10 IP addresses will not be allocated. For example, if you create a reserved IPv4 CIDR block for a vSwitch whose CIDR block is 192.168.1.0/24, the reserved CIDR block cannot contain the following IP addresses: 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255.
     *
     * @param request - CreateVSwitchCidrReservationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateVSwitchCidrReservationResponse
     *
     * @param CreateVSwitchCidrReservationRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return CreateVSwitchCidrReservationResponse
     */
    public function createVSwitchCidrReservationWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ipVersion) {
            @$query['IpVersion'] = $request->ipVersion;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->vSwitchCidrReservationCidr) {
            @$query['VSwitchCidrReservationCidr'] = $request->vSwitchCidrReservationCidr;
        }

        if (null !== $request->vSwitchCidrReservationDescription) {
            @$query['VSwitchCidrReservationDescription'] = $request->vSwitchCidrReservationDescription;
        }

        if (null !== $request->vSwitchCidrReservationMask) {
            @$query['VSwitchCidrReservationMask'] = $request->vSwitchCidrReservationMask;
        }

        if (null !== $request->vSwitchCidrReservationName) {
            @$query['VSwitchCidrReservationName'] = $request->vSwitchCidrReservationName;
        }

        if (null !== $request->vSwitchCidrReservationType) {
            @$query['VSwitchCidrReservationType'] = $request->vSwitchCidrReservationType;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateVSwitchCidrReservation',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateVSwitchCidrReservationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a reserved CIDR block for a vSwitch.
     *
     * @remarks
     * ## [](#)Description
     * Take note of the following items:
     * *   You can create at most 10 reserved IPv4 CIDR blocks and 10 reserved IPv6 CIDR blocks for each vSwitch in a virtual private cloud (VPC).
     * *   After you create a reserved CIDR block for a vSwitch, the CIDR block cannot contain the IP address of the subnet gateway of the VPC to which the vSwitch belongs.
     * *   **CreateVSwitchCidrReservation** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListVSwitchCidrReservations](https://help.aliyun.com/document_detail/610155.html) to query the status of the task:
     *     *   If the vSwitch is in the **Assigning** state, the reserved CIDR block is being created.
     *     *   If the vSwitch is in the **Assigned** state, the reserved CIDR block is created.
     * *   When you create a reserved IPv4 CIDR block for a vSwitch, the first IP address and the last three IP addresses of the vSwitch are reserved by the system. The four IP addresses will not be allocated.
     * *   When you create a reserved IPv6 CIDR block for a vSwitch, the first IP address and the last nine IP addresses of the vSwitch are reserved by the system. The 10 IP addresses will not be allocated. For example, if you create a reserved IPv4 CIDR block for a vSwitch whose CIDR block is 192.168.1.0/24, the reserved CIDR block cannot contain the following IP addresses: 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255.
     *
     * @param request - CreateVSwitchCidrReservationRequest
     *
     * @returns CreateVSwitchCidrReservationResponse
     *
     * @param CreateVSwitchCidrReservationRequest $request
     *
     * @return CreateVSwitchCidrReservationResponse
     */
    public function createVSwitchCidrReservation($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVSwitchCidrReservationWithOptions($request, $runtime);
    }

    /**
     * Creates a virtual border router (VBR) failover group.
     *
     * @param request - CreateVbrHaRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateVbrHaResponse
     *
     * @param CreateVbrHaRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return CreateVbrHaResponse
     */
    public function createVbrHaWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->peerVbrId) {
            @$query['PeerVbrId'] = $request->peerVbrId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vbrId) {
            @$query['VbrId'] = $request->vbrId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateVbrHa',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateVbrHaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a virtual border router (VBR) failover group.
     *
     * @param request - CreateVbrHaRequest
     *
     * @returns CreateVbrHaResponse
     *
     * @param CreateVbrHaRequest $request
     *
     * @return CreateVbrHaResponse
     */
    public function createVbrHa($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVbrHaWithOptions($request, $runtime);
    }

    /**
     * Adds a destination-based route for an IPsec-VPN connection.
     *
     * @remarks
     *   The IPsec-VPN connection must be associated with a transit router. For more information, see [CreateTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/468249.html).
     * *   You cannot create a destination-based route whose destination CIDR block is 0.0.0.0/0.
     * *   Do not add a destination-based route whose destination CIDR block is 100.64.0.0/10, or a CIDR block that contains 100.64.0.0/10 or belongs to 100.64.0.0/10. Such a route will make the console fail to display the status of the IPsec-VPN connection or cause IPsec negotiation failures.
     * *   **CreateVcoRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) to query the status of the task.
     *     *   If the IPsec-VPN connection is in the **updating** state, the destination-based route is being created.
     *     *   If the IPsec-VPN connection is in the **attached** state, the destination-based route is created.
     * *   You cannot repeatedly call **CreateVcoRouteEntry** within the specified period of time.
     *
     * @param request - CreateVcoRouteEntryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateVcoRouteEntryResponse
     *
     * @param CreateVcoRouteEntryRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return CreateVcoRouteEntryResponse
     */
    public function createVcoRouteEntryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->nextHop) {
            @$query['NextHop'] = $request->nextHop;
        }

        if (null !== $request->overlayMode) {
            @$query['OverlayMode'] = $request->overlayMode;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeDest) {
            @$query['RouteDest'] = $request->routeDest;
        }

        if (null !== $request->vpnConnectionId) {
            @$query['VpnConnectionId'] = $request->vpnConnectionId;
        }

        if (null !== $request->weight) {
            @$query['Weight'] = $request->weight;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateVcoRouteEntry',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateVcoRouteEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds a destination-based route for an IPsec-VPN connection.
     *
     * @remarks
     *   The IPsec-VPN connection must be associated with a transit router. For more information, see [CreateTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/468249.html).
     * *   You cannot create a destination-based route whose destination CIDR block is 0.0.0.0/0.
     * *   Do not add a destination-based route whose destination CIDR block is 100.64.0.0/10, or a CIDR block that contains 100.64.0.0/10 or belongs to 100.64.0.0/10. Such a route will make the console fail to display the status of the IPsec-VPN connection or cause IPsec negotiation failures.
     * *   **CreateVcoRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) to query the status of the task.
     *     *   If the IPsec-VPN connection is in the **updating** state, the destination-based route is being created.
     *     *   If the IPsec-VPN connection is in the **attached** state, the destination-based route is created.
     * *   You cannot repeatedly call **CreateVcoRouteEntry** within the specified period of time.
     *
     * @param request - CreateVcoRouteEntryRequest
     *
     * @returns CreateVcoRouteEntryResponse
     *
     * @param CreateVcoRouteEntryRequest $request
     *
     * @return CreateVcoRouteEntryResponse
     */
    public function createVcoRouteEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVcoRouteEntryWithOptions($request, $runtime);
    }

    /**
     * Creates a virtual border router (VBR).
     *
     * @remarks
     * After you create a VBR, the VBR is in the **active** state.
     *
     * @param request - CreateVirtualBorderRouterRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateVirtualBorderRouterResponse
     *
     * @param CreateVirtualBorderRouterRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return CreateVirtualBorderRouterResponse
     */
    public function createVirtualBorderRouterWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bandwidth) {
            @$query['Bandwidth'] = $request->bandwidth;
        }

        if (null !== $request->circuitCode) {
            @$query['CircuitCode'] = $request->circuitCode;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->enableIpv6) {
            @$query['EnableIpv6'] = $request->enableIpv6;
        }

        if (null !== $request->localGatewayIp) {
            @$query['LocalGatewayIp'] = $request->localGatewayIp;
        }

        if (null !== $request->localIpv6GatewayIp) {
            @$query['LocalIpv6GatewayIp'] = $request->localIpv6GatewayIp;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->peerGatewayIp) {
            @$query['PeerGatewayIp'] = $request->peerGatewayIp;
        }

        if (null !== $request->peerIpv6GatewayIp) {
            @$query['PeerIpv6GatewayIp'] = $request->peerIpv6GatewayIp;
        }

        if (null !== $request->peeringIpv6SubnetMask) {
            @$query['PeeringIpv6SubnetMask'] = $request->peeringIpv6SubnetMask;
        }

        if (null !== $request->peeringSubnetMask) {
            @$query['PeeringSubnetMask'] = $request->peeringSubnetMask;
        }

        if (null !== $request->physicalConnectionId) {
            @$query['PhysicalConnectionId'] = $request->physicalConnectionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        if (null !== $request->vbrOwnerId) {
            @$query['VbrOwnerId'] = $request->vbrOwnerId;
        }

        if (null !== $request->vlanId) {
            @$query['VlanId'] = $request->vlanId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateVirtualBorderRouter',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateVirtualBorderRouterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a virtual border router (VBR).
     *
     * @remarks
     * After you create a VBR, the VBR is in the **active** state.
     *
     * @param request - CreateVirtualBorderRouterRequest
     *
     * @returns CreateVirtualBorderRouterResponse
     *
     * @param CreateVirtualBorderRouterRequest $request
     *
     * @return CreateVirtualBorderRouterResponse
     */
    public function createVirtualBorderRouter($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVirtualBorderRouterWithOptions($request, $runtime);
    }

    /**
     * Creates a hosted connection over Express Connect circuit.
     *
     * @remarks
     * # [](#)Description
     * Before you call this operation, we recommend that you learn about the workflow for creating a hosted connection and the environment requirements. For more information, see [Overview of hosted connections](https://help.aliyun.com/document_detail/146571.html) and [Operations performed by Express Connect partners](https://help.aliyun.com/document_detail/155987.html).
     *
     * @param request - CreateVirtualPhysicalConnectionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateVirtualPhysicalConnectionResponse
     *
     * @param CreateVirtualPhysicalConnectionRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return CreateVirtualPhysicalConnectionResponse
     */
    public function createVirtualPhysicalConnectionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->orderMode) {
            @$query['OrderMode'] = $request->orderMode;
        }

        if (null !== $request->physicalConnectionId) {
            @$query['PhysicalConnectionId'] = $request->physicalConnectionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->spec) {
            @$query['Spec'] = $request->spec;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->token) {
            @$query['Token'] = $request->token;
        }

        if (null !== $request->vlanId) {
            @$query['VlanId'] = $request->vlanId;
        }

        if (null !== $request->vpconnAliUid) {
            @$query['VpconnAliUid'] = $request->vpconnAliUid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateVirtualPhysicalConnection',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateVirtualPhysicalConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a hosted connection over Express Connect circuit.
     *
     * @remarks
     * # [](#)Description
     * Before you call this operation, we recommend that you learn about the workflow for creating a hosted connection and the environment requirements. For more information, see [Overview of hosted connections](https://help.aliyun.com/document_detail/146571.html) and [Operations performed by Express Connect partners](https://help.aliyun.com/document_detail/155987.html).
     *
     * @param request - CreateVirtualPhysicalConnectionRequest
     *
     * @returns CreateVirtualPhysicalConnectionResponse
     *
     * @param CreateVirtualPhysicalConnectionRequest $request
     *
     * @return CreateVirtualPhysicalConnectionResponse
     */
    public function createVirtualPhysicalConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVirtualPhysicalConnectionWithOptions($request, $runtime);
    }

    /**
     * Creates a virtual private cloud (VPC).
     *
     * @remarks
     * When you call this operation, take note of the following items:
     * *   You can specify only one CIDR block for each VPC.
     * *   After you create a VPC, you cannot change its CIDR block. However, you can add secondary IPv4 CIDR blocks to the VPC.
     * *   In each VPC, cloud services can use a maximum of 60,000 private IP addresses. You cannot increase the quota.
     * *   After you create a VPC, a vRouter and a route table are automatically created.
     * *   At most three user CIDR blocks can be added to a VPC. If a user CIDR block includes another user CIDR block, the one with the shorter subnet mask takes effect. For example, if both 10.0.0.0/8 and 10.1.0.0/16 are specified, only 10.0.0.0/8 takes effect.
     * *   **CreateVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task:
     *     *   If the VPC is in the **Creating** state, the VPC is being created.
     *     *   If the VPC is in the **Created** state, the VPC is created.
     * *   You cannot repeatedly call the **DeleteRouteEntry** operation to create default VPCs within a specific time period. However, you can repeatedly call this operation to create custom VPCs within a specific time period.
     *
     * @param request - CreateVpcRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateVpcResponse
     *
     * @param CreateVpcRequest $request
     * @param RuntimeOptions   $runtime
     *
     * @return CreateVpcResponse
     */
    public function createVpcWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->cidrBlock) {
            @$query['CidrBlock'] = $request->cidrBlock;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->enableDnsHostname) {
            @$query['EnableDnsHostname'] = $request->enableDnsHostname;
        }

        if (null !== $request->enableIpv6) {
            @$query['EnableIpv6'] = $request->enableIpv6;
        }

        if (null !== $request->ipv4CidrMask) {
            @$query['Ipv4CidrMask'] = $request->ipv4CidrMask;
        }

        if (null !== $request->ipv4IpamPoolId) {
            @$query['Ipv4IpamPoolId'] = $request->ipv4IpamPoolId;
        }

        if (null !== $request->ipv6CidrBlock) {
            @$query['Ipv6CidrBlock'] = $request->ipv6CidrBlock;
        }

        if (null !== $request->ipv6CidrMask) {
            @$query['Ipv6CidrMask'] = $request->ipv6CidrMask;
        }

        if (null !== $request->ipv6IpamPoolId) {
            @$query['Ipv6IpamPoolId'] = $request->ipv6IpamPoolId;
        }

        if (null !== $request->ipv6Isp) {
            @$query['Ipv6Isp'] = $request->ipv6Isp;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->userCidr) {
            @$query['UserCidr'] = $request->userCidr;
        }

        if (null !== $request->vpcName) {
            @$query['VpcName'] = $request->vpcName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateVpc',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateVpcResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a virtual private cloud (VPC).
     *
     * @remarks
     * When you call this operation, take note of the following items:
     * *   You can specify only one CIDR block for each VPC.
     * *   After you create a VPC, you cannot change its CIDR block. However, you can add secondary IPv4 CIDR blocks to the VPC.
     * *   In each VPC, cloud services can use a maximum of 60,000 private IP addresses. You cannot increase the quota.
     * *   After you create a VPC, a vRouter and a route table are automatically created.
     * *   At most three user CIDR blocks can be added to a VPC. If a user CIDR block includes another user CIDR block, the one with the shorter subnet mask takes effect. For example, if both 10.0.0.0/8 and 10.1.0.0/16 are specified, only 10.0.0.0/8 takes effect.
     * *   **CreateVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task:
     *     *   If the VPC is in the **Creating** state, the VPC is being created.
     *     *   If the VPC is in the **Created** state, the VPC is created.
     * *   You cannot repeatedly call the **DeleteRouteEntry** operation to create default VPCs within a specific time period. However, you can repeatedly call this operation to create custom VPCs within a specific time period.
     *
     * @param request - CreateVpcRequest
     *
     * @returns CreateVpcResponse
     *
     * @param CreateVpcRequest $request
     *
     * @return CreateVpcResponse
     */
    public function createVpc($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVpcWithOptions($request, $runtime);
    }

    /**
     * Creates a gateway endpoint.
     *
     * @remarks
     *   **CreateVpcGatewayEndpoint** is an asynchronous operation. After a request is sent, the system returns an **EndpointId** and runs the task in the background. You can call the [ListVpcGatewayEndpoints](https://help.aliyun.com/document_detail/448682.html) operation to query the status of the task.
     *     *   If the gateway endpoint is in the **Creating** state, the gateway endpoint is being created.
     *     *   If the gateway endpoint is in the **Created** state, the gateway endpoint is created.
     * *   You cannot repeatedly call the **CreateVpcGatewayEndpoint** operation for the same endpoint service within the specified period of time.
     *
     * @param request - CreateVpcGatewayEndpointRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateVpcGatewayEndpointResponse
     *
     * @param CreateVpcGatewayEndpointRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return CreateVpcGatewayEndpointResponse
     */
    public function createVpcGatewayEndpointWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->endpointDescription) {
            @$query['EndpointDescription'] = $request->endpointDescription;
        }

        if (null !== $request->endpointName) {
            @$query['EndpointName'] = $request->endpointName;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->policyDocument) {
            @$query['PolicyDocument'] = $request->policyDocument;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->serviceName) {
            @$query['ServiceName'] = $request->serviceName;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateVpcGatewayEndpoint',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateVpcGatewayEndpointResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a gateway endpoint.
     *
     * @remarks
     *   **CreateVpcGatewayEndpoint** is an asynchronous operation. After a request is sent, the system returns an **EndpointId** and runs the task in the background. You can call the [ListVpcGatewayEndpoints](https://help.aliyun.com/document_detail/448682.html) operation to query the status of the task.
     *     *   If the gateway endpoint is in the **Creating** state, the gateway endpoint is being created.
     *     *   If the gateway endpoint is in the **Created** state, the gateway endpoint is created.
     * *   You cannot repeatedly call the **CreateVpcGatewayEndpoint** operation for the same endpoint service within the specified period of time.
     *
     * @param request - CreateVpcGatewayEndpointRequest
     *
     * @returns CreateVpcGatewayEndpointResponse
     *
     * @param CreateVpcGatewayEndpointRequest $request
     *
     * @return CreateVpcGatewayEndpointResponse
     */
    public function createVpcGatewayEndpoint($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVpcGatewayEndpointWithOptions($request, $runtime);
    }

    /**
     * Creates a prefix list.
     *
     * @remarks
     * You cannot repeatedly call the **CreateVpcPrefixList** operation within the specified period of time.
     *
     * @param request - CreateVpcPrefixListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateVpcPrefixListResponse
     *
     * @param CreateVpcPrefixListRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return CreateVpcPrefixListResponse
     */
    public function createVpcPrefixListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ipVersion) {
            @$query['IpVersion'] = $request->ipVersion;
        }

        if (null !== $request->maxEntries) {
            @$query['MaxEntries'] = $request->maxEntries;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->prefixListDescription) {
            @$query['PrefixListDescription'] = $request->prefixListDescription;
        }

        if (null !== $request->prefixListEntries) {
            @$query['PrefixListEntries'] = $request->prefixListEntries;
        }

        if (null !== $request->prefixListName) {
            @$query['PrefixListName'] = $request->prefixListName;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateVpcPrefixList',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateVpcPrefixListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a prefix list.
     *
     * @remarks
     * You cannot repeatedly call the **CreateVpcPrefixList** operation within the specified period of time.
     *
     * @param request - CreateVpcPrefixListRequest
     *
     * @returns CreateVpcPrefixListResponse
     *
     * @param CreateVpcPrefixListRequest $request
     *
     * @return CreateVpcPrefixListResponse
     */
    public function createVpcPrefixList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVpcPrefixListWithOptions($request, $runtime);
    }

    /**
     * Adds a shared port to a hosted connection.
     *
     * @remarks
     * If an Express Connect partner has created a virtual border router (VBR) for a tenant before, the Express Connect partner can push the Express Connect circuit that is associated with the VBR to the tenant account by adding a shared port for the tenant account. The service of the tenant is not interrupted in this process.
     * Preparations:
     * Before the Express Connect partner performs the operation, the Express Connect partner must notify the tenant and request the tenant to enable outbound data transfer billing. For more information, see [Enable outbound data transfer billing](https://help.aliyun.com/document_detail/274385.html).
     * What to do next:
     * 1.  After the Express Connect partner performs the operation, a shared port is added for the tenant account. The tenant must call the [ConfirmPhysicalConnection](https://help.aliyun.com/document_detail/324198.html) operation to accept the shared port.
     * 2.  Then, the Express Connect partner must call the [AttachVbrToVpconn](https://help.aliyun.com/document_detail/324191.html) operation to associate the VBR with the newly added shared port that belongs to the tenant account.
     *
     * @param request - CreateVpconnFromVbrRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateVpconnFromVbrResponse
     *
     * @param CreateVpconnFromVbrRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return CreateVpconnFromVbrResponse
     */
    public function createVpconnFromVbrWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->orderMode) {
            @$query['OrderMode'] = $request->orderMode;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->token) {
            @$query['Token'] = $request->token;
        }

        if (null !== $request->vbrId) {
            @$query['VbrId'] = $request->vbrId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateVpconnFromVbr',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateVpconnFromVbrResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds a shared port to a hosted connection.
     *
     * @remarks
     * If an Express Connect partner has created a virtual border router (VBR) for a tenant before, the Express Connect partner can push the Express Connect circuit that is associated with the VBR to the tenant account by adding a shared port for the tenant account. The service of the tenant is not interrupted in this process.
     * Preparations:
     * Before the Express Connect partner performs the operation, the Express Connect partner must notify the tenant and request the tenant to enable outbound data transfer billing. For more information, see [Enable outbound data transfer billing](https://help.aliyun.com/document_detail/274385.html).
     * What to do next:
     * 1.  After the Express Connect partner performs the operation, a shared port is added for the tenant account. The tenant must call the [ConfirmPhysicalConnection](https://help.aliyun.com/document_detail/324198.html) operation to accept the shared port.
     * 2.  Then, the Express Connect partner must call the [AttachVbrToVpconn](https://help.aliyun.com/document_detail/324191.html) operation to associate the VBR with the newly added shared port that belongs to the tenant account.
     *
     * @param request - CreateVpconnFromVbrRequest
     *
     * @returns CreateVpconnFromVbrResponse
     *
     * @param CreateVpconnFromVbrRequest $request
     *
     * @return CreateVpconnFromVbrResponse
     */
    public function createVpconnFromVbr($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVpconnFromVbrWithOptions($request, $runtime);
    }

    /**
     * Creates an IPsec-VPN connection. After you create the IPsec-VPN connection, you can associate the IPsec-VPN connection with a transit router.
     *
     * @remarks
     *   By default, the IPsec-VPN connection created by calling the `CreateVpnAttachment` operation is not bound to any resources. You can call the [CreateTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/443993.html) operation to bind the IPsec-VPN connection to a transit router.
     * *   If you want to associate an IPsec-VPN connection with a transit router, you can create a dual-tunnel connection in some regions. For more information, see [Dual-tunnel IPsec-VPN connections](https://help.aliyun.com/document_detail/2853535.html).
     *     *   When you create a IPsec-VPN connection in dual tunnel mode, you can configure the following request parameters in addition to the required parameters: **ClientToken**, **Name**, **NetworkType**, **EffectImmediately**, **AutoConfigRoute**, **Tags** array, **ResourceGroupId**, **TunnelOptionsSpecification** array, and **EnableTunnelsBgp**.
     *     *   When you create a IPsec-VPN connection in single tunnel mode, you can configure the following request parameters in addition to the required parameters: **ClientToken**, **CustomerGatewayId**, **NetworkType**, **Name**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, **Tags** array, and **ResourceGroupId**.
     * ### [](#)Prerequisites
     * Before you create an IPsec-VPN connection, you must create a customer gateway in the region where you want to create the IPsec-VPN connection. For more information, see [CreateCustomerGateway](https://help.aliyun.com/document_detail/120368.html).
     * If you want to add BGP configurations to an IPsec-VPN connection, make sure that an autonomous system number (ASN) is assigned to the customer gateway.
     *
     * @param request - CreateVpnAttachmentRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateVpnAttachmentResponse
     *
     * @param CreateVpnAttachmentRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return CreateVpnAttachmentResponse
     */
    public function createVpnAttachmentWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->autoConfigRoute) {
            @$query['AutoConfigRoute'] = $request->autoConfigRoute;
        }

        if (null !== $request->bgpConfig) {
            @$query['BgpConfig'] = $request->bgpConfig;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->customerGatewayId) {
            @$query['CustomerGatewayId'] = $request->customerGatewayId;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->effectImmediately) {
            @$query['EffectImmediately'] = $request->effectImmediately;
        }

        if (null !== $request->enableDpd) {
            @$query['EnableDpd'] = $request->enableDpd;
        }

        if (null !== $request->enableNatTraversal) {
            @$query['EnableNatTraversal'] = $request->enableNatTraversal;
        }

        if (null !== $request->enableTunnelsBgp) {
            @$query['EnableTunnelsBgp'] = $request->enableTunnelsBgp;
        }

        if (null !== $request->healthCheckConfig) {
            @$query['HealthCheckConfig'] = $request->healthCheckConfig;
        }

        if (null !== $request->ikeConfig) {
            @$query['IkeConfig'] = $request->ikeConfig;
        }

        if (null !== $request->ipsecConfig) {
            @$query['IpsecConfig'] = $request->ipsecConfig;
        }

        if (null !== $request->localSubnet) {
            @$query['LocalSubnet'] = $request->localSubnet;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->networkType) {
            @$query['NetworkType'] = $request->networkType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->remoteCaCert) {
            @$query['RemoteCaCert'] = $request->remoteCaCert;
        }

        if (null !== $request->remoteSubnet) {
            @$query['RemoteSubnet'] = $request->remoteSubnet;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        $body = [];
        $bodyFlat = [];
        if (null !== $request->tunnelOptionsSpecification) {
            @$bodyFlat['TunnelOptionsSpecification'] = $request->tunnelOptionsSpecification;
        }

        $body = Dara::merge([
        ], $body, Utils::query($bodyFlat));
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateVpnAttachment',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateVpnAttachmentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an IPsec-VPN connection. After you create the IPsec-VPN connection, you can associate the IPsec-VPN connection with a transit router.
     *
     * @remarks
     *   By default, the IPsec-VPN connection created by calling the `CreateVpnAttachment` operation is not bound to any resources. You can call the [CreateTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/443993.html) operation to bind the IPsec-VPN connection to a transit router.
     * *   If you want to associate an IPsec-VPN connection with a transit router, you can create a dual-tunnel connection in some regions. For more information, see [Dual-tunnel IPsec-VPN connections](https://help.aliyun.com/document_detail/2853535.html).
     *     *   When you create a IPsec-VPN connection in dual tunnel mode, you can configure the following request parameters in addition to the required parameters: **ClientToken**, **Name**, **NetworkType**, **EffectImmediately**, **AutoConfigRoute**, **Tags** array, **ResourceGroupId**, **TunnelOptionsSpecification** array, and **EnableTunnelsBgp**.
     *     *   When you create a IPsec-VPN connection in single tunnel mode, you can configure the following request parameters in addition to the required parameters: **ClientToken**, **CustomerGatewayId**, **NetworkType**, **Name**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, **Tags** array, and **ResourceGroupId**.
     * ### [](#)Prerequisites
     * Before you create an IPsec-VPN connection, you must create a customer gateway in the region where you want to create the IPsec-VPN connection. For more information, see [CreateCustomerGateway](https://help.aliyun.com/document_detail/120368.html).
     * If you want to add BGP configurations to an IPsec-VPN connection, make sure that an autonomous system number (ASN) is assigned to the customer gateway.
     *
     * @param request - CreateVpnAttachmentRequest
     *
     * @returns CreateVpnAttachmentResponse
     *
     * @param CreateVpnAttachmentRequest $request
     *
     * @return CreateVpnAttachmentResponse
     */
    public function createVpnAttachment($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVpnAttachmentWithOptions($request, $runtime);
    }

    /**
     * Creates an IPsec-VPN connection.
     *
     * @remarks
     *   If the VPN gateway supports the dual-tunnel mode, you can specify the following parameters in addition to the required parameters when you call `CreateVpnConnection`:
     *     **ClientToken**, **Name**, **EffectImmediately**, **AutoConfigRoute**, **Tags** array, **TunnelOptionsSpecification** array, and **EnableTunnelsBgp**.
     *     For more information about the regions and zones that support the dual-tunnel mode, see [IPsec-VPN connections support the dual-tunnel mode](https://help.aliyun.com/document_detail/2358946.html).
     * *   If the VPN gateway supports only the dual-tunnel mode, you can specify the following parameters in addition to the required parameters when you call `CreateVpnConnection`:
     *     **ClientToken**, **CustomerGatewayId**, **Name**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, **RemoteCaCertificate**, and **Tags** array.
     * *   **CreateVpnConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the IPsec-VPN connection is being created.
     *     *   If the VPN gateway is in the **active** state, the IPsec-VPN connection is created.
     * *   You cannot call **CreateVpnConnection** to create multiple IPsec-VPN connections associated with a VPN gateway at the same time.
     *
     * @param request - CreateVpnConnectionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateVpnConnectionResponse
     *
     * @param CreateVpnConnectionRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return CreateVpnConnectionResponse
     */
    public function createVpnConnectionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->autoConfigRoute) {
            @$query['AutoConfigRoute'] = $request->autoConfigRoute;
        }

        if (null !== $request->bgpConfig) {
            @$query['BgpConfig'] = $request->bgpConfig;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->customerGatewayId) {
            @$query['CustomerGatewayId'] = $request->customerGatewayId;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->effectImmediately) {
            @$query['EffectImmediately'] = $request->effectImmediately;
        }

        if (null !== $request->enableDpd) {
            @$query['EnableDpd'] = $request->enableDpd;
        }

        if (null !== $request->enableNatTraversal) {
            @$query['EnableNatTraversal'] = $request->enableNatTraversal;
        }

        if (null !== $request->enableTunnelsBgp) {
            @$query['EnableTunnelsBgp'] = $request->enableTunnelsBgp;
        }

        if (null !== $request->healthCheckConfig) {
            @$query['HealthCheckConfig'] = $request->healthCheckConfig;
        }

        if (null !== $request->ikeConfig) {
            @$query['IkeConfig'] = $request->ikeConfig;
        }

        if (null !== $request->ipsecConfig) {
            @$query['IpsecConfig'] = $request->ipsecConfig;
        }

        if (null !== $request->localSubnet) {
            @$query['LocalSubnet'] = $request->localSubnet;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->remoteCaCertificate) {
            @$query['RemoteCaCertificate'] = $request->remoteCaCertificate;
        }

        if (null !== $request->remoteSubnet) {
            @$query['RemoteSubnet'] = $request->remoteSubnet;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        if (null !== $request->vpnGatewayId) {
            @$query['VpnGatewayId'] = $request->vpnGatewayId;
        }

        $body = [];
        $bodyFlat = [];
        if (null !== $request->tunnelOptionsSpecification) {
            @$bodyFlat['TunnelOptionsSpecification'] = $request->tunnelOptionsSpecification;
        }

        $body = Dara::merge([
        ], $body, Utils::query($bodyFlat));
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateVpnConnection',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateVpnConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an IPsec-VPN connection.
     *
     * @remarks
     *   If the VPN gateway supports the dual-tunnel mode, you can specify the following parameters in addition to the required parameters when you call `CreateVpnConnection`:
     *     **ClientToken**, **Name**, **EffectImmediately**, **AutoConfigRoute**, **Tags** array, **TunnelOptionsSpecification** array, and **EnableTunnelsBgp**.
     *     For more information about the regions and zones that support the dual-tunnel mode, see [IPsec-VPN connections support the dual-tunnel mode](https://help.aliyun.com/document_detail/2358946.html).
     * *   If the VPN gateway supports only the dual-tunnel mode, you can specify the following parameters in addition to the required parameters when you call `CreateVpnConnection`:
     *     **ClientToken**, **CustomerGatewayId**, **Name**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, **RemoteCaCertificate**, and **Tags** array.
     * *   **CreateVpnConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the IPsec-VPN connection is being created.
     *     *   If the VPN gateway is in the **active** state, the IPsec-VPN connection is created.
     * *   You cannot call **CreateVpnConnection** to create multiple IPsec-VPN connections associated with a VPN gateway at the same time.
     *
     * @param request - CreateVpnConnectionRequest
     *
     * @returns CreateVpnConnectionResponse
     *
     * @param CreateVpnConnectionRequest $request
     *
     * @return CreateVpnConnectionResponse
     */
    public function createVpnConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVpnConnectionWithOptions($request, $runtime);
    }

    /**
     * Creates a VPN gateway.
     *
     * @remarks
     *   Before you create a VPN gateway, we recommend that you know more about the limits of VPN gateways. For more information, see the [Limits](https://help.aliyun.com/document_detail/65290.html) section in the "Create and manage a VPN gateway" topic.
     * *   VPN gateways in some regions support only IPsec-VPN connections in dual-tunnel mode. If you call `CreateVpnGateway` in these regions, you must specify **VSwitchId** and **DisasterRecoveryVSwitchId** in addition to the required parameters. For more information about the regions and zones that support the IPsec-VPN connections in dual-tunnel mode, see [IPsec-VPN connections support the dual-tunnel mode](https://help.aliyun.com/document_detail/2358946.html).
     * *   **CreateVpnGateway** is an asynchronous operation. After you send a request to call this operation, the system returns a request ID and the endpoint service is being created in the backend. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of a VPN gateway.
     *     *   If the VPN gateway is in the **provisioning** state, the VPN gateway is being created.
     *     *   If the VPN gateway is in the **active** state, the VPN gateway is created.
     *
     * @param request - CreateVpnGatewayRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateVpnGatewayResponse
     *
     * @param CreateVpnGatewayRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return CreateVpnGatewayResponse
     */
    public function createVpnGatewayWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->autoPay) {
            @$query['AutoPay'] = $request->autoPay;
        }

        if (null !== $request->bandwidth) {
            @$query['Bandwidth'] = $request->bandwidth;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->disasterRecoveryVSwitchId) {
            @$query['DisasterRecoveryVSwitchId'] = $request->disasterRecoveryVSwitchId;
        }

        if (null !== $request->enableIpsec) {
            @$query['EnableIpsec'] = $request->enableIpsec;
        }

        if (null !== $request->enableSsl) {
            @$query['EnableSsl'] = $request->enableSsl;
        }

        if (null !== $request->instanceChargeType) {
            @$query['InstanceChargeType'] = $request->instanceChargeType;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->networkType) {
            @$query['NetworkType'] = $request->networkType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->period) {
            @$query['Period'] = $request->period;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sslConnections) {
            @$query['SslConnections'] = $request->sslConnections;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        if (null !== $request->vpnType) {
            @$query['VpnType'] = $request->vpnType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateVpnGateway',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateVpnGatewayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a VPN gateway.
     *
     * @remarks
     *   Before you create a VPN gateway, we recommend that you know more about the limits of VPN gateways. For more information, see the [Limits](https://help.aliyun.com/document_detail/65290.html) section in the "Create and manage a VPN gateway" topic.
     * *   VPN gateways in some regions support only IPsec-VPN connections in dual-tunnel mode. If you call `CreateVpnGateway` in these regions, you must specify **VSwitchId** and **DisasterRecoveryVSwitchId** in addition to the required parameters. For more information about the regions and zones that support the IPsec-VPN connections in dual-tunnel mode, see [IPsec-VPN connections support the dual-tunnel mode](https://help.aliyun.com/document_detail/2358946.html).
     * *   **CreateVpnGateway** is an asynchronous operation. After you send a request to call this operation, the system returns a request ID and the endpoint service is being created in the backend. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of a VPN gateway.
     *     *   If the VPN gateway is in the **provisioning** state, the VPN gateway is being created.
     *     *   If the VPN gateway is in the **active** state, the VPN gateway is created.
     *
     * @param request - CreateVpnGatewayRequest
     *
     * @returns CreateVpnGatewayResponse
     *
     * @param CreateVpnGatewayRequest $request
     *
     * @return CreateVpnGatewayResponse
     */
    public function createVpnGateway($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVpnGatewayWithOptions($request, $runtime);
    }

    /**
     * Creates a policy-based route for a VPN gateway.
     *
     * @remarks
     *   Before you call this operation, make sure that you are familiar with the match rules of and limits on policy-based routes. For more information, see [Manage policy-based routes](https://help.aliyun.com/document_detail/110777.html).
     * *   Before you create a policy-based route, make sure that an IPsec-VPN connection is created. For more information, see [CreateVpnConnection](https://help.aliyun.com/document_detail/120391.html).
     * *   **CreateVpnPbrRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of the VPN gateway.
     *     *   If the VPN gateway is in the **updating** state, the policy-based route is being created.
     *     *   If the VPN gateway is in the **active** state, the policy-based route is created.
     * *   You cannot call the **CreateVpnPbrRouteEntry** operation to create multiple policy-based routes for a VPN gateway at a time.
     *
     * @param request - CreateVpnPbrRouteEntryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateVpnPbrRouteEntryResponse
     *
     * @param CreateVpnPbrRouteEntryRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return CreateVpnPbrRouteEntryResponse
     */
    public function createVpnPbrRouteEntryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->nextHop) {
            @$query['NextHop'] = $request->nextHop;
        }

        if (null !== $request->overlayMode) {
            @$query['OverlayMode'] = $request->overlayMode;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->priority) {
            @$query['Priority'] = $request->priority;
        }

        if (null !== $request->publishVpc) {
            @$query['PublishVpc'] = $request->publishVpc;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeDest) {
            @$query['RouteDest'] = $request->routeDest;
        }

        if (null !== $request->routeSource) {
            @$query['RouteSource'] = $request->routeSource;
        }

        if (null !== $request->vpnGatewayId) {
            @$query['VpnGatewayId'] = $request->vpnGatewayId;
        }

        if (null !== $request->weight) {
            @$query['Weight'] = $request->weight;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateVpnPbrRouteEntry',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateVpnPbrRouteEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a policy-based route for a VPN gateway.
     *
     * @remarks
     *   Before you call this operation, make sure that you are familiar with the match rules of and limits on policy-based routes. For more information, see [Manage policy-based routes](https://help.aliyun.com/document_detail/110777.html).
     * *   Before you create a policy-based route, make sure that an IPsec-VPN connection is created. For more information, see [CreateVpnConnection](https://help.aliyun.com/document_detail/120391.html).
     * *   **CreateVpnPbrRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of the VPN gateway.
     *     *   If the VPN gateway is in the **updating** state, the policy-based route is being created.
     *     *   If the VPN gateway is in the **active** state, the policy-based route is created.
     * *   You cannot call the **CreateVpnPbrRouteEntry** operation to create multiple policy-based routes for a VPN gateway at a time.
     *
     * @param request - CreateVpnPbrRouteEntryRequest
     *
     * @returns CreateVpnPbrRouteEntryResponse
     *
     * @param CreateVpnPbrRouteEntryRequest $request
     *
     * @return CreateVpnPbrRouteEntryResponse
     */
    public function createVpnPbrRouteEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVpnPbrRouteEntryWithOptions($request, $runtime);
    }

    /**
     * Creates a destination-based route entry for a VPN gateway.
     *
     * @remarks
     *   **CreateVpnRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If a VPN gateway is in the **updating** state, the destination-based route entry is being created.
     *     *   If a VPN gateway is in the **active** state, the destination-based route entry has been created.
     * *   You cannot repeatedly call **CreateVpnRouteEntry** to create a destination-based route entry for a VPN gateway within the specified period of time.
     *
     * @param request - CreateVpnRouteEntryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateVpnRouteEntryResponse
     *
     * @param CreateVpnRouteEntryRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return CreateVpnRouteEntryResponse
     */
    public function createVpnRouteEntryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->nextHop) {
            @$query['NextHop'] = $request->nextHop;
        }

        if (null !== $request->overlayMode) {
            @$query['OverlayMode'] = $request->overlayMode;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->publishVpc) {
            @$query['PublishVpc'] = $request->publishVpc;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeDest) {
            @$query['RouteDest'] = $request->routeDest;
        }

        if (null !== $request->vpnGatewayId) {
            @$query['VpnGatewayId'] = $request->vpnGatewayId;
        }

        if (null !== $request->weight) {
            @$query['Weight'] = $request->weight;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateVpnRouteEntry',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateVpnRouteEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a destination-based route entry for a VPN gateway.
     *
     * @remarks
     *   **CreateVpnRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If a VPN gateway is in the **updating** state, the destination-based route entry is being created.
     *     *   If a VPN gateway is in the **active** state, the destination-based route entry has been created.
     * *   You cannot repeatedly call **CreateVpnRouteEntry** to create a destination-based route entry for a VPN gateway within the specified period of time.
     *
     * @param request - CreateVpnRouteEntryRequest
     *
     * @returns CreateVpnRouteEntryResponse
     *
     * @param CreateVpnRouteEntryRequest $request
     *
     * @return CreateVpnRouteEntryResponse
     */
    public function createVpnRouteEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVpnRouteEntryWithOptions($request, $runtime);
    }

    /**
     * .
     *
     * @param request - DeactivateRouterInterfaceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeactivateRouterInterfaceResponse
     *
     * @param DeactivateRouterInterfaceRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DeactivateRouterInterfaceResponse
     */
    public function deactivateRouterInterfaceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routerInterfaceId) {
            @$query['RouterInterfaceId'] = $request->routerInterfaceId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeactivateRouterInterface',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeactivateRouterInterfaceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * .
     *
     * @param request - DeactivateRouterInterfaceRequest
     *
     * @returns DeactivateRouterInterfaceResponse
     *
     * @param DeactivateRouterInterfaceRequest $request
     *
     * @return DeactivateRouterInterfaceResponse
     */
    public function deactivateRouterInterface($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deactivateRouterInterfaceWithOptions($request, $runtime);
    }

    /**
     * Disables a flow log. After a flow log is disabled, the system no longer captures the traffic information about a resource.
     *
     * @remarks
     *   The **DeactiveFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
     *     *   If the flow log is in the **Deactivating** state, the flow log is being disabled.
     *     *   If the flow log is in the **Inactive** state, the flow log is disabled.
     * *   You cannot repeatedly call the **DeactiveFlowLog** operation to disable a flow log within the specified period of time.
     *
     * @param request - DeactiveFlowLogRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeactiveFlowLogResponse
     *
     * @param DeactiveFlowLogRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return DeactiveFlowLogResponse
     */
    public function deactiveFlowLogWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->flowLogId) {
            @$query['FlowLogId'] = $request->flowLogId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeactiveFlowLog',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeactiveFlowLogResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Disables a flow log. After a flow log is disabled, the system no longer captures the traffic information about a resource.
     *
     * @remarks
     *   The **DeactiveFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
     *     *   If the flow log is in the **Deactivating** state, the flow log is being disabled.
     *     *   If the flow log is in the **Inactive** state, the flow log is disabled.
     * *   You cannot repeatedly call the **DeactiveFlowLog** operation to disable a flow log within the specified period of time.
     *
     * @param request - DeactiveFlowLogRequest
     *
     * @returns DeactiveFlowLogResponse
     *
     * @param DeactiveFlowLogRequest $request
     *
     * @return DeactiveFlowLogResponse
     */
    public function deactiveFlowLog($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deactiveFlowLogWithOptions($request, $runtime);
    }

    /**
     * Deletes a Border Gateway Protocol (BGP) group.
     *
     * @param request - DeleteBgpGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteBgpGroupResponse
     *
     * @param DeleteBgpGroupRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return DeleteBgpGroupResponse
     */
    public function deleteBgpGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bgpGroupId) {
            @$query['BgpGroupId'] = $request->bgpGroupId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteBgpGroup',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteBgpGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a Border Gateway Protocol (BGP) group.
     *
     * @param request - DeleteBgpGroupRequest
     *
     * @returns DeleteBgpGroupResponse
     *
     * @param DeleteBgpGroupRequest $request
     *
     * @return DeleteBgpGroupResponse
     */
    public function deleteBgpGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBgpGroupWithOptions($request, $runtime);
    }

    /**
     * Deletes an advertised Border Gateway Protocol (BGP) network.
     *
     * @param request - DeleteBgpNetworkRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteBgpNetworkResponse
     *
     * @param DeleteBgpNetworkRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DeleteBgpNetworkResponse
     */
    public function deleteBgpNetworkWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dstCidrBlock) {
            @$query['DstCidrBlock'] = $request->dstCidrBlock;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routerId) {
            @$query['RouterId'] = $request->routerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteBgpNetwork',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteBgpNetworkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an advertised Border Gateway Protocol (BGP) network.
     *
     * @param request - DeleteBgpNetworkRequest
     *
     * @returns DeleteBgpNetworkResponse
     *
     * @param DeleteBgpNetworkRequest $request
     *
     * @return DeleteBgpNetworkResponse
     */
    public function deleteBgpNetwork($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBgpNetworkWithOptions($request, $runtime);
    }

    /**
     * Deletes a Border Gateway Protocol (BGP) peer.
     *
     * @param request - DeleteBgpPeerRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteBgpPeerResponse
     *
     * @param DeleteBgpPeerRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return DeleteBgpPeerResponse
     */
    public function deleteBgpPeerWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bgpPeerId) {
            @$query['BgpPeerId'] = $request->bgpPeerId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteBgpPeer',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteBgpPeerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a Border Gateway Protocol (BGP) peer.
     *
     * @param request - DeleteBgpPeerRequest
     *
     * @returns DeleteBgpPeerResponse
     *
     * @param DeleteBgpPeerRequest $request
     *
     * @return DeleteBgpPeerResponse
     */
    public function deleteBgpPeer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBgpPeerWithOptions($request, $runtime);
    }

    /**
     * Deletes an Internet Shared Bandwidth instance.
     *
     * @remarks
     * You cannot repeatedly call the **DeleteCommonBandwidthPackage** operation to delete an Internet Shared Bandwidth instance within the specified period of time.
     *
     * @param request - DeleteCommonBandwidthPackageRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteCommonBandwidthPackageResponse
     *
     * @param DeleteCommonBandwidthPackageRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DeleteCommonBandwidthPackageResponse
     */
    public function deleteCommonBandwidthPackageWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bandwidthPackageId) {
            @$query['BandwidthPackageId'] = $request->bandwidthPackageId;
        }

        if (null !== $request->force) {
            @$query['Force'] = $request->force;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteCommonBandwidthPackage',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteCommonBandwidthPackageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an Internet Shared Bandwidth instance.
     *
     * @remarks
     * You cannot repeatedly call the **DeleteCommonBandwidthPackage** operation to delete an Internet Shared Bandwidth instance within the specified period of time.
     *
     * @param request - DeleteCommonBandwidthPackageRequest
     *
     * @returns DeleteCommonBandwidthPackageResponse
     *
     * @param DeleteCommonBandwidthPackageRequest $request
     *
     * @return DeleteCommonBandwidthPackageResponse
     */
    public function deleteCommonBandwidthPackage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCommonBandwidthPackageWithOptions($request, $runtime);
    }

    /**
     * Deletes a customer gateway.
     *
     * @remarks
     * Before you delete a customer gateway, make sure that no IPsec-VPN connection is associated with the customer gateway. For more information about how to delete an IPsec-VPN connection, see [DeleteVpnAttachment](https://help.aliyun.com/document_detail/2526938.html) or [DeleteVpnConnection](https://help.aliyun.com/document_detail/2526948.html).
     *
     * @param request - DeleteCustomerGatewayRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteCustomerGatewayResponse
     *
     * @param DeleteCustomerGatewayRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DeleteCustomerGatewayResponse
     */
    public function deleteCustomerGatewayWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->customerGatewayId) {
            @$query['CustomerGatewayId'] = $request->customerGatewayId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteCustomerGateway',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteCustomerGatewayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a customer gateway.
     *
     * @remarks
     * Before you delete a customer gateway, make sure that no IPsec-VPN connection is associated with the customer gateway. For more information about how to delete an IPsec-VPN connection, see [DeleteVpnAttachment](https://help.aliyun.com/document_detail/2526938.html) or [DeleteVpnConnection](https://help.aliyun.com/document_detail/2526948.html).
     *
     * @param request - DeleteCustomerGatewayRequest
     *
     * @returns DeleteCustomerGatewayResponse
     *
     * @param DeleteCustomerGatewayRequest $request
     *
     * @return DeleteCustomerGatewayResponse
     */
    public function deleteCustomerGateway($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCustomerGatewayWithOptions($request, $runtime);
    }

    /**
     * Deletes a DHCP options set.
     *
     * @remarks
     * ## [](#)Description
     * *   **DeleteDhcpOptionsSet** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetDhcpOptionsSet](https://help.aliyun.com/document_detail/189208.html) operation to query the status of the task.
     *     *   If the DHCP options set is in the **Deleting** state, the DHCP options set is being deleted.
     *     *   If you cannot query the DHCP options set, the DHCP options set is deleted.
     * *   You cannot repeatedly call the **DeleteDhcpOptionsSet** operation to delete a DHCP options set within the specified period of time.
     *
     * @param request - DeleteDhcpOptionsSetRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteDhcpOptionsSetResponse
     *
     * @param DeleteDhcpOptionsSetRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DeleteDhcpOptionsSetResponse
     */
    public function deleteDhcpOptionsSetWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dhcpOptionsSetId) {
            @$query['DhcpOptionsSetId'] = $request->dhcpOptionsSetId;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteDhcpOptionsSet',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteDhcpOptionsSetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a DHCP options set.
     *
     * @remarks
     * ## [](#)Description
     * *   **DeleteDhcpOptionsSet** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetDhcpOptionsSet](https://help.aliyun.com/document_detail/189208.html) operation to query the status of the task.
     *     *   If the DHCP options set is in the **Deleting** state, the DHCP options set is being deleted.
     *     *   If you cannot query the DHCP options set, the DHCP options set is deleted.
     * *   You cannot repeatedly call the **DeleteDhcpOptionsSet** operation to delete a DHCP options set within the specified period of time.
     *
     * @param request - DeleteDhcpOptionsSetRequest
     *
     * @returns DeleteDhcpOptionsSetResponse
     *
     * @param DeleteDhcpOptionsSetRequest $request
     *
     * @return DeleteDhcpOptionsSetResponse
     */
    public function deleteDhcpOptionsSet($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteDhcpOptionsSetWithOptions($request, $runtime);
    }

    /**
     * Deletes a Express Connect instance, including the initiator and acceptor.
     *
     * @param request - DeleteExpressConnectRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteExpressConnectResponse
     *
     * @param DeleteExpressConnectRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DeleteExpressConnectResponse
     */
    public function deleteExpressConnectWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->force) {
            @$query['Force'] = $request->force;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routerInterfaceId) {
            @$query['RouterInterfaceId'] = $request->routerInterfaceId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteExpressConnect',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteExpressConnectResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a Express Connect instance, including the initiator and acceptor.
     *
     * @param request - DeleteExpressConnectRequest
     *
     * @returns DeleteExpressConnectResponse
     *
     * @param DeleteExpressConnectRequest $request
     *
     * @return DeleteExpressConnectResponse
     */
    public function deleteExpressConnect($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteExpressConnectWithOptions($request, $runtime);
    }

    /**
     * Deletes a quality of service (QoS) policy.
     *
     * @param request - DeleteExpressConnectTrafficQosRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteExpressConnectTrafficQosResponse
     *
     * @param DeleteExpressConnectTrafficQosRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DeleteExpressConnectTrafficQosResponse
     */
    public function deleteExpressConnectTrafficQosWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->qosId) {
            @$query['QosId'] = $request->qosId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteExpressConnectTrafficQos',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteExpressConnectTrafficQosResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a quality of service (QoS) policy.
     *
     * @param request - DeleteExpressConnectTrafficQosRequest
     *
     * @returns DeleteExpressConnectTrafficQosResponse
     *
     * @param DeleteExpressConnectTrafficQosRequest $request
     *
     * @return DeleteExpressConnectTrafficQosResponse
     */
    public function deleteExpressConnectTrafficQos($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteExpressConnectTrafficQosWithOptions($request, $runtime);
    }

    /**
     * Deletes a quality of service (QoS) queue.
     *
     * @param request - DeleteExpressConnectTrafficQosQueueRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteExpressConnectTrafficQosQueueResponse
     *
     * @param DeleteExpressConnectTrafficQosQueueRequest $request
     * @param RuntimeOptions                             $runtime
     *
     * @return DeleteExpressConnectTrafficQosQueueResponse
     */
    public function deleteExpressConnectTrafficQosQueueWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->qosId) {
            @$query['QosId'] = $request->qosId;
        }

        if (null !== $request->queueId) {
            @$query['QueueId'] = $request->queueId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteExpressConnectTrafficQosQueue',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteExpressConnectTrafficQosQueueResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a quality of service (QoS) queue.
     *
     * @param request - DeleteExpressConnectTrafficQosQueueRequest
     *
     * @returns DeleteExpressConnectTrafficQosQueueResponse
     *
     * @param DeleteExpressConnectTrafficQosQueueRequest $request
     *
     * @return DeleteExpressConnectTrafficQosQueueResponse
     */
    public function deleteExpressConnectTrafficQosQueue($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteExpressConnectTrafficQosQueueWithOptions($request, $runtime);
    }

    /**
     * Deletes a quality of service (QoS) rule.
     *
     * @param request - DeleteExpressConnectTrafficQosRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteExpressConnectTrafficQosRuleResponse
     *
     * @param DeleteExpressConnectTrafficQosRuleRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return DeleteExpressConnectTrafficQosRuleResponse
     */
    public function deleteExpressConnectTrafficQosRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->qosId) {
            @$query['QosId'] = $request->qosId;
        }

        if (null !== $request->queueId) {
            @$query['QueueId'] = $request->queueId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->ruleId) {
            @$query['RuleId'] = $request->ruleId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteExpressConnectTrafficQosRule',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteExpressConnectTrafficQosRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a quality of service (QoS) rule.
     *
     * @param request - DeleteExpressConnectTrafficQosRuleRequest
     *
     * @returns DeleteExpressConnectTrafficQosRuleResponse
     *
     * @param DeleteExpressConnectTrafficQosRuleRequest $request
     *
     * @return DeleteExpressConnectTrafficQosRuleResponse
     */
    public function deleteExpressConnectTrafficQosRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteExpressConnectTrafficQosRuleWithOptions($request, $runtime);
    }

    /**
     * Deletes a failover test.
     *
     * @remarks
     * You can delete only failover tests that are in the **Pending** or **Complete** state.
     *
     * @param request - DeleteFailoverTestJobRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteFailoverTestJobResponse
     *
     * @param DeleteFailoverTestJobRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DeleteFailoverTestJobResponse
     */
    public function deleteFailoverTestJobWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->jobId) {
            @$query['JobId'] = $request->jobId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteFailoverTestJob',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteFailoverTestJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a failover test.
     *
     * @remarks
     * You can delete only failover tests that are in the **Pending** or **Complete** state.
     *
     * @param request - DeleteFailoverTestJobRequest
     *
     * @returns DeleteFailoverTestJobResponse
     *
     * @param DeleteFailoverTestJobRequest $request
     *
     * @return DeleteFailoverTestJobResponse
     */
    public function deleteFailoverTestJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteFailoverTestJobWithOptions($request, $runtime);
    }

    /**
     * Deletes a flow log.
     *
     * @remarks
     *   The **DeleteFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
     *     *   If the flow log is in the **Deleting** state, the flow log is being deleted.
     *     *   If you cannot query the flow log, the flow log is deleted.
     * *   You cannot repeatedly call the **DeleteFlowLog** operation to delete a flow log within the specified period of time.
     *
     * @param request - DeleteFlowLogRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteFlowLogResponse
     *
     * @param DeleteFlowLogRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return DeleteFlowLogResponse
     */
    public function deleteFlowLogWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->flowLogId) {
            @$query['FlowLogId'] = $request->flowLogId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteFlowLog',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteFlowLogResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a flow log.
     *
     * @remarks
     *   The **DeleteFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
     *     *   If the flow log is in the **Deleting** state, the flow log is being deleted.
     *     *   If you cannot query the flow log, the flow log is deleted.
     * *   You cannot repeatedly call the **DeleteFlowLog** operation to delete a flow log within the specified period of time.
     *
     * @param request - DeleteFlowLogRequest
     *
     * @returns DeleteFlowLogResponse
     *
     * @param DeleteFlowLogRequest $request
     *
     * @return DeleteFlowLogResponse
     */
    public function deleteFlowLog($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteFlowLogWithOptions($request, $runtime);
    }

    /**
     * Deletes a DNAT entry.
     *
     * @remarks
     * ## [](#)Description
     * *   **DeleteForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
     *     *   If the DNAT entry is in the **Deleting** state, the system is deleting the DNAT entry. In this case, you can only query the status of the DNAT entry, but cannot perform other operations.
     *     *   If the DNAT entry cannot be found, it is deleted.
     * >  If a DNAT table has DNAT entries in the **Pending** state, you cannot delete the DNAT entries.
     * *   You cannot repeatedly call the **DeleteForwardEntry** operation to delete a DNAT entry within the specified period of time.
     *
     * @param request - DeleteForwardEntryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteForwardEntryResponse
     *
     * @param DeleteForwardEntryRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return DeleteForwardEntryResponse
     */
    public function deleteForwardEntryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->forwardEntryId) {
            @$query['ForwardEntryId'] = $request->forwardEntryId;
        }

        if (null !== $request->forwardTableId) {
            @$query['ForwardTableId'] = $request->forwardTableId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteForwardEntry',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteForwardEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a DNAT entry.
     *
     * @remarks
     * ## [](#)Description
     * *   **DeleteForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
     *     *   If the DNAT entry is in the **Deleting** state, the system is deleting the DNAT entry. In this case, you can only query the status of the DNAT entry, but cannot perform other operations.
     *     *   If the DNAT entry cannot be found, it is deleted.
     * >  If a DNAT table has DNAT entries in the **Pending** state, you cannot delete the DNAT entries.
     * *   You cannot repeatedly call the **DeleteForwardEntry** operation to delete a DNAT entry within the specified period of time.
     *
     * @param request - DeleteForwardEntryRequest
     *
     * @returns DeleteForwardEntryResponse
     *
     * @param DeleteForwardEntryRequest $request
     *
     * @return DeleteForwardEntryResponse
     */
    public function deleteForwardEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteForwardEntryWithOptions($request, $runtime);
    }

    /**
     * Deletes a FULLNAT entry.
     *
     * @remarks
     * ## [](#)Description
     * **DeleteFullNatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
     * *   If the FULLNAT entry is in the **Deleting** state, the system is deleting the FULLNAT entry. In this case, you can query the status of the FULLNAT entry, but cannot perform other operations.
     * *   If the FULLNAT entry cannot be found, the FULLNAT entry is deleted.
     * You cannot repeatedly call the **DeleteFullNatEntry** operation to delete a FULLNAT entry within the specified period of time.
     *
     * @param request - DeleteFullNatEntryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteFullNatEntryResponse
     *
     * @param DeleteFullNatEntryRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return DeleteFullNatEntryResponse
     */
    public function deleteFullNatEntryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->fullNatEntryId) {
            @$query['FullNatEntryId'] = $request->fullNatEntryId;
        }

        if (null !== $request->fullNatTableId) {
            @$query['FullNatTableId'] = $request->fullNatTableId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteFullNatEntry',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteFullNatEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a FULLNAT entry.
     *
     * @remarks
     * ## [](#)Description
     * **DeleteFullNatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
     * *   If the FULLNAT entry is in the **Deleting** state, the system is deleting the FULLNAT entry. In this case, you can query the status of the FULLNAT entry, but cannot perform other operations.
     * *   If the FULLNAT entry cannot be found, the FULLNAT entry is deleted.
     * You cannot repeatedly call the **DeleteFullNatEntry** operation to delete a FULLNAT entry within the specified period of time.
     *
     * @param request - DeleteFullNatEntryRequest
     *
     * @returns DeleteFullNatEntryResponse
     *
     * @param DeleteFullNatEntryRequest $request
     *
     * @return DeleteFullNatEntryResponse
     */
    public function deleteFullNatEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteFullNatEntryWithOptions($request, $runtime);
    }

    /**
     * Deletes a Global Accelerator (GA) instance.
     *
     * @remarks
     * When you call this operation, take note of the following items:
     * *   You can delete only pay-as-you-go instances.
     * *   Before you can delete a dedicated instance, disassociate the backend server from the instance first.
     * *   Before you can delete a shared instance, disassociate the elastic IP address (EIP) from the instance first.
     *
     * @param request - DeleteGlobalAccelerationInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteGlobalAccelerationInstanceResponse
     *
     * @param DeleteGlobalAccelerationInstanceRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return DeleteGlobalAccelerationInstanceResponse
     */
    public function deleteGlobalAccelerationInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->globalAccelerationInstanceId) {
            @$query['GlobalAccelerationInstanceId'] = $request->globalAccelerationInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteGlobalAccelerationInstance',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteGlobalAccelerationInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a Global Accelerator (GA) instance.
     *
     * @remarks
     * When you call this operation, take note of the following items:
     * *   You can delete only pay-as-you-go instances.
     * *   Before you can delete a dedicated instance, disassociate the backend server from the instance first.
     * *   Before you can delete a shared instance, disassociate the elastic IP address (EIP) from the instance first.
     *
     * @param request - DeleteGlobalAccelerationInstanceRequest
     *
     * @returns DeleteGlobalAccelerationInstanceResponse
     *
     * @param DeleteGlobalAccelerationInstanceRequest $request
     *
     * @return DeleteGlobalAccelerationInstanceResponse
     */
    public function deleteGlobalAccelerationInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteGlobalAccelerationInstanceWithOptions($request, $runtime);
    }

    /**
     * Deletes a high-availability virtual IP address (HaVip).
     *
     * @remarks
     * When you call this operation, take note of the following rules:
     * *   The HaVip must be in the available state before it can be deleted.
     * *   Make sure that no routes are destined for the HaVip.
     * *   Make sure that no elastic IP addresses (EIPs) are associated with the HaVip.
     * *   **DeleteHaVip** is an asynchronous operation. After a request is sent, the system returns a request ID while deleting the HaVip in the background. Call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HaVip:
     *     *   The **Deleting** state indicates the HaVip is being deleted.
     *     *   If no HaVip is found, the HaVip is deleted.
     * *   You cannot repeatedly call the **DeleteHaVip** operation to delete the same HaVip.
     *
     * @param request - DeleteHaVipRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteHaVipResponse
     *
     * @param DeleteHaVipRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return DeleteHaVipResponse
     */
    public function deleteHaVipWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->haVipId) {
            @$query['HaVipId'] = $request->haVipId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteHaVip',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteHaVipResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a high-availability virtual IP address (HaVip).
     *
     * @remarks
     * When you call this operation, take note of the following rules:
     * *   The HaVip must be in the available state before it can be deleted.
     * *   Make sure that no routes are destined for the HaVip.
     * *   Make sure that no elastic IP addresses (EIPs) are associated with the HaVip.
     * *   **DeleteHaVip** is an asynchronous operation. After a request is sent, the system returns a request ID while deleting the HaVip in the background. Call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HaVip:
     *     *   The **Deleting** state indicates the HaVip is being deleted.
     *     *   If no HaVip is found, the HaVip is deleted.
     * *   You cannot repeatedly call the **DeleteHaVip** operation to delete the same HaVip.
     *
     * @param request - DeleteHaVipRequest
     *
     * @returns DeleteHaVipResponse
     *
     * @param DeleteHaVipRequest $request
     *
     * @return DeleteHaVipResponse
     */
    public function deleteHaVip($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteHaVipWithOptions($request, $runtime);
    }

    /**
     * Deletes an IPv6 Translation Service instance.
     *
     * @param request - DeleteIPv6TranslatorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteIPv6TranslatorResponse
     *
     * @param DeleteIPv6TranslatorRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DeleteIPv6TranslatorResponse
     */
    public function deleteIPv6TranslatorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ipv6TranslatorId) {
            @$query['Ipv6TranslatorId'] = $request->ipv6TranslatorId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteIPv6Translator',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteIPv6TranslatorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an IPv6 Translation Service instance.
     *
     * @param request - DeleteIPv6TranslatorRequest
     *
     * @returns DeleteIPv6TranslatorResponse
     *
     * @param DeleteIPv6TranslatorRequest $request
     *
     * @return DeleteIPv6TranslatorResponse
     */
    public function deleteIPv6Translator($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteIPv6TranslatorWithOptions($request, $runtime);
    }

    /**
     * Deletes an access control list (ACL). You can delete an ACL only when the ACL is not associated with IPv6 translation mappings.
     *
     * @deprecated OpenAPI DeleteIPv6TranslatorAclList is deprecated
     *
     * @param request - DeleteIPv6TranslatorAclListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteIPv6TranslatorAclListResponse
     *
     * @param DeleteIPv6TranslatorAclListRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DeleteIPv6TranslatorAclListResponse
     */
    public function deleteIPv6TranslatorAclListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aclId) {
            @$query['AclId'] = $request->aclId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteIPv6TranslatorAclList',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteIPv6TranslatorAclListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Deletes an access control list (ACL). You can delete an ACL only when the ACL is not associated with IPv6 translation mappings.
     *
     * @deprecated OpenAPI DeleteIPv6TranslatorAclList is deprecated
     *
     * @param request - DeleteIPv6TranslatorAclListRequest
     *
     * @returns DeleteIPv6TranslatorAclListResponse
     *
     * @param DeleteIPv6TranslatorAclListRequest $request
     *
     * @return DeleteIPv6TranslatorAclListResponse
     */
    public function deleteIPv6TranslatorAclList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteIPv6TranslatorAclListWithOptions($request, $runtime);
    }

    /**
     * Deletes an IPv6 mapping entry.
     *
     * @deprecated OpenAPI DeleteIPv6TranslatorEntry is deprecated
     *
     * @param request - DeleteIPv6TranslatorEntryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteIPv6TranslatorEntryResponse
     *
     * @param DeleteIPv6TranslatorEntryRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DeleteIPv6TranslatorEntryResponse
     */
    public function deleteIPv6TranslatorEntryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ipv6TranslatorEntryId) {
            @$query['Ipv6TranslatorEntryId'] = $request->ipv6TranslatorEntryId;
        }

        if (null !== $request->ipv6TranslatorId) {
            @$query['Ipv6TranslatorId'] = $request->ipv6TranslatorId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteIPv6TranslatorEntry',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteIPv6TranslatorEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Deletes an IPv6 mapping entry.
     *
     * @deprecated OpenAPI DeleteIPv6TranslatorEntry is deprecated
     *
     * @param request - DeleteIPv6TranslatorEntryRequest
     *
     * @returns DeleteIPv6TranslatorEntryResponse
     *
     * @param DeleteIPv6TranslatorEntryRequest $request
     *
     * @return DeleteIPv6TranslatorEntryResponse
     */
    public function deleteIPv6TranslatorEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteIPv6TranslatorEntryWithOptions($request, $runtime);
    }

    /**
     * Deletes an IPsec server.
     *
     * @remarks
     *   **DeleteIpsecServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the IPsec server is being deleted.
     *     *   If the VPN gateway is in the **active** state, the IPsec server is deleted.
     * *   You cannot call **DeleteIpsecServer** within the specified period of time.
     *
     * @param request - DeleteIpsecServerRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteIpsecServerResponse
     *
     * @param DeleteIpsecServerRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return DeleteIpsecServerResponse
     */
    public function deleteIpsecServerWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ipsecServerId) {
            @$query['IpsecServerId'] = $request->ipsecServerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteIpsecServer',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteIpsecServerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an IPsec server.
     *
     * @remarks
     *   **DeleteIpsecServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the IPsec server is being deleted.
     *     *   If the VPN gateway is in the **active** state, the IPsec server is deleted.
     * *   You cannot call **DeleteIpsecServer** within the specified period of time.
     *
     * @param request - DeleteIpsecServerRequest
     *
     * @returns DeleteIpsecServerResponse
     *
     * @param DeleteIpsecServerRequest $request
     *
     * @return DeleteIpsecServerResponse
     */
    public function deleteIpsecServer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteIpsecServerWithOptions($request, $runtime);
    }

    /**
     * Deletes an IPv4 gateway.
     *
     * @remarks
     * ### [](#)Description
     * *   Before you delete an IPv4 gateway, make sure that no route tables are associated with the IPv4 gateway.
     * *   **DeleteIpv4Gateway** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of the task.
     *     *   If the IPv4 gateway is in the **Deleting** state, the IPv4 gateway is being deleted.
     *     *   If the IPv4 gateway cannot be queried, the IPv4 gateway is deleted.
     * *   After you call the **DeleteIpv4Gateway** operation to delete an IPv4 gateway, you cannot call the operation again to delete the IPv4 gateway until the deletion task is complete.
     *
     * @param request - DeleteIpv4GatewayRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteIpv4GatewayResponse
     *
     * @param DeleteIpv4GatewayRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return DeleteIpv4GatewayResponse
     */
    public function deleteIpv4GatewayWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->internetMode) {
            @$query['InternetMode'] = $request->internetMode;
        }

        if (null !== $request->ipv4GatewayId) {
            @$query['Ipv4GatewayId'] = $request->ipv4GatewayId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteIpv4Gateway',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteIpv4GatewayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an IPv4 gateway.
     *
     * @remarks
     * ### [](#)Description
     * *   Before you delete an IPv4 gateway, make sure that no route tables are associated with the IPv4 gateway.
     * *   **DeleteIpv4Gateway** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of the task.
     *     *   If the IPv4 gateway is in the **Deleting** state, the IPv4 gateway is being deleted.
     *     *   If the IPv4 gateway cannot be queried, the IPv4 gateway is deleted.
     * *   After you call the **DeleteIpv4Gateway** operation to delete an IPv4 gateway, you cannot call the operation again to delete the IPv4 gateway until the deletion task is complete.
     *
     * @param request - DeleteIpv4GatewayRequest
     *
     * @returns DeleteIpv4GatewayResponse
     *
     * @param DeleteIpv4GatewayRequest $request
     *
     * @return DeleteIpv4GatewayResponse
     */
    public function deleteIpv4Gateway($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteIpv4GatewayWithOptions($request, $runtime);
    }

    /**
     * Deletes an egress-only rule.
     *
     * @remarks
     *   **DeleteIpv6EgressOnlyRule** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6EgressOnlyRules](https://help.aliyun.com/document_detail/102208.html) operation to query the status of the task.
     *     *   If the egress-only rule is in the **Deleting** state, the egress-only rule is being deleted.
     *     *   If you cannot query the egress-only rule, the egress-only rule is deleted.
     * *   You cannot call the **DeleteIpv6EgressOnlyRule** within the specified period of time.
     *
     * @param request - DeleteIpv6EgressOnlyRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteIpv6EgressOnlyRuleResponse
     *
     * @param DeleteIpv6EgressOnlyRuleRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DeleteIpv6EgressOnlyRuleResponse
     */
    public function deleteIpv6EgressOnlyRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ipv6EgressOnlyRuleId) {
            @$query['Ipv6EgressOnlyRuleId'] = $request->ipv6EgressOnlyRuleId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteIpv6EgressOnlyRule',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteIpv6EgressOnlyRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an egress-only rule.
     *
     * @remarks
     *   **DeleteIpv6EgressOnlyRule** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6EgressOnlyRules](https://help.aliyun.com/document_detail/102208.html) operation to query the status of the task.
     *     *   If the egress-only rule is in the **Deleting** state, the egress-only rule is being deleted.
     *     *   If you cannot query the egress-only rule, the egress-only rule is deleted.
     * *   You cannot call the **DeleteIpv6EgressOnlyRule** within the specified period of time.
     *
     * @param request - DeleteIpv6EgressOnlyRuleRequest
     *
     * @returns DeleteIpv6EgressOnlyRuleResponse
     *
     * @param DeleteIpv6EgressOnlyRuleRequest $request
     *
     * @return DeleteIpv6EgressOnlyRuleResponse
     */
    public function deleteIpv6EgressOnlyRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteIpv6EgressOnlyRuleWithOptions($request, $runtime);
    }

    /**
     * Deletes an IPv6 gateway.
     *
     * @remarks
     * Before you delete an IPv6 gateway, you must delete the egress-only rules of the IPv6 gateway. For more information, see [DeleteIpv6EgressOnlyRule](https://help.aliyun.com/document_detail/102201.html).
     * *   **DeleteIpv6Gateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6GatewayAttribute](https://help.aliyun.com/document_detail/102226.html) operation to query the status of the task:
     *     *   If the IPv6 gateway is in the **Deleting** state, the IPv6 gateway is being deleted.
     *     *   If you cannot query the IPv6 gateway, the IPv6 gateway is deleted.
     * *   You cannot repeatedly call the **DeleteIpv6Gateway** operation to delete an IPv6 gateway within the specified period of time.
     *
     * @param request - DeleteIpv6GatewayRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteIpv6GatewayResponse
     *
     * @param DeleteIpv6GatewayRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return DeleteIpv6GatewayResponse
     */
    public function deleteIpv6GatewayWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ipv6GatewayId) {
            @$query['Ipv6GatewayId'] = $request->ipv6GatewayId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteIpv6Gateway',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteIpv6GatewayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an IPv6 gateway.
     *
     * @remarks
     * Before you delete an IPv6 gateway, you must delete the egress-only rules of the IPv6 gateway. For more information, see [DeleteIpv6EgressOnlyRule](https://help.aliyun.com/document_detail/102201.html).
     * *   **DeleteIpv6Gateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6GatewayAttribute](https://help.aliyun.com/document_detail/102226.html) operation to query the status of the task:
     *     *   If the IPv6 gateway is in the **Deleting** state, the IPv6 gateway is being deleted.
     *     *   If you cannot query the IPv6 gateway, the IPv6 gateway is deleted.
     * *   You cannot repeatedly call the **DeleteIpv6Gateway** operation to delete an IPv6 gateway within the specified period of time.
     *
     * @param request - DeleteIpv6GatewayRequest
     *
     * @returns DeleteIpv6GatewayResponse
     *
     * @param DeleteIpv6GatewayRequest $request
     *
     * @return DeleteIpv6GatewayResponse
     */
    public function deleteIpv6Gateway($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteIpv6GatewayWithOptions($request, $runtime);
    }

    /**
     * Deletes Internet bandwidth.
     *
     * @remarks
     * You cannot call the **DeleteIpv6InternetBandwidth** operation within the specified period of time.
     *
     * @param request - DeleteIpv6InternetBandwidthRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteIpv6InternetBandwidthResponse
     *
     * @param DeleteIpv6InternetBandwidthRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DeleteIpv6InternetBandwidthResponse
     */
    public function deleteIpv6InternetBandwidthWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ipv6AddressId) {
            @$query['Ipv6AddressId'] = $request->ipv6AddressId;
        }

        if (null !== $request->ipv6InternetBandwidthId) {
            @$query['Ipv6InternetBandwidthId'] = $request->ipv6InternetBandwidthId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteIpv6InternetBandwidth',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteIpv6InternetBandwidthResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes Internet bandwidth.
     *
     * @remarks
     * You cannot call the **DeleteIpv6InternetBandwidth** operation within the specified period of time.
     *
     * @param request - DeleteIpv6InternetBandwidthRequest
     *
     * @returns DeleteIpv6InternetBandwidthResponse
     *
     * @param DeleteIpv6InternetBandwidthRequest $request
     *
     * @return DeleteIpv6InternetBandwidthResponse
     */
    public function deleteIpv6InternetBandwidth($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteIpv6InternetBandwidthWithOptions($request, $runtime);
    }

    /**
     * Deletes a specified Internet NAT gateway.
     *
     * @remarks
     * ## [](#)Description
     * *   **DeleteNatGateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNatGateways](https://help.aliyun.com/document_detail/36054.html) to query the status of the task.
     *     *   If a NAT gateway is in the **Deleting** state, the NAT gateway is being deleted. In this case, you can query the NAT gateway but you cannot perform other operations.
     *     *   If the NAT gateway cannot be found, the NAT gateway is deleted.
     *         After you delete a NAT gateway, you cannot restore the NAT gateway. Proceed with caution.
     * *   You cannot repeatedly call the **DeleteNatGateway** operation to delete a NAT gateway within the specified period of time.
     *
     * @param request - DeleteNatGatewayRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteNatGatewayResponse
     *
     * @param DeleteNatGatewayRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DeleteNatGatewayResponse
     */
    public function deleteNatGatewayWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->force) {
            @$query['Force'] = $request->force;
        }

        if (null !== $request->natGatewayId) {
            @$query['NatGatewayId'] = $request->natGatewayId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteNatGateway',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteNatGatewayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a specified Internet NAT gateway.
     *
     * @remarks
     * ## [](#)Description
     * *   **DeleteNatGateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNatGateways](https://help.aliyun.com/document_detail/36054.html) to query the status of the task.
     *     *   If a NAT gateway is in the **Deleting** state, the NAT gateway is being deleted. In this case, you can query the NAT gateway but you cannot perform other operations.
     *     *   If the NAT gateway cannot be found, the NAT gateway is deleted.
     *         After you delete a NAT gateway, you cannot restore the NAT gateway. Proceed with caution.
     * *   You cannot repeatedly call the **DeleteNatGateway** operation to delete a NAT gateway within the specified period of time.
     *
     * @param request - DeleteNatGatewayRequest
     *
     * @returns DeleteNatGatewayResponse
     *
     * @param DeleteNatGatewayRequest $request
     *
     * @return DeleteNatGatewayResponse
     */
    public function deleteNatGateway($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteNatGatewayWithOptions($request, $runtime);
    }

    /**
     * Deletes a NAT IP address.
     *
     * @remarks
     * ## [](#)Description
     * *   **DeleteNatIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListNatIps](https://help.aliyun.com/document_detail/281979.html) operation to query the status of the task.
     *     *   If the NAT IP address is in the **Deleting** state, the NAT IP address is being deleted. In this case, you can only query the NAT IP address but cannot perform other operations.
     *     *   If the NAT IP address cannot be found, it is deleted.
     * *   You cannot repeatedly call the **DeleteNatIp** operation to delete a NAT IP address within the specified period of time.
     *
     * @param request - DeleteNatIpRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteNatIpResponse
     *
     * @param DeleteNatIpRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return DeleteNatIpResponse
     */
    public function deleteNatIpWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ipv4Prefix) {
            @$query['Ipv4Prefix'] = $request->ipv4Prefix;
        }

        if (null !== $request->natGatewayId) {
            @$query['NatGatewayId'] = $request->natGatewayId;
        }

        if (null !== $request->natIpId) {
            @$query['NatIpId'] = $request->natIpId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteNatIp',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteNatIpResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a NAT IP address.
     *
     * @remarks
     * ## [](#)Description
     * *   **DeleteNatIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListNatIps](https://help.aliyun.com/document_detail/281979.html) operation to query the status of the task.
     *     *   If the NAT IP address is in the **Deleting** state, the NAT IP address is being deleted. In this case, you can only query the NAT IP address but cannot perform other operations.
     *     *   If the NAT IP address cannot be found, it is deleted.
     * *   You cannot repeatedly call the **DeleteNatIp** operation to delete a NAT IP address within the specified period of time.
     *
     * @param request - DeleteNatIpRequest
     *
     * @returns DeleteNatIpResponse
     *
     * @param DeleteNatIpRequest $request
     *
     * @return DeleteNatIpResponse
     */
    public function deleteNatIp($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteNatIpWithOptions($request, $runtime);
    }

    /**
     * Deletes a NAT CIDR block.
     *
     * @remarks
     * ## [](#)Description
     * You cannot repeatedly call the **DeleteNatIpCidr** operation to delete a NAT CIDR block within the specified period of time.
     *
     * @param request - DeleteNatIpCidrRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteNatIpCidrResponse
     *
     * @param DeleteNatIpCidrRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return DeleteNatIpCidrResponse
     */
    public function deleteNatIpCidrWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->natGatewayId) {
            @$query['NatGatewayId'] = $request->natGatewayId;
        }

        if (null !== $request->natIpCidr) {
            @$query['NatIpCidr'] = $request->natIpCidr;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteNatIpCidr',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteNatIpCidrResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a NAT CIDR block.
     *
     * @remarks
     * ## [](#)Description
     * You cannot repeatedly call the **DeleteNatIpCidr** operation to delete a NAT CIDR block within the specified period of time.
     *
     * @param request - DeleteNatIpCidrRequest
     *
     * @returns DeleteNatIpCidrResponse
     *
     * @param DeleteNatIpCidrRequest $request
     *
     * @return DeleteNatIpCidrResponse
     */
    public function deleteNatIpCidr($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteNatIpCidrWithOptions($request, $runtime);
    }

    /**
     * Deletes a network access control list (ACL).
     *
     * @remarks
     * ## [](#)Description
     * You cannot repeatedly call the **DeleteNetworkAcl** operation within the specified period of time.
     *
     * @param request - DeleteNetworkAclRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteNetworkAclResponse
     *
     * @param DeleteNetworkAclRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DeleteNetworkAclResponse
     */
    public function deleteNetworkAclWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->networkAclId) {
            @$query['NetworkAclId'] = $request->networkAclId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteNetworkAcl',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteNetworkAclResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a network access control list (ACL).
     *
     * @remarks
     * ## [](#)Description
     * You cannot repeatedly call the **DeleteNetworkAcl** operation within the specified period of time.
     *
     * @param request - DeleteNetworkAclRequest
     *
     * @returns DeleteNetworkAclResponse
     *
     * @param DeleteNetworkAclRequest $request
     *
     * @return DeleteNetworkAclResponse
     */
    public function deleteNetworkAcl($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteNetworkAclWithOptions($request, $runtime);
    }

    /**
     * Deletes a connection over an Express Connect circuit.
     *
     * @remarks
     * You can only delete a connection over an Express Connect circuit that is in the **Allocated**, **Confirmed**, **Rejected**, **Canceled**, **AllocationFailed**, and **Terminated** states.
     *
     * @param request - DeletePhysicalConnectionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeletePhysicalConnectionResponse
     *
     * @param DeletePhysicalConnectionRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DeletePhysicalConnectionResponse
     */
    public function deletePhysicalConnectionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->physicalConnectionId) {
            @$query['PhysicalConnectionId'] = $request->physicalConnectionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeletePhysicalConnection',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeletePhysicalConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a connection over an Express Connect circuit.
     *
     * @remarks
     * You can only delete a connection over an Express Connect circuit that is in the **Allocated**, **Confirmed**, **Rejected**, **Canceled**, **AllocationFailed**, and **Terminated** states.
     *
     * @param request - DeletePhysicalConnectionRequest
     *
     * @returns DeletePhysicalConnectionResponse
     *
     * @param DeletePhysicalConnectionRequest $request
     *
     * @return DeletePhysicalConnectionResponse
     */
    public function deletePhysicalConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deletePhysicalConnectionWithOptions($request, $runtime);
    }

    /**
     * Deletes an IP address pool.
     *
     * @remarks
     * Before you call this operation, take note of the following items:
     * *   Before you delete an IP address pool, make sure that no IP address in the pool is being used.
     * *   **DeletePublicIpAddressPool** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPools](https://help.aliyun.com/document_detail/429433.html) operation to query the status of the task.
     *     *   If the IP address pool is in the **Deleting** state, the IP address pool is being deleted. In this state. you can only query the IP address pool and cannot perform other operations.
     *     *   If you cannot query the IP address pool, the IP address pool is deleted.
     * *   You cannot repeatedly call the **DeletePublicIpAddressPool** operation to delete an IP address pool within the specified period of time.
     *
     * @param request - DeletePublicIpAddressPoolRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeletePublicIpAddressPoolResponse
     *
     * @param DeletePublicIpAddressPoolRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DeletePublicIpAddressPoolResponse
     */
    public function deletePublicIpAddressPoolWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->publicIpAddressPoolId) {
            @$query['PublicIpAddressPoolId'] = $request->publicIpAddressPoolId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeletePublicIpAddressPool',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeletePublicIpAddressPoolResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an IP address pool.
     *
     * @remarks
     * Before you call this operation, take note of the following items:
     * *   Before you delete an IP address pool, make sure that no IP address in the pool is being used.
     * *   **DeletePublicIpAddressPool** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPools](https://help.aliyun.com/document_detail/429433.html) operation to query the status of the task.
     *     *   If the IP address pool is in the **Deleting** state, the IP address pool is being deleted. In this state. you can only query the IP address pool and cannot perform other operations.
     *     *   If you cannot query the IP address pool, the IP address pool is deleted.
     * *   You cannot repeatedly call the **DeletePublicIpAddressPool** operation to delete an IP address pool within the specified period of time.
     *
     * @param request - DeletePublicIpAddressPoolRequest
     *
     * @returns DeletePublicIpAddressPoolResponse
     *
     * @param DeletePublicIpAddressPoolRequest $request
     *
     * @return DeletePublicIpAddressPoolResponse
     */
    public function deletePublicIpAddressPool($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deletePublicIpAddressPoolWithOptions($request, $runtime);
    }

    /**
     * Deletes a CIDR block from an IP address pool.
     *
     * @remarks
     * Before you call this operation, take note of the following items:
     * *   Before you delete a CIDR block, make sure that it is not being used.
     * *   **DeletePublicIpAddressPoolCidrBlock** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPoolCidrBlocks](https://help.aliyun.com/document_detail/429436.html) operation to query the status of the task.
     *     *   If the CIDR block is in the **Deleting** state, the CIDR block is being deleted. In this state, you can only query the CIDR block and cannot perform other operations.
     *     *   If you cannot query the CIDR block, the CIDR block is deleted.
     * *   You cannot repeatedly call the **DeletePublicIpAddressPoolCidrBlock** operation to delete a CIDR block within the specified period of time.
     *
     * @param request - DeletePublicIpAddressPoolCidrBlockRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeletePublicIpAddressPoolCidrBlockResponse
     *
     * @param DeletePublicIpAddressPoolCidrBlockRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return DeletePublicIpAddressPoolCidrBlockResponse
     */
    public function deletePublicIpAddressPoolCidrBlockWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->cidrBlock) {
            @$query['CidrBlock'] = $request->cidrBlock;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->publicIpAddressPoolId) {
            @$query['PublicIpAddressPoolId'] = $request->publicIpAddressPoolId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeletePublicIpAddressPoolCidrBlock',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeletePublicIpAddressPoolCidrBlockResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a CIDR block from an IP address pool.
     *
     * @remarks
     * Before you call this operation, take note of the following items:
     * *   Before you delete a CIDR block, make sure that it is not being used.
     * *   **DeletePublicIpAddressPoolCidrBlock** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPoolCidrBlocks](https://help.aliyun.com/document_detail/429436.html) operation to query the status of the task.
     *     *   If the CIDR block is in the **Deleting** state, the CIDR block is being deleted. In this state, you can only query the CIDR block and cannot perform other operations.
     *     *   If you cannot query the CIDR block, the CIDR block is deleted.
     * *   You cannot repeatedly call the **DeletePublicIpAddressPoolCidrBlock** operation to delete a CIDR block within the specified period of time.
     *
     * @param request - DeletePublicIpAddressPoolCidrBlockRequest
     *
     * @returns DeletePublicIpAddressPoolCidrBlockResponse
     *
     * @param DeletePublicIpAddressPoolCidrBlockRequest $request
     *
     * @return DeletePublicIpAddressPoolCidrBlockResponse
     */
    public function deletePublicIpAddressPoolCidrBlock($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deletePublicIpAddressPoolCidrBlockWithOptions($request, $runtime);
    }

    /**
     * Deletes multiple custom route entries at a time.
     *
     * @remarks
     * When you call this operation, take note of the following items:
     * *   You can delete only routes that are in the **Available** state.
     * *   You cannot delete a route of a virtual private cloud (VPC) in which a vSwitch or another route is being created or deleted.
     * *   **DeleteRouteEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
     *     *   If the route is in the **Deleting** state, the route is being deleted.
     *     *   If you cannot query the route, the route is deleted.
     * *   You cannot repeatedly call **DeleteRouteEntries** within a specific period of time.
     *
     * @param request - DeleteRouteEntriesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteRouteEntriesResponse
     *
     * @param DeleteRouteEntriesRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return DeleteRouteEntriesResponse
     */
    public function deleteRouteEntriesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeEntries) {
            @$query['RouteEntries'] = $request->routeEntries;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteRouteEntries',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteRouteEntriesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes multiple custom route entries at a time.
     *
     * @remarks
     * When you call this operation, take note of the following items:
     * *   You can delete only routes that are in the **Available** state.
     * *   You cannot delete a route of a virtual private cloud (VPC) in which a vSwitch or another route is being created or deleted.
     * *   **DeleteRouteEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
     *     *   If the route is in the **Deleting** state, the route is being deleted.
     *     *   If you cannot query the route, the route is deleted.
     * *   You cannot repeatedly call **DeleteRouteEntries** within a specific period of time.
     *
     * @param request - DeleteRouteEntriesRequest
     *
     * @returns DeleteRouteEntriesResponse
     *
     * @param DeleteRouteEntriesRequest $request
     *
     * @return DeleteRouteEntriesResponse
     */
    public function deleteRouteEntries($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteRouteEntriesWithOptions($request, $runtime);
    }

    /**
     * Deletes a route entry from a route table of a VRouter or virtual border router (VBR).
     *
     * @remarks
     * When you call this operation, take note of the following items:
     * *   You can delete only routes that are in the **Available** state.
     * *   You cannot delete a route entry of a virtual private cloud (VPC) in which a vSwitch or another route entry is being created or deleted.
     * *   Before you call this operation to delete a route of a VBR route table, call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the **NextHopId** of the route first.
     * *   **DeleteRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
     *     *   If the route is in the **Deleting** state, the route is being deleted.
     *     *   If you cannot query the route entry, the route entry is deleted.
     * *   You cannot repeatedly call the **DeleteRouteEntry** operation to delete a route from the route table of a vRouter or a VBR within the specified period of time.
     *
     * @param request - DeleteRouteEntryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteRouteEntryResponse
     *
     * @param DeleteRouteEntryRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DeleteRouteEntryResponse
     */
    public function deleteRouteEntryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->destinationCidrBlock) {
            @$query['DestinationCidrBlock'] = $request->destinationCidrBlock;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->nextHopId) {
            @$query['NextHopId'] = $request->nextHopId;
        }

        if (null !== $request->nextHopList) {
            @$query['NextHopList'] = $request->nextHopList;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeEntryId) {
            @$query['RouteEntryId'] = $request->routeEntryId;
        }

        if (null !== $request->routeTableId) {
            @$query['RouteTableId'] = $request->routeTableId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteRouteEntry',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteRouteEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a route entry from a route table of a VRouter or virtual border router (VBR).
     *
     * @remarks
     * When you call this operation, take note of the following items:
     * *   You can delete only routes that are in the **Available** state.
     * *   You cannot delete a route entry of a virtual private cloud (VPC) in which a vSwitch or another route entry is being created or deleted.
     * *   Before you call this operation to delete a route of a VBR route table, call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the **NextHopId** of the route first.
     * *   **DeleteRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
     *     *   If the route is in the **Deleting** state, the route is being deleted.
     *     *   If you cannot query the route entry, the route entry is deleted.
     * *   You cannot repeatedly call the **DeleteRouteEntry** operation to delete a route from the route table of a vRouter or a VBR within the specified period of time.
     *
     * @param request - DeleteRouteEntryRequest
     *
     * @returns DeleteRouteEntryResponse
     *
     * @param DeleteRouteEntryRequest $request
     *
     * @return DeleteRouteEntryResponse
     */
    public function deleteRouteEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteRouteEntryWithOptions($request, $runtime);
    }

    /**
     * Deletes a custom route table.
     *
     * @remarks
     * ## [](#)Description
     * *   **DeleteRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteTableList](https://help.aliyun.com/document_detail/87602.html) operation to query the status of the task.
     *     *   If the custom route table is in the **Deleting** state, the custom route table is being deleted.
     *     *   If you cannot query the custom route table, the custom route table is deleted.
     * *   You cannot repeatedly call the **DeleteRouteTable** operation to delete a custom route table within the specified period of time.
     *
     * @param request - DeleteRouteTableRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteRouteTableResponse
     *
     * @param DeleteRouteTableRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DeleteRouteTableResponse
     */
    public function deleteRouteTableWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeTableId) {
            @$query['RouteTableId'] = $request->routeTableId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteRouteTable',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteRouteTableResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a custom route table.
     *
     * @remarks
     * ## [](#)Description
     * *   **DeleteRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteTableList](https://help.aliyun.com/document_detail/87602.html) operation to query the status of the task.
     *     *   If the custom route table is in the **Deleting** state, the custom route table is being deleted.
     *     *   If you cannot query the custom route table, the custom route table is deleted.
     * *   You cannot repeatedly call the **DeleteRouteTable** operation to delete a custom route table within the specified period of time.
     *
     * @param request - DeleteRouteTableRequest
     *
     * @returns DeleteRouteTableResponse
     *
     * @param DeleteRouteTableRequest $request
     *
     * @return DeleteRouteTableResponse
     */
    public function deleteRouteTable($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteRouteTableWithOptions($request, $runtime);
    }

    /**
     * Deletes a router interface.
     *
     * @remarks
     * When you call this operation, take note of the following limits:
     * *   You can delete only a router interface that is in the **Idle** or **Inactive** state.
     * *   Before you delete a router interface, you must delete all custom route entries destined for the router interface.
     *
     * @param request - DeleteRouterInterfaceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteRouterInterfaceResponse
     *
     * @param DeleteRouterInterfaceRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DeleteRouterInterfaceResponse
     */
    public function deleteRouterInterfaceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routerInterfaceId) {
            @$query['RouterInterfaceId'] = $request->routerInterfaceId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteRouterInterface',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteRouterInterfaceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a router interface.
     *
     * @remarks
     * When you call this operation, take note of the following limits:
     * *   You can delete only a router interface that is in the **Idle** or **Inactive** state.
     * *   Before you delete a router interface, you must delete all custom route entries destined for the router interface.
     *
     * @param request - DeleteRouterInterfaceRequest
     *
     * @returns DeleteRouterInterfaceResponse
     *
     * @param DeleteRouterInterfaceRequest $request
     *
     * @return DeleteRouterInterfaceResponse
     */
    public function deleteRouterInterface($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteRouterInterfaceWithOptions($request, $runtime);
    }

    /**
     * Deletes an SNAT entry.
     *
     * @remarks
     * DeleteSnatEntry is an asynchronous operation. After you make a request, the ID of the request is returned but the specified SNAT entry is not deleted. The system deletes the SNAT entry in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of SNAT entries.
     * *   If the SNAT entries are in the **Deleting** state, the system is deleting the SNAT entries. In this case, you can only query the status of the SNAT entries, and cannot perform other operations.
     * *   If no SNAT entry is returned in the response, the SNAT entry is deleted.
     * If some SNAT entries are in the **Pending** state, you cannot delete these SNAT entries.
     *
     * @param request - DeleteSnatEntryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteSnatEntryResponse
     *
     * @param DeleteSnatEntryRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return DeleteSnatEntryResponse
     */
    public function deleteSnatEntryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->snatEntryId) {
            @$query['SnatEntryId'] = $request->snatEntryId;
        }

        if (null !== $request->snatTableId) {
            @$query['SnatTableId'] = $request->snatTableId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteSnatEntry',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteSnatEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an SNAT entry.
     *
     * @remarks
     * DeleteSnatEntry is an asynchronous operation. After you make a request, the ID of the request is returned but the specified SNAT entry is not deleted. The system deletes the SNAT entry in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of SNAT entries.
     * *   If the SNAT entries are in the **Deleting** state, the system is deleting the SNAT entries. In this case, you can only query the status of the SNAT entries, and cannot perform other operations.
     * *   If no SNAT entry is returned in the response, the SNAT entry is deleted.
     * If some SNAT entries are in the **Pending** state, you cannot delete these SNAT entries.
     *
     * @param request - DeleteSnatEntryRequest
     *
     * @returns DeleteSnatEntryResponse
     *
     * @param DeleteSnatEntryRequest $request
     *
     * @return DeleteSnatEntryResponse
     */
    public function deleteSnatEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteSnatEntryWithOptions($request, $runtime);
    }

    /**
     * Deletes an SSL client certificate.
     *
     * @remarks
     *   If you delete an SSL client certificate, all SSL-VPN client connections to the SSL server are disconnected. You need to reinitiate connections from SSL clients.
     *     For example, SSL client certificate 1 and SSL client certificate 2 are created on an SSL server. After you delete certificate 1, all client connections associated with certificate 1 and certificate 2 are disconnected from the SSL server.
     *     *   If clients associated with certificate 1 require SSL-VPN connections, you need to install other certificates on the clients and reinitiate connections from the clients.
     *     *   If clients associated with certificate 2 require SSL-VPN connections, you can directly reinitiate connections from the clients.
     * *   **DeleteSslVpnClientCert** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the SSL client certificate is being deleted.
     *     *   If the VPN gateway is in the **active** state, the SSL client certificate is deleted.
     * *   You cannot call **DeleteSslVpnClientCert** within the specified period of time.
     *
     * @param request - DeleteSslVpnClientCertRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteSslVpnClientCertResponse
     *
     * @param DeleteSslVpnClientCertRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DeleteSslVpnClientCertResponse
     */
    public function deleteSslVpnClientCertWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sslVpnClientCertId) {
            @$query['SslVpnClientCertId'] = $request->sslVpnClientCertId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteSslVpnClientCert',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteSslVpnClientCertResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an SSL client certificate.
     *
     * @remarks
     *   If you delete an SSL client certificate, all SSL-VPN client connections to the SSL server are disconnected. You need to reinitiate connections from SSL clients.
     *     For example, SSL client certificate 1 and SSL client certificate 2 are created on an SSL server. After you delete certificate 1, all client connections associated with certificate 1 and certificate 2 are disconnected from the SSL server.
     *     *   If clients associated with certificate 1 require SSL-VPN connections, you need to install other certificates on the clients and reinitiate connections from the clients.
     *     *   If clients associated with certificate 2 require SSL-VPN connections, you can directly reinitiate connections from the clients.
     * *   **DeleteSslVpnClientCert** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the SSL client certificate is being deleted.
     *     *   If the VPN gateway is in the **active** state, the SSL client certificate is deleted.
     * *   You cannot call **DeleteSslVpnClientCert** within the specified period of time.
     *
     * @param request - DeleteSslVpnClientCertRequest
     *
     * @returns DeleteSslVpnClientCertResponse
     *
     * @param DeleteSslVpnClientCertRequest $request
     *
     * @return DeleteSslVpnClientCertResponse
     */
    public function deleteSslVpnClientCert($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteSslVpnClientCertWithOptions($request, $runtime);
    }

    /**
     * Deletes an SSL server.
     *
     * @remarks
     *   **DeleteSslVpnServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the SSL server is being deleted.
     *     *   If the VPN gateway is in the **active** state, the SSL server is deleted.
     * *   You cannot repeatedly call the **DeleteSslVpnServer** operation to delete an SSL server from the same VPN gateway within the specified period of time.
     *
     * @param request - DeleteSslVpnServerRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteSslVpnServerResponse
     *
     * @param DeleteSslVpnServerRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return DeleteSslVpnServerResponse
     */
    public function deleteSslVpnServerWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sslVpnServerId) {
            @$query['SslVpnServerId'] = $request->sslVpnServerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteSslVpnServer',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteSslVpnServerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an SSL server.
     *
     * @remarks
     *   **DeleteSslVpnServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the SSL server is being deleted.
     *     *   If the VPN gateway is in the **active** state, the SSL server is deleted.
     * *   You cannot repeatedly call the **DeleteSslVpnServer** operation to delete an SSL server from the same VPN gateway within the specified period of time.
     *
     * @param request - DeleteSslVpnServerRequest
     *
     * @returns DeleteSslVpnServerResponse
     *
     * @param DeleteSslVpnServerRequest $request
     *
     * @return DeleteSslVpnServerResponse
     */
    public function deleteSslVpnServer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteSslVpnServerWithOptions($request, $runtime);
    }

    /**
     * Deletes a filter of traffic mirror.
     *
     * @remarks
     *   The **DeleteTrafficMirrorFilter** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of a filter:
     *     *   If the filter is in the **Deleting** state, the filter is being deleted.
     *     *   If you cannot query the filter, the filter is deleted.
     * *   You cannot repeatedly call the **DeleteTrafficMirrorFilter** operation to delete a filter within the specified period of time.
     *
     * @param request - DeleteTrafficMirrorFilterRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteTrafficMirrorFilterResponse
     *
     * @param DeleteTrafficMirrorFilterRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DeleteTrafficMirrorFilterResponse
     */
    public function deleteTrafficMirrorFilterWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->trafficMirrorFilterId) {
            @$query['TrafficMirrorFilterId'] = $request->trafficMirrorFilterId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteTrafficMirrorFilter',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteTrafficMirrorFilterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a filter of traffic mirror.
     *
     * @remarks
     *   The **DeleteTrafficMirrorFilter** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of a filter:
     *     *   If the filter is in the **Deleting** state, the filter is being deleted.
     *     *   If you cannot query the filter, the filter is deleted.
     * *   You cannot repeatedly call the **DeleteTrafficMirrorFilter** operation to delete a filter within the specified period of time.
     *
     * @param request - DeleteTrafficMirrorFilterRequest
     *
     * @returns DeleteTrafficMirrorFilterResponse
     *
     * @param DeleteTrafficMirrorFilterRequest $request
     *
     * @return DeleteTrafficMirrorFilterResponse
     */
    public function deleteTrafficMirrorFilter($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteTrafficMirrorFilterWithOptions($request, $runtime);
    }

    /**
     * Deletes an inbound or outbound rule of a filter for traffic mirror.
     *
     * @remarks
     *   **DeleteTrafficMirrorFilterRules** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) to query the status of the task.
     *     *   If the inbound or outbound rule is in the **Deleting** state, the rule is being deleted.
     *     *   If you cannot query the rule, the rule is deleted.
     * *   You cannot repeatedly call **DeleteTrafficMirrorFilterRules** within the specified period of time.
     *
     * @param request - DeleteTrafficMirrorFilterRulesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteTrafficMirrorFilterRulesResponse
     *
     * @param DeleteTrafficMirrorFilterRulesRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DeleteTrafficMirrorFilterRulesResponse
     */
    public function deleteTrafficMirrorFilterRulesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->trafficMirrorFilterId) {
            @$query['TrafficMirrorFilterId'] = $request->trafficMirrorFilterId;
        }

        if (null !== $request->trafficMirrorFilterRuleIds) {
            @$query['TrafficMirrorFilterRuleIds'] = $request->trafficMirrorFilterRuleIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteTrafficMirrorFilterRules',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteTrafficMirrorFilterRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an inbound or outbound rule of a filter for traffic mirror.
     *
     * @remarks
     *   **DeleteTrafficMirrorFilterRules** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) to query the status of the task.
     *     *   If the inbound or outbound rule is in the **Deleting** state, the rule is being deleted.
     *     *   If you cannot query the rule, the rule is deleted.
     * *   You cannot repeatedly call **DeleteTrafficMirrorFilterRules** within the specified period of time.
     *
     * @param request - DeleteTrafficMirrorFilterRulesRequest
     *
     * @returns DeleteTrafficMirrorFilterRulesResponse
     *
     * @param DeleteTrafficMirrorFilterRulesRequest $request
     *
     * @return DeleteTrafficMirrorFilterRulesResponse
     */
    public function deleteTrafficMirrorFilterRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteTrafficMirrorFilterRulesWithOptions($request, $runtime);
    }

    /**
     * Deletes a traffic mirror session.
     *
     * @remarks
     *   **DeleteTrafficMirrorSession** is an asynchronous operation. After you send the request, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of a traffic mirror session.
     *     *   If the traffic mirror session is in the **Deleting** state, the traffic mirror session is being deleted.
     *     *   If you cannot query the traffic mirror session, the traffic mirror session is deleted.
     * *   You cannot repeatedly call the **DeleteTrafficMirrorSession** operation to delete a traffic mirror session within the specified period of time.
     *
     * @param request - DeleteTrafficMirrorSessionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteTrafficMirrorSessionResponse
     *
     * @param DeleteTrafficMirrorSessionRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DeleteTrafficMirrorSessionResponse
     */
    public function deleteTrafficMirrorSessionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->trafficMirrorSessionId) {
            @$query['TrafficMirrorSessionId'] = $request->trafficMirrorSessionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteTrafficMirrorSession',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteTrafficMirrorSessionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a traffic mirror session.
     *
     * @remarks
     *   **DeleteTrafficMirrorSession** is an asynchronous operation. After you send the request, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of a traffic mirror session.
     *     *   If the traffic mirror session is in the **Deleting** state, the traffic mirror session is being deleted.
     *     *   If you cannot query the traffic mirror session, the traffic mirror session is deleted.
     * *   You cannot repeatedly call the **DeleteTrafficMirrorSession** operation to delete a traffic mirror session within the specified period of time.
     *
     * @param request - DeleteTrafficMirrorSessionRequest
     *
     * @returns DeleteTrafficMirrorSessionResponse
     *
     * @param DeleteTrafficMirrorSessionRequest $request
     *
     * @return DeleteTrafficMirrorSessionResponse
     */
    public function deleteTrafficMirrorSession($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteTrafficMirrorSessionWithOptions($request, $runtime);
    }

    /**
     * Deletes a vSwitch.
     *
     * @remarks
     * When you call this operation, take note of the following limits:
     * *   Before you delete a vSwitch, you must first release or remove all virtual private cloud (VPC) resources, including vSwitches, instances, router interfaces, and high-availability virtual IP addresses (HaVips).
     * *   You can delete only vSwitches that are in the **Available** state.
     * *   You cannot delete a vSwitch from a VPC where a vSwitch or a route is being created or deleted.
     * *   **DeleteVSwitch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
     *     *   If the vSwitch is in the **Pending** state, the vSwitch is being deleted.
     *     *   If you cannot query the vSwitch, the vSwitch is deleted.
     * *   You cannot repeatedly call the **DeleteVSwitch** operation to delete a vSwitch within the specified period of time.
     *
     * @param request - DeleteVSwitchRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteVSwitchResponse
     *
     * @param DeleteVSwitchRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return DeleteVSwitchResponse
     */
    public function deleteVSwitchWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteVSwitch',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteVSwitchResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a vSwitch.
     *
     * @remarks
     * When you call this operation, take note of the following limits:
     * *   Before you delete a vSwitch, you must first release or remove all virtual private cloud (VPC) resources, including vSwitches, instances, router interfaces, and high-availability virtual IP addresses (HaVips).
     * *   You can delete only vSwitches that are in the **Available** state.
     * *   You cannot delete a vSwitch from a VPC where a vSwitch or a route is being created or deleted.
     * *   **DeleteVSwitch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
     *     *   If the vSwitch is in the **Pending** state, the vSwitch is being deleted.
     *     *   If you cannot query the vSwitch, the vSwitch is deleted.
     * *   You cannot repeatedly call the **DeleteVSwitch** operation to delete a vSwitch within the specified period of time.
     *
     * @param request - DeleteVSwitchRequest
     *
     * @returns DeleteVSwitchResponse
     *
     * @param DeleteVSwitchRequest $request
     *
     * @return DeleteVSwitchResponse
     */
    public function deleteVSwitch($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVSwitchWithOptions($request, $runtime);
    }

    /**
     * Deletes a reserved CIDR block of a vSwitch.
     *
     * @remarks
     * ## [](#)Description
     * *   Before you call this operation, make sure that the IP address allocated to an elastic network interface (ENI) from the reserved CIDR block is deleted. If the IP address of the ENI is not deleted, call [UnassignPrivateIpAddresses](https://help.aliyun.com/document_detail/85919.html) or [UnassignIpv6Addresses](https://help.aliyun.com/document_detail/98611.html) to delete the IPv4 or IPv6 address.
     * *   **DeleteVSwitchCidrReservation** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListVSwitchCidrReservations](https://help.aliyun.com/document_detail/610155.html) to query the status of the task:
     *     *   If the reserved CIDR block is in the **Releasing** state, it is being released.
     *     *   If the reserved CIDR block is in the **Released** state, it is released.
     *
     * @param request - DeleteVSwitchCidrReservationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteVSwitchCidrReservationResponse
     *
     * @param DeleteVSwitchCidrReservationRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DeleteVSwitchCidrReservationResponse
     */
    public function deleteVSwitchCidrReservationWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vSwitchCidrReservationId) {
            @$query['VSwitchCidrReservationId'] = $request->vSwitchCidrReservationId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteVSwitchCidrReservation',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteVSwitchCidrReservationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a reserved CIDR block of a vSwitch.
     *
     * @remarks
     * ## [](#)Description
     * *   Before you call this operation, make sure that the IP address allocated to an elastic network interface (ENI) from the reserved CIDR block is deleted. If the IP address of the ENI is not deleted, call [UnassignPrivateIpAddresses](https://help.aliyun.com/document_detail/85919.html) or [UnassignIpv6Addresses](https://help.aliyun.com/document_detail/98611.html) to delete the IPv4 or IPv6 address.
     * *   **DeleteVSwitchCidrReservation** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListVSwitchCidrReservations](https://help.aliyun.com/document_detail/610155.html) to query the status of the task:
     *     *   If the reserved CIDR block is in the **Releasing** state, it is being released.
     *     *   If the reserved CIDR block is in the **Released** state, it is released.
     *
     * @param request - DeleteVSwitchCidrReservationRequest
     *
     * @returns DeleteVSwitchCidrReservationResponse
     *
     * @param DeleteVSwitchCidrReservationRequest $request
     *
     * @return DeleteVSwitchCidrReservationResponse
     */
    public function deleteVSwitchCidrReservation($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVSwitchCidrReservationWithOptions($request, $runtime);
    }

    /**
     * Deletes a virtual border router (VBR) failover group.
     *
     * @param request - DeleteVbrHaRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteVbrHaResponse
     *
     * @param DeleteVbrHaRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return DeleteVbrHaResponse
     */
    public function deleteVbrHaWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteVbrHa',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteVbrHaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a virtual border router (VBR) failover group.
     *
     * @param request - DeleteVbrHaRequest
     *
     * @returns DeleteVbrHaResponse
     *
     * @param DeleteVbrHaRequest $request
     *
     * @return DeleteVbrHaResponse
     */
    public function deleteVbrHa($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVbrHaWithOptions($request, $runtime);
    }

    /**
     * Deletes a destination-based route from an IPsec-VPN connection.
     *
     * @remarks
     *   **DeleteVcoRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the task.
     *     *   If the IPsec-VPN connection is in the **updating** state, the route is being deleted.
     *     *   If the IPsec-VPN connection is in the **attached** state, the route is deleted.
     * *   You cannot repeatedly call the **DeleteVcoRouteEntry** operation within a specific time period.
     *
     * @param request - DeleteVcoRouteEntryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteVcoRouteEntryResponse
     *
     * @param DeleteVcoRouteEntryRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DeleteVcoRouteEntryResponse
     */
    public function deleteVcoRouteEntryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->nextHop) {
            @$query['NextHop'] = $request->nextHop;
        }

        if (null !== $request->overlayMode) {
            @$query['OverlayMode'] = $request->overlayMode;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeDest) {
            @$query['RouteDest'] = $request->routeDest;
        }

        if (null !== $request->vpnConnectionId) {
            @$query['VpnConnectionId'] = $request->vpnConnectionId;
        }

        if (null !== $request->weight) {
            @$query['Weight'] = $request->weight;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteVcoRouteEntry',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteVcoRouteEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a destination-based route from an IPsec-VPN connection.
     *
     * @remarks
     *   **DeleteVcoRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the task.
     *     *   If the IPsec-VPN connection is in the **updating** state, the route is being deleted.
     *     *   If the IPsec-VPN connection is in the **attached** state, the route is deleted.
     * *   You cannot repeatedly call the **DeleteVcoRouteEntry** operation within a specific time period.
     *
     * @param request - DeleteVcoRouteEntryRequest
     *
     * @returns DeleteVcoRouteEntryResponse
     *
     * @param DeleteVcoRouteEntryRequest $request
     *
     * @return DeleteVcoRouteEntryResponse
     */
    public function deleteVcoRouteEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVcoRouteEntryWithOptions($request, $runtime);
    }

    /**
     * Deletes a virtual border router (VBR).
     *
     * @remarks
     * Before you call this operation, take note of the following limits:
     * *   Before you delete a VBR, you must delete all router interfaces of the VBR.
     * *   You can delete only a VBR in the **unconfirmed**, **active**, or **terminated** state.
     * *   The owner of an Express Connect circuit can delete a VBR that belongs to another account only if the VBR is in the **unconfirmed** state.
     *
     * @param request - DeleteVirtualBorderRouterRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteVirtualBorderRouterResponse
     *
     * @param DeleteVirtualBorderRouterRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DeleteVirtualBorderRouterResponse
     */
    public function deleteVirtualBorderRouterWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vbrId) {
            @$query['VbrId'] = $request->vbrId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteVirtualBorderRouter',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteVirtualBorderRouterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a virtual border router (VBR).
     *
     * @remarks
     * Before you call this operation, take note of the following limits:
     * *   Before you delete a VBR, you must delete all router interfaces of the VBR.
     * *   You can delete only a VBR in the **unconfirmed**, **active**, or **terminated** state.
     * *   The owner of an Express Connect circuit can delete a VBR that belongs to another account only if the VBR is in the **unconfirmed** state.
     *
     * @param request - DeleteVirtualBorderRouterRequest
     *
     * @returns DeleteVirtualBorderRouterResponse
     *
     * @param DeleteVirtualBorderRouterRequest $request
     *
     * @return DeleteVirtualBorderRouterResponse
     */
    public function deleteVirtualBorderRouter($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVirtualBorderRouterWithOptions($request, $runtime);
    }

    /**
     * Deletes a virtual private cloud (VPC).
     *
     * @remarks
     * When you call this operation, take note of the following limits:
     * *   Before you delete a VPC, make sure that all resources deployed in the VPC are released or removed, such as vSwitches, instances, and high-availability virtual IP addresses (HaVips).
     * *   You can delete only a VPC that is in the **Available** state.
     * *   The **DeleteVpc** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a VPC:
     *     *   If the VPC is in the **Deleting** state, the VPC is being deleted.
     *     *   If you cannot query the VPC, the VPC is deleted.
     * *   You cannot repeatedly call the **DeleteVpc** operation to delete a VPC within the specified period of time.
     *
     * @param request - DeleteVpcRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteVpcResponse
     *
     * @param DeleteVpcRequest $request
     * @param RuntimeOptions   $runtime
     *
     * @return DeleteVpcResponse
     */
    public function deleteVpcWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->forceDelete) {
            @$query['ForceDelete'] = $request->forceDelete;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteVpc',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteVpcResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a virtual private cloud (VPC).
     *
     * @remarks
     * When you call this operation, take note of the following limits:
     * *   Before you delete a VPC, make sure that all resources deployed in the VPC are released or removed, such as vSwitches, instances, and high-availability virtual IP addresses (HaVips).
     * *   You can delete only a VPC that is in the **Available** state.
     * *   The **DeleteVpc** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a VPC:
     *     *   If the VPC is in the **Deleting** state, the VPC is being deleted.
     *     *   If you cannot query the VPC, the VPC is deleted.
     * *   You cannot repeatedly call the **DeleteVpc** operation to delete a VPC within the specified period of time.
     *
     * @param request - DeleteVpcRequest
     *
     * @returns DeleteVpcResponse
     *
     * @param DeleteVpcRequest $request
     *
     * @return DeleteVpcResponse
     */
    public function deleteVpc($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVpcWithOptions($request, $runtime);
    }

    /**
     * Deletes a gateway endpoint.
     *
     * @param request - DeleteVpcGatewayEndpointRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteVpcGatewayEndpointResponse
     *
     * @param DeleteVpcGatewayEndpointRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DeleteVpcGatewayEndpointResponse
     */
    public function deleteVpcGatewayEndpointWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->endpointId) {
            @$query['EndpointId'] = $request->endpointId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteVpcGatewayEndpoint',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteVpcGatewayEndpointResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a gateway endpoint.
     *
     * @param request - DeleteVpcGatewayEndpointRequest
     *
     * @returns DeleteVpcGatewayEndpointResponse
     *
     * @param DeleteVpcGatewayEndpointRequest $request
     *
     * @return DeleteVpcGatewayEndpointResponse
     */
    public function deleteVpcGatewayEndpoint($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVpcGatewayEndpointWithOptions($request, $runtime);
    }

    /**
     * Deletes a prefix list.
     *
     * @remarks
     * You cannot repeatedly call the **DeleteDhcpOptionsSet** operation to delete a prefix list within the specified period of time.
     *
     * @param request - DeleteVpcPrefixListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteVpcPrefixListResponse
     *
     * @param DeleteVpcPrefixListRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DeleteVpcPrefixListResponse
     */
    public function deleteVpcPrefixListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->prefixListId) {
            @$query['PrefixListId'] = $request->prefixListId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteVpcPrefixList',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteVpcPrefixListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a prefix list.
     *
     * @remarks
     * You cannot repeatedly call the **DeleteDhcpOptionsSet** operation to delete a prefix list within the specified period of time.
     *
     * @param request - DeleteVpcPrefixListRequest
     *
     * @returns DeleteVpcPrefixListResponse
     *
     * @param DeleteVpcPrefixListRequest $request
     *
     * @return DeleteVpcPrefixListResponse
     */
    public function deleteVpcPrefixList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVpcPrefixListWithOptions($request, $runtime);
    }

    /**
     * Deletes an IPsec-VPN connection.
     *
     * @remarks
     *   If an IPsec-VPN connection is associated with a transit router, you must disassociate the transit router from the IPsec-VPN connection before you delete the IPsec-VPN connection. For more information, see [DeleteTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/468251.html).
     * *   If an IPsec-VPN connection is not associated with a resource, you can call `DeleteVpnAttachment` to directly delete the IPsec-VPN connection.
     *
     * @param request - DeleteVpnAttachmentRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteVpnAttachmentResponse
     *
     * @param DeleteVpnAttachmentRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DeleteVpnAttachmentResponse
     */
    public function deleteVpnAttachmentWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vpnConnectionId) {
            @$query['VpnConnectionId'] = $request->vpnConnectionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteVpnAttachment',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteVpnAttachmentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an IPsec-VPN connection.
     *
     * @remarks
     *   If an IPsec-VPN connection is associated with a transit router, you must disassociate the transit router from the IPsec-VPN connection before you delete the IPsec-VPN connection. For more information, see [DeleteTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/468251.html).
     * *   If an IPsec-VPN connection is not associated with a resource, you can call `DeleteVpnAttachment` to directly delete the IPsec-VPN connection.
     *
     * @param request - DeleteVpnAttachmentRequest
     *
     * @returns DeleteVpnAttachmentResponse
     *
     * @param DeleteVpnAttachmentRequest $request
     *
     * @return DeleteVpnAttachmentResponse
     */
    public function deleteVpnAttachment($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVpnAttachmentWithOptions($request, $runtime);
    }

    /**
     * Deletes an IPsec-VPN connection.
     *
     * @remarks
     *   **DeleteVpnConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of a VPN gateway.
     *     *   If a VPN gateway is in the **updating** state, the IPsec-VPN connection is being deleted.
     *     *   If a VPN gateway is in the **active** state, the IPsec-VPN connection has been deleted.
     * *   You cannot call the **DeleteVpnConnection** operation to delete multiple IPsec-VPN connections for a VPN gateway at a time.
     * >  After an IPsec-VPN connection between a data center and Alibaba Cloud is deleted, the connection between the data center and Alibaba Cloud is closed.
     *
     * @param request - DeleteVpnConnectionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteVpnConnectionResponse
     *
     * @param DeleteVpnConnectionRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DeleteVpnConnectionResponse
     */
    public function deleteVpnConnectionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vpnConnectionId) {
            @$query['VpnConnectionId'] = $request->vpnConnectionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteVpnConnection',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteVpnConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an IPsec-VPN connection.
     *
     * @remarks
     *   **DeleteVpnConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of a VPN gateway.
     *     *   If a VPN gateway is in the **updating** state, the IPsec-VPN connection is being deleted.
     *     *   If a VPN gateway is in the **active** state, the IPsec-VPN connection has been deleted.
     * *   You cannot call the **DeleteVpnConnection** operation to delete multiple IPsec-VPN connections for a VPN gateway at a time.
     * >  After an IPsec-VPN connection between a data center and Alibaba Cloud is deleted, the connection between the data center and Alibaba Cloud is closed.
     *
     * @param request - DeleteVpnConnectionRequest
     *
     * @returns DeleteVpnConnectionResponse
     *
     * @param DeleteVpnConnectionRequest $request
     *
     * @return DeleteVpnConnectionResponse
     */
    public function deleteVpnConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVpnConnectionWithOptions($request, $runtime);
    }

    /**
     * Deletes a VPN gateway.
     *
     * @remarks
     * >  You cannot delete a VPN gateway associated with existing IPsec-VPN connections.
     *
     * @param request - DeleteVpnGatewayRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteVpnGatewayResponse
     *
     * @param DeleteVpnGatewayRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DeleteVpnGatewayResponse
     */
    public function deleteVpnGatewayWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vpnGatewayId) {
            @$query['VpnGatewayId'] = $request->vpnGatewayId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteVpnGateway',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteVpnGatewayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a VPN gateway.
     *
     * @remarks
     * >  You cannot delete a VPN gateway associated with existing IPsec-VPN connections.
     *
     * @param request - DeleteVpnGatewayRequest
     *
     * @returns DeleteVpnGatewayResponse
     *
     * @param DeleteVpnGatewayRequest $request
     *
     * @return DeleteVpnGatewayResponse
     */
    public function deleteVpnGateway($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVpnGatewayWithOptions($request, $runtime);
    }

    /**
     * Deletes a policy-based route from a VPN gateway.
     *
     * @remarks
     *   **DeleteVpnPbrRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If a VPN gateway is in the **updating** state, the policy-based route is being deleted.
     *     *   If a VPN gateway is in the **active** state, the policy-based route has been deleted.
     * *   You cannot repeatedly call **DeleteVpnPbrRouteEntry** to delete a policy-based route within the specified period of time.
     *
     * @param request - DeleteVpnPbrRouteEntryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteVpnPbrRouteEntryResponse
     *
     * @param DeleteVpnPbrRouteEntryRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DeleteVpnPbrRouteEntryResponse
     */
    public function deleteVpnPbrRouteEntryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->nextHop) {
            @$query['NextHop'] = $request->nextHop;
        }

        if (null !== $request->overlayMode) {
            @$query['OverlayMode'] = $request->overlayMode;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->priority) {
            @$query['Priority'] = $request->priority;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeDest) {
            @$query['RouteDest'] = $request->routeDest;
        }

        if (null !== $request->routeSource) {
            @$query['RouteSource'] = $request->routeSource;
        }

        if (null !== $request->vpnGatewayId) {
            @$query['VpnGatewayId'] = $request->vpnGatewayId;
        }

        if (null !== $request->weight) {
            @$query['Weight'] = $request->weight;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteVpnPbrRouteEntry',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteVpnPbrRouteEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a policy-based route from a VPN gateway.
     *
     * @remarks
     *   **DeleteVpnPbrRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If a VPN gateway is in the **updating** state, the policy-based route is being deleted.
     *     *   If a VPN gateway is in the **active** state, the policy-based route has been deleted.
     * *   You cannot repeatedly call **DeleteVpnPbrRouteEntry** to delete a policy-based route within the specified period of time.
     *
     * @param request - DeleteVpnPbrRouteEntryRequest
     *
     * @returns DeleteVpnPbrRouteEntryResponse
     *
     * @param DeleteVpnPbrRouteEntryRequest $request
     *
     * @return DeleteVpnPbrRouteEntryResponse
     */
    public function deleteVpnPbrRouteEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVpnPbrRouteEntryWithOptions($request, $runtime);
    }

    /**
     * Deletes a destination-based route from a VPN gateway.
     *
     * @remarks
     *   **DeleteVpnRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If a VPN gateway is in the **updating** state, the destination-based route is being deleted.
     *     *   If the VPN gateway is in the **active** state, the destination-based route is deleted.
     * *   You cannot repeatedly call **DeleteVpnRouteEntry** to delete a destination-based route from a VPN gateway within the specified period of time.
     *
     * @param request - DeleteVpnRouteEntryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteVpnRouteEntryResponse
     *
     * @param DeleteVpnRouteEntryRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DeleteVpnRouteEntryResponse
     */
    public function deleteVpnRouteEntryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->nextHop) {
            @$query['NextHop'] = $request->nextHop;
        }

        if (null !== $request->overlayMode) {
            @$query['OverlayMode'] = $request->overlayMode;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeDest) {
            @$query['RouteDest'] = $request->routeDest;
        }

        if (null !== $request->vpnGatewayId) {
            @$query['VpnGatewayId'] = $request->vpnGatewayId;
        }

        if (null !== $request->weight) {
            @$query['Weight'] = $request->weight;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteVpnRouteEntry',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteVpnRouteEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a destination-based route from a VPN gateway.
     *
     * @remarks
     *   **DeleteVpnRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If a VPN gateway is in the **updating** state, the destination-based route is being deleted.
     *     *   If the VPN gateway is in the **active** state, the destination-based route is deleted.
     * *   You cannot repeatedly call **DeleteVpnRouteEntry** to delete a destination-based route from a VPN gateway within the specified period of time.
     *
     * @param request - DeleteVpnRouteEntryRequest
     *
     * @returns DeleteVpnRouteEntryResponse
     *
     * @param DeleteVpnRouteEntryRequest $request
     *
     * @return DeleteVpnRouteEntryResponse
     */
    public function deleteVpnRouteEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVpnRouteEntryWithOptions($request, $runtime);
    }

    /**
     * 
     *
     * @remarks
     * After you enable deletion protection for an instance, you cannot delete the instance. You must disable deletion protection before you can delete the instance.
     *
     * @param request - DeletionProtectionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeletionProtectionResponse
     *
     * @param DeletionProtectionRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return DeletionProtectionResponse
     */
    public function deletionProtectionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->protectionEnable) {
            @$query['ProtectionEnable'] = $request->protectionEnable;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeletionProtection',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeletionProtectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 
     *
     * @remarks
     * After you enable deletion protection for an instance, you cannot delete the instance. You must disable deletion protection before you can delete the instance.
     *
     * @param request - DeletionProtectionRequest
     *
     * @returns DeletionProtectionResponse
     *
     * @param DeletionProtectionRequest $request
     *
     * @return DeletionProtectionResponse
     */
    public function deletionProtection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deletionProtectionWithOptions($request, $runtime);
    }

    /**
     * Queries traffic data of a pay-by-enhanced-95th-percentile Internet Shared Bandwidth instance.
     *
     * @param request - Describe95TrafficRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns Describe95TrafficResponse
     *
     * @param Describe95TrafficRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return Describe95TrafficResponse
     */
    public function describe95TrafficWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->day) {
            @$query['Day'] = $request->day;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'Describe95Traffic',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return Describe95TrafficResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries traffic data of a pay-by-enhanced-95th-percentile Internet Shared Bandwidth instance.
     *
     * @param request - Describe95TrafficRequest
     *
     * @returns Describe95TrafficResponse
     *
     * @param Describe95TrafficRequest $request
     *
     * @return Describe95TrafficResponse
     */
    public function describe95Traffic($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describe95TrafficWithOptions($request, $runtime);
    }

    /**
     * Queries the access points of Express Connect circuits in a region.
     *
     * @param request - DescribeAccessPointsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAccessPointsResponse
     *
     * @param DescribeAccessPointsRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DescribeAccessPointsResponse
     */
    public function describeAccessPointsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceptLanguage) {
            @$query['AcceptLanguage'] = $request->acceptLanguage;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeAccessPoints',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAccessPointsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the access points of Express Connect circuits in a region.
     *
     * @param request - DescribeAccessPointsRequest
     *
     * @returns DescribeAccessPointsResponse
     *
     * @param DescribeAccessPointsRequest $request
     *
     * @return DescribeAccessPointsResponse
     */
    public function describeAccessPoints($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAccessPointsWithOptions($request, $runtime);
    }

    /**
     * Queries Border Gateway Protocol (BGP) groups in a region.
     *
     * @param request - DescribeBgpGroupsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeBgpGroupsResponse
     *
     * @param DescribeBgpGroupsRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return DescribeBgpGroupsResponse
     */
    public function describeBgpGroupsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bgpGroupId) {
            @$query['BgpGroupId'] = $request->bgpGroupId;
        }

        if (null !== $request->isDefault) {
            @$query['IsDefault'] = $request->isDefault;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routerId) {
            @$query['RouterId'] = $request->routerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeBgpGroups',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeBgpGroupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries Border Gateway Protocol (BGP) groups in a region.
     *
     * @param request - DescribeBgpGroupsRequest
     *
     * @returns DescribeBgpGroupsResponse
     *
     * @param DescribeBgpGroupsRequest $request
     *
     * @return DescribeBgpGroupsResponse
     */
    public function describeBgpGroups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBgpGroupsWithOptions($request, $runtime);
    }

    /**
     * Queries advertised Border Gateway Protocol (BGP) networks.
     *
     * @param request - DescribeBgpNetworksRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeBgpNetworksResponse
     *
     * @param DescribeBgpNetworksRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DescribeBgpNetworksResponse
     */
    public function describeBgpNetworksWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routerId) {
            @$query['RouterId'] = $request->routerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeBgpNetworks',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeBgpNetworksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries advertised Border Gateway Protocol (BGP) networks.
     *
     * @param request - DescribeBgpNetworksRequest
     *
     * @returns DescribeBgpNetworksResponse
     *
     * @param DescribeBgpNetworksRequest $request
     *
     * @return DescribeBgpNetworksResponse
     */
    public function describeBgpNetworks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBgpNetworksWithOptions($request, $runtime);
    }

    /**
     * Queries Border Gateway Protocol (BGP) peers in a region.
     *
     * @param request - DescribeBgpPeersRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeBgpPeersResponse
     *
     * @param DescribeBgpPeersRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DescribeBgpPeersResponse
     */
    public function describeBgpPeersWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bgpGroupId) {
            @$query['BgpGroupId'] = $request->bgpGroupId;
        }

        if (null !== $request->bgpPeerId) {
            @$query['BgpPeerId'] = $request->bgpPeerId;
        }

        if (null !== $request->isDefault) {
            @$query['IsDefault'] = $request->isDefault;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routerId) {
            @$query['RouterId'] = $request->routerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeBgpPeers',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeBgpPeersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries Border Gateway Protocol (BGP) peers in a region.
     *
     * @param request - DescribeBgpPeersRequest
     *
     * @returns DescribeBgpPeersResponse
     *
     * @param DescribeBgpPeersRequest $request
     *
     * @return DescribeBgpPeersResponse
     */
    public function describeBgpPeers($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBgpPeersWithOptions($request, $runtime);
    }

    /**
     * Queries a list of Internet Shared Bandwidth instances in a region.
     *
     * @param request - DescribeCommonBandwidthPackagesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCommonBandwidthPackagesResponse
     *
     * @param DescribeCommonBandwidthPackagesRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return DescribeCommonBandwidthPackagesResponse
     */
    public function describeCommonBandwidthPackagesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bandwidthPackageId) {
            @$query['BandwidthPackageId'] = $request->bandwidthPackageId;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->includeReservationData) {
            @$query['IncludeReservationData'] = $request->includeReservationData;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->securityProtectionEnabled) {
            @$query['SecurityProtectionEnabled'] = $request->securityProtectionEnabled;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCommonBandwidthPackages',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCommonBandwidthPackagesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of Internet Shared Bandwidth instances in a region.
     *
     * @param request - DescribeCommonBandwidthPackagesRequest
     *
     * @returns DescribeCommonBandwidthPackagesResponse
     *
     * @param DescribeCommonBandwidthPackagesRequest $request
     *
     * @return DescribeCommonBandwidthPackagesResponse
     */
    public function describeCommonBandwidthPackages($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCommonBandwidthPackagesWithOptions($request, $runtime);
    }

    /**
     * Queries details of a customer gateway.
     *
     * @param request - DescribeCustomerGatewayRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCustomerGatewayResponse
     *
     * @param DescribeCustomerGatewayRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeCustomerGatewayResponse
     */
    public function describeCustomerGatewayWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->customerGatewayId) {
            @$query['CustomerGatewayId'] = $request->customerGatewayId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCustomerGateway',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCustomerGatewayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries details of a customer gateway.
     *
     * @param request - DescribeCustomerGatewayRequest
     *
     * @returns DescribeCustomerGatewayResponse
     *
     * @param DescribeCustomerGatewayRequest $request
     *
     * @return DescribeCustomerGatewayResponse
     */
    public function describeCustomerGateway($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCustomerGatewayWithOptions($request, $runtime);
    }

    /**
     * Queries customer gateways.
     *
     * @param request - DescribeCustomerGatewaysRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCustomerGatewaysResponse
     *
     * @param DescribeCustomerGatewaysRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeCustomerGatewaysResponse
     */
    public function describeCustomerGatewaysWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->customerGatewayId) {
            @$query['CustomerGatewayId'] = $request->customerGatewayId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCustomerGateways',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCustomerGatewaysResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries customer gateways.
     *
     * @param request - DescribeCustomerGatewaysRequest
     *
     * @returns DescribeCustomerGatewaysResponse
     *
     * @param DescribeCustomerGatewaysRequest $request
     *
     * @return DescribeCustomerGatewaysResponse
     */
    public function describeCustomerGateways($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCustomerGatewaysWithOptions($request, $runtime);
    }

    /**
     * Queries whether permissions on a virtual private cloud (VPC) are granted to a virtual border router (VBR).
     *
     * @param request - DescribeEcGrantRelationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeEcGrantRelationResponse
     *
     * @param DescribeEcGrantRelationRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeEcGrantRelationResponse
     */
    public function describeEcGrantRelationWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->instanceType) {
            @$query['InstanceType'] = $request->instanceType;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->vbrRegionNo) {
            @$query['VbrRegionNo'] = $request->vbrRegionNo;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeEcGrantRelation',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeEcGrantRelationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries whether permissions on a virtual private cloud (VPC) are granted to a virtual border router (VBR).
     *
     * @param request - DescribeEcGrantRelationRequest
     *
     * @returns DescribeEcGrantRelationResponse
     *
     * @param DescribeEcGrantRelationRequest $request
     *
     * @return DescribeEcGrantRelationResponse
     */
    public function describeEcGrantRelation($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeEcGrantRelationWithOptions($request, $runtime);
    }

    /**
     * Queries elastic IP addresses (EIPs) created in a region.
     *
     * @remarks
     * You can call this operation to query information about EIPs in a region, including maximum bandwidth, billing methods, and associated instances.
     *
     * @param request - DescribeEipAddressesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeEipAddressesResponse
     *
     * @param DescribeEipAddressesRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DescribeEipAddressesResponse
     */
    public function describeEipAddressesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->allocationId) {
            @$query['AllocationId'] = $request->allocationId;
        }

        if (null !== $request->associatedInstanceId) {
            @$query['AssociatedInstanceId'] = $request->associatedInstanceId;
        }

        if (null !== $request->associatedInstanceType) {
            @$query['AssociatedInstanceType'] = $request->associatedInstanceType;
        }

        if (null !== $request->chargeType) {
            @$query['ChargeType'] = $request->chargeType;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->eipAddress) {
            @$query['EipAddress'] = $request->eipAddress;
        }

        if (null !== $request->eipName) {
            @$query['EipName'] = $request->eipName;
        }

        if (null !== $request->ISP) {
            @$query['ISP'] = $request->ISP;
        }

        if (null !== $request->includeReservationData) {
            @$query['IncludeReservationData'] = $request->includeReservationData;
        }

        if (null !== $request->lockReason) {
            @$query['LockReason'] = $request->lockReason;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->publicIpAddressPoolId) {
            @$query['PublicIpAddressPoolId'] = $request->publicIpAddressPoolId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->securityProtectionEnabled) {
            @$query['SecurityProtectionEnabled'] = $request->securityProtectionEnabled;
        }

        if (null !== $request->segmentInstanceId) {
            @$query['SegmentInstanceId'] = $request->segmentInstanceId;
        }

        if (null !== $request->serviceManaged) {
            @$query['ServiceManaged'] = $request->serviceManaged;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->filter) {
            @$query['Filter'] = $request->filter;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeEipAddresses',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeEipAddressesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries elastic IP addresses (EIPs) created in a region.
     *
     * @remarks
     * You can call this operation to query information about EIPs in a region, including maximum bandwidth, billing methods, and associated instances.
     *
     * @param request - DescribeEipAddressesRequest
     *
     * @returns DescribeEipAddressesResponse
     *
     * @param DescribeEipAddressesRequest $request
     *
     * @return DescribeEipAddressesResponse
     */
    public function describeEipAddresses($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeEipAddressesWithOptions($request, $runtime);
    }

    /**
     * Queries the gateway and subnet mask of an elastic IP address (EIP).
     *
     * @remarks
     * You can query only EIPs that are associated with secondary elastic network interfaces (ENIs) in multi-EIP-to-ENI mode.
     *
     * @param request - DescribeEipGatewayInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeEipGatewayInfoResponse
     *
     * @param DescribeEipGatewayInfoRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DescribeEipGatewayInfoResponse
     */
    public function describeEipGatewayInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeEipGatewayInfo',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeEipGatewayInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the gateway and subnet mask of an elastic IP address (EIP).
     *
     * @remarks
     * You can query only EIPs that are associated with secondary elastic network interfaces (ENIs) in multi-EIP-to-ENI mode.
     *
     * @param request - DescribeEipGatewayInfoRequest
     *
     * @returns DescribeEipGatewayInfoResponse
     *
     * @param DescribeEipGatewayInfoRequest $request
     *
     * @return DescribeEipGatewayInfoResponse
     */
    public function describeEipGatewayInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeEipGatewayInfoWithOptions($request, $runtime);
    }

    /**
     * Queries the monitoring data of an elastic IP address (EIP). You can query monitoring data within the last 30 days, and obtain up to 400 data points in each request.
     *
     * @remarks
     * To improve user experience in querying monitoring data, we recommend that you call the DescribeMetricList API operation provided by CloudMonitor to query EIP monitoring data. For more information, see [DescribeMetricList](https://help.aliyun.com/document_detail/51936.html) and [EIP monitoring data](https://help.aliyun.com/document_detail/162874.html).
     *
     * @param request - DescribeEipMonitorDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeEipMonitorDataResponse
     *
     * @param DescribeEipMonitorDataRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DescribeEipMonitorDataResponse
     */
    public function describeEipMonitorDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->allocationId) {
            @$query['AllocationId'] = $request->allocationId;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->period) {
            @$query['Period'] = $request->period;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeEipMonitorData',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeEipMonitorDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the monitoring data of an elastic IP address (EIP). You can query monitoring data within the last 30 days, and obtain up to 400 data points in each request.
     *
     * @remarks
     * To improve user experience in querying monitoring data, we recommend that you call the DescribeMetricList API operation provided by CloudMonitor to query EIP monitoring data. For more information, see [DescribeMetricList](https://help.aliyun.com/document_detail/51936.html) and [EIP monitoring data](https://help.aliyun.com/document_detail/162874.html).
     *
     * @param request - DescribeEipMonitorDataRequest
     *
     * @returns DescribeEipMonitorDataResponse
     *
     * @param DescribeEipMonitorDataRequest $request
     *
     * @return DescribeEipMonitorDataResponse
     */
    public function describeEipMonitorData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeEipMonitorDataWithOptions($request, $runtime);
    }

    /**
     * Queries contiguous elastic IP address (EIP) groups.
     *
     * @param request - DescribeEipSegmentRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeEipSegmentResponse
     *
     * @param DescribeEipSegmentRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return DescribeEipSegmentResponse
     */
    public function describeEipSegmentWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->segmentInstanceId) {
            @$query['SegmentInstanceId'] = $request->segmentInstanceId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeEipSegment',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeEipSegmentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries contiguous elastic IP address (EIP) groups.
     *
     * @param request - DescribeEipSegmentRequest
     *
     * @returns DescribeEipSegmentResponse
     *
     * @param DescribeEipSegmentRequest $request
     *
     * @return DescribeEipSegmentResponse
     */
    public function describeEipSegment($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeEipSegmentWithOptions($request, $runtime);
    }

    /**
     * Queries the quality of service (QoS) policies of Express Connect. The response can be displayed by page.
     *
     * @param request - DescribeExpressConnectTrafficQosRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeExpressConnectTrafficQosResponse
     *
     * @param DescribeExpressConnectTrafficQosRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return DescribeExpressConnectTrafficQosResponse
     */
    public function describeExpressConnectTrafficQosWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->qosIdList) {
            @$query['QosIdList'] = $request->qosIdList;
        }

        if (null !== $request->qosNameList) {
            @$query['QosNameList'] = $request->qosNameList;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeExpressConnectTrafficQos',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeExpressConnectTrafficQosResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the quality of service (QoS) policies of Express Connect. The response can be displayed by page.
     *
     * @param request - DescribeExpressConnectTrafficQosRequest
     *
     * @returns DescribeExpressConnectTrafficQosResponse
     *
     * @param DescribeExpressConnectTrafficQosRequest $request
     *
     * @return DescribeExpressConnectTrafficQosResponse
     */
    public function describeExpressConnectTrafficQos($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeExpressConnectTrafficQosWithOptions($request, $runtime);
    }

    /**
     * Queries the information about the quality of service (QoS) queues of the Express Connect circuit.
     *
     * @param request - DescribeExpressConnectTrafficQosQueueRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeExpressConnectTrafficQosQueueResponse
     *
     * @param DescribeExpressConnectTrafficQosQueueRequest $request
     * @param RuntimeOptions                               $runtime
     *
     * @return DescribeExpressConnectTrafficQosQueueResponse
     */
    public function describeExpressConnectTrafficQosQueueWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->qosId) {
            @$query['QosId'] = $request->qosId;
        }

        if (null !== $request->queueIdList) {
            @$query['QueueIdList'] = $request->queueIdList;
        }

        if (null !== $request->queueNameList) {
            @$query['QueueNameList'] = $request->queueNameList;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeExpressConnectTrafficQosQueue',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeExpressConnectTrafficQosQueueResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about the quality of service (QoS) queues of the Express Connect circuit.
     *
     * @param request - DescribeExpressConnectTrafficQosQueueRequest
     *
     * @returns DescribeExpressConnectTrafficQosQueueResponse
     *
     * @param DescribeExpressConnectTrafficQosQueueRequest $request
     *
     * @return DescribeExpressConnectTrafficQosQueueResponse
     */
    public function describeExpressConnectTrafficQosQueue($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeExpressConnectTrafficQosQueueWithOptions($request, $runtime);
    }

    /**
     * Queries quality of service (QoS) rules. Paging parameters are not supported.
     *
     * @param request - DescribeExpressConnectTrafficQosRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeExpressConnectTrafficQosRuleResponse
     *
     * @param DescribeExpressConnectTrafficQosRuleRequest $request
     * @param RuntimeOptions                              $runtime
     *
     * @return DescribeExpressConnectTrafficQosRuleResponse
     */
    public function describeExpressConnectTrafficQosRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->qosId) {
            @$query['QosId'] = $request->qosId;
        }

        if (null !== $request->queueId) {
            @$query['QueueId'] = $request->queueId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->ruleIdList) {
            @$query['RuleIdList'] = $request->ruleIdList;
        }

        if (null !== $request->ruleNameList) {
            @$query['RuleNameList'] = $request->ruleNameList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeExpressConnectTrafficQosRule',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeExpressConnectTrafficQosRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries quality of service (QoS) rules. Paging parameters are not supported.
     *
     * @param request - DescribeExpressConnectTrafficQosRuleRequest
     *
     * @returns DescribeExpressConnectTrafficQosRuleResponse
     *
     * @param DescribeExpressConnectTrafficQosRuleRequest $request
     *
     * @return DescribeExpressConnectTrafficQosRuleResponse
     */
    public function describeExpressConnectTrafficQosRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeExpressConnectTrafficQosRuleWithOptions($request, $runtime);
    }

    /**
     * Queries failover tests.
     *
     * @param request - DescribeFailoverTestJobRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeFailoverTestJobResponse
     *
     * @param DescribeFailoverTestJobRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeFailoverTestJobResponse
     */
    public function describeFailoverTestJobWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->jobId) {
            @$query['JobId'] = $request->jobId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeFailoverTestJob',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeFailoverTestJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries failover tests.
     *
     * @param request - DescribeFailoverTestJobRequest
     *
     * @returns DescribeFailoverTestJobResponse
     *
     * @param DescribeFailoverTestJobRequest $request
     *
     * @return DescribeFailoverTestJobResponse
     */
    public function describeFailoverTestJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeFailoverTestJobWithOptions($request, $runtime);
    }

    /**
     * Queries failover tests for Express Connect.
     *
     * @param request - DescribeFailoverTestJobsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeFailoverTestJobsResponse
     *
     * @param DescribeFailoverTestJobsRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeFailoverTestJobsResponse
     */
    public function describeFailoverTestJobsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->filter) {
            @$query['Filter'] = $request->filter;
        }

        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeFailoverTestJobs',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeFailoverTestJobsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries failover tests for Express Connect.
     *
     * @param request - DescribeFailoverTestJobsRequest
     *
     * @returns DescribeFailoverTestJobsResponse
     *
     * @param DescribeFailoverTestJobsRequest $request
     *
     * @return DescribeFailoverTestJobsResponse
     */
    public function describeFailoverTestJobs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeFailoverTestJobsWithOptions($request, $runtime);
    }

    /**
     * Query flow logs.
     *
     * @param request - DescribeFlowLogsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeFlowLogsResponse
     *
     * @param DescribeFlowLogsRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DescribeFlowLogsResponse
     */
    public function describeFlowLogsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->flowLogId) {
            @$query['FlowLogId'] = $request->flowLogId;
        }

        if (null !== $request->flowLogName) {
            @$query['FlowLogName'] = $request->flowLogName;
        }

        if (null !== $request->logStoreName) {
            @$query['LogStoreName'] = $request->logStoreName;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->projectName) {
            @$query['ProjectName'] = $request->projectName;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        if (null !== $request->trafficType) {
            @$query['TrafficType'] = $request->trafficType;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeFlowLogs',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeFlowLogsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Query flow logs.
     *
     * @param request - DescribeFlowLogsRequest
     *
     * @returns DescribeFlowLogsResponse
     *
     * @param DescribeFlowLogsRequest $request
     *
     * @return DescribeFlowLogsResponse
     */
    public function describeFlowLogs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeFlowLogsWithOptions($request, $runtime);
    }

    /**
     * Queries DNAT entries.
     *
     * @param request - DescribeForwardTableEntriesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeForwardTableEntriesResponse
     *
     * @param DescribeForwardTableEntriesRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeForwardTableEntriesResponse
     */
    public function describeForwardTableEntriesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->externalIp) {
            @$query['ExternalIp'] = $request->externalIp;
        }

        if (null !== $request->externalPort) {
            @$query['ExternalPort'] = $request->externalPort;
        }

        if (null !== $request->forwardEntryId) {
            @$query['ForwardEntryId'] = $request->forwardEntryId;
        }

        if (null !== $request->forwardEntryName) {
            @$query['ForwardEntryName'] = $request->forwardEntryName;
        }

        if (null !== $request->forwardTableId) {
            @$query['ForwardTableId'] = $request->forwardTableId;
        }

        if (null !== $request->internalIp) {
            @$query['InternalIp'] = $request->internalIp;
        }

        if (null !== $request->internalPort) {
            @$query['InternalPort'] = $request->internalPort;
        }

        if (null !== $request->ipProtocol) {
            @$query['IpProtocol'] = $request->ipProtocol;
        }

        if (null !== $request->natGatewayId) {
            @$query['NatGatewayId'] = $request->natGatewayId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeForwardTableEntries',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeForwardTableEntriesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries DNAT entries.
     *
     * @param request - DescribeForwardTableEntriesRequest
     *
     * @returns DescribeForwardTableEntriesResponse
     *
     * @param DescribeForwardTableEntriesRequest $request
     *
     * @return DescribeForwardTableEntriesResponse
     */
    public function describeForwardTableEntries($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeForwardTableEntriesWithOptions($request, $runtime);
    }

    /**
     * Queries Global Accelerator (GA) instances.
     *
     * @param request - DescribeGlobalAccelerationInstancesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeGlobalAccelerationInstancesResponse
     *
     * @param DescribeGlobalAccelerationInstancesRequest $request
     * @param RuntimeOptions                             $runtime
     *
     * @return DescribeGlobalAccelerationInstancesResponse
     */
    public function describeGlobalAccelerationInstancesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bandwidthType) {
            @$query['BandwidthType'] = $request->bandwidthType;
        }

        if (null !== $request->globalAccelerationInstanceId) {
            @$query['GlobalAccelerationInstanceId'] = $request->globalAccelerationInstanceId;
        }

        if (null !== $request->includeReservationData) {
            @$query['IncludeReservationData'] = $request->includeReservationData;
        }

        if (null !== $request->ipAddress) {
            @$query['IpAddress'] = $request->ipAddress;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->serverId) {
            @$query['ServerId'] = $request->serverId;
        }

        if (null !== $request->serviceLocation) {
            @$query['ServiceLocation'] = $request->serviceLocation;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeGlobalAccelerationInstances',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeGlobalAccelerationInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries Global Accelerator (GA) instances.
     *
     * @param request - DescribeGlobalAccelerationInstancesRequest
     *
     * @returns DescribeGlobalAccelerationInstancesResponse
     *
     * @param DescribeGlobalAccelerationInstancesRequest $request
     *
     * @return DescribeGlobalAccelerationInstancesResponse
     */
    public function describeGlobalAccelerationInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeGlobalAccelerationInstancesWithOptions($request, $runtime);
    }

    /**
     * VPCVBR.
     *
     * @param request - DescribeGrantRulesToCenRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeGrantRulesToCenResponse
     *
     * @param DescribeGrantRulesToCenRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeGrantRulesToCenResponse
     */
    public function describeGrantRulesToCenWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->instanceType) {
            @$query['InstanceType'] = $request->instanceType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeGrantRulesToCen',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeGrantRulesToCenResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * VPCVBR.
     *
     * @param request - DescribeGrantRulesToCenRequest
     *
     * @returns DescribeGrantRulesToCenResponse
     *
     * @param DescribeGrantRulesToCenRequest $request
     *
     * @return DescribeGrantRulesToCenResponse
     */
    public function describeGrantRulesToCen($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeGrantRulesToCenWithOptions($request, $runtime);
    }

    /**
     * Queries the cross-account authorization list of an Express Connect Router (ECR).
     *
     * @param request - DescribeGrantRulesToEcrRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeGrantRulesToEcrResponse
     *
     * @param DescribeGrantRulesToEcrRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeGrantRulesToEcrResponse
     */
    public function describeGrantRulesToEcrWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeGrantRulesToEcr',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeGrantRulesToEcrResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the cross-account authorization list of an Express Connect Router (ECR).
     *
     * @param request - DescribeGrantRulesToEcrRequest
     *
     * @returns DescribeGrantRulesToEcrResponse
     *
     * @param DescribeGrantRulesToEcrRequest $request
     *
     * @return DescribeGrantRulesToEcrResponse
     */
    public function describeGrantRulesToEcr($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeGrantRulesToEcrWithOptions($request, $runtime);
    }

    /**
     * Queries HaVips in a region.
     *
     * @param request - DescribeHaVipsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeHaVipsResponse
     *
     * @param DescribeHaVipsRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return DescribeHaVipsResponse
     */
    public function describeHaVipsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->filter) {
            @$query['Filter'] = $request->filter;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeHaVips',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeHaVipsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries HaVips in a region.
     *
     * @param request - DescribeHaVipsRequest
     *
     * @returns DescribeHaVipsResponse
     *
     * @param DescribeHaVipsRequest $request
     *
     * @return DescribeHaVipsResponse
     */
    public function describeHaVips($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeHaVipsWithOptions($request, $runtime);
    }

    /**
     * Queries configurations about the fine-grained monitoring feature of an elastic IP address (EIP).
     *
     * @param request - DescribeHighDefinitionMonitorLogAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeHighDefinitionMonitorLogAttributeResponse
     *
     * @param DescribeHighDefinitionMonitorLogAttributeRequest $request
     * @param RuntimeOptions                                   $runtime
     *
     * @return DescribeHighDefinitionMonitorLogAttributeResponse
     */
    public function describeHighDefinitionMonitorLogAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->instanceType) {
            @$query['InstanceType'] = $request->instanceType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeHighDefinitionMonitorLogAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeHighDefinitionMonitorLogAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries configurations about the fine-grained monitoring feature of an elastic IP address (EIP).
     *
     * @param request - DescribeHighDefinitionMonitorLogAttributeRequest
     *
     * @returns DescribeHighDefinitionMonitorLogAttributeResponse
     *
     * @param DescribeHighDefinitionMonitorLogAttributeRequest $request
     *
     * @return DescribeHighDefinitionMonitorLogAttributeResponse
     */
    public function describeHighDefinitionMonitorLogAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeHighDefinitionMonitorLogAttributeWithOptions($request, $runtime);
    }

    /**
     * Queries the details of an access control list (ACL), including the specified IP addresses and associated IPv6 mapping entries.
     *
     * @param request - DescribeIPv6TranslatorAclListAttributesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeIPv6TranslatorAclListAttributesResponse
     *
     * @param DescribeIPv6TranslatorAclListAttributesRequest $request
     * @param RuntimeOptions                                 $runtime
     *
     * @return DescribeIPv6TranslatorAclListAttributesResponse
     */
    public function describeIPv6TranslatorAclListAttributesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aclId) {
            @$query['AclId'] = $request->aclId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeIPv6TranslatorAclListAttributes',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeIPv6TranslatorAclListAttributesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of an access control list (ACL), including the specified IP addresses and associated IPv6 mapping entries.
     *
     * @param request - DescribeIPv6TranslatorAclListAttributesRequest
     *
     * @returns DescribeIPv6TranslatorAclListAttributesResponse
     *
     * @param DescribeIPv6TranslatorAclListAttributesRequest $request
     *
     * @return DescribeIPv6TranslatorAclListAttributesResponse
     */
    public function describeIPv6TranslatorAclListAttributes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeIPv6TranslatorAclListAttributesWithOptions($request, $runtime);
    }

    /**
     * Queries access control lists (ACLs).
     *
     * @deprecated OpenAPI DescribeIPv6TranslatorAclLists is deprecated
     *
     * @param request - DescribeIPv6TranslatorAclListsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeIPv6TranslatorAclListsResponse
     *
     * @param DescribeIPv6TranslatorAclListsRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DescribeIPv6TranslatorAclListsResponse
     */
    public function describeIPv6TranslatorAclListsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aclId) {
            @$query['AclId'] = $request->aclId;
        }

        if (null !== $request->aclName) {
            @$query['AclName'] = $request->aclName;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeIPv6TranslatorAclLists',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeIPv6TranslatorAclListsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Queries access control lists (ACLs).
     *
     * @deprecated OpenAPI DescribeIPv6TranslatorAclLists is deprecated
     *
     * @param request - DescribeIPv6TranslatorAclListsRequest
     *
     * @returns DescribeIPv6TranslatorAclListsResponse
     *
     * @param DescribeIPv6TranslatorAclListsRequest $request
     *
     * @return DescribeIPv6TranslatorAclListsResponse
     */
    public function describeIPv6TranslatorAclLists($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeIPv6TranslatorAclListsWithOptions($request, $runtime);
    }

    /**
     * Queries IPv6 mapping entries.
     *
     * @deprecated OpenAPI DescribeIPv6TranslatorEntries is deprecated
     *
     * @param request - DescribeIPv6TranslatorEntriesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeIPv6TranslatorEntriesResponse
     *
     * @param DescribeIPv6TranslatorEntriesRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DescribeIPv6TranslatorEntriesResponse
     */
    public function describeIPv6TranslatorEntriesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aclId) {
            @$query['AclId'] = $request->aclId;
        }

        if (null !== $request->aclStatus) {
            @$query['AclStatus'] = $request->aclStatus;
        }

        if (null !== $request->aclType) {
            @$query['AclType'] = $request->aclType;
        }

        if (null !== $request->allocateIpv6Addr) {
            @$query['AllocateIpv6Addr'] = $request->allocateIpv6Addr;
        }

        if (null !== $request->allocateIpv6Port) {
            @$query['AllocateIpv6Port'] = $request->allocateIpv6Port;
        }

        if (null !== $request->backendIpv4Addr) {
            @$query['BackendIpv4Addr'] = $request->backendIpv4Addr;
        }

        if (null !== $request->backendIpv4Port) {
            @$query['BackendIpv4Port'] = $request->backendIpv4Port;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->entryName) {
            @$query['EntryName'] = $request->entryName;
        }

        if (null !== $request->ipv6TranslatorEntryId) {
            @$query['Ipv6TranslatorEntryId'] = $request->ipv6TranslatorEntryId;
        }

        if (null !== $request->ipv6TranslatorId) {
            @$query['Ipv6TranslatorId'] = $request->ipv6TranslatorId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->transProtocol) {
            @$query['TransProtocol'] = $request->transProtocol;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeIPv6TranslatorEntries',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeIPv6TranslatorEntriesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Queries IPv6 mapping entries.
     *
     * @deprecated OpenAPI DescribeIPv6TranslatorEntries is deprecated
     *
     * @param request - DescribeIPv6TranslatorEntriesRequest
     *
     * @returns DescribeIPv6TranslatorEntriesResponse
     *
     * @param DescribeIPv6TranslatorEntriesRequest $request
     *
     * @return DescribeIPv6TranslatorEntriesResponse
     */
    public function describeIPv6TranslatorEntries($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeIPv6TranslatorEntriesWithOptions($request, $runtime);
    }

    /**
     * Queries IPv6 Translation Service instances.
     *
     * @deprecated OpenAPI DescribeIPv6Translators is deprecated
     *
     * @param request - DescribeIPv6TranslatorsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeIPv6TranslatorsResponse
     *
     * @param DescribeIPv6TranslatorsRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeIPv6TranslatorsResponse
     */
    public function describeIPv6TranslatorsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->allocateIpv4Addr) {
            @$query['AllocateIpv4Addr'] = $request->allocateIpv4Addr;
        }

        if (null !== $request->allocateIpv6Addr) {
            @$query['AllocateIpv6Addr'] = $request->allocateIpv6Addr;
        }

        if (null !== $request->businessStatus) {
            @$query['BusinessStatus'] = $request->businessStatus;
        }

        if (null !== $request->ipv6TranslatorId) {
            @$query['Ipv6TranslatorId'] = $request->ipv6TranslatorId;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->payType) {
            @$query['PayType'] = $request->payType;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->spec) {
            @$query['Spec'] = $request->spec;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeIPv6Translators',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeIPv6TranslatorsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Queries IPv6 Translation Service instances.
     *
     * @deprecated OpenAPI DescribeIPv6Translators is deprecated
     *
     * @param request - DescribeIPv6TranslatorsRequest
     *
     * @returns DescribeIPv6TranslatorsResponse
     *
     * @param DescribeIPv6TranslatorsRequest $request
     *
     * @return DescribeIPv6TranslatorsResponse
     */
    public function describeIPv6Translators($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeIPv6TranslatorsWithOptions($request, $runtime);
    }

    /**
     * Queries IPv6 addresses in a region.
     *
     * @param request - DescribeIpv6AddressesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeIpv6AddressesResponse
     *
     * @param DescribeIpv6AddressesRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DescribeIpv6AddressesResponse
     */
    public function describeIpv6AddressesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->addressType) {
            @$query['AddressType'] = $request->addressType;
        }

        if (null !== $request->associatedInstanceId) {
            @$query['AssociatedInstanceId'] = $request->associatedInstanceId;
        }

        if (null !== $request->associatedInstanceType) {
            @$query['AssociatedInstanceType'] = $request->associatedInstanceType;
        }

        if (null !== $request->includeReservationData) {
            @$query['IncludeReservationData'] = $request->includeReservationData;
        }

        if (null !== $request->ipv6Address) {
            @$query['Ipv6Address'] = $request->ipv6Address;
        }

        if (null !== $request->ipv6AddressId) {
            @$query['Ipv6AddressId'] = $request->ipv6AddressId;
        }

        if (null !== $request->ipv6InternetBandwidthId) {
            @$query['Ipv6InternetBandwidthId'] = $request->ipv6InternetBandwidthId;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->networkType) {
            @$query['NetworkType'] = $request->networkType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->serviceManaged) {
            @$query['ServiceManaged'] = $request->serviceManaged;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeIpv6Addresses',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeIpv6AddressesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries IPv6 addresses in a region.
     *
     * @param request - DescribeIpv6AddressesRequest
     *
     * @returns DescribeIpv6AddressesResponse
     *
     * @param DescribeIpv6AddressesRequest $request
     *
     * @return DescribeIpv6AddressesResponse
     */
    public function describeIpv6Addresses($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeIpv6AddressesWithOptions($request, $runtime);
    }

    /**
     * Queries egress-only rules.
     *
     * @param request - DescribeIpv6EgressOnlyRulesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeIpv6EgressOnlyRulesResponse
     *
     * @param DescribeIpv6EgressOnlyRulesRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeIpv6EgressOnlyRulesResponse
     */
    public function describeIpv6EgressOnlyRulesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->instanceType) {
            @$query['InstanceType'] = $request->instanceType;
        }

        if (null !== $request->ipv6EgressOnlyRuleId) {
            @$query['Ipv6EgressOnlyRuleId'] = $request->ipv6EgressOnlyRuleId;
        }

        if (null !== $request->ipv6GatewayId) {
            @$query['Ipv6GatewayId'] = $request->ipv6GatewayId;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeIpv6EgressOnlyRules',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeIpv6EgressOnlyRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries egress-only rules.
     *
     * @param request - DescribeIpv6EgressOnlyRulesRequest
     *
     * @returns DescribeIpv6EgressOnlyRulesResponse
     *
     * @param DescribeIpv6EgressOnlyRulesRequest $request
     *
     * @return DescribeIpv6EgressOnlyRulesResponse
     */
    public function describeIpv6EgressOnlyRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeIpv6EgressOnlyRulesWithOptions($request, $runtime);
    }

    /**
     * Queries the information about an IPv6 gateway, including the region, virtual private cloud (VPC), status, and billing method.
     *
     * @param request - DescribeIpv6GatewayAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeIpv6GatewayAttributeResponse
     *
     * @param DescribeIpv6GatewayAttributeRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribeIpv6GatewayAttributeResponse
     */
    public function describeIpv6GatewayAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ipv6GatewayId) {
            @$query['Ipv6GatewayId'] = $request->ipv6GatewayId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeIpv6GatewayAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeIpv6GatewayAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about an IPv6 gateway, including the region, virtual private cloud (VPC), status, and billing method.
     *
     * @param request - DescribeIpv6GatewayAttributeRequest
     *
     * @returns DescribeIpv6GatewayAttributeResponse
     *
     * @param DescribeIpv6GatewayAttributeRequest $request
     *
     * @return DescribeIpv6GatewayAttributeResponse
     */
    public function describeIpv6GatewayAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeIpv6GatewayAttributeWithOptions($request, $runtime);
    }

    /**
     * Queries IPv6 gateways in a region.
     *
     * @param request - DescribeIpv6GatewaysRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeIpv6GatewaysResponse
     *
     * @param DescribeIpv6GatewaysRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DescribeIpv6GatewaysResponse
     */
    public function describeIpv6GatewaysWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ipv6GatewayId) {
            @$query['Ipv6GatewayId'] = $request->ipv6GatewayId;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeIpv6Gateways',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeIpv6GatewaysResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries IPv6 gateways in a region.
     *
     * @param request - DescribeIpv6GatewaysRequest
     *
     * @returns DescribeIpv6GatewaysResponse
     *
     * @param DescribeIpv6GatewaysRequest $request
     *
     * @return DescribeIpv6GatewaysResponse
     */
    public function describeIpv6Gateways($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeIpv6GatewaysWithOptions($request, $runtime);
    }

    /**
     * Queries elastic network interfaces (ENIs) associated with a virtual private cloud (VPC) NAT gateway when the VPC NAT gateway serves as a PrivateLink service resource. This feature is not publicly available.
     *
     * @param request - DescribeNatGatewayAssociateNetworkInterfacesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeNatGatewayAssociateNetworkInterfacesResponse
     *
     * @param DescribeNatGatewayAssociateNetworkInterfacesRequest $request
     * @param RuntimeOptions                                      $runtime
     *
     * @return DescribeNatGatewayAssociateNetworkInterfacesResponse
     */
    public function describeNatGatewayAssociateNetworkInterfacesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->filter) {
            @$query['Filter'] = $request->filter;
        }

        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->natGatewayId) {
            @$query['NatGatewayId'] = $request->natGatewayId;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeNatGatewayAssociateNetworkInterfaces',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeNatGatewayAssociateNetworkInterfacesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries elastic network interfaces (ENIs) associated with a virtual private cloud (VPC) NAT gateway when the VPC NAT gateway serves as a PrivateLink service resource. This feature is not publicly available.
     *
     * @param request - DescribeNatGatewayAssociateNetworkInterfacesRequest
     *
     * @returns DescribeNatGatewayAssociateNetworkInterfacesResponse
     *
     * @param DescribeNatGatewayAssociateNetworkInterfacesRequest $request
     *
     * @return DescribeNatGatewayAssociateNetworkInterfacesResponse
     */
    public function describeNatGatewayAssociateNetworkInterfaces($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeNatGatewayAssociateNetworkInterfacesWithOptions($request, $runtime);
    }

    /**
     * Queries NAT gateways that meet specific conditions in a specified region.
     *
     * @remarks
     * You can call this operation to query both Virtual Private Cloud (VPC) NAT gateways and Internet NAT gateways. NAT gateways in this topic refer to both VPC NAT gateways and Internet NAT gateways.
     *
     * @param request - DescribeNatGatewaysRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeNatGatewaysResponse
     *
     * @param DescribeNatGatewaysRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DescribeNatGatewaysResponse
     */
    public function describeNatGatewaysWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->instanceChargeType) {
            @$query['InstanceChargeType'] = $request->instanceChargeType;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->natGatewayId) {
            @$query['NatGatewayId'] = $request->natGatewayId;
        }

        if (null !== $request->natType) {
            @$query['NatType'] = $request->natType;
        }

        if (null !== $request->networkType) {
            @$query['NetworkType'] = $request->networkType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->spec) {
            @$query['Spec'] = $request->spec;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        if (null !== $request->zoneId) {
            @$query['ZoneId'] = $request->zoneId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeNatGateways',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeNatGatewaysResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries NAT gateways that meet specific conditions in a specified region.
     *
     * @remarks
     * You can call this operation to query both Virtual Private Cloud (VPC) NAT gateways and Internet NAT gateways. NAT gateways in this topic refer to both VPC NAT gateways and Internet NAT gateways.
     *
     * @param request - DescribeNatGatewaysRequest
     *
     * @returns DescribeNatGatewaysResponse
     *
     * @param DescribeNatGatewaysRequest $request
     *
     * @return DescribeNatGatewaysResponse
     */
    public function describeNatGateways($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeNatGatewaysWithOptions($request, $runtime);
    }

    /**
     * Queries network access control lists (ACLs).
     *
     * @param request - DescribeNetworkAclAttributesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeNetworkAclAttributesResponse
     *
     * @param DescribeNetworkAclAttributesRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribeNetworkAclAttributesResponse
     */
    public function describeNetworkAclAttributesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->networkAclId) {
            @$query['NetworkAclId'] = $request->networkAclId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeNetworkAclAttributes',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeNetworkAclAttributesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries network access control lists (ACLs).
     *
     * @param request - DescribeNetworkAclAttributesRequest
     *
     * @returns DescribeNetworkAclAttributesResponse
     *
     * @param DescribeNetworkAclAttributesRequest $request
     *
     * @return DescribeNetworkAclAttributesResponse
     */
    public function describeNetworkAclAttributes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeNetworkAclAttributesWithOptions($request, $runtime);
    }

    /**
     * Queries network ACLs.
     *
     * @param request - DescribeNetworkAclsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeNetworkAclsResponse
     *
     * @param DescribeNetworkAclsRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DescribeNetworkAclsResponse
     */
    public function describeNetworkAclsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->networkAclId) {
            @$query['NetworkAclId'] = $request->networkAclId;
        }

        if (null !== $request->networkAclName) {
            @$query['NetworkAclName'] = $request->networkAclName;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeNetworkAcls',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeNetworkAclsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries network ACLs.
     *
     * @param request - DescribeNetworkAclsRequest
     *
     * @returns DescribeNetworkAclsResponse
     *
     * @param DescribeNetworkAclsRequest $request
     *
     * @return DescribeNetworkAclsResponse
     */
    public function describeNetworkAcls($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeNetworkAclsWithOptions($request, $runtime);
    }

    /**
     * LOA.
     *
     * @param request - DescribePhysicalConnectionLOARequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribePhysicalConnectionLOAResponse
     *
     * @param DescribePhysicalConnectionLOARequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DescribePhysicalConnectionLOAResponse
     */
    public function describePhysicalConnectionLOAWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribePhysicalConnectionLOA',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribePhysicalConnectionLOAResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * LOA.
     *
     * @param request - DescribePhysicalConnectionLOARequest
     *
     * @returns DescribePhysicalConnectionLOAResponse
     *
     * @param DescribePhysicalConnectionLOARequest $request
     *
     * @return DescribePhysicalConnectionLOAResponse
     */
    public function describePhysicalConnectionLOA($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePhysicalConnectionLOAWithOptions($request, $runtime);
    }

    /**
     * Queries Express Connect circuits in a region.
     *
     * @remarks
     * By default, the system queries information about all Express Connect circuits in the specified region. You can query Express Connect circuits that meet specific conditions by specifying filter conditions provided by the **DescribePhysicalConnections** operation. For more information about the supported filter conditions, see **Key** in the **Request parameters** section.
     *
     * @param request - DescribePhysicalConnectionsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribePhysicalConnectionsResponse
     *
     * @param DescribePhysicalConnectionsRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribePhysicalConnectionsResponse
     */
    public function describePhysicalConnectionsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->filter) {
            @$query['Filter'] = $request->filter;
        }

        if (null !== $request->includeReservationData) {
            @$query['IncludeReservationData'] = $request->includeReservationData;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribePhysicalConnections',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribePhysicalConnectionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries Express Connect circuits in a region.
     *
     * @remarks
     * By default, the system queries information about all Express Connect circuits in the specified region. You can query Express Connect circuits that meet specific conditions by specifying filter conditions provided by the **DescribePhysicalConnections** operation. For more information about the supported filter conditions, see **Key** in the **Request parameters** section.
     *
     * @param request - DescribePhysicalConnectionsRequest
     *
     * @returns DescribePhysicalConnectionsResponse
     *
     * @param DescribePhysicalConnectionsRequest $request
     *
     * @return DescribePhysicalConnectionsResponse
     */
    public function describePhysicalConnections($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePhysicalConnectionsWithOptions($request, $runtime);
    }

    /**
     * Queries the public IP address range of a virtual private cloud (VPC) in a region.
     *
     * @remarks
     * You cannot query the range of public IP addresses of a classic network by calling the **DescribePublicIpAddress** operation.
     *
     * @param request - DescribePublicIpAddressRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribePublicIpAddressResponse
     *
     * @param DescribePublicIpAddressRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribePublicIpAddressResponse
     */
    public function describePublicIpAddressWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ipVersion) {
            @$query['IpVersion'] = $request->ipVersion;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribePublicIpAddress',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribePublicIpAddressResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the public IP address range of a virtual private cloud (VPC) in a region.
     *
     * @remarks
     * You cannot query the range of public IP addresses of a classic network by calling the **DescribePublicIpAddress** operation.
     *
     * @param request - DescribePublicIpAddressRequest
     *
     * @returns DescribePublicIpAddressResponse
     *
     * @param DescribePublicIpAddressRequest $request
     *
     * @return DescribePublicIpAddressResponse
     */
    public function describePublicIpAddress($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePublicIpAddressWithOptions($request, $runtime);
    }

    /**
     * Queries the most recent region list.
     *
     * @param request - DescribeRegionsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRegionsResponse
     *
     * @param DescribeRegionsRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return DescribeRegionsResponse
     */
    public function describeRegionsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceptLanguage) {
            @$query['AcceptLanguage'] = $request->acceptLanguage;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->productType) {
            @$query['ProductType'] = $request->productType;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRegions',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRegionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the most recent region list.
     *
     * @param request - DescribeRegionsRequest
     *
     * @returns DescribeRegionsResponse
     *
     * @param DescribeRegionsRequest $request
     *
     * @return DescribeRegionsResponse
     */
    public function describeRegions($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRegionsWithOptions($request, $runtime);
    }

    /**
     * Queries information about route entries in a route table.
     *
     * @remarks
     * Before you call the [DeleteRouteEntry](https://help.aliyun.com/document_detail/36013.html) operation to delete a route, you can call this operation to query the next hop of the route that you want to delete.
     *
     * @param request - DescribeRouteEntryListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRouteEntryListResponse
     *
     * @param DescribeRouteEntryListRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DescribeRouteEntryListResponse
     */
    public function describeRouteEntryListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->destCidrBlockList) {
            @$query['DestCidrBlockList'] = $request->destCidrBlockList;
        }

        if (null !== $request->destinationCidrBlock) {
            @$query['DestinationCidrBlock'] = $request->destinationCidrBlock;
        }

        if (null !== $request->ipVersion) {
            @$query['IpVersion'] = $request->ipVersion;
        }

        if (null !== $request->maxResult) {
            @$query['MaxResult'] = $request->maxResult;
        }

        if (null !== $request->nextHopId) {
            @$query['NextHopId'] = $request->nextHopId;
        }

        if (null !== $request->nextHopType) {
            @$query['NextHopType'] = $request->nextHopType;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeEntryId) {
            @$query['RouteEntryId'] = $request->routeEntryId;
        }

        if (null !== $request->routeEntryName) {
            @$query['RouteEntryName'] = $request->routeEntryName;
        }

        if (null !== $request->routeEntryType) {
            @$query['RouteEntryType'] = $request->routeEntryType;
        }

        if (null !== $request->routeTableId) {
            @$query['RouteTableId'] = $request->routeTableId;
        }

        if (null !== $request->serviceType) {
            @$query['ServiceType'] = $request->serviceType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRouteEntryList',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRouteEntryListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries information about route entries in a route table.
     *
     * @remarks
     * Before you call the [DeleteRouteEntry](https://help.aliyun.com/document_detail/36013.html) operation to delete a route, you can call this operation to query the next hop of the route that you want to delete.
     *
     * @param request - DescribeRouteEntryListRequest
     *
     * @returns DescribeRouteEntryListResponse
     *
     * @param DescribeRouteEntryListRequest $request
     *
     * @return DescribeRouteEntryListResponse
     */
    public function describeRouteEntryList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRouteEntryListWithOptions($request, $runtime);
    }

    /**
     * Queries route tables.
     *
     * @param request - DescribeRouteTableListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRouteTableListResponse
     *
     * @param DescribeRouteTableListRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DescribeRouteTableListResponse
     */
    public function describeRouteTableListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeTableId) {
            @$query['RouteTableId'] = $request->routeTableId;
        }

        if (null !== $request->routeTableName) {
            @$query['RouteTableName'] = $request->routeTableName;
        }

        if (null !== $request->routeTableType) {
            @$query['RouteTableType'] = $request->routeTableType;
        }

        if (null !== $request->routerId) {
            @$query['RouterId'] = $request->routerId;
        }

        if (null !== $request->routerType) {
            @$query['RouterType'] = $request->routerType;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRouteTableList',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRouteTableListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries route tables.
     *
     * @param request - DescribeRouteTableListRequest
     *
     * @returns DescribeRouteTableListResponse
     *
     * @param DescribeRouteTableListRequest $request
     *
     * @return DescribeRouteTableListResponse
     */
    public function describeRouteTableList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRouteTableListWithOptions($request, $runtime);
    }

    /**
     * Queries route tables.
     *
     * @deprecated openAPI DescribeRouteTables is deprecated, please use Vpc::2016-04-28::DescribeRouteTableList instead
     *
     * @param request - DescribeRouteTablesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRouteTablesResponse
     *
     * @param DescribeRouteTablesRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DescribeRouteTablesResponse
     */
    public function describeRouteTablesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeTableId) {
            @$query['RouteTableId'] = $request->routeTableId;
        }

        if (null !== $request->routeTableName) {
            @$query['RouteTableName'] = $request->routeTableName;
        }

        if (null !== $request->routerId) {
            @$query['RouterId'] = $request->routerId;
        }

        if (null !== $request->routerType) {
            @$query['RouterType'] = $request->routerType;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        if (null !== $request->VRouterId) {
            @$query['VRouterId'] = $request->VRouterId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRouteTables',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRouteTablesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Queries route tables.
     *
     * @deprecated openAPI DescribeRouteTables is deprecated, please use Vpc::2016-04-28::DescribeRouteTableList instead
     *
     * @param request - DescribeRouteTablesRequest
     *
     * @returns DescribeRouteTablesResponse
     *
     * @param DescribeRouteTablesRequest $request
     *
     * @return DescribeRouteTablesResponse
     */
    public function describeRouteTables($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRouteTablesWithOptions($request, $runtime);
    }

    /**
     * Queries the configuration of a router interface.
     *
     * @param request - DescribeRouterInterfaceAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRouterInterfaceAttributeResponse
     *
     * @param DescribeRouterInterfaceAttributeRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return DescribeRouterInterfaceAttributeResponse
     */
    public function describeRouterInterfaceAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRouterInterfaceAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRouterInterfaceAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configuration of a router interface.
     *
     * @param request - DescribeRouterInterfaceAttributeRequest
     *
     * @returns DescribeRouterInterfaceAttributeResponse
     *
     * @param DescribeRouterInterfaceAttributeRequest $request
     *
     * @return DescribeRouterInterfaceAttributeResponse
     */
    public function describeRouterInterfaceAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRouterInterfaceAttributeWithOptions($request, $runtime);
    }

    /**
     * Queries router interfaces in a specified region.
     *
     * @param request - DescribeRouterInterfacesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRouterInterfacesResponse
     *
     * @param DescribeRouterInterfacesRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeRouterInterfacesResponse
     */
    public function describeRouterInterfacesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->filter) {
            @$query['Filter'] = $request->filter;
        }

        if (null !== $request->includeReservationData) {
            @$query['IncludeReservationData'] = $request->includeReservationData;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRouterInterfaces',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRouterInterfacesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries router interfaces in a specified region.
     *
     * @param request - DescribeRouterInterfacesRequest
     *
     * @returns DescribeRouterInterfacesResponse
     *
     * @param DescribeRouterInterfacesRequest $request
     *
     * @return DescribeRouterInterfacesResponse
     */
    public function describeRouterInterfaces($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRouterInterfacesWithOptions($request, $runtime);
    }

    /**
     * Queries Global Accelerator (GA) instances that are associated with a backend server.
     *
     * @remarks
     * > You can call this operation to query only dedicated-bandwidth GA instances.
     *
     * @param request - DescribeServerRelatedGlobalAccelerationInstancesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeServerRelatedGlobalAccelerationInstancesResponse
     *
     * @param DescribeServerRelatedGlobalAccelerationInstancesRequest $request
     * @param RuntimeOptions                                          $runtime
     *
     * @return DescribeServerRelatedGlobalAccelerationInstancesResponse
     */
    public function describeServerRelatedGlobalAccelerationInstancesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->serverId) {
            @$query['ServerId'] = $request->serverId;
        }

        if (null !== $request->serverType) {
            @$query['ServerType'] = $request->serverType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeServerRelatedGlobalAccelerationInstances',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeServerRelatedGlobalAccelerationInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries Global Accelerator (GA) instances that are associated with a backend server.
     *
     * @remarks
     * > You can call this operation to query only dedicated-bandwidth GA instances.
     *
     * @param request - DescribeServerRelatedGlobalAccelerationInstancesRequest
     *
     * @returns DescribeServerRelatedGlobalAccelerationInstancesResponse
     *
     * @param DescribeServerRelatedGlobalAccelerationInstancesRequest $request
     *
     * @return DescribeServerRelatedGlobalAccelerationInstancesResponse
     */
    public function describeServerRelatedGlobalAccelerationInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeServerRelatedGlobalAccelerationInstancesWithOptions($request, $runtime);
    }

    /**
     * Queries SNAT entries.
     *
     * @param request - DescribeSnatTableEntriesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSnatTableEntriesResponse
     *
     * @param DescribeSnatTableEntriesRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeSnatTableEntriesResponse
     */
    public function describeSnatTableEntriesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->natGatewayId) {
            @$query['NatGatewayId'] = $request->natGatewayId;
        }

        if (null !== $request->networkInterfaceIds) {
            @$query['NetworkInterfaceIds'] = $request->networkInterfaceIds;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->snatEntryId) {
            @$query['SnatEntryId'] = $request->snatEntryId;
        }

        if (null !== $request->snatEntryName) {
            @$query['SnatEntryName'] = $request->snatEntryName;
        }

        if (null !== $request->snatIp) {
            @$query['SnatIp'] = $request->snatIp;
        }

        if (null !== $request->snatTableId) {
            @$query['SnatTableId'] = $request->snatTableId;
        }

        if (null !== $request->sourceCIDR) {
            @$query['SourceCIDR'] = $request->sourceCIDR;
        }

        if (null !== $request->sourceVSwitchId) {
            @$query['SourceVSwitchId'] = $request->sourceVSwitchId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSnatTableEntries',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSnatTableEntriesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries SNAT entries.
     *
     * @param request - DescribeSnatTableEntriesRequest
     *
     * @returns DescribeSnatTableEntriesResponse
     *
     * @param DescribeSnatTableEntriesRequest $request
     *
     * @return DescribeSnatTableEntriesResponse
     */
    public function describeSnatTableEntries($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSnatTableEntriesWithOptions($request, $runtime);
    }

    /**
     * Queries the details of an SSL client certificate.
     *
     * @param request - DescribeSslVpnClientCertRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSslVpnClientCertResponse
     *
     * @param DescribeSslVpnClientCertRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeSslVpnClientCertResponse
     */
    public function describeSslVpnClientCertWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sslVpnClientCertId) {
            @$query['SslVpnClientCertId'] = $request->sslVpnClientCertId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSslVpnClientCert',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSslVpnClientCertResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of an SSL client certificate.
     *
     * @param request - DescribeSslVpnClientCertRequest
     *
     * @returns DescribeSslVpnClientCertResponse
     *
     * @param DescribeSslVpnClientCertRequest $request
     *
     * @return DescribeSslVpnClientCertResponse
     */
    public function describeSslVpnClientCert($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSslVpnClientCertWithOptions($request, $runtime);
    }

    /**
     * Queries SSL client certificates.
     *
     * @param request - DescribeSslVpnClientCertsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSslVpnClientCertsResponse
     *
     * @param DescribeSslVpnClientCertsRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeSslVpnClientCertsResponse
     */
    public function describeSslVpnClientCertsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sslVpnClientCertId) {
            @$query['SslVpnClientCertId'] = $request->sslVpnClientCertId;
        }

        if (null !== $request->sslVpnServerId) {
            @$query['SslVpnServerId'] = $request->sslVpnServerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSslVpnClientCerts',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSslVpnClientCertsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries SSL client certificates.
     *
     * @param request - DescribeSslVpnClientCertsRequest
     *
     * @returns DescribeSslVpnClientCertsResponse
     *
     * @param DescribeSslVpnClientCertsRequest $request
     *
     * @return DescribeSslVpnClientCertsResponse
     */
    public function describeSslVpnClientCerts($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSslVpnClientCertsWithOptions($request, $runtime);
    }

    /**
     * Queries the clients that have connected to a VPN gateway through SSL-VPN connections.
     *
     * @remarks
     * If your VPN gateway was created before December 10, 2022, you need to upgrade the VPN gateway to the latest version to view the connection information about SSL clients. For more information, see [Upgrade a VPN gateway](https://help.aliyun.com/document_detail/2671058.html).
     * If your VPN gateway was created after December 10, 2022, you can view the connection information about SSL clients by default.
     *
     * @param request - DescribeSslVpnClientsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSslVpnClientsResponse
     *
     * @param DescribeSslVpnClientsRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DescribeSslVpnClientsResponse
     */
    public function describeSslVpnClientsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vpnGatewayId) {
            @$query['VpnGatewayId'] = $request->vpnGatewayId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSslVpnClients',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSslVpnClientsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the clients that have connected to a VPN gateway through SSL-VPN connections.
     *
     * @remarks
     * If your VPN gateway was created before December 10, 2022, you need to upgrade the VPN gateway to the latest version to view the connection information about SSL clients. For more information, see [Upgrade a VPN gateway](https://help.aliyun.com/document_detail/2671058.html).
     * If your VPN gateway was created after December 10, 2022, you can view the connection information about SSL clients by default.
     *
     * @param request - DescribeSslVpnClientsRequest
     *
     * @returns DescribeSslVpnClientsResponse
     *
     * @param DescribeSslVpnClientsRequest $request
     *
     * @return DescribeSslVpnClientsResponse
     */
    public function describeSslVpnClients($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSslVpnClientsWithOptions($request, $runtime);
    }

    /**
     * Queries one or more SSL-VPN servers.
     *
     * @param request - DescribeSslVpnServersRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSslVpnServersResponse
     *
     * @param DescribeSslVpnServersRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DescribeSslVpnServersResponse
     */
    public function describeSslVpnServersWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sslVpnServerId) {
            @$query['SslVpnServerId'] = $request->sslVpnServerId;
        }

        if (null !== $request->vpnGatewayId) {
            @$query['VpnGatewayId'] = $request->vpnGatewayId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSslVpnServers',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSslVpnServersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries one or more SSL-VPN servers.
     *
     * @param request - DescribeSslVpnServersRequest
     *
     * @returns DescribeSslVpnServersResponse
     *
     * @param DescribeSslVpnServersRequest $request
     *
     * @return DescribeSslVpnServersResponse
     */
    public function describeSslVpnServers($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSslVpnServersWithOptions($request, $runtime);
    }

    /**
     * Queries tag keys.
     *
     * @param request - DescribeTagKeysRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeTagKeysResponse
     *
     * @param DescribeTagKeysRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return DescribeTagKeysResponse
     */
    public function describeTagKeysWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->keyword) {
            @$query['Keyword'] = $request->keyword;
        }

        if (null !== $request->maxResult) {
            @$query['MaxResult'] = $request->maxResult;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeTagKeys',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeTagKeysResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries tag keys.
     *
     * @param request - DescribeTagKeysRequest
     *
     * @returns DescribeTagKeysResponse
     *
     * @param DescribeTagKeysRequest $request
     *
     * @return DescribeTagKeysResponse
     */
    public function describeTagKeys($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeTagKeysWithOptions($request, $runtime);
    }

    /**
     * Queries the tags of an Express Connect circuit.
     *
     * @param request - DescribeTagKeysForExpressConnectRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeTagKeysForExpressConnectResponse
     *
     * @param DescribeTagKeysForExpressConnectRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return DescribeTagKeysForExpressConnectResponse
     */
    public function describeTagKeysForExpressConnectWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->keyword) {
            @$query['Keyword'] = $request->keyword;
        }

        if (null !== $request->maxResult) {
            @$query['MaxResult'] = $request->maxResult;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeTagKeysForExpressConnect',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeTagKeysForExpressConnectResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the tags of an Express Connect circuit.
     *
     * @param request - DescribeTagKeysForExpressConnectRequest
     *
     * @returns DescribeTagKeysForExpressConnectResponse
     *
     * @param DescribeTagKeysForExpressConnectRequest $request
     *
     * @return DescribeTagKeysForExpressConnectResponse
     */
    public function describeTagKeysForExpressConnect($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeTagKeysForExpressConnectWithOptions($request, $runtime);
    }

    /**
     * Queries tags that meet the specified filter conditions.
     *
     * @remarks
     *   You must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request to specify the object that you want to query.
     * *   **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified tag key are returned. If you specify only **Tag.N.Value**, an error message is returned.
     * *   If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
     * *   If you specify multiple key-value pairs, all tags that match the key-value pairs are returned.
     *
     * @param request - DescribeTagsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeTagsResponse
     *
     * @param DescribeTagsRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return DescribeTagsResponse
     */
    public function describeTagsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->maxResult) {
            @$query['MaxResult'] = $request->maxResult;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeTags',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeTagsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries tags that meet the specified filter conditions.
     *
     * @remarks
     *   You must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request to specify the object that you want to query.
     * *   **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified tag key are returned. If you specify only **Tag.N.Value**, an error message is returned.
     * *   If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
     * *   If you specify multiple key-value pairs, all tags that match the key-value pairs are returned.
     *
     * @param request - DescribeTagsRequest
     *
     * @returns DescribeTagsResponse
     *
     * @param DescribeTagsRequest $request
     *
     * @return DescribeTagsResponse
     */
    public function describeTags($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeTagsWithOptions($request, $runtime);
    }

    /**
     * Queries vRouters in a region.
     *
     * @param request - DescribeVRoutersRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVRoutersResponse
     *
     * @param DescribeVRoutersRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DescribeVRoutersResponse
     */
    public function describeVRoutersWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->VRouterId) {
            @$query['VRouterId'] = $request->VRouterId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVRouters',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVRoutersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries vRouters in a region.
     *
     * @param request - DescribeVRoutersRequest
     *
     * @returns DescribeVRoutersResponse
     *
     * @param DescribeVRoutersRequest $request
     *
     * @return DescribeVRoutersResponse
     */
    public function describeVRouters($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVRoutersWithOptions($request, $runtime);
    }

    /**
     * Queries the detailed information about a vSwitch.
     *
     * @param request - DescribeVSwitchAttributesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVSwitchAttributesResponse
     *
     * @param DescribeVSwitchAttributesRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeVSwitchAttributesResponse
     */
    public function describeVSwitchAttributesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVSwitchAttributes',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVSwitchAttributesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the detailed information about a vSwitch.
     *
     * @param request - DescribeVSwitchAttributesRequest
     *
     * @returns DescribeVSwitchAttributesResponse
     *
     * @param DescribeVSwitchAttributesRequest $request
     *
     * @return DescribeVSwitchAttributesResponse
     */
    public function describeVSwitchAttributes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVSwitchAttributesWithOptions($request, $runtime);
    }

    /**
     * Queries the information about available vSwitches that are used for an internal network.
     *
     * @param request - DescribeVSwitchesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVSwitchesResponse
     *
     * @param DescribeVSwitchesRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return DescribeVSwitchesResponse
     */
    public function describeVSwitchesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->enableIpv6) {
            @$query['EnableIpv6'] = $request->enableIpv6;
        }

        if (null !== $request->isDefault) {
            @$query['IsDefault'] = $request->isDefault;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeTableId) {
            @$query['RouteTableId'] = $request->routeTableId;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        if (null !== $request->vSwitchName) {
            @$query['VSwitchName'] = $request->vSwitchName;
        }

        if (null !== $request->vSwitchOwnerId) {
            @$query['VSwitchOwnerId'] = $request->vSwitchOwnerId;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        if (null !== $request->zoneId) {
            @$query['ZoneId'] = $request->zoneId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVSwitches',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVSwitchesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about available vSwitches that are used for an internal network.
     *
     * @param request - DescribeVSwitchesRequest
     *
     * @returns DescribeVSwitchesResponse
     *
     * @param DescribeVSwitchesRequest $request
     *
     * @return DescribeVSwitchesResponse
     */
    public function describeVSwitches($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVSwitchesWithOptions($request, $runtime);
    }

    /**
     * Queries virtual border router (VBR) failover groups.
     *
     * @param request - DescribeVbrHaRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVbrHaResponse
     *
     * @param DescribeVbrHaRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return DescribeVbrHaResponse
     */
    public function describeVbrHaWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vbrHaId) {
            @$query['VbrHaId'] = $request->vbrHaId;
        }

        if (null !== $request->vbrId) {
            @$query['VbrId'] = $request->vbrId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVbrHa',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVbrHaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries virtual border router (VBR) failover groups.
     *
     * @param request - DescribeVbrHaRequest
     *
     * @returns DescribeVbrHaResponse
     *
     * @param DescribeVbrHaRequest $request
     *
     * @return DescribeVbrHaResponse
     */
    public function describeVbrHa($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVbrHaWithOptions($request, $runtime);
    }

    /**
     * Queries the routes of an IPsec-VPN connection.
     *
     * @param request - DescribeVcoRouteEntriesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVcoRouteEntriesResponse
     *
     * @param DescribeVcoRouteEntriesRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeVcoRouteEntriesResponse
     */
    public function describeVcoRouteEntriesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeEntryType) {
            @$query['RouteEntryType'] = $request->routeEntryType;
        }

        if (null !== $request->vpnConnectionId) {
            @$query['VpnConnectionId'] = $request->vpnConnectionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVcoRouteEntries',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVcoRouteEntriesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the routes of an IPsec-VPN connection.
     *
     * @param request - DescribeVcoRouteEntriesRequest
     *
     * @returns DescribeVcoRouteEntriesResponse
     *
     * @param DescribeVcoRouteEntriesRequest $request
     *
     * @return DescribeVcoRouteEntriesResponse
     */
    public function describeVcoRouteEntries($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVcoRouteEntriesWithOptions($request, $runtime);
    }

    /**
     * Queries virtual border routers (VBRs).
     *
     * @param request - DescribeVirtualBorderRoutersRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVirtualBorderRoutersResponse
     *
     * @param DescribeVirtualBorderRoutersRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribeVirtualBorderRoutersResponse
     */
    public function describeVirtualBorderRoutersWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->filter) {
            @$query['Filter'] = $request->filter;
        }

        if (null !== $request->includeCrossAccountVbr) {
            @$query['IncludeCrossAccountVbr'] = $request->includeCrossAccountVbr;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVirtualBorderRouters',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVirtualBorderRoutersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries virtual border routers (VBRs).
     *
     * @param request - DescribeVirtualBorderRoutersRequest
     *
     * @returns DescribeVirtualBorderRoutersResponse
     *
     * @param DescribeVirtualBorderRoutersRequest $request
     *
     * @return DescribeVirtualBorderRoutersResponse
     */
    public function describeVirtualBorderRouters($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVirtualBorderRoutersWithOptions($request, $runtime);
    }

    /**
     * Queries the virtual border routers (VBRs) that are associated with an Express Connect circuit. The VBRs can be created by the owner of the Express Connect circuit and by other Alibaba Cloud accounts.
     *
     * @param request - DescribeVirtualBorderRoutersForPhysicalConnectionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVirtualBorderRoutersForPhysicalConnectionResponse
     *
     * @param DescribeVirtualBorderRoutersForPhysicalConnectionRequest $request
     * @param RuntimeOptions                                           $runtime
     *
     * @return DescribeVirtualBorderRoutersForPhysicalConnectionResponse
     */
    public function describeVirtualBorderRoutersForPhysicalConnectionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->filter) {
            @$query['Filter'] = $request->filter;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->physicalConnectionId) {
            @$query['PhysicalConnectionId'] = $request->physicalConnectionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVirtualBorderRoutersForPhysicalConnection',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVirtualBorderRoutersForPhysicalConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the virtual border routers (VBRs) that are associated with an Express Connect circuit. The VBRs can be created by the owner of the Express Connect circuit and by other Alibaba Cloud accounts.
     *
     * @param request - DescribeVirtualBorderRoutersForPhysicalConnectionRequest
     *
     * @returns DescribeVirtualBorderRoutersForPhysicalConnectionResponse
     *
     * @param DescribeVirtualBorderRoutersForPhysicalConnectionRequest $request
     *
     * @return DescribeVirtualBorderRoutersForPhysicalConnectionResponse
     */
    public function describeVirtualBorderRoutersForPhysicalConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVirtualBorderRoutersForPhysicalConnectionWithOptions($request, $runtime);
    }

    /**
     * Queries the configuration of a virtual private cloud (VPC).
     *
     * @param request - DescribeVpcAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVpcAttributeResponse
     *
     * @param DescribeVpcAttributeRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DescribeVpcAttributeResponse
     */
    public function describeVpcAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->isDefault) {
            @$query['IsDefault'] = $request->isDefault;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVpcAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVpcAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configuration of a virtual private cloud (VPC).
     *
     * @param request - DescribeVpcAttributeRequest
     *
     * @returns DescribeVpcAttributeResponse
     *
     * @param DescribeVpcAttributeRequest $request
     *
     * @return DescribeVpcAttributeResponse
     */
    public function describeVpcAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpcAttributeWithOptions($request, $runtime);
    }

    /**
     * Queries the cross-account authorization information of an ECR for a specified network instance.
     *
     * @param request - DescribeVpcGrantRulesToEcrRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVpcGrantRulesToEcrResponse
     *
     * @param DescribeVpcGrantRulesToEcrRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeVpcGrantRulesToEcrResponse
     */
    public function describeVpcGrantRulesToEcrWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ecrInstanceId) {
            @$query['EcrInstanceId'] = $request->ecrInstanceId;
        }

        if (null !== $request->ecrOwnerId) {
            @$query['EcrOwnerId'] = $request->ecrOwnerId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->instanceType) {
            @$query['InstanceType'] = $request->instanceType;
        }

        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVpcGrantRulesToEcr',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVpcGrantRulesToEcrResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the cross-account authorization information of an ECR for a specified network instance.
     *
     * @param request - DescribeVpcGrantRulesToEcrRequest
     *
     * @returns DescribeVpcGrantRulesToEcrResponse
     *
     * @param DescribeVpcGrantRulesToEcrRequest $request
     *
     * @return DescribeVpcGrantRulesToEcrResponse
     */
    public function describeVpcGrantRulesToEcr($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpcGrantRulesToEcrWithOptions($request, $runtime);
    }

    /**
     * Queries virtual private clouds (VPCs).
     *
     * @param request - DescribeVpcsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVpcsResponse
     *
     * @param DescribeVpcsRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return DescribeVpcsResponse
     */
    public function describeVpcsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dhcpOptionsSetId) {
            @$query['DhcpOptionsSetId'] = $request->dhcpOptionsSetId;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->enableIpv6) {
            @$query['EnableIpv6'] = $request->enableIpv6;
        }

        if (null !== $request->isDefault) {
            @$query['IsDefault'] = $request->isDefault;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        if (null !== $request->vpcName) {
            @$query['VpcName'] = $request->vpcName;
        }

        if (null !== $request->vpcOwnerId) {
            @$query['VpcOwnerId'] = $request->vpcOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVpcs',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVpcsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries virtual private clouds (VPCs).
     *
     * @param request - DescribeVpcsRequest
     *
     * @returns DescribeVpcsResponse
     *
     * @param DescribeVpcsRequest $request
     *
     * @return DescribeVpcsResponse
     */
    public function describeVpcs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpcsWithOptions($request, $runtime);
    }

    /**
     * Queries the IPsec-VPN connections associated with a transit router.
     *
     * @param request - DescribeVpnAttachmentsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVpnAttachmentsResponse
     *
     * @param DescribeVpnAttachmentsRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DescribeVpnAttachmentsResponse
     */
    public function describeVpnAttachmentsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->attachType) {
            @$query['AttachType'] = $request->attachType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vpnConnectionId) {
            @$query['VpnConnectionId'] = $request->vpnConnectionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVpnAttachments',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVpnAttachmentsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the IPsec-VPN connections associated with a transit router.
     *
     * @param request - DescribeVpnAttachmentsRequest
     *
     * @returns DescribeVpnAttachmentsResponse
     *
     * @param DescribeVpnAttachmentsRequest $request
     *
     * @return DescribeVpnAttachmentsResponse
     */
    public function describeVpnAttachments($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpnAttachmentsWithOptions($request, $runtime);
    }

    /**
     * Queries the detailed information about an IPsec-VPN connection.
     *
     * @param request - DescribeVpnConnectionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVpnConnectionResponse
     *
     * @param DescribeVpnConnectionRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DescribeVpnConnectionResponse
     */
    public function describeVpnConnectionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vpnConnectionId) {
            @$query['VpnConnectionId'] = $request->vpnConnectionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVpnConnection',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVpnConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the detailed information about an IPsec-VPN connection.
     *
     * @param request - DescribeVpnConnectionRequest
     *
     * @returns DescribeVpnConnectionResponse
     *
     * @param DescribeVpnConnectionRequest $request
     *
     * @return DescribeVpnConnectionResponse
     */
    public function describeVpnConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpnConnectionWithOptions($request, $runtime);
    }

    /**
     * Queries logs of IPsec-VPN connections.
     *
     * @param request - DescribeVpnConnectionLogsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVpnConnectionLogsResponse
     *
     * @param DescribeVpnConnectionLogsRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeVpnConnectionLogsResponse
     */
    public function describeVpnConnectionLogsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        if (null !== $request->minutePeriod) {
            @$query['MinutePeriod'] = $request->minutePeriod;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->to) {
            @$query['To'] = $request->to;
        }

        if (null !== $request->tunnelId) {
            @$query['TunnelId'] = $request->tunnelId;
        }

        if (null !== $request->vpnConnectionId) {
            @$query['VpnConnectionId'] = $request->vpnConnectionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVpnConnectionLogs',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVpnConnectionLogsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries logs of IPsec-VPN connections.
     *
     * @param request - DescribeVpnConnectionLogsRequest
     *
     * @returns DescribeVpnConnectionLogsResponse
     *
     * @param DescribeVpnConnectionLogsRequest $request
     *
     * @return DescribeVpnConnectionLogsResponse
     */
    public function describeVpnConnectionLogs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpnConnectionLogsWithOptions($request, $runtime);
    }

    /**
     * Queries IPsec-VPN connections.
     *
     * @param request - DescribeVpnConnectionsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVpnConnectionsResponse
     *
     * @param DescribeVpnConnectionsRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DescribeVpnConnectionsResponse
     */
    public function describeVpnConnectionsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->customerGatewayId) {
            @$query['CustomerGatewayId'] = $request->customerGatewayId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->vpnConnectionId) {
            @$query['VpnConnectionId'] = $request->vpnConnectionId;
        }

        if (null !== $request->vpnGatewayId) {
            @$query['VpnGatewayId'] = $request->vpnGatewayId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVpnConnections',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVpnConnectionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries IPsec-VPN connections.
     *
     * @param request - DescribeVpnConnectionsRequest
     *
     * @returns DescribeVpnConnectionsResponse
     *
     * @param DescribeVpnConnectionsRequest $request
     *
     * @return DescribeVpnConnectionsResponse
     */
    public function describeVpnConnections($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpnConnectionsWithOptions($request, $runtime);
    }

    /**
     * Queries the cross-account authorization information about an IPsec-VPN connection.
     *
     * @param request - DescribeVpnCrossAccountAuthorizationsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVpnCrossAccountAuthorizationsResponse
     *
     * @param DescribeVpnCrossAccountAuthorizationsRequest $request
     * @param RuntimeOptions                               $runtime
     *
     * @return DescribeVpnCrossAccountAuthorizationsResponse
     */
    public function describeVpnCrossAccountAuthorizationsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vpnConnectionId) {
            @$query['VpnConnectionId'] = $request->vpnConnectionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVpnCrossAccountAuthorizations',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVpnCrossAccountAuthorizationsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the cross-account authorization information about an IPsec-VPN connection.
     *
     * @param request - DescribeVpnCrossAccountAuthorizationsRequest
     *
     * @returns DescribeVpnCrossAccountAuthorizationsResponse
     *
     * @param DescribeVpnCrossAccountAuthorizationsRequest $request
     *
     * @return DescribeVpnCrossAccountAuthorizationsResponse
     */
    public function describeVpnCrossAccountAuthorizations($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpnCrossAccountAuthorizationsWithOptions($request, $runtime);
    }

    /**
     * Queries the detailed information about a VPN gateway.
     *
     * @param request - DescribeVpnGatewayRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVpnGatewayResponse
     *
     * @param DescribeVpnGatewayRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return DescribeVpnGatewayResponse
     */
    public function describeVpnGatewayWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->includeReservationData) {
            @$query['IncludeReservationData'] = $request->includeReservationData;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vpnGatewayId) {
            @$query['VpnGatewayId'] = $request->vpnGatewayId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVpnGateway',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVpnGatewayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the detailed information about a VPN gateway.
     *
     * @param request - DescribeVpnGatewayRequest
     *
     * @returns DescribeVpnGatewayResponse
     *
     * @param DescribeVpnGatewayRequest $request
     *
     * @return DescribeVpnGatewayResponse
     */
    public function describeVpnGateway($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpnGatewayWithOptions($request, $runtime);
    }

    /**
     * Queries zones that support IPsec-VPN connections in a region.
     *
     * @param request - DescribeVpnGatewayAvailableZonesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVpnGatewayAvailableZonesResponse
     *
     * @param DescribeVpnGatewayAvailableZonesRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return DescribeVpnGatewayAvailableZonesResponse
     */
    public function describeVpnGatewayAvailableZonesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVpnGatewayAvailableZones',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVpnGatewayAvailableZonesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries zones that support IPsec-VPN connections in a region.
     *
     * @param request - DescribeVpnGatewayAvailableZonesRequest
     *
     * @returns DescribeVpnGatewayAvailableZonesResponse
     *
     * @param DescribeVpnGatewayAvailableZonesRequest $request
     *
     * @return DescribeVpnGatewayAvailableZonesResponse
     */
    public function describeVpnGatewayAvailableZones($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpnGatewayAvailableZonesWithOptions($request, $runtime);
    }

    /**
     * Queries VPN gateways in a region.
     *
     * @param request - DescribeVpnGatewaysRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVpnGatewaysResponse
     *
     * @param DescribeVpnGatewaysRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DescribeVpnGatewaysResponse
     */
    public function describeVpnGatewaysWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->businessStatus) {
            @$query['BusinessStatus'] = $request->businessStatus;
        }

        if (null !== $request->includeReservationData) {
            @$query['IncludeReservationData'] = $request->includeReservationData;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        if (null !== $request->vpnGatewayId) {
            @$query['VpnGatewayId'] = $request->vpnGatewayId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVpnGateways',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVpnGatewaysResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries VPN gateways in a region.
     *
     * @param request - DescribeVpnGatewaysRequest
     *
     * @returns DescribeVpnGatewaysResponse
     *
     * @param DescribeVpnGatewaysRequest $request
     *
     * @return DescribeVpnGatewaysResponse
     */
    public function describeVpnGateways($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpnGatewaysWithOptions($request, $runtime);
    }

    /**
     * Queries policy-based routes configured for a VPN gateway.
     *
     * @param request - DescribeVpnPbrRouteEntriesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVpnPbrRouteEntriesResponse
     *
     * @param DescribeVpnPbrRouteEntriesRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeVpnPbrRouteEntriesResponse
     */
    public function describeVpnPbrRouteEntriesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vpnGatewayId) {
            @$query['VpnGatewayId'] = $request->vpnGatewayId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVpnPbrRouteEntries',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVpnPbrRouteEntriesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries policy-based routes configured for a VPN gateway.
     *
     * @param request - DescribeVpnPbrRouteEntriesRequest
     *
     * @returns DescribeVpnPbrRouteEntriesResponse
     *
     * @param DescribeVpnPbrRouteEntriesRequest $request
     *
     * @return DescribeVpnPbrRouteEntriesResponse
     */
    public function describeVpnPbrRouteEntries($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpnPbrRouteEntriesWithOptions($request, $runtime);
    }

    /**
     * Queries destination-based and BGP route entries of a VPN gateway.
     *
     * @param request - DescribeVpnRouteEntriesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVpnRouteEntriesResponse
     *
     * @param DescribeVpnRouteEntriesRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeVpnRouteEntriesResponse
     */
    public function describeVpnRouteEntriesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeEntryType) {
            @$query['RouteEntryType'] = $request->routeEntryType;
        }

        if (null !== $request->vpnGatewayId) {
            @$query['VpnGatewayId'] = $request->vpnGatewayId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVpnRouteEntries',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVpnRouteEntriesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries destination-based and BGP route entries of a VPN gateway.
     *
     * @param request - DescribeVpnRouteEntriesRequest
     *
     * @returns DescribeVpnRouteEntriesResponse
     *
     * @param DescribeVpnRouteEntriesRequest $request
     *
     * @return DescribeVpnRouteEntriesResponse
     */
    public function describeVpnRouteEntries($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpnRouteEntriesWithOptions($request, $runtime);
    }

    /**
     * Queries the log entries of an SSL server.
     *
     * @param request - DescribeVpnSslServerLogsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVpnSslServerLogsResponse
     *
     * @param DescribeVpnSslServerLogsRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeVpnSslServerLogsResponse
     */
    public function describeVpnSslServerLogsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        if (null !== $request->minutePeriod) {
            @$query['MinutePeriod'] = $request->minutePeriod;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sslVpnClientCertId) {
            @$query['SslVpnClientCertId'] = $request->sslVpnClientCertId;
        }

        if (null !== $request->to) {
            @$query['To'] = $request->to;
        }

        if (null !== $request->vpnSslServerId) {
            @$query['VpnSslServerId'] = $request->vpnSslServerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVpnSslServerLogs',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVpnSslServerLogsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the log entries of an SSL server.
     *
     * @param request - DescribeVpnSslServerLogsRequest
     *
     * @returns DescribeVpnSslServerLogsResponse
     *
     * @param DescribeVpnSslServerLogsRequest $request
     *
     * @return DescribeVpnSslServerLogsResponse
     */
    public function describeVpnSslServerLogs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpnSslServerLogsWithOptions($request, $runtime);
    }

    /**
     * Queries zones in a region.
     *
     * @param request - DescribeZonesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeZonesResponse
     *
     * @param DescribeZonesRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return DescribeZonesResponse
     */
    public function describeZonesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceptLanguage) {
            @$query['AcceptLanguage'] = $request->acceptLanguage;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->zoneType) {
            @$query['ZoneType'] = $request->zoneType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeZones',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeZonesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries zones in a region.
     *
     * @param request - DescribeZonesRequest
     *
     * @returns DescribeZonesResponse
     *
     * @param DescribeZonesRequest $request
     *
     * @return DescribeZonesResponse
     */
    public function describeZones($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeZonesWithOptions($request, $runtime);
    }

    /**
     * Disassociates a DHCP options set from a virtual private cloud (VPC).
     *
     * @remarks
     * ## [](#)Description
     * *   **DetachDhcpOptionsSetFromVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task.
     *     *   If the DHCP options set is in the **Pending** state, the DHCP options set is being disassociated.
     *     *   If the DHCP options set is in the **UnUsed** state, the DHCP options set is disassociated.
     * *   You cannot repeatedly call the **DetachDhcpOptionsSetFromVpc** operation to disassociate a DHCP options set from a VPC within the specified period of time.
     *
     * @param request - DetachDhcpOptionsSetFromVpcRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DetachDhcpOptionsSetFromVpcResponse
     *
     * @param DetachDhcpOptionsSetFromVpcRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DetachDhcpOptionsSetFromVpcResponse
     */
    public function detachDhcpOptionsSetFromVpcWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dhcpOptionsSetId) {
            @$query['DhcpOptionsSetId'] = $request->dhcpOptionsSetId;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DetachDhcpOptionsSetFromVpc',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DetachDhcpOptionsSetFromVpcResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Disassociates a DHCP options set from a virtual private cloud (VPC).
     *
     * @remarks
     * ## [](#)Description
     * *   **DetachDhcpOptionsSetFromVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task.
     *     *   If the DHCP options set is in the **Pending** state, the DHCP options set is being disassociated.
     *     *   If the DHCP options set is in the **UnUsed** state, the DHCP options set is disassociated.
     * *   You cannot repeatedly call the **DetachDhcpOptionsSetFromVpc** operation to disassociate a DHCP options set from a VPC within the specified period of time.
     *
     * @param request - DetachDhcpOptionsSetFromVpcRequest
     *
     * @returns DetachDhcpOptionsSetFromVpcResponse
     *
     * @param DetachDhcpOptionsSetFromVpcRequest $request
     *
     * @return DetachDhcpOptionsSetFromVpcResponse
     */
    public function detachDhcpOptionsSetFromVpc($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->detachDhcpOptionsSetFromVpcWithOptions($request, $runtime);
    }

    /**
     * Diagnoses IPsec-VPN connections.
     *
     * @remarks
     *   If the IPsec-VPN connection is in single-tunnel mode, the request parameter `VpnConnectionIds` is required when you call the **DiagnoseVpnConnections** operation.
     * *   If the IPsec-VPN connection is in dual-tunnel mode, the request parameter `TunnelIds` is required when you call the **DiagnoseVpnConnections** operation.
     * *   After you call the **DiagnoseVpnConnections** operation, if the current IPsec-VPN connection is faulty, the operation returns the corresponding error code (**FailedReasonCode**) and log (**SourceLog**). You can troubleshoot based on the error code and log information. For more information, see [Common errors and troubleshooting methods for IPsec-VPN connections](https://help.aliyun.com/document_detail/477862.html).
     *
     * @param request - DiagnoseVpnConnectionsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DiagnoseVpnConnectionsResponse
     *
     * @param DiagnoseVpnConnectionsRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DiagnoseVpnConnectionsResponse
     */
    public function diagnoseVpnConnectionsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tunnelIds) {
            @$query['TunnelIds'] = $request->tunnelIds;
        }

        if (null !== $request->vpnConnectionIds) {
            @$query['VpnConnectionIds'] = $request->vpnConnectionIds;
        }

        if (null !== $request->vpnGatewayId) {
            @$query['VpnGatewayId'] = $request->vpnGatewayId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DiagnoseVpnConnections',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DiagnoseVpnConnectionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Diagnoses IPsec-VPN connections.
     *
     * @remarks
     *   If the IPsec-VPN connection is in single-tunnel mode, the request parameter `VpnConnectionIds` is required when you call the **DiagnoseVpnConnections** operation.
     * *   If the IPsec-VPN connection is in dual-tunnel mode, the request parameter `TunnelIds` is required when you call the **DiagnoseVpnConnections** operation.
     * *   After you call the **DiagnoseVpnConnections** operation, if the current IPsec-VPN connection is faulty, the operation returns the corresponding error code (**FailedReasonCode**) and log (**SourceLog**). You can troubleshoot based on the error code and log information. For more information, see [Common errors and troubleshooting methods for IPsec-VPN connections](https://help.aliyun.com/document_detail/477862.html).
     *
     * @param request - DiagnoseVpnConnectionsRequest
     *
     * @returns DiagnoseVpnConnectionsResponse
     *
     * @param DiagnoseVpnConnectionsRequest $request
     *
     * @return DiagnoseVpnConnectionsResponse
     */
    public function diagnoseVpnConnections($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->diagnoseVpnConnectionsWithOptions($request, $runtime);
    }

    /**
     * Diagnoses a VPN gateway.
     *
     * @param request - DiagnoseVpnGatewayRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DiagnoseVpnGatewayResponse
     *
     * @param DiagnoseVpnGatewayRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return DiagnoseVpnGatewayResponse
     */
    public function diagnoseVpnGatewayWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->IPsecExtendInfo) {
            @$query['IPsecExtendInfo'] = $request->IPsecExtendInfo;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        if (null !== $request->vpnGatewayId) {
            @$query['VpnGatewayId'] = $request->vpnGatewayId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DiagnoseVpnGateway',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DiagnoseVpnGatewayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Diagnoses a VPN gateway.
     *
     * @param request - DiagnoseVpnGatewayRequest
     *
     * @returns DiagnoseVpnGatewayResponse
     *
     * @param DiagnoseVpnGatewayRequest $request
     *
     * @return DiagnoseVpnGatewayResponse
     */
    public function diagnoseVpnGateway($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->diagnoseVpnGatewayWithOptions($request, $runtime);
    }

    /**
     * Disables traffic monitoring for an Elastic Compute Service (ECS) instance.
     *
     * @deprecated OpenAPI DisableNatGatewayEcsMetric is deprecated
     *
     * @param request - DisableNatGatewayEcsMetricRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DisableNatGatewayEcsMetricResponse
     *
     * @param DisableNatGatewayEcsMetricRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DisableNatGatewayEcsMetricResponse
     */
    public function disableNatGatewayEcsMetricWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->natGatewayId) {
            @$query['NatGatewayId'] = $request->natGatewayId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DisableNatGatewayEcsMetric',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DisableNatGatewayEcsMetricResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Disables traffic monitoring for an Elastic Compute Service (ECS) instance.
     *
     * @deprecated OpenAPI DisableNatGatewayEcsMetric is deprecated
     *
     * @param request - DisableNatGatewayEcsMetricRequest
     *
     * @returns DisableNatGatewayEcsMetricResponse
     *
     * @param DisableNatGatewayEcsMetricRequest $request
     *
     * @return DisableNatGatewayEcsMetricResponse
     */
    public function disableNatGatewayEcsMetric($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->disableNatGatewayEcsMetricWithOptions($request, $runtime);
    }

    /**
     * Disables ClassicLink for a virtual private cloud (VPC).
     *
     * @param request - DisableVpcClassicLinkRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DisableVpcClassicLinkResponse
     *
     * @param DisableVpcClassicLinkRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DisableVpcClassicLinkResponse
     */
    public function disableVpcClassicLinkWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DisableVpcClassicLink',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DisableVpcClassicLinkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Disables ClassicLink for a virtual private cloud (VPC).
     *
     * @param request - DisableVpcClassicLinkRequest
     *
     * @returns DisableVpcClassicLinkResponse
     *
     * @param DisableVpcClassicLinkRequest $request
     *
     * @return DisableVpcClassicLinkResponse
     */
    public function disableVpcClassicLink($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->disableVpcClassicLinkWithOptions($request, $runtime);
    }

    /**
     * Disassociates a gateway route table from an IPv4 gateway.
     *
     * @param request - DissociateRouteTableFromGatewayRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DissociateRouteTableFromGatewayResponse
     *
     * @param DissociateRouteTableFromGatewayRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return DissociateRouteTableFromGatewayResponse
     */
    public function dissociateRouteTableFromGatewayWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->gatewayId) {
            @$query['GatewayId'] = $request->gatewayId;
        }

        if (null !== $request->gatewayType) {
            @$query['GatewayType'] = $request->gatewayType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeTableId) {
            @$query['RouteTableId'] = $request->routeTableId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DissociateRouteTableFromGateway',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DissociateRouteTableFromGatewayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Disassociates a gateway route table from an IPv4 gateway.
     *
     * @param request - DissociateRouteTableFromGatewayRequest
     *
     * @returns DissociateRouteTableFromGatewayResponse
     *
     * @param DissociateRouteTableFromGatewayRequest $request
     *
     * @return DissociateRouteTableFromGatewayResponse
     */
    public function dissociateRouteTableFromGateway($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dissociateRouteTableFromGatewayWithOptions($request, $runtime);
    }

    /**
     * Disassociates a gateway endpoint from a route table.
     *
     * @param request - DissociateRouteTablesFromVpcGatewayEndpointRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DissociateRouteTablesFromVpcGatewayEndpointResponse
     *
     * @param DissociateRouteTablesFromVpcGatewayEndpointRequest $request
     * @param RuntimeOptions                                     $runtime
     *
     * @return DissociateRouteTablesFromVpcGatewayEndpointResponse
     */
    public function dissociateRouteTablesFromVpcGatewayEndpointWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->endpointId) {
            @$query['EndpointId'] = $request->endpointId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeTableIds) {
            @$query['RouteTableIds'] = $request->routeTableIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DissociateRouteTablesFromVpcGatewayEndpoint',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DissociateRouteTablesFromVpcGatewayEndpointResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Disassociates a gateway endpoint from a route table.
     *
     * @param request - DissociateRouteTablesFromVpcGatewayEndpointRequest
     *
     * @returns DissociateRouteTablesFromVpcGatewayEndpointResponse
     *
     * @param DissociateRouteTablesFromVpcGatewayEndpointRequest $request
     *
     * @return DissociateRouteTablesFromVpcGatewayEndpointResponse
     */
    public function dissociateRouteTablesFromVpcGatewayEndpoint($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dissociateRouteTablesFromVpcGatewayEndpointWithOptions($request, $runtime);
    }

    /**
     * Disassociates a certificate from a VPN gateway.
     *
     * @remarks
     *   **DissociateVpnGatewayWithCertificate** is an asynchronous operation. After a request is sent, the system returns a request and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status the task.
     *     *   If the VPN gateway is in the **updating** state, the SSL certificate is being disassociated from the VPN gateway.
     *     *   If the VPN gateway is in the **active** state, the SSL certificate is disassociated from the VPN gateway.
     * *   You cannot repeatedly call **DissociateVpnGatewayWithCertificate** within a specific period of time.
     *
     * @param request - DissociateVpnGatewayWithCertificateRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DissociateVpnGatewayWithCertificateResponse
     *
     * @param DissociateVpnGatewayWithCertificateRequest $request
     * @param RuntimeOptions                             $runtime
     *
     * @return DissociateVpnGatewayWithCertificateResponse
     */
    public function dissociateVpnGatewayWithCertificateWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->certificateId) {
            @$query['CertificateId'] = $request->certificateId;
        }

        if (null !== $request->certificateType) {
            @$query['CertificateType'] = $request->certificateType;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->vpnGatewayId) {
            @$query['VpnGatewayId'] = $request->vpnGatewayId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DissociateVpnGatewayWithCertificate',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DissociateVpnGatewayWithCertificateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Disassociates a certificate from a VPN gateway.
     *
     * @remarks
     *   **DissociateVpnGatewayWithCertificate** is an asynchronous operation. After a request is sent, the system returns a request and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status the task.
     *     *   If the VPN gateway is in the **updating** state, the SSL certificate is being disassociated from the VPN gateway.
     *     *   If the VPN gateway is in the **active** state, the SSL certificate is disassociated from the VPN gateway.
     * *   You cannot repeatedly call **DissociateVpnGatewayWithCertificate** within a specific period of time.
     *
     * @param request - DissociateVpnGatewayWithCertificateRequest
     *
     * @returns DissociateVpnGatewayWithCertificateResponse
     *
     * @param DissociateVpnGatewayWithCertificateRequest $request
     *
     * @return DissociateVpnGatewayWithCertificateResponse
     */
    public function dissociateVpnGatewayWithCertificate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dissociateVpnGatewayWithCertificateWithOptions($request, $runtime);
    }

    /**
     * Queries the configuration of an IPsec-VPN connection.
     *
     * @param request - DownloadVpnConnectionConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DownloadVpnConnectionConfigResponse
     *
     * @param DownloadVpnConnectionConfigRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DownloadVpnConnectionConfigResponse
     */
    public function downloadVpnConnectionConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vpnConnectionId) {
            @$query['VpnConnectionId'] = $request->vpnConnectionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DownloadVpnConnectionConfig',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DownloadVpnConnectionConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configuration of an IPsec-VPN connection.
     *
     * @param request - DownloadVpnConnectionConfigRequest
     *
     * @returns DownloadVpnConnectionConfigResponse
     *
     * @param DownloadVpnConnectionConfigRequest $request
     *
     * @return DownloadVpnConnectionConfigResponse
     */
    public function downloadVpnConnectionConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->downloadVpnConnectionConfigWithOptions($request, $runtime);
    }

    /**
     * Enables Elastic Compute Service (ECS) traffic monitoring.
     *
     * @deprecated OpenAPI EnableNatGatewayEcsMetric is deprecated
     *
     * @param request - EnableNatGatewayEcsMetricRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns EnableNatGatewayEcsMetricResponse
     *
     * @param EnableNatGatewayEcsMetricRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return EnableNatGatewayEcsMetricResponse
     */
    public function enableNatGatewayEcsMetricWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->natGatewayId) {
            @$query['NatGatewayId'] = $request->natGatewayId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'EnableNatGatewayEcsMetric',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return EnableNatGatewayEcsMetricResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Enables Elastic Compute Service (ECS) traffic monitoring.
     *
     * @deprecated OpenAPI EnableNatGatewayEcsMetric is deprecated
     *
     * @param request - EnableNatGatewayEcsMetricRequest
     *
     * @returns EnableNatGatewayEcsMetricResponse
     *
     * @param EnableNatGatewayEcsMetricRequest $request
     *
     * @return EnableNatGatewayEcsMetricResponse
     */
    public function enableNatGatewayEcsMetric($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->enableNatGatewayEcsMetricWithOptions($request, $runtime);
    }

    /**
     * Enables an Express Connect circuit that is in the Confirmed state. After you perform this operation, the Express Connect circuit enters the Enabled state.
     *
     * @remarks
     * When you call this operation, take note of the following limits:
     * *   You can enable only an Express Connect circuit that is in the **Confirmed** state.
     * *   After you enable an Express Connect circuit, it enters the **Enabled** state.
     * *   **EnablePhysicalConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribePhysicalConnections](https://help.aliyun.com/document_detail/36042.html) operation to query the status of the task.
     * *   You cannot repeatedly call **EnablePhysicalConnection** for an Express Connect circuit in the **Confirmed** state within a specific time period.
     *
     * @param request - EnablePhysicalConnectionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns EnablePhysicalConnectionResponse
     *
     * @param EnablePhysicalConnectionRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return EnablePhysicalConnectionResponse
     */
    public function enablePhysicalConnectionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->byPassSp) {
            @$query['ByPassSp'] = $request->byPassSp;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->physicalConnectionId) {
            @$query['PhysicalConnectionId'] = $request->physicalConnectionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'EnablePhysicalConnection',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return EnablePhysicalConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables an Express Connect circuit that is in the Confirmed state. After you perform this operation, the Express Connect circuit enters the Enabled state.
     *
     * @remarks
     * When you call this operation, take note of the following limits:
     * *   You can enable only an Express Connect circuit that is in the **Confirmed** state.
     * *   After you enable an Express Connect circuit, it enters the **Enabled** state.
     * *   **EnablePhysicalConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribePhysicalConnections](https://help.aliyun.com/document_detail/36042.html) operation to query the status of the task.
     * *   You cannot repeatedly call **EnablePhysicalConnection** for an Express Connect circuit in the **Confirmed** state within a specific time period.
     *
     * @param request - EnablePhysicalConnectionRequest
     *
     * @returns EnablePhysicalConnectionResponse
     *
     * @param EnablePhysicalConnectionRequest $request
     *
     * @return EnablePhysicalConnectionResponse
     */
    public function enablePhysicalConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->enablePhysicalConnectionWithOptions($request, $runtime);
    }

    /**
     * Enables ClassicLink for a VPC.
     *
     * @param request - EnableVpcClassicLinkRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns EnableVpcClassicLinkResponse
     *
     * @param EnableVpcClassicLinkRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return EnableVpcClassicLinkResponse
     */
    public function enableVpcClassicLinkWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'EnableVpcClassicLink',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return EnableVpcClassicLinkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables ClassicLink for a VPC.
     *
     * @param request - EnableVpcClassicLinkRequest
     *
     * @returns EnableVpcClassicLinkResponse
     *
     * @param EnableVpcClassicLinkRequest $request
     *
     * @return EnableVpcClassicLinkResponse
     */
    public function enableVpcClassicLink($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->enableVpcClassicLinkWithOptions($request, $runtime);
    }

    /**
     * Activates an IPv4 gateway.
     *
     * @remarks
     * ## [](#)Description
     * *   **EnableVpcIpv4Gateway** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of an IPv4 gateway.
     *     *   If the IPv4 gateway is in the **Activating** state, the IPv4 gateway is being activated.
     *     *   If the IPv4 gateway is in the **Created** state, the IPv4 gateway is activated.
     * *   You cannot repeatedly call the **EnableVpcIpv4Gateway** operation to activate an IPv4 gateway within the specified period of time.
     *
     * @param request - EnableVpcIpv4GatewayRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns EnableVpcIpv4GatewayResponse
     *
     * @param EnableVpcIpv4GatewayRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return EnableVpcIpv4GatewayResponse
     */
    public function enableVpcIpv4GatewayWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ipv4GatewayId) {
            @$query['Ipv4GatewayId'] = $request->ipv4GatewayId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeTableList) {
            @$query['RouteTableList'] = $request->routeTableList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'EnableVpcIpv4Gateway',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return EnableVpcIpv4GatewayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Activates an IPv4 gateway.
     *
     * @remarks
     * ## [](#)Description
     * *   **EnableVpcIpv4Gateway** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of an IPv4 gateway.
     *     *   If the IPv4 gateway is in the **Activating** state, the IPv4 gateway is being activated.
     *     *   If the IPv4 gateway is in the **Created** state, the IPv4 gateway is activated.
     * *   You cannot repeatedly call the **EnableVpcIpv4Gateway** operation to activate an IPv4 gateway within the specified period of time.
     *
     * @param request - EnableVpcIpv4GatewayRequest
     *
     * @returns EnableVpcIpv4GatewayResponse
     *
     * @param EnableVpcIpv4GatewayRequest $request
     *
     * @return EnableVpcIpv4GatewayResponse
     */
    public function enableVpcIpv4Gateway($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->enableVpcIpv4GatewayWithOptions($request, $runtime);
    }

    /**
     * Queries a DHCP options set.
     *
     * @param request - GetDhcpOptionsSetRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetDhcpOptionsSetResponse
     *
     * @param GetDhcpOptionsSetRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return GetDhcpOptionsSetResponse
     */
    public function getDhcpOptionsSetWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dhcpOptionsSetId) {
            @$query['DhcpOptionsSetId'] = $request->dhcpOptionsSetId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetDhcpOptionsSet',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetDhcpOptionsSetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a DHCP options set.
     *
     * @param request - GetDhcpOptionsSetRequest
     *
     * @returns GetDhcpOptionsSetResponse
     *
     * @param GetDhcpOptionsSetRequest $request
     *
     * @return GetDhcpOptionsSetResponse
     */
    public function getDhcpOptionsSet($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDhcpOptionsSetWithOptions($request, $runtime);
    }

    /**
     * Queries the status of a flow log.
     *
     * @param request - GetFlowLogServiceStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetFlowLogServiceStatusResponse
     *
     * @param GetFlowLogServiceStatusRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return GetFlowLogServiceStatusResponse
     */
    public function getFlowLogServiceStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetFlowLogServiceStatus',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetFlowLogServiceStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the status of a flow log.
     *
     * @param request - GetFlowLogServiceStatusRequest
     *
     * @returns GetFlowLogServiceStatusResponse
     *
     * @param GetFlowLogServiceStatusRequest $request
     *
     * @return GetFlowLogServiceStatusResponse
     */
    public function getFlowLogServiceStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFlowLogServiceStatusWithOptions($request, $runtime);
    }

    /**
     * Queries an IPv4 gateway.
     *
     * @param request - GetIpv4GatewayAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetIpv4GatewayAttributeResponse
     *
     * @param GetIpv4GatewayAttributeRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return GetIpv4GatewayAttributeResponse
     */
    public function getIpv4GatewayAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ipv4GatewayId) {
            @$query['Ipv4GatewayId'] = $request->ipv4GatewayId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetIpv4GatewayAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetIpv4GatewayAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries an IPv4 gateway.
     *
     * @param request - GetIpv4GatewayAttributeRequest
     *
     * @returns GetIpv4GatewayAttributeResponse
     *
     * @param GetIpv4GatewayAttributeRequest $request
     *
     * @return GetIpv4GatewayAttributeResponse
     */
    public function getIpv4GatewayAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getIpv4GatewayAttributeWithOptions($request, $runtime);
    }

    /**
     * NAT.
     *
     * @remarks
     * You can call this operation to query information about a specified Internet NAT gateway or Virtual Private Cloud (VPC) NAT gateway. In this topic, "NAT gateway" refers to both gateway types.
     *
     * @param request - GetNatGatewayAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetNatGatewayAttributeResponse
     *
     * @param GetNatGatewayAttributeRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return GetNatGatewayAttributeResponse
     */
    public function getNatGatewayAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->natGatewayId) {
            @$query['NatGatewayId'] = $request->natGatewayId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetNatGatewayAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetNatGatewayAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * NAT.
     *
     * @remarks
     * You can call this operation to query information about a specified Internet NAT gateway or Virtual Private Cloud (VPC) NAT gateway. In this topic, "NAT gateway" refers to both gateway types.
     *
     * @param request - GetNatGatewayAttributeRequest
     *
     * @returns GetNatGatewayAttributeResponse
     *
     * @param GetNatGatewayAttributeRequest $request
     *
     * @return GetNatGatewayAttributeResponse
     */
    public function getNatGatewayAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getNatGatewayAttributeWithOptions($request, $runtime);
    }

    /**
     * 
     *
     * @remarks
     * You can call this API operation to query the status of outbound data transfer billing for the current account. For more information about outbound data transfer billing, see [Outbound data transfer billing](https://help.aliyun.com/document_detail/274385.html) and [Billing](https://help.aliyun.com/document_detail/54582.html).
     *
     * @param request - GetPhysicalConnectionServiceStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetPhysicalConnectionServiceStatusResponse
     *
     * @param GetPhysicalConnectionServiceStatusRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return GetPhysicalConnectionServiceStatusResponse
     */
    public function getPhysicalConnectionServiceStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetPhysicalConnectionServiceStatus',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetPhysicalConnectionServiceStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 
     *
     * @remarks
     * You can call this API operation to query the status of outbound data transfer billing for the current account. For more information about outbound data transfer billing, see [Outbound data transfer billing](https://help.aliyun.com/document_detail/274385.html) and [Billing](https://help.aliyun.com/document_detail/54582.html).
     *
     * @param request - GetPhysicalConnectionServiceStatusRequest
     *
     * @returns GetPhysicalConnectionServiceStatusResponse
     *
     * @param GetPhysicalConnectionServiceStatusRequest $request
     *
     * @return GetPhysicalConnectionServiceStatusResponse
     */
    public function getPhysicalConnectionServiceStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getPhysicalConnectionServiceStatusWithOptions($request, $runtime);
    }

    /**
     * Queries whether the IP address pool feature is enabled.
     *
     * @param request - GetPublicIpAddressPoolServiceStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetPublicIpAddressPoolServiceStatusResponse
     *
     * @param GetPublicIpAddressPoolServiceStatusRequest $request
     * @param RuntimeOptions                             $runtime
     *
     * @return GetPublicIpAddressPoolServiceStatusResponse
     */
    public function getPublicIpAddressPoolServiceStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetPublicIpAddressPoolServiceStatus',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetPublicIpAddressPoolServiceStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries whether the IP address pool feature is enabled.
     *
     * @param request - GetPublicIpAddressPoolServiceStatusRequest
     *
     * @returns GetPublicIpAddressPoolServiceStatusResponse
     *
     * @param GetPublicIpAddressPoolServiceStatusRequest $request
     *
     * @return GetPublicIpAddressPoolServiceStatusResponse
     */
    public function getPublicIpAddressPoolServiceStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getPublicIpAddressPoolServiceStatusWithOptions($request, $runtime);
    }

    /**
     * Queries the status of the traffic mirror feature.
     *
     * @param request - GetTrafficMirrorServiceStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetTrafficMirrorServiceStatusResponse
     *
     * @param GetTrafficMirrorServiceStatusRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return GetTrafficMirrorServiceStatusResponse
     */
    public function getTrafficMirrorServiceStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetTrafficMirrorServiceStatus',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetTrafficMirrorServiceStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the status of the traffic mirror feature.
     *
     * @param request - GetTrafficMirrorServiceStatusRequest
     *
     * @returns GetTrafficMirrorServiceStatusResponse
     *
     * @param GetTrafficMirrorServiceStatusRequest $request
     *
     * @return GetTrafficMirrorServiceStatusResponse
     */
    public function getTrafficMirrorServiceStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getTrafficMirrorServiceStatusWithOptions($request, $runtime);
    }

    /**
     * Queries the usage of a prefix list.
     *
     * @param request - GetVSwitchCidrReservationUsageRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetVSwitchCidrReservationUsageResponse
     *
     * @param GetVSwitchCidrReservationUsageRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return GetVSwitchCidrReservationUsageResponse
     */
    public function getVSwitchCidrReservationUsageWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vSwitchCidrReservationId) {
            @$query['VSwitchCidrReservationId'] = $request->vSwitchCidrReservationId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetVSwitchCidrReservationUsage',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetVSwitchCidrReservationUsageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the usage of a prefix list.
     *
     * @param request - GetVSwitchCidrReservationUsageRequest
     *
     * @returns GetVSwitchCidrReservationUsageResponse
     *
     * @param GetVSwitchCidrReservationUsageRequest $request
     *
     * @return GetVSwitchCidrReservationUsageResponse
     */
    public function getVSwitchCidrReservationUsage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getVSwitchCidrReservationUsageWithOptions($request, $runtime);
    }

    /**
     * Queries the attributes of a gateway endpoint.
     *
     * @param request - GetVpcGatewayEndpointAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetVpcGatewayEndpointAttributeResponse
     *
     * @param GetVpcGatewayEndpointAttributeRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return GetVpcGatewayEndpointAttributeResponse
     */
    public function getVpcGatewayEndpointAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->endpointId) {
            @$query['EndpointId'] = $request->endpointId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetVpcGatewayEndpointAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetVpcGatewayEndpointAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the attributes of a gateway endpoint.
     *
     * @param request - GetVpcGatewayEndpointAttributeRequest
     *
     * @returns GetVpcGatewayEndpointAttributeResponse
     *
     * @param GetVpcGatewayEndpointAttributeRequest $request
     *
     * @return GetVpcGatewayEndpointAttributeResponse
     */
    public function getVpcGatewayEndpointAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getVpcGatewayEndpointAttributeWithOptions($request, $runtime);
    }

    /**
     * Queries the resources that are associated with a prefix list.
     *
     * @param request - GetVpcPrefixListAssociationsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetVpcPrefixListAssociationsResponse
     *
     * @param GetVpcPrefixListAssociationsRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return GetVpcPrefixListAssociationsResponse
     */
    public function getVpcPrefixListAssociationsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->prefixListId) {
            @$query['PrefixListId'] = $request->prefixListId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetVpcPrefixListAssociations',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetVpcPrefixListAssociationsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the resources that are associated with a prefix list.
     *
     * @param request - GetVpcPrefixListAssociationsRequest
     *
     * @returns GetVpcPrefixListAssociationsResponse
     *
     * @param GetVpcPrefixListAssociationsRequest $request
     *
     * @return GetVpcPrefixListAssociationsResponse
     */
    public function getVpcPrefixListAssociations($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getVpcPrefixListAssociationsWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a prefix list.
     *
     * @param request - GetVpcPrefixListEntriesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetVpcPrefixListEntriesResponse
     *
     * @param GetVpcPrefixListEntriesRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return GetVpcPrefixListEntriesResponse
     */
    public function getVpcPrefixListEntriesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->prefixListId) {
            @$query['PrefixListId'] = $request->prefixListId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetVpcPrefixListEntries',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetVpcPrefixListEntriesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a prefix list.
     *
     * @param request - GetVpcPrefixListEntriesRequest
     *
     * @returns GetVpcPrefixListEntriesResponse
     *
     * @param GetVpcPrefixListEntriesRequest $request
     *
     * @return GetVpcPrefixListEntriesResponse
     */
    public function getVpcPrefixListEntries($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getVpcPrefixListEntriesWithOptions($request, $runtime);
    }

    /**
     * 
     *
     * @param request - GetVpcRouteEntrySummaryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetVpcRouteEntrySummaryResponse
     *
     * @param GetVpcRouteEntrySummaryRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return GetVpcRouteEntrySummaryResponse
     */
    public function getVpcRouteEntrySummaryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeEntryType) {
            @$query['RouteEntryType'] = $request->routeEntryType;
        }

        if (null !== $request->routeTableId) {
            @$query['RouteTableId'] = $request->routeTableId;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetVpcRouteEntrySummary',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetVpcRouteEntrySummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 
     *
     * @param request - GetVpcRouteEntrySummaryRequest
     *
     * @returns GetVpcRouteEntrySummaryResponse
     *
     * @param GetVpcRouteEntrySummaryRequest $request
     *
     * @return GetVpcRouteEntrySummaryResponse
     */
    public function getVpcRouteEntrySummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getVpcRouteEntrySummaryWithOptions($request, $runtime);
    }

    /**
     * Queries the diagnostic result of a VPN gateway.
     *
     * @remarks
     * When you call the **GetVpnGatewayDiagnoseResult** operation, you must specify one of **DiagnoseId** and **VpnGatewayId**.
     *
     * @param request - GetVpnGatewayDiagnoseResultRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetVpnGatewayDiagnoseResultResponse
     *
     * @param GetVpnGatewayDiagnoseResultRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return GetVpnGatewayDiagnoseResultResponse
     */
    public function getVpnGatewayDiagnoseResultWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->diagnoseId) {
            @$query['DiagnoseId'] = $request->diagnoseId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->vpnGatewayId) {
            @$query['VpnGatewayId'] = $request->vpnGatewayId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetVpnGatewayDiagnoseResult',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetVpnGatewayDiagnoseResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the diagnostic result of a VPN gateway.
     *
     * @remarks
     * When you call the **GetVpnGatewayDiagnoseResult** operation, you must specify one of **DiagnoseId** and **VpnGatewayId**.
     *
     * @param request - GetVpnGatewayDiagnoseResultRequest
     *
     * @returns GetVpnGatewayDiagnoseResultResponse
     *
     * @param GetVpnGatewayDiagnoseResultRequest $request
     *
     * @return GetVpnGatewayDiagnoseResultResponse
     */
    public function getVpnGatewayDiagnoseResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getVpnGatewayDiagnoseResultWithOptions($request, $runtime);
    }

    /**
     * Grants permissions to a Cloud Enterprise Network (CEN) instance.
     *
     * @remarks
     *   Before you can attach a network instance that belongs to another Alibaba Cloud account to your CEN instance, you must grant permissions to your CEN instance.
     * >  **GrantInstanceToCen** is a Virtual Private Cloud (VPC) operation. Therefore, you must use the `vpc.aliyuncs.com` domain name to call this operation. The API version is `2016-04-28`.
     * *   You cannot repeatedly call the **GrantInstanceToCen** operation to grant the permissions on a network instance to a CEN instance. The network instance can be a VPC, a virtual border router (VBR), or a Cloud Connect Network (CCN) instance.
     *
     * @param request - GrantInstanceToCenRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GrantInstanceToCenResponse
     *
     * @param GrantInstanceToCenRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return GrantInstanceToCenResponse
     */
    public function grantInstanceToCenWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->cenId) {
            @$query['CenId'] = $request->cenId;
        }

        if (null !== $request->cenOwnerId) {
            @$query['CenOwnerId'] = $request->cenOwnerId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->instanceType) {
            @$query['InstanceType'] = $request->instanceType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GrantInstanceToCen',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GrantInstanceToCenResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Grants permissions to a Cloud Enterprise Network (CEN) instance.
     *
     * @remarks
     *   Before you can attach a network instance that belongs to another Alibaba Cloud account to your CEN instance, you must grant permissions to your CEN instance.
     * >  **GrantInstanceToCen** is a Virtual Private Cloud (VPC) operation. Therefore, you must use the `vpc.aliyuncs.com` domain name to call this operation. The API version is `2016-04-28`.
     * *   You cannot repeatedly call the **GrantInstanceToCen** operation to grant the permissions on a network instance to a CEN instance. The network instance can be a VPC, a virtual border router (VBR), or a Cloud Connect Network (CCN) instance.
     *
     * @param request - GrantInstanceToCenRequest
     *
     * @returns GrantInstanceToCenResponse
     *
     * @param GrantInstanceToCenRequest $request
     *
     * @return GrantInstanceToCenResponse
     */
    public function grantInstanceToCen($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->grantInstanceToCenWithOptions($request, $runtime);
    }

    /**
     * Grants a virtual border router (VBR) the permissions to connect to a virtual private cloud (VPC) that belongs to another Alibaba Cloud account.
     *
     * @remarks
     * ## Usage notes
     * When you connect a VBR to a VPC that belongs to another Alibaba Cloud account, the VBR must acquire the required permissions from the VPC.
     *
     * @param tmpReq - GrantInstanceToVbrRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GrantInstanceToVbrResponse
     *
     * @param GrantInstanceToVbrRequest $tmpReq
     * @param RuntimeOptions            $runtime
     *
     * @return GrantInstanceToVbrResponse
     */
    public function grantInstanceToVbrWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new GrantInstanceToVbrShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->vbrInstanceIds) {
            $request->vbrInstanceIdsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->vbrInstanceIds, 'VbrInstanceIds', 'simple');
        }

        $query = [];
        if (null !== $request->grantType) {
            @$query['GrantType'] = $request->grantType;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->vbrInstanceIdsShrink) {
            @$query['VbrInstanceIds'] = $request->vbrInstanceIdsShrink;
        }

        if (null !== $request->vbrOwnerUid) {
            @$query['VbrOwnerUid'] = $request->vbrOwnerUid;
        }

        if (null !== $request->vbrRegionNo) {
            @$query['VbrRegionNo'] = $request->vbrRegionNo;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GrantInstanceToVbr',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GrantInstanceToVbrResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Grants a virtual border router (VBR) the permissions to connect to a virtual private cloud (VPC) that belongs to another Alibaba Cloud account.
     *
     * @remarks
     * ## Usage notes
     * When you connect a VBR to a VPC that belongs to another Alibaba Cloud account, the VBR must acquire the required permissions from the VPC.
     *
     * @param request - GrantInstanceToVbrRequest
     *
     * @returns GrantInstanceToVbrResponse
     *
     * @param GrantInstanceToVbrRequest $request
     *
     * @return GrantInstanceToVbrResponse
     */
    public function grantInstanceToVbr($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->grantInstanceToVbrWithOptions($request, $runtime);
    }

    /**
     * Queries the access points of an Express Connect circuit.
     *
     * @param request - ListBusinessAccessPointsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListBusinessAccessPointsResponse
     *
     * @param ListBusinessAccessPointsRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return ListBusinessAccessPointsResponse
     */
    public function listBusinessAccessPointsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListBusinessAccessPoints',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListBusinessAccessPointsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the access points of an Express Connect circuit.
     *
     * @param request - ListBusinessAccessPointsRequest
     *
     * @returns ListBusinessAccessPointsResponse
     *
     * @param ListBusinessAccessPointsRequest $request
     *
     * @return ListBusinessAccessPointsResponse
     */
    public function listBusinessAccessPoints($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listBusinessAccessPointsWithOptions($request, $runtime);
    }

    /**
     * Query the list of regions available for an Express Connect circuit.
     *
     * @param request - ListBusinessRegionsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListBusinessRegionsResponse
     *
     * @param ListBusinessRegionsRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ListBusinessRegionsResponse
     */
    public function listBusinessRegionsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceptLanguage) {
            @$query['AcceptLanguage'] = $request->acceptLanguage;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListBusinessRegions',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListBusinessRegionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Query the list of regions available for an Express Connect circuit.
     *
     * @param request - ListBusinessRegionsRequest
     *
     * @returns ListBusinessRegionsResponse
     *
     * @param ListBusinessRegionsRequest $request
     *
     * @return ListBusinessRegionsResponse
     */
    public function listBusinessRegions($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listBusinessRegionsWithOptions($request, $runtime);
    }

    /**
     * Queries Dynamic Host Configuration Protocol (DHCP) options sets.
     *
     * @param request - ListDhcpOptionsSetsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListDhcpOptionsSetsResponse
     *
     * @param ListDhcpOptionsSetsRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ListDhcpOptionsSetsResponse
     */
    public function listDhcpOptionsSetsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dhcpOptionsSetId) {
            @$query['DhcpOptionsSetId'] = $request->dhcpOptionsSetId;
        }

        if (null !== $request->dhcpOptionsSetName) {
            @$query['DhcpOptionsSetName'] = $request->dhcpOptionsSetName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListDhcpOptionsSets',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListDhcpOptionsSetsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries Dynamic Host Configuration Protocol (DHCP) options sets.
     *
     * @param request - ListDhcpOptionsSetsRequest
     *
     * @returns ListDhcpOptionsSetsResponse
     *
     * @param ListDhcpOptionsSetsRequest $request
     *
     * @return ListDhcpOptionsSetsResponse
     */
    public function listDhcpOptionsSets($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDhcpOptionsSetsWithOptions($request, $runtime);
    }

    /**
     * Queries the zones that support NAT gateways.
     *
     * @remarks
     * You can call this operation to query zones that support NAT gateways, including Internet NAT gateways and Virtual Private Cloud (VPC) NAT gateways.
     *
     * @param request - ListEnhanhcedNatGatewayAvailableZonesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListEnhanhcedNatGatewayAvailableZonesResponse
     *
     * @param ListEnhanhcedNatGatewayAvailableZonesRequest $request
     * @param RuntimeOptions                               $runtime
     *
     * @return ListEnhanhcedNatGatewayAvailableZonesResponse
     */
    public function listEnhanhcedNatGatewayAvailableZonesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceptLanguage) {
            @$query['AcceptLanguage'] = $request->acceptLanguage;
        }

        if (null !== $request->filter) {
            @$query['Filter'] = $request->filter;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListEnhanhcedNatGatewayAvailableZones',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListEnhanhcedNatGatewayAvailableZonesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the zones that support NAT gateways.
     *
     * @remarks
     * You can call this operation to query zones that support NAT gateways, including Internet NAT gateways and Virtual Private Cloud (VPC) NAT gateways.
     *
     * @param request - ListEnhanhcedNatGatewayAvailableZonesRequest
     *
     * @returns ListEnhanhcedNatGatewayAvailableZonesResponse
     *
     * @param ListEnhanhcedNatGatewayAvailableZonesRequest $request
     *
     * @return ListEnhanhcedNatGatewayAvailableZonesResponse
     */
    public function listEnhanhcedNatGatewayAvailableZones($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listEnhanhcedNatGatewayAvailableZonesWithOptions($request, $runtime);
    }

    /**
     * Queries FULLNAT entries.
     *
     * @param request - ListFullNatEntriesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListFullNatEntriesResponse
     *
     * @param ListFullNatEntriesRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return ListFullNatEntriesResponse
     */
    public function listFullNatEntriesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->fullNatEntryId) {
            @$query['FullNatEntryId'] = $request->fullNatEntryId;
        }

        if (null !== $request->fullNatEntryNames) {
            @$query['FullNatEntryNames'] = $request->fullNatEntryNames;
        }

        if (null !== $request->fullNatTableId) {
            @$query['FullNatTableId'] = $request->fullNatTableId;
        }

        if (null !== $request->ipProtocol) {
            @$query['IpProtocol'] = $request->ipProtocol;
        }

        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->natGatewayId) {
            @$query['NatGatewayId'] = $request->natGatewayId;
        }

        if (null !== $request->natIp) {
            @$query['NatIp'] = $request->natIp;
        }

        if (null !== $request->natIpPort) {
            @$query['NatIpPort'] = $request->natIpPort;
        }

        if (null !== $request->networkInterfaceIds) {
            @$query['NetworkInterfaceIds'] = $request->networkInterfaceIds;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListFullNatEntries',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListFullNatEntriesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries FULLNAT entries.
     *
     * @param request - ListFullNatEntriesRequest
     *
     * @returns ListFullNatEntriesResponse
     *
     * @param ListFullNatEntriesRequest $request
     *
     * @return ListFullNatEntriesResponse
     */
    public function listFullNatEntries($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listFullNatEntriesWithOptions($request, $runtime);
    }

    /**
     * Queries route entries of a gateway route table.
     *
     * @param request - ListGatewayRouteTableEntriesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListGatewayRouteTableEntriesResponse
     *
     * @param ListGatewayRouteTableEntriesRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return ListGatewayRouteTableEntriesResponse
     */
    public function listGatewayRouteTableEntriesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->destinationCidrBlock) {
            @$query['DestinationCidrBlock'] = $request->destinationCidrBlock;
        }

        if (null !== $request->gatewayRouteTableId) {
            @$query['GatewayRouteTableId'] = $request->gatewayRouteTableId;
        }

        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListGatewayRouteTableEntries',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListGatewayRouteTableEntriesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries route entries of a gateway route table.
     *
     * @param request - ListGatewayRouteTableEntriesRequest
     *
     * @returns ListGatewayRouteTableEntriesResponse
     *
     * @param ListGatewayRouteTableEntriesRequest $request
     *
     * @return ListGatewayRouteTableEntriesResponse
     */
    public function listGatewayRouteTableEntries($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listGatewayRouteTableEntriesWithOptions($request, $runtime);
    }

    /**
     * Queries the most recent region list.
     *
     * @param request - ListGeographicSubRegionsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListGeographicSubRegionsResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return ListGeographicSubRegionsResponse
     */
    public function listGeographicSubRegionsWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'ListGeographicSubRegions',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListGeographicSubRegionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the most recent region list.
     *
     * @returns ListGeographicSubRegionsResponse
     *
     * @return ListGeographicSubRegionsResponse
     */
    public function listGeographicSubRegions()
    {
        $runtime = new RuntimeOptions([]);

        return $this->listGeographicSubRegionsWithOptions($runtime);
    }

    /**
     * Queries the logs of an IPsec server.
     *
     * @param request - ListIpsecServerLogsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListIpsecServerLogsResponse
     *
     * @param ListIpsecServerLogsRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ListIpsecServerLogsResponse
     */
    public function listIpsecServerLogsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        if (null !== $request->ipsecServerId) {
            @$query['IpsecServerId'] = $request->ipsecServerId;
        }

        if (null !== $request->minutePeriod) {
            @$query['MinutePeriod'] = $request->minutePeriod;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->to) {
            @$query['To'] = $request->to;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListIpsecServerLogs',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListIpsecServerLogsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the logs of an IPsec server.
     *
     * @param request - ListIpsecServerLogsRequest
     *
     * @returns ListIpsecServerLogsResponse
     *
     * @param ListIpsecServerLogsRequest $request
     *
     * @return ListIpsecServerLogsResponse
     */
    public function listIpsecServerLogs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listIpsecServerLogsWithOptions($request, $runtime);
    }

    /**
     * Queries IPsec servers.
     *
     * @param request - ListIpsecServersRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListIpsecServersResponse
     *
     * @param ListIpsecServersRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return ListIpsecServersResponse
     */
    public function listIpsecServersWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ipsecServerId) {
            @$query['IpsecServerId'] = $request->ipsecServerId;
        }

        if (null !== $request->ipsecServerName) {
            @$query['IpsecServerName'] = $request->ipsecServerName;
        }

        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->vpnGatewayId) {
            @$query['VpnGatewayId'] = $request->vpnGatewayId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListIpsecServers',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListIpsecServersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries IPsec servers.
     *
     * @param request - ListIpsecServersRequest
     *
     * @returns ListIpsecServersResponse
     *
     * @param ListIpsecServersRequest $request
     *
     * @return ListIpsecServersResponse
     */
    public function listIpsecServers($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listIpsecServersWithOptions($request, $runtime);
    }

    /**
     * Queries IPv4 gateways.
     *
     * @param request - ListIpv4GatewaysRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListIpv4GatewaysResponse
     *
     * @param ListIpv4GatewaysRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return ListIpv4GatewaysResponse
     */
    public function listIpv4GatewaysWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ipv4GatewayId) {
            @$query['Ipv4GatewayId'] = $request->ipv4GatewayId;
        }

        if (null !== $request->ipv4GatewayName) {
            @$query['Ipv4GatewayName'] = $request->ipv4GatewayName;
        }

        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListIpv4Gateways',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListIpv4GatewaysResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries IPv4 gateways.
     *
     * @param request - ListIpv4GatewaysRequest
     *
     * @returns ListIpv4GatewaysResponse
     *
     * @param ListIpv4GatewaysRequest $request
     *
     * @return ListIpv4GatewaysResponse
     */
    public function listIpv4Gateways($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listIpv4GatewaysWithOptions($request, $runtime);
    }

    /**
     * Queries the CIDR blocks of a specified NAT gateway.
     *
     * @param request - ListNatIpCidrsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListNatIpCidrsResponse
     *
     * @param ListNatIpCidrsRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return ListNatIpCidrsResponse
     */
    public function listNatIpCidrsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->natGatewayId) {
            @$query['NatGatewayId'] = $request->natGatewayId;
        }

        if (null !== $request->natIpCidr) {
            @$query['NatIpCidr'] = $request->natIpCidr;
        }

        if (null !== $request->natIpCidrName) {
            @$query['NatIpCidrName'] = $request->natIpCidrName;
        }

        if (null !== $request->natIpCidrStatus) {
            @$query['NatIpCidrStatus'] = $request->natIpCidrStatus;
        }

        if (null !== $request->natIpCidrs) {
            @$query['NatIpCidrs'] = $request->natIpCidrs;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListNatIpCidrs',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListNatIpCidrsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the CIDR blocks of a specified NAT gateway.
     *
     * @param request - ListNatIpCidrsRequest
     *
     * @returns ListNatIpCidrsResponse
     *
     * @param ListNatIpCidrsRequest $request
     *
     * @return ListNatIpCidrsResponse
     */
    public function listNatIpCidrs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listNatIpCidrsWithOptions($request, $runtime);
    }

    /**
     * Queries the IP addresses on a NAT gateway.
     *
     * @param request - ListNatIpsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListNatIpsResponse
     *
     * @param ListNatIpsRequest $request
     * @param RuntimeOptions    $runtime
     *
     * @return ListNatIpsResponse
     */
    public function listNatIpsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ipOrigin) {
            @$query['IpOrigin'] = $request->ipOrigin;
        }

        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->natGatewayId) {
            @$query['NatGatewayId'] = $request->natGatewayId;
        }

        if (null !== $request->natIpCidr) {
            @$query['NatIpCidr'] = $request->natIpCidr;
        }

        if (null !== $request->natIpIds) {
            @$query['NatIpIds'] = $request->natIpIds;
        }

        if (null !== $request->natIpName) {
            @$query['NatIpName'] = $request->natIpName;
        }

        if (null !== $request->natIpStatus) {
            @$query['NatIpStatus'] = $request->natIpStatus;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListNatIps',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListNatIpsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the IP addresses on a NAT gateway.
     *
     * @param request - ListNatIpsRequest
     *
     * @returns ListNatIpsResponse
     *
     * @param ListNatIpsRequest $request
     *
     * @return ListNatIpsResponse
     */
    public function listNatIps($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listNatIpsWithOptions($request, $runtime);
    }

    /**
     * Querying the connection features supported by a Express Connect circuit.
     *
     * @param request - ListPhysicalConnectionFeaturesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListPhysicalConnectionFeaturesResponse
     *
     * @param ListPhysicalConnectionFeaturesRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return ListPhysicalConnectionFeaturesResponse
     */
    public function listPhysicalConnectionFeaturesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->physicalConnectionId) {
            @$query['PhysicalConnectionId'] = $request->physicalConnectionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListPhysicalConnectionFeatures',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListPhysicalConnectionFeaturesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Querying the connection features supported by a Express Connect circuit.
     *
     * @param request - ListPhysicalConnectionFeaturesRequest
     *
     * @returns ListPhysicalConnectionFeaturesResponse
     *
     * @param ListPhysicalConnectionFeaturesRequest $request
     *
     * @return ListPhysicalConnectionFeaturesResponse
     */
    public function listPhysicalConnectionFeatures($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listPhysicalConnectionFeaturesWithOptions($request, $runtime);
    }

    /**
     * Queries prefix lists.
     *
     * @param request - ListPrefixListsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListPrefixListsResponse
     *
     * @param ListPrefixListsRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return ListPrefixListsResponse
     */
    public function listPrefixListsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->prefixListIds) {
            @$query['PrefixListIds'] = $request->prefixListIds;
        }

        if (null !== $request->prefixListName) {
            @$query['PrefixListName'] = $request->prefixListName;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListPrefixLists',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListPrefixListsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries prefix lists.
     *
     * @param request - ListPrefixListsRequest
     *
     * @returns ListPrefixListsResponse
     *
     * @param ListPrefixListsRequest $request
     *
     * @return ListPrefixListsResponse
     */
    public function listPrefixLists($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listPrefixListsWithOptions($request, $runtime);
    }

    /**
     * IPIP.
     *
     * @param request - ListPublicIpAddressPoolCidrBlocksRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListPublicIpAddressPoolCidrBlocksResponse
     *
     * @param ListPublicIpAddressPoolCidrBlocksRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return ListPublicIpAddressPoolCidrBlocksResponse
     */
    public function listPublicIpAddressPoolCidrBlocksWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->cidrBlock) {
            @$query['CidrBlock'] = $request->cidrBlock;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->publicIpAddressPoolId) {
            @$query['PublicIpAddressPoolId'] = $request->publicIpAddressPoolId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListPublicIpAddressPoolCidrBlocks',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListPublicIpAddressPoolCidrBlocksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * IPIP.
     *
     * @param request - ListPublicIpAddressPoolCidrBlocksRequest
     *
     * @returns ListPublicIpAddressPoolCidrBlocksResponse
     *
     * @param ListPublicIpAddressPoolCidrBlocksRequest $request
     *
     * @return ListPublicIpAddressPoolCidrBlocksResponse
     */
    public function listPublicIpAddressPoolCidrBlocks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listPublicIpAddressPoolCidrBlocksWithOptions($request, $runtime);
    }

    /**
     * Queries available IP address pools.
     *
     * @param request - ListPublicIpAddressPoolsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListPublicIpAddressPoolsResponse
     *
     * @param ListPublicIpAddressPoolsRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return ListPublicIpAddressPoolsResponse
     */
    public function listPublicIpAddressPoolsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->isp) {
            @$query['Isp'] = $request->isp;
        }

        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->publicIpAddressPoolIds) {
            @$query['PublicIpAddressPoolIds'] = $request->publicIpAddressPoolIds;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->securityProtectionEnabled) {
            @$query['SecurityProtectionEnabled'] = $request->securityProtectionEnabled;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListPublicIpAddressPools',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListPublicIpAddressPoolsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries available IP address pools.
     *
     * @param request - ListPublicIpAddressPoolsRequest
     *
     * @returns ListPublicIpAddressPoolsResponse
     *
     * @param ListPublicIpAddressPoolsRequest $request
     *
     * @return ListPublicIpAddressPoolsResponse
     */
    public function listPublicIpAddressPools($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listPublicIpAddressPoolsWithOptions($request, $runtime);
    }

    /**
     * Queries the tags that are added to resources.
     *
     * @remarks
     * ## Usage notes
     * *   You must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request to specify the object that you want to query.
     * *   **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified key are returned. If you specify only **Tag.N.Value**, an error message is returned.
     * *   If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
     * *   If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
     *
     * @param request - ListTagResourcesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListTagResourcesResponse
     *
     * @param ListTagResourcesRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return ListTagResourcesResponse
     */
    public function listTagResourcesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListTagResources',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListTagResourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the tags that are added to resources.
     *
     * @remarks
     * ## Usage notes
     * *   You must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request to specify the object that you want to query.
     * *   **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified key are returned. If you specify only **Tag.N.Value**, an error message is returned.
     * *   If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
     * *   If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
     *
     * @param request - ListTagResourcesRequest
     *
     * @returns ListTagResourcesResponse
     *
     * @param ListTagResourcesRequest $request
     *
     * @return ListTagResourcesResponse
     */
    public function listTagResources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listTagResourcesWithOptions($request, $runtime);
    }

    /**
     * Queries the tags that are added to an Express Connect circuit.
     *
     * @remarks
     * ## [](#)
     * *   If you want to query a specific object, you must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request.
     * *   **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified key are returned. If you specify only **Tag.N.Value**, an error message is returned.
     * *   If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
     * *   If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
     *
     * @param request - ListTagResourcesForExpressConnectRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListTagResourcesForExpressConnectResponse
     *
     * @param ListTagResourcesForExpressConnectRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return ListTagResourcesForExpressConnectResponse
     */
    public function listTagResourcesForExpressConnectWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListTagResourcesForExpressConnect',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListTagResourcesForExpressConnectResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the tags that are added to an Express Connect circuit.
     *
     * @remarks
     * ## [](#)
     * *   If you want to query a specific object, you must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request.
     * *   **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified key are returned. If you specify only **Tag.N.Value**, an error message is returned.
     * *   If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
     * *   If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
     *
     * @param request - ListTagResourcesForExpressConnectRequest
     *
     * @returns ListTagResourcesForExpressConnectResponse
     *
     * @param ListTagResourcesForExpressConnectRequest $request
     *
     * @return ListTagResourcesForExpressConnectResponse
     */
    public function listTagResourcesForExpressConnect($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listTagResourcesForExpressConnectWithOptions($request, $runtime);
    }

    /**
     * Queries filters for traffic mirror.
     *
     * @param request - ListTrafficMirrorFiltersRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListTrafficMirrorFiltersResponse
     *
     * @param ListTrafficMirrorFiltersRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return ListTrafficMirrorFiltersResponse
     */
    public function listTrafficMirrorFiltersWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        if (null !== $request->trafficMirrorFilterIds) {
            @$query['TrafficMirrorFilterIds'] = $request->trafficMirrorFilterIds;
        }

        if (null !== $request->trafficMirrorFilterName) {
            @$query['TrafficMirrorFilterName'] = $request->trafficMirrorFilterName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListTrafficMirrorFilters',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListTrafficMirrorFiltersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries filters for traffic mirror.
     *
     * @param request - ListTrafficMirrorFiltersRequest
     *
     * @returns ListTrafficMirrorFiltersResponse
     *
     * @param ListTrafficMirrorFiltersRequest $request
     *
     * @return ListTrafficMirrorFiltersResponse
     */
    public function listTrafficMirrorFilters($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listTrafficMirrorFiltersWithOptions($request, $runtime);
    }

    /**
     * Queries the details of a traffic mirror session.
     *
     * @param request - ListTrafficMirrorSessionsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListTrafficMirrorSessionsResponse
     *
     * @param ListTrafficMirrorSessionsRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return ListTrafficMirrorSessionsResponse
     */
    public function listTrafficMirrorSessionsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->enabled) {
            @$query['Enabled'] = $request->enabled;
        }

        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->priority) {
            @$query['Priority'] = $request->priority;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        if (null !== $request->trafficMirrorFilterId) {
            @$query['TrafficMirrorFilterId'] = $request->trafficMirrorFilterId;
        }

        if (null !== $request->trafficMirrorSessionIds) {
            @$query['TrafficMirrorSessionIds'] = $request->trafficMirrorSessionIds;
        }

        if (null !== $request->trafficMirrorSessionName) {
            @$query['TrafficMirrorSessionName'] = $request->trafficMirrorSessionName;
        }

        if (null !== $request->trafficMirrorSourceId) {
            @$query['TrafficMirrorSourceId'] = $request->trafficMirrorSourceId;
        }

        if (null !== $request->trafficMirrorTargetId) {
            @$query['TrafficMirrorTargetId'] = $request->trafficMirrorTargetId;
        }

        if (null !== $request->virtualNetworkId) {
            @$query['VirtualNetworkId'] = $request->virtualNetworkId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListTrafficMirrorSessions',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListTrafficMirrorSessionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of a traffic mirror session.
     *
     * @param request - ListTrafficMirrorSessionsRequest
     *
     * @returns ListTrafficMirrorSessionsResponse
     *
     * @param ListTrafficMirrorSessionsRequest $request
     *
     * @return ListTrafficMirrorSessionsResponse
     */
    public function listTrafficMirrorSessions($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listTrafficMirrorSessionsWithOptions($request, $runtime);
    }

    /**
     * Queries the CIDR reservation information about vSwitches.
     *
     * @param request - ListVSwitchCidrReservationsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListVSwitchCidrReservationsResponse
     *
     * @param ListVSwitchCidrReservationsRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return ListVSwitchCidrReservationsResponse
     */
    public function listVSwitchCidrReservationsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ipVersion) {
            @$query['IpVersion'] = $request->ipVersion;
        }

        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        if (null !== $request->vSwitchCidrReservationIds) {
            @$query['VSwitchCidrReservationIds'] = $request->vSwitchCidrReservationIds;
        }

        if (null !== $request->vSwitchCidrReservationType) {
            @$query['VSwitchCidrReservationType'] = $request->vSwitchCidrReservationType;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListVSwitchCidrReservations',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListVSwitchCidrReservationsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the CIDR reservation information about vSwitches.
     *
     * @param request - ListVSwitchCidrReservationsRequest
     *
     * @returns ListVSwitchCidrReservationsResponse
     *
     * @param ListVSwitchCidrReservationsRequest $request
     *
     * @return ListVSwitchCidrReservationsResponse
     */
    public function listVSwitchCidrReservations($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listVSwitchCidrReservationsWithOptions($request, $runtime);
    }

    /**
     * Queries hosted connections.
     *
     * @param request - ListVirtualPhysicalConnectionsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListVirtualPhysicalConnectionsResponse
     *
     * @param ListVirtualPhysicalConnectionsRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return ListVirtualPhysicalConnectionsResponse
     */
    public function listVirtualPhysicalConnectionsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->isConfirmed) {
            @$query['IsConfirmed'] = $request->isConfirmed;
        }

        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->physicalConnectionId) {
            @$query['PhysicalConnectionId'] = $request->physicalConnectionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        if (null !== $request->virtualPhysicalConnectionAliUids) {
            @$query['VirtualPhysicalConnectionAliUids'] = $request->virtualPhysicalConnectionAliUids;
        }

        if (null !== $request->virtualPhysicalConnectionBusinessStatus) {
            @$query['VirtualPhysicalConnectionBusinessStatus'] = $request->virtualPhysicalConnectionBusinessStatus;
        }

        if (null !== $request->virtualPhysicalConnectionIds) {
            @$query['VirtualPhysicalConnectionIds'] = $request->virtualPhysicalConnectionIds;
        }

        if (null !== $request->virtualPhysicalConnectionStatuses) {
            @$query['VirtualPhysicalConnectionStatuses'] = $request->virtualPhysicalConnectionStatuses;
        }

        if (null !== $request->vlanIds) {
            @$query['VlanIds'] = $request->vlanIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListVirtualPhysicalConnections',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListVirtualPhysicalConnectionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries hosted connections.
     *
     * @param request - ListVirtualPhysicalConnectionsRequest
     *
     * @returns ListVirtualPhysicalConnectionsResponse
     *
     * @param ListVirtualPhysicalConnectionsRequest $request
     *
     * @return ListVirtualPhysicalConnectionsResponse
     */
    public function listVirtualPhysicalConnections($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listVirtualPhysicalConnectionsWithOptions($request, $runtime);
    }

    /**
     * Queries available endpoint services.
     *
     * @param request - ListVpcEndpointServicesByEndUserRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListVpcEndpointServicesByEndUserResponse
     *
     * @param ListVpcEndpointServicesByEndUserRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return ListVpcEndpointServicesByEndUserResponse
     */
    public function listVpcEndpointServicesByEndUserWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->serviceName) {
            @$query['ServiceName'] = $request->serviceName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListVpcEndpointServicesByEndUser',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListVpcEndpointServicesByEndUserResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries available endpoint services.
     *
     * @param request - ListVpcEndpointServicesByEndUserRequest
     *
     * @returns ListVpcEndpointServicesByEndUserResponse
     *
     * @param ListVpcEndpointServicesByEndUserRequest $request
     *
     * @return ListVpcEndpointServicesByEndUserResponse
     */
    public function listVpcEndpointServicesByEndUser($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listVpcEndpointServicesByEndUserWithOptions($request, $runtime);
    }

    /**
     * Queries gateway endpoints.
     *
     * @param request - ListVpcGatewayEndpointsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListVpcGatewayEndpointsResponse
     *
     * @param ListVpcGatewayEndpointsRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ListVpcGatewayEndpointsResponse
     */
    public function listVpcGatewayEndpointsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->endpointId) {
            @$query['EndpointId'] = $request->endpointId;
        }

        if (null !== $request->endpointName) {
            @$query['EndpointName'] = $request->endpointName;
        }

        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->serviceName) {
            @$query['ServiceName'] = $request->serviceName;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListVpcGatewayEndpoints',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListVpcGatewayEndpointsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries gateway endpoints.
     *
     * @param request - ListVpcGatewayEndpointsRequest
     *
     * @returns ListVpcGatewayEndpointsResponse
     *
     * @param ListVpcGatewayEndpointsRequest $request
     *
     * @return ListVpcGatewayEndpointsResponse
     */
    public function listVpcGatewayEndpoints($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listVpcGatewayEndpointsWithOptions($request, $runtime);
    }

    /**
     * Queries advertised routes.
     *
     * @param request - ListVpcPublishedRouteEntriesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListVpcPublishedRouteEntriesResponse
     *
     * @param ListVpcPublishedRouteEntriesRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return ListVpcPublishedRouteEntriesResponse
     */
    public function listVpcPublishedRouteEntriesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->destinationCidrBlock) {
            @$query['DestinationCidrBlock'] = $request->destinationCidrBlock;
        }

        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeTableId) {
            @$query['RouteTableId'] = $request->routeTableId;
        }

        if (null !== $request->targetInstanceId) {
            @$query['TargetInstanceId'] = $request->targetInstanceId;
        }

        if (null !== $request->targetType) {
            @$query['TargetType'] = $request->targetType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListVpcPublishedRouteEntries',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListVpcPublishedRouteEntriesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries advertised routes.
     *
     * @param request - ListVpcPublishedRouteEntriesRequest
     *
     * @returns ListVpcPublishedRouteEntriesResponse
     *
     * @param ListVpcPublishedRouteEntriesRequest $request
     *
     * @return ListVpcPublishedRouteEntriesResponse
     */
    public function listVpcPublishedRouteEntries($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listVpcPublishedRouteEntriesWithOptions($request, $runtime);
    }

    /**
     * Queries the association between VPN gateways and certificates in a region.
     *
     * @remarks
     * When you call **ListVpnCertificateAssociations**, take note of the following information:
     * *   If you specify only **RegionId**, the SSL certificates associated with all VPN gateways in the specified region are queried.
     * *   If you specify **RegionId** and **CertificateType**, the SSL certificates of the specified type that are associated with the VPN gateways in the specified region are queried.
     * *   If you specify **RegionId** and **VpnGatewayId**, the SSL certificates associated with the specified VPN gateway in the specified region are queried.
     * *   If you specify **RegionId** and **CertificateId**, the VPN gateways associated with the specified SSL certificate in the specified region are queried.
     *
     * @param request - ListVpnCertificateAssociationsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListVpnCertificateAssociationsResponse
     *
     * @param ListVpnCertificateAssociationsRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return ListVpnCertificateAssociationsResponse
     */
    public function listVpnCertificateAssociationsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->certificateId) {
            @$query['CertificateId'] = $request->certificateId;
        }

        if (null !== $request->certificateType) {
            @$query['CertificateType'] = $request->certificateType;
        }

        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->vpnGatewayId) {
            @$query['VpnGatewayId'] = $request->vpnGatewayId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListVpnCertificateAssociations',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListVpnCertificateAssociationsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the association between VPN gateways and certificates in a region.
     *
     * @remarks
     * When you call **ListVpnCertificateAssociations**, take note of the following information:
     * *   If you specify only **RegionId**, the SSL certificates associated with all VPN gateways in the specified region are queried.
     * *   If you specify **RegionId** and **CertificateType**, the SSL certificates of the specified type that are associated with the VPN gateways in the specified region are queried.
     * *   If you specify **RegionId** and **VpnGatewayId**, the SSL certificates associated with the specified VPN gateway in the specified region are queried.
     * *   If you specify **RegionId** and **CertificateId**, the VPN gateways associated with the specified SSL certificate in the specified region are queried.
     *
     * @param request - ListVpnCertificateAssociationsRequest
     *
     * @returns ListVpnCertificateAssociationsResponse
     *
     * @param ListVpnCertificateAssociationsRequest $request
     *
     * @return ListVpnCertificateAssociationsResponse
     */
    public function listVpnCertificateAssociations($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listVpnCertificateAssociationsWithOptions($request, $runtime);
    }

    /**
     * Modifies the configuration of a Border Gateway Protocol (BGP) group.
     *
     * @param request - ModifyBgpGroupAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyBgpGroupAttributeResponse
     *
     * @param ModifyBgpGroupAttributeRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ModifyBgpGroupAttributeResponse
     */
    public function modifyBgpGroupAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->authKey) {
            @$query['AuthKey'] = $request->authKey;
        }

        if (null !== $request->bgpGroupId) {
            @$query['BgpGroupId'] = $request->bgpGroupId;
        }

        if (null !== $request->clearAuthKey) {
            @$query['ClearAuthKey'] = $request->clearAuthKey;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->isFakeAsn) {
            @$query['IsFakeAsn'] = $request->isFakeAsn;
        }

        if (null !== $request->localAsn) {
            @$query['LocalAsn'] = $request->localAsn;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->peerAsn) {
            @$query['PeerAsn'] = $request->peerAsn;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeQuota) {
            @$query['RouteQuota'] = $request->routeQuota;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyBgpGroupAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyBgpGroupAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configuration of a Border Gateway Protocol (BGP) group.
     *
     * @param request - ModifyBgpGroupAttributeRequest
     *
     * @returns ModifyBgpGroupAttributeResponse
     *
     * @param ModifyBgpGroupAttributeRequest $request
     *
     * @return ModifyBgpGroupAttributeResponse
     */
    public function modifyBgpGroupAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyBgpGroupAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies the configuration of a BGP peer.
     *
     * @param request - ModifyBgpPeerAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyBgpPeerAttributeResponse
     *
     * @param ModifyBgpPeerAttributeRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return ModifyBgpPeerAttributeResponse
     */
    public function modifyBgpPeerAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bfdMultiHop) {
            @$query['BfdMultiHop'] = $request->bfdMultiHop;
        }

        if (null !== $request->bgpGroupId) {
            @$query['BgpGroupId'] = $request->bgpGroupId;
        }

        if (null !== $request->bgpPeerId) {
            @$query['BgpPeerId'] = $request->bgpPeerId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->enableBfd) {
            @$query['EnableBfd'] = $request->enableBfd;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->peerIpAddress) {
            @$query['PeerIpAddress'] = $request->peerIpAddress;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyBgpPeerAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyBgpPeerAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configuration of a BGP peer.
     *
     * @param request - ModifyBgpPeerAttributeRequest
     *
     * @returns ModifyBgpPeerAttributeResponse
     *
     * @param ModifyBgpPeerAttributeRequest $request
     *
     * @return ModifyBgpPeerAttributeResponse
     */
    public function modifyBgpPeerAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyBgpPeerAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies the name and description of an EIP bandwidth plan.
     *
     * @param request - ModifyCommonBandwidthPackageAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyCommonBandwidthPackageAttributeResponse
     *
     * @param ModifyCommonBandwidthPackageAttributeRequest $request
     * @param RuntimeOptions                               $runtime
     *
     * @return ModifyCommonBandwidthPackageAttributeResponse
     */
    public function modifyCommonBandwidthPackageAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bandwidthPackageId) {
            @$query['BandwidthPackageId'] = $request->bandwidthPackageId;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyCommonBandwidthPackageAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyCommonBandwidthPackageAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the name and description of an EIP bandwidth plan.
     *
     * @param request - ModifyCommonBandwidthPackageAttributeRequest
     *
     * @returns ModifyCommonBandwidthPackageAttributeResponse
     *
     * @param ModifyCommonBandwidthPackageAttributeRequest $request
     *
     * @return ModifyCommonBandwidthPackageAttributeResponse
     */
    public function modifyCommonBandwidthPackageAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyCommonBandwidthPackageAttributeWithOptions($request, $runtime);
    }

    /**
     * Sets the maximum bandwidth of an EIP that is associated with an Internet Shared Bandwidth instance.
     *
     * @remarks
     * You can call the **ModifyCommonBandwidthPackageIpBandwidth** operation to set the maximum bandwidth of an EIP that is associated with an Internet Shared Bandwidth instance. This prevents an EIP from exhausting the bandwidth resources of an Internet Shared Bandwidth instance.
     * For example, two EIPs are associated with an Internet Shared Bandwidth instance whose maximum bandwidth is 800 Mbit/s. In this case, you can set the maximum bandwidth of one EIP to 500 Mbit/s and that of the other EIP to 400 Mbit/s. After you set the maximum bandwidth values, the first EIP cannot consume bandwidth higher than 500 Mbit/s. The second EIP cannot consume bandwidth higher than 400 Mbit/s.
     * When you call this operation, take note of the following items:
     * *   This operation is valid only for EIPs that are associated with Elastic Compute Service (ECS) instances. This operation is invalid for EIPs that are associated with Server Load Balancer (SLB) instances, NAT gateways, secondary elastic network interfaces (ENIs), or high-availability virtual IP addresses (HAVIPs).
     * *   This operation is in public preview. You can call this operation to set the maximum bandwidth of EIPs only if the EIPs are associated with an Internet Shared Bandwidth instance. The feature is not supported in the console.
     * *   You cannot repeatedly call this operation to set the maximum bandwidth of an EIP within the specified period of time.
     *
     * @param request - ModifyCommonBandwidthPackageIpBandwidthRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyCommonBandwidthPackageIpBandwidthResponse
     *
     * @param ModifyCommonBandwidthPackageIpBandwidthRequest $request
     * @param RuntimeOptions                                 $runtime
     *
     * @return ModifyCommonBandwidthPackageIpBandwidthResponse
     */
    public function modifyCommonBandwidthPackageIpBandwidthWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bandwidth) {
            @$query['Bandwidth'] = $request->bandwidth;
        }

        if (null !== $request->bandwidthPackageId) {
            @$query['BandwidthPackageId'] = $request->bandwidthPackageId;
        }

        if (null !== $request->eipId) {
            @$query['EipId'] = $request->eipId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyCommonBandwidthPackageIpBandwidth',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyCommonBandwidthPackageIpBandwidthResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Sets the maximum bandwidth of an EIP that is associated with an Internet Shared Bandwidth instance.
     *
     * @remarks
     * You can call the **ModifyCommonBandwidthPackageIpBandwidth** operation to set the maximum bandwidth of an EIP that is associated with an Internet Shared Bandwidth instance. This prevents an EIP from exhausting the bandwidth resources of an Internet Shared Bandwidth instance.
     * For example, two EIPs are associated with an Internet Shared Bandwidth instance whose maximum bandwidth is 800 Mbit/s. In this case, you can set the maximum bandwidth of one EIP to 500 Mbit/s and that of the other EIP to 400 Mbit/s. After you set the maximum bandwidth values, the first EIP cannot consume bandwidth higher than 500 Mbit/s. The second EIP cannot consume bandwidth higher than 400 Mbit/s.
     * When you call this operation, take note of the following items:
     * *   This operation is valid only for EIPs that are associated with Elastic Compute Service (ECS) instances. This operation is invalid for EIPs that are associated with Server Load Balancer (SLB) instances, NAT gateways, secondary elastic network interfaces (ENIs), or high-availability virtual IP addresses (HAVIPs).
     * *   This operation is in public preview. You can call this operation to set the maximum bandwidth of EIPs only if the EIPs are associated with an Internet Shared Bandwidth instance. The feature is not supported in the console.
     * *   You cannot repeatedly call this operation to set the maximum bandwidth of an EIP within the specified period of time.
     *
     * @param request - ModifyCommonBandwidthPackageIpBandwidthRequest
     *
     * @returns ModifyCommonBandwidthPackageIpBandwidthResponse
     *
     * @param ModifyCommonBandwidthPackageIpBandwidthRequest $request
     *
     * @return ModifyCommonBandwidthPackageIpBandwidthResponse
     */
    public function modifyCommonBandwidthPackageIpBandwidth($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyCommonBandwidthPackageIpBandwidthWithOptions($request, $runtime);
    }

    /**
     * Modifies the maximum bandwidth of an Internet Shared Bandwidth instance.
     *
     * @remarks
     * Before you call this operation, take note of the following items:
     * *   **ModifyCommonBandwidthPackageSpec** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](https://help.aliyun.com/document_detail/120309.html) operation to query the status of the task.
     *     *   If the Internet Shared Bandwidth instance is in the **Modifying** state, the maximum bandwidth of the Internet Shared Bandwidth instance is being modified. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
     *     *   If the Internet Shared Bandwidth instance is in the **Available** state, the maximum bandwidth of the Internet Shared Bandwidth instance is modified.
     * *   You cannot repeatedly call the **ModifyCommonBandwidthPackageSpec** operation to modify the maximum bandwidth of an Internet Shared Bandwidth instance within the specified period of time.
     *
     * @param request - ModifyCommonBandwidthPackageSpecRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyCommonBandwidthPackageSpecResponse
     *
     * @param ModifyCommonBandwidthPackageSpecRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return ModifyCommonBandwidthPackageSpecResponse
     */
    public function modifyCommonBandwidthPackageSpecWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bandwidth) {
            @$query['Bandwidth'] = $request->bandwidth;
        }

        if (null !== $request->bandwidthPackageId) {
            @$query['BandwidthPackageId'] = $request->bandwidthPackageId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyCommonBandwidthPackageSpec',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyCommonBandwidthPackageSpecResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the maximum bandwidth of an Internet Shared Bandwidth instance.
     *
     * @remarks
     * Before you call this operation, take note of the following items:
     * *   **ModifyCommonBandwidthPackageSpec** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](https://help.aliyun.com/document_detail/120309.html) operation to query the status of the task.
     *     *   If the Internet Shared Bandwidth instance is in the **Modifying** state, the maximum bandwidth of the Internet Shared Bandwidth instance is being modified. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
     *     *   If the Internet Shared Bandwidth instance is in the **Available** state, the maximum bandwidth of the Internet Shared Bandwidth instance is modified.
     * *   You cannot repeatedly call the **ModifyCommonBandwidthPackageSpec** operation to modify the maximum bandwidth of an Internet Shared Bandwidth instance within the specified period of time.
     *
     * @param request - ModifyCommonBandwidthPackageSpecRequest
     *
     * @returns ModifyCommonBandwidthPackageSpecResponse
     *
     * @param ModifyCommonBandwidthPackageSpecRequest $request
     *
     * @return ModifyCommonBandwidthPackageSpecResponse
     */
    public function modifyCommonBandwidthPackageSpec($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyCommonBandwidthPackageSpecWithOptions($request, $runtime);
    }

    /**
     * Modifies the configuration of a customer gateway.
     *
     * @remarks
     *   When you call **ModifyCustomerGatewayAttribute**, if a value is assigned to **AuthKey**, the operation is asynchronous. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If a VPN gateway is in the **updating** state, the configurations are being modified.
     *     *   If a VPN gateway is in the **active** state, the configurations are modified.
     * *   When you call **ModifyCustomerGatewayAttribute**, if no value is assigned to **AuthKey**, the operation is synchronous.
     * *   You cannot repeatedly call **ModifyCustomerGatewayAttribute** to modify the configurations of a customer gateway within the specified period of time.
     *
     * @param request - ModifyCustomerGatewayAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyCustomerGatewayAttributeResponse
     *
     * @param ModifyCustomerGatewayAttributeRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return ModifyCustomerGatewayAttributeResponse
     */
    public function modifyCustomerGatewayAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->authKey) {
            @$query['AuthKey'] = $request->authKey;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->customerGatewayId) {
            @$query['CustomerGatewayId'] = $request->customerGatewayId;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyCustomerGatewayAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyCustomerGatewayAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configuration of a customer gateway.
     *
     * @remarks
     *   When you call **ModifyCustomerGatewayAttribute**, if a value is assigned to **AuthKey**, the operation is asynchronous. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If a VPN gateway is in the **updating** state, the configurations are being modified.
     *     *   If a VPN gateway is in the **active** state, the configurations are modified.
     * *   When you call **ModifyCustomerGatewayAttribute**, if no value is assigned to **AuthKey**, the operation is synchronous.
     * *   You cannot repeatedly call **ModifyCustomerGatewayAttribute** to modify the configurations of a customer gateway within the specified period of time.
     *
     * @param request - ModifyCustomerGatewayAttributeRequest
     *
     * @returns ModifyCustomerGatewayAttributeResponse
     *
     * @param ModifyCustomerGatewayAttributeRequest $request
     *
     * @return ModifyCustomerGatewayAttributeResponse
     */
    public function modifyCustomerGatewayAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyCustomerGatewayAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies the name, description, and maximum bandwidth of an elastic IP address (EIP).
     *
     * @param request - ModifyEipAddressAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyEipAddressAttributeResponse
     *
     * @param ModifyEipAddressAttributeRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return ModifyEipAddressAttributeResponse
     */
    public function modifyEipAddressAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->allocationId) {
            @$query['AllocationId'] = $request->allocationId;
        }

        if (null !== $request->bandwidth) {
            @$query['Bandwidth'] = $request->bandwidth;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyEipAddressAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyEipAddressAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the name, description, and maximum bandwidth of an elastic IP address (EIP).
     *
     * @param request - ModifyEipAddressAttributeRequest
     *
     * @returns ModifyEipAddressAttributeResponse
     *
     * @param ModifyEipAddressAttributeRequest $request
     *
     * @return ModifyEipAddressAttributeResponse
     */
    public function modifyEipAddressAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyEipAddressAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies the EIP forwarding mode.
     *
     * @param request - ModifyEipForwardModeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyEipForwardModeResponse
     *
     * @param ModifyEipForwardModeRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return ModifyEipForwardModeResponse
     */
    public function modifyEipForwardModeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->mode) {
            @$query['Mode'] = $request->mode;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyEipForwardMode',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyEipForwardModeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the EIP forwarding mode.
     *
     * @param request - ModifyEipForwardModeRequest
     *
     * @returns ModifyEipForwardModeResponse
     *
     * @param ModifyEipForwardModeRequest $request
     *
     * @return ModifyEipForwardModeResponse
     */
    public function modifyEipForwardMode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyEipForwardModeWithOptions($request, $runtime);
    }

    /**
     * Modifies the configuration of an Express Cloud Connect (ECC) instance.
     *
     * @param request - ModifyExpressCloudConnectionAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyExpressCloudConnectionAttributeResponse
     *
     * @param ModifyExpressCloudConnectionAttributeRequest $request
     * @param RuntimeOptions                               $runtime
     *
     * @return ModifyExpressCloudConnectionAttributeResponse
     */
    public function modifyExpressCloudConnectionAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bgpAs) {
            @$query['BgpAs'] = $request->bgpAs;
        }

        if (null !== $request->ceIp) {
            @$query['CeIp'] = $request->ceIp;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->eccId) {
            @$query['EccId'] = $request->eccId;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->peIp) {
            @$query['PeIp'] = $request->peIp;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyExpressCloudConnectionAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyExpressCloudConnectionAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configuration of an Express Cloud Connect (ECC) instance.
     *
     * @param request - ModifyExpressCloudConnectionAttributeRequest
     *
     * @returns ModifyExpressCloudConnectionAttributeResponse
     *
     * @param ModifyExpressCloudConnectionAttributeRequest $request
     *
     * @return ModifyExpressCloudConnectionAttributeResponse
     */
    public function modifyExpressCloudConnectionAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyExpressCloudConnectionAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies the bandwidth of an Express Cloud Connect (ECC) instance.
     *
     * @param request - ModifyExpressCloudConnectionBandwidthRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyExpressCloudConnectionBandwidthResponse
     *
     * @param ModifyExpressCloudConnectionBandwidthRequest $request
     * @param RuntimeOptions                               $runtime
     *
     * @return ModifyExpressCloudConnectionBandwidthResponse
     */
    public function modifyExpressCloudConnectionBandwidthWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bandwidth) {
            @$query['Bandwidth'] = $request->bandwidth;
        }

        if (null !== $request->eccId) {
            @$query['EccId'] = $request->eccId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyExpressCloudConnectionBandwidth',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyExpressCloudConnectionBandwidthResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the bandwidth of an Express Cloud Connect (ECC) instance.
     *
     * @param request - ModifyExpressCloudConnectionBandwidthRequest
     *
     * @returns ModifyExpressCloudConnectionBandwidthResponse
     *
     * @param ModifyExpressCloudConnectionBandwidthRequest $request
     *
     * @return ModifyExpressCloudConnectionBandwidthResponse
     */
    public function modifyExpressCloudConnectionBandwidth($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyExpressCloudConnectionBandwidthWithOptions($request, $runtime);
    }

    /**
     * Modifies a quality of service (QoS) policy or associates a QoS policy with a dedicated Express Connect circuit.
     *
     * @param request - ModifyExpressConnectTrafficQosRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyExpressConnectTrafficQosResponse
     *
     * @param ModifyExpressConnectTrafficQosRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return ModifyExpressConnectTrafficQosResponse
     */
    public function modifyExpressConnectTrafficQosWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->addInstanceList) {
            @$query['AddInstanceList'] = $request->addInstanceList;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->qosDescription) {
            @$query['QosDescription'] = $request->qosDescription;
        }

        if (null !== $request->qosId) {
            @$query['QosId'] = $request->qosId;
        }

        if (null !== $request->qosName) {
            @$query['QosName'] = $request->qosName;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->removeInstanceList) {
            @$query['RemoveInstanceList'] = $request->removeInstanceList;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyExpressConnectTrafficQos',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyExpressConnectTrafficQosResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies a quality of service (QoS) policy or associates a QoS policy with a dedicated Express Connect circuit.
     *
     * @param request - ModifyExpressConnectTrafficQosRequest
     *
     * @returns ModifyExpressConnectTrafficQosResponse
     *
     * @param ModifyExpressConnectTrafficQosRequest $request
     *
     * @return ModifyExpressConnectTrafficQosResponse
     */
    public function modifyExpressConnectTrafficQos($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyExpressConnectTrafficQosWithOptions($request, $runtime);
    }

    /**
     * Modifies a quality of service (QoS) queue.
     *
     * @param request - ModifyExpressConnectTrafficQosQueueRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyExpressConnectTrafficQosQueueResponse
     *
     * @param ModifyExpressConnectTrafficQosQueueRequest $request
     * @param RuntimeOptions                             $runtime
     *
     * @return ModifyExpressConnectTrafficQosQueueResponse
     */
    public function modifyExpressConnectTrafficQosQueueWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bandwidthPercent) {
            @$query['BandwidthPercent'] = $request->bandwidthPercent;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->qosId) {
            @$query['QosId'] = $request->qosId;
        }

        if (null !== $request->queueDescription) {
            @$query['QueueDescription'] = $request->queueDescription;
        }

        if (null !== $request->queueId) {
            @$query['QueueId'] = $request->queueId;
        }

        if (null !== $request->queueName) {
            @$query['QueueName'] = $request->queueName;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyExpressConnectTrafficQosQueue',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyExpressConnectTrafficQosQueueResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies a quality of service (QoS) queue.
     *
     * @param request - ModifyExpressConnectTrafficQosQueueRequest
     *
     * @returns ModifyExpressConnectTrafficQosQueueResponse
     *
     * @param ModifyExpressConnectTrafficQosQueueRequest $request
     *
     * @return ModifyExpressConnectTrafficQosQueueResponse
     */
    public function modifyExpressConnectTrafficQosQueue($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyExpressConnectTrafficQosQueueWithOptions($request, $runtime);
    }

    /**
     * Modifies a quality of service (QoS) rule.
     *
     * @param request - ModifyExpressConnectTrafficQosRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyExpressConnectTrafficQosRuleResponse
     *
     * @param ModifyExpressConnectTrafficQosRuleRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return ModifyExpressConnectTrafficQosRuleResponse
     */
    public function modifyExpressConnectTrafficQosRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dstCidr) {
            @$query['DstCidr'] = $request->dstCidr;
        }

        if (null !== $request->dstIPv6Cidr) {
            @$query['DstIPv6Cidr'] = $request->dstIPv6Cidr;
        }

        if (null !== $request->dstPortRange) {
            @$query['DstPortRange'] = $request->dstPortRange;
        }

        if (null !== $request->matchDscp) {
            @$query['MatchDscp'] = $request->matchDscp;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->priority) {
            @$query['Priority'] = $request->priority;
        }

        if (null !== $request->protocol) {
            @$query['Protocol'] = $request->protocol;
        }

        if (null !== $request->qosId) {
            @$query['QosId'] = $request->qosId;
        }

        if (null !== $request->queueId) {
            @$query['QueueId'] = $request->queueId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->remarkingDscp) {
            @$query['RemarkingDscp'] = $request->remarkingDscp;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->ruleDescription) {
            @$query['RuleDescription'] = $request->ruleDescription;
        }

        if (null !== $request->ruleId) {
            @$query['RuleId'] = $request->ruleId;
        }

        if (null !== $request->ruleName) {
            @$query['RuleName'] = $request->ruleName;
        }

        if (null !== $request->srcCidr) {
            @$query['SrcCidr'] = $request->srcCidr;
        }

        if (null !== $request->srcIPv6Cidr) {
            @$query['SrcIPv6Cidr'] = $request->srcIPv6Cidr;
        }

        if (null !== $request->srcPortRange) {
            @$query['SrcPortRange'] = $request->srcPortRange;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyExpressConnectTrafficQosRule',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyExpressConnectTrafficQosRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies a quality of service (QoS) rule.
     *
     * @param request - ModifyExpressConnectTrafficQosRuleRequest
     *
     * @returns ModifyExpressConnectTrafficQosRuleResponse
     *
     * @param ModifyExpressConnectTrafficQosRuleRequest $request
     *
     * @return ModifyExpressConnectTrafficQosRuleResponse
     */
    public function modifyExpressConnectTrafficQosRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyExpressConnectTrafficQosRuleWithOptions($request, $runtime);
    }

    /**
     * Modifies the name and description of a flow log.
     *
     * @remarks
     *   **ModifyFlowLogAttribute** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
     *     *   If the flow log is in the **Modifying** state, the flow log is being modified.
     *     *   If the flow log is in the **Active** or **Inactive** state, the flow log is modified.
     * *   You cannot repeatedly call the **ModifyFlowLogAttribute** operation to modify a flow log within the specified period of time.
     *
     * @param request - ModifyFlowLogAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyFlowLogAttributeResponse
     *
     * @param ModifyFlowLogAttributeRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return ModifyFlowLogAttributeResponse
     */
    public function modifyFlowLogAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aggregationInterval) {
            @$query['AggregationInterval'] = $request->aggregationInterval;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->flowLogId) {
            @$query['FlowLogId'] = $request->flowLogId;
        }

        if (null !== $request->flowLogName) {
            @$query['FlowLogName'] = $request->flowLogName;
        }

        if (null !== $request->ipVersion) {
            @$query['IpVersion'] = $request->ipVersion;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyFlowLogAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyFlowLogAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the name and description of a flow log.
     *
     * @remarks
     *   **ModifyFlowLogAttribute** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
     *     *   If the flow log is in the **Modifying** state, the flow log is being modified.
     *     *   If the flow log is in the **Active** or **Inactive** state, the flow log is modified.
     * *   You cannot repeatedly call the **ModifyFlowLogAttribute** operation to modify a flow log within the specified period of time.
     *
     * @param request - ModifyFlowLogAttributeRequest
     *
     * @returns ModifyFlowLogAttributeResponse
     *
     * @param ModifyFlowLogAttributeRequest $request
     *
     * @return ModifyFlowLogAttributeResponse
     */
    public function modifyFlowLogAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyFlowLogAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies a DNAT entry.
     *
     * @remarks
     *   **ModifyForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
     *     *   **Pending**: indicates that the system is modifying the DNAT entry. You can only query the DNAT entry, but cannot perform other operations.
     *     *   **Available**: indicates that the DNAT entry is modified.
     * *   You cannot repeatedly call the **ModifyForwardEntry** operation to modify a DNAT entry within the specified period of time.
     *
     * @param request - ModifyForwardEntryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyForwardEntryResponse
     *
     * @param ModifyForwardEntryRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return ModifyForwardEntryResponse
     */
    public function modifyForwardEntryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->externalIp) {
            @$query['ExternalIp'] = $request->externalIp;
        }

        if (null !== $request->externalPort) {
            @$query['ExternalPort'] = $request->externalPort;
        }

        if (null !== $request->forwardEntryId) {
            @$query['ForwardEntryId'] = $request->forwardEntryId;
        }

        if (null !== $request->forwardEntryName) {
            @$query['ForwardEntryName'] = $request->forwardEntryName;
        }

        if (null !== $request->forwardTableId) {
            @$query['ForwardTableId'] = $request->forwardTableId;
        }

        if (null !== $request->internalIp) {
            @$query['InternalIp'] = $request->internalIp;
        }

        if (null !== $request->internalPort) {
            @$query['InternalPort'] = $request->internalPort;
        }

        if (null !== $request->ipProtocol) {
            @$query['IpProtocol'] = $request->ipProtocol;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->portBreak) {
            @$query['PortBreak'] = $request->portBreak;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyForwardEntry',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyForwardEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies a DNAT entry.
     *
     * @remarks
     *   **ModifyForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
     *     *   **Pending**: indicates that the system is modifying the DNAT entry. You can only query the DNAT entry, but cannot perform other operations.
     *     *   **Available**: indicates that the DNAT entry is modified.
     * *   You cannot repeatedly call the **ModifyForwardEntry** operation to modify a DNAT entry within the specified period of time.
     *
     * @param request - ModifyForwardEntryRequest
     *
     * @returns ModifyForwardEntryResponse
     *
     * @param ModifyForwardEntryRequest $request
     *
     * @return ModifyForwardEntryResponse
     */
    public function modifyForwardEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyForwardEntryWithOptions($request, $runtime);
    }

    /**
     * Modifies a FULLNAT entry.
     *
     * @remarks
     * ## [](#)
     * *   **ModifyFullNatEntryAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
     *     *   **Modifying**: indicates that the system is modifying the FULLNAT entry. You can query the FULLNAT entry, but cannot perform other operations.
     *     *   **Available**: indicates that the FULLNAT entry is modified.
     * *   You cannot repeatedly call the **ModifyFullNatEntryAttribute** operation to modify a FULLNAT entry within the specified period of time.
     *
     * @param request - ModifyFullNatEntryAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyFullNatEntryAttributeResponse
     *
     * @param ModifyFullNatEntryAttributeRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return ModifyFullNatEntryAttributeResponse
     */
    public function modifyFullNatEntryAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accessIp) {
            @$query['AccessIp'] = $request->accessIp;
        }

        if (null !== $request->accessPort) {
            @$query['AccessPort'] = $request->accessPort;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->fullNatEntryDescription) {
            @$query['FullNatEntryDescription'] = $request->fullNatEntryDescription;
        }

        if (null !== $request->fullNatEntryId) {
            @$query['FullNatEntryId'] = $request->fullNatEntryId;
        }

        if (null !== $request->fullNatEntryName) {
            @$query['FullNatEntryName'] = $request->fullNatEntryName;
        }

        if (null !== $request->fullNatTableId) {
            @$query['FullNatTableId'] = $request->fullNatTableId;
        }

        if (null !== $request->ipProtocol) {
            @$query['IpProtocol'] = $request->ipProtocol;
        }

        if (null !== $request->natIp) {
            @$query['NatIp'] = $request->natIp;
        }

        if (null !== $request->natIpPort) {
            @$query['NatIpPort'] = $request->natIpPort;
        }

        if (null !== $request->networkInterfaceId) {
            @$query['NetworkInterfaceId'] = $request->networkInterfaceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyFullNatEntryAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyFullNatEntryAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies a FULLNAT entry.
     *
     * @remarks
     * ## [](#)
     * *   **ModifyFullNatEntryAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
     *     *   **Modifying**: indicates that the system is modifying the FULLNAT entry. You can query the FULLNAT entry, but cannot perform other operations.
     *     *   **Available**: indicates that the FULLNAT entry is modified.
     * *   You cannot repeatedly call the **ModifyFullNatEntryAttribute** operation to modify a FULLNAT entry within the specified period of time.
     *
     * @param request - ModifyFullNatEntryAttributeRequest
     *
     * @returns ModifyFullNatEntryAttributeResponse
     *
     * @param ModifyFullNatEntryAttributeRequest $request
     *
     * @return ModifyFullNatEntryAttributeResponse
     */
    public function modifyFullNatEntryAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyFullNatEntryAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies the name and description of a Global Accelerator (GA) instance.
     *
     * @param request - ModifyGlobalAccelerationInstanceAttributesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyGlobalAccelerationInstanceAttributesResponse
     *
     * @param ModifyGlobalAccelerationInstanceAttributesRequest $request
     * @param RuntimeOptions                                    $runtime
     *
     * @return ModifyGlobalAccelerationInstanceAttributesResponse
     */
    public function modifyGlobalAccelerationInstanceAttributesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->globalAccelerationInstanceId) {
            @$query['GlobalAccelerationInstanceId'] = $request->globalAccelerationInstanceId;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyGlobalAccelerationInstanceAttributes',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyGlobalAccelerationInstanceAttributesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the name and description of a Global Accelerator (GA) instance.
     *
     * @param request - ModifyGlobalAccelerationInstanceAttributesRequest
     *
     * @returns ModifyGlobalAccelerationInstanceAttributesResponse
     *
     * @param ModifyGlobalAccelerationInstanceAttributesRequest $request
     *
     * @return ModifyGlobalAccelerationInstanceAttributesResponse
     */
    public function modifyGlobalAccelerationInstanceAttributes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyGlobalAccelerationInstanceAttributesWithOptions($request, $runtime);
    }

    /**
     * Modifies the maximum bandwidth of a Global Accelerator (GA) instance.
     *
     * @remarks
     * ## Usage notes
     * You cannot call this operation to modify the maximum bandwidth of a subscription GA instance.
     *
     * @param request - ModifyGlobalAccelerationInstanceSpecRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyGlobalAccelerationInstanceSpecResponse
     *
     * @param ModifyGlobalAccelerationInstanceSpecRequest $request
     * @param RuntimeOptions                              $runtime
     *
     * @return ModifyGlobalAccelerationInstanceSpecResponse
     */
    public function modifyGlobalAccelerationInstanceSpecWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bandwidth) {
            @$query['Bandwidth'] = $request->bandwidth;
        }

        if (null !== $request->globalAccelerationInstanceId) {
            @$query['GlobalAccelerationInstanceId'] = $request->globalAccelerationInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyGlobalAccelerationInstanceSpec',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyGlobalAccelerationInstanceSpecResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the maximum bandwidth of a Global Accelerator (GA) instance.
     *
     * @remarks
     * ## Usage notes
     * You cannot call this operation to modify the maximum bandwidth of a subscription GA instance.
     *
     * @param request - ModifyGlobalAccelerationInstanceSpecRequest
     *
     * @returns ModifyGlobalAccelerationInstanceSpecResponse
     *
     * @param ModifyGlobalAccelerationInstanceSpecRequest $request
     *
     * @return ModifyGlobalAccelerationInstanceSpecResponse
     */
    public function modifyGlobalAccelerationInstanceSpec($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyGlobalAccelerationInstanceSpecWithOptions($request, $runtime);
    }

    /**
     * Modifies the name and description of a high-availability virtual IP address (HaVip).
     *
     * @remarks
     * You cannot repeatedly call the **ModifyHaVipAttribute** operation to modify the name and description of an HaVip within the specified periods of time.
     *
     * @param request - ModifyHaVipAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyHaVipAttributeResponse
     *
     * @param ModifyHaVipAttributeRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return ModifyHaVipAttributeResponse
     */
    public function modifyHaVipAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->haVipId) {
            @$query['HaVipId'] = $request->haVipId;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyHaVipAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyHaVipAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the name and description of a high-availability virtual IP address (HaVip).
     *
     * @remarks
     * You cannot repeatedly call the **ModifyHaVipAttribute** operation to modify the name and description of an HaVip within the specified periods of time.
     *
     * @param request - ModifyHaVipAttributeRequest
     *
     * @returns ModifyHaVipAttributeResponse
     *
     * @param ModifyHaVipAttributeRequest $request
     *
     * @return ModifyHaVipAttributeResponse
     */
    public function modifyHaVipAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyHaVipAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies the name of an access control list (ACL).
     *
     * @deprecated OpenAPI ModifyIPv6TranslatorAclAttribute is deprecated
     *
     * @param request - ModifyIPv6TranslatorAclAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyIPv6TranslatorAclAttributeResponse
     *
     * @param ModifyIPv6TranslatorAclAttributeRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return ModifyIPv6TranslatorAclAttributeResponse
     */
    public function modifyIPv6TranslatorAclAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aclId) {
            @$query['AclId'] = $request->aclId;
        }

        if (null !== $request->aclName) {
            @$query['AclName'] = $request->aclName;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyIPv6TranslatorAclAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyIPv6TranslatorAclAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Modifies the name of an access control list (ACL).
     *
     * @deprecated OpenAPI ModifyIPv6TranslatorAclAttribute is deprecated
     *
     * @param request - ModifyIPv6TranslatorAclAttributeRequest
     *
     * @returns ModifyIPv6TranslatorAclAttributeResponse
     *
     * @param ModifyIPv6TranslatorAclAttributeRequest $request
     *
     * @return ModifyIPv6TranslatorAclAttributeResponse
     */
    public function modifyIPv6TranslatorAclAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyIPv6TranslatorAclAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies an IP entry in an access control list (ACL).
     *
     * @param request - ModifyIPv6TranslatorAclListEntryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyIPv6TranslatorAclListEntryResponse
     *
     * @param ModifyIPv6TranslatorAclListEntryRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return ModifyIPv6TranslatorAclListEntryResponse
     */
    public function modifyIPv6TranslatorAclListEntryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aclEntryComment) {
            @$query['AclEntryComment'] = $request->aclEntryComment;
        }

        if (null !== $request->aclEntryId) {
            @$query['AclEntryId'] = $request->aclEntryId;
        }

        if (null !== $request->aclId) {
            @$query['AclId'] = $request->aclId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyIPv6TranslatorAclListEntry',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyIPv6TranslatorAclListEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies an IP entry in an access control list (ACL).
     *
     * @param request - ModifyIPv6TranslatorAclListEntryRequest
     *
     * @returns ModifyIPv6TranslatorAclListEntryResponse
     *
     * @param ModifyIPv6TranslatorAclListEntryRequest $request
     *
     * @return ModifyIPv6TranslatorAclListEntryResponse
     */
    public function modifyIPv6TranslatorAclListEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyIPv6TranslatorAclListEntryWithOptions($request, $runtime);
    }

    /**
     * Modifies the name and description of an IPv6 Translation Service instance.
     *
     * @param request - ModifyIPv6TranslatorAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyIPv6TranslatorAttributeResponse
     *
     * @param ModifyIPv6TranslatorAttributeRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return ModifyIPv6TranslatorAttributeResponse
     */
    public function modifyIPv6TranslatorAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->ipv6TranslatorId) {
            @$query['Ipv6TranslatorId'] = $request->ipv6TranslatorId;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyIPv6TranslatorAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyIPv6TranslatorAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the name and description of an IPv6 Translation Service instance.
     *
     * @param request - ModifyIPv6TranslatorAttributeRequest
     *
     * @returns ModifyIPv6TranslatorAttributeResponse
     *
     * @param ModifyIPv6TranslatorAttributeRequest $request
     *
     * @return ModifyIPv6TranslatorAttributeResponse
     */
    public function modifyIPv6TranslatorAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyIPv6TranslatorAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies the maximum bandwidth of an IPv6 Translation Service instance.
     *
     * @param request - ModifyIPv6TranslatorBandwidthRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyIPv6TranslatorBandwidthResponse
     *
     * @param ModifyIPv6TranslatorBandwidthRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return ModifyIPv6TranslatorBandwidthResponse
     */
    public function modifyIPv6TranslatorBandwidthWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->autoPay) {
            @$query['AutoPay'] = $request->autoPay;
        }

        if (null !== $request->bandwidth) {
            @$query['Bandwidth'] = $request->bandwidth;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ipv6TranslatorId) {
            @$query['Ipv6TranslatorId'] = $request->ipv6TranslatorId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyIPv6TranslatorBandwidth',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyIPv6TranslatorBandwidthResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the maximum bandwidth of an IPv6 Translation Service instance.
     *
     * @param request - ModifyIPv6TranslatorBandwidthRequest
     *
     * @returns ModifyIPv6TranslatorBandwidthResponse
     *
     * @param ModifyIPv6TranslatorBandwidthRequest $request
     *
     * @return ModifyIPv6TranslatorBandwidthResponse
     */
    public function modifyIPv6TranslatorBandwidth($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyIPv6TranslatorBandwidthWithOptions($request, $runtime);
    }

    /**
     * Modifies an IPv6 mapping entry.
     *
     * @deprecated OpenAPI ModifyIPv6TranslatorEntry is deprecated
     *
     * @param request - ModifyIPv6TranslatorEntryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyIPv6TranslatorEntryResponse
     *
     * @param ModifyIPv6TranslatorEntryRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return ModifyIPv6TranslatorEntryResponse
     */
    public function modifyIPv6TranslatorEntryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aclId) {
            @$query['AclId'] = $request->aclId;
        }

        if (null !== $request->aclStatus) {
            @$query['AclStatus'] = $request->aclStatus;
        }

        if (null !== $request->aclType) {
            @$query['AclType'] = $request->aclType;
        }

        if (null !== $request->allocateIpv6Port) {
            @$query['AllocateIpv6Port'] = $request->allocateIpv6Port;
        }

        if (null !== $request->backendIpv4Addr) {
            @$query['BackendIpv4Addr'] = $request->backendIpv4Addr;
        }

        if (null !== $request->backendIpv4Port) {
            @$query['BackendIpv4Port'] = $request->backendIpv4Port;
        }

        if (null !== $request->entryBandwidth) {
            @$query['EntryBandwidth'] = $request->entryBandwidth;
        }

        if (null !== $request->entryDescription) {
            @$query['EntryDescription'] = $request->entryDescription;
        }

        if (null !== $request->entryName) {
            @$query['EntryName'] = $request->entryName;
        }

        if (null !== $request->ipv6TranslatorEntryId) {
            @$query['Ipv6TranslatorEntryId'] = $request->ipv6TranslatorEntryId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->transProtocol) {
            @$query['TransProtocol'] = $request->transProtocol;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyIPv6TranslatorEntry',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyIPv6TranslatorEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Modifies an IPv6 mapping entry.
     *
     * @deprecated OpenAPI ModifyIPv6TranslatorEntry is deprecated
     *
     * @param request - ModifyIPv6TranslatorEntryRequest
     *
     * @returns ModifyIPv6TranslatorEntryResponse
     *
     * @param ModifyIPv6TranslatorEntryRequest $request
     *
     * @return ModifyIPv6TranslatorEntryResponse
     */
    public function modifyIPv6TranslatorEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyIPv6TranslatorEntryWithOptions($request, $runtime);
    }

    /**
     * Modifies the name and description of an IPv6 address.
     *
     * @param request - ModifyIpv6AddressAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyIpv6AddressAttributeResponse
     *
     * @param ModifyIpv6AddressAttributeRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return ModifyIpv6AddressAttributeResponse
     */
    public function modifyIpv6AddressAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ipv6AddressId) {
            @$query['Ipv6AddressId'] = $request->ipv6AddressId;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyIpv6AddressAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyIpv6AddressAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the name and description of an IPv6 address.
     *
     * @param request - ModifyIpv6AddressAttributeRequest
     *
     * @returns ModifyIpv6AddressAttributeResponse
     *
     * @param ModifyIpv6AddressAttributeRequest $request
     *
     * @return ModifyIpv6AddressAttributeResponse
     */
    public function modifyIpv6AddressAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyIpv6AddressAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies the name and description of an IPv6 gateway.
     *
     * @param request - ModifyIpv6GatewayAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyIpv6GatewayAttributeResponse
     *
     * @param ModifyIpv6GatewayAttributeRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return ModifyIpv6GatewayAttributeResponse
     */
    public function modifyIpv6GatewayAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ipv6GatewayId) {
            @$query['Ipv6GatewayId'] = $request->ipv6GatewayId;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyIpv6GatewayAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyIpv6GatewayAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the name and description of an IPv6 gateway.
     *
     * @param request - ModifyIpv6GatewayAttributeRequest
     *
     * @returns ModifyIpv6GatewayAttributeResponse
     *
     * @param ModifyIpv6GatewayAttributeRequest $request
     *
     * @return ModifyIpv6GatewayAttributeResponse
     */
    public function modifyIpv6GatewayAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyIpv6GatewayAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies the Internet bandwidth of an IPv6 address.
     *
     * @remarks
     * You cannot repeatedly call the **ModifyIpv6InternetBandwidth** operation to modify the Internet bandwidth value of an IPv6 CIDR block within the specified period of time.
     *
     * @param request - ModifyIpv6InternetBandwidthRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyIpv6InternetBandwidthResponse
     *
     * @param ModifyIpv6InternetBandwidthRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return ModifyIpv6InternetBandwidthResponse
     */
    public function modifyIpv6InternetBandwidthWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bandwidth) {
            @$query['Bandwidth'] = $request->bandwidth;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ipv6AddressId) {
            @$query['Ipv6AddressId'] = $request->ipv6AddressId;
        }

        if (null !== $request->ipv6InternetBandwidthId) {
            @$query['Ipv6InternetBandwidthId'] = $request->ipv6InternetBandwidthId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyIpv6InternetBandwidth',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyIpv6InternetBandwidthResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the Internet bandwidth of an IPv6 address.
     *
     * @remarks
     * You cannot repeatedly call the **ModifyIpv6InternetBandwidth** operation to modify the Internet bandwidth value of an IPv6 CIDR block within the specified period of time.
     *
     * @param request - ModifyIpv6InternetBandwidthRequest
     *
     * @returns ModifyIpv6InternetBandwidthResponse
     *
     * @param ModifyIpv6InternetBandwidthRequest $request
     *
     * @return ModifyIpv6InternetBandwidthResponse
     */
    public function modifyIpv6InternetBandwidth($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyIpv6InternetBandwidthWithOptions($request, $runtime);
    }

    /**
     * Modifies the name and description of a NAT gateway.
     *
     * @remarks
     * ## [](#)Description
     * You can call this operation to query an Internet NAT gateway or a virtual private cloud (VPC) NAT gateway. The term NAT gateway in this topic refers to both NAT gateway types.
     *
     * @param tmpReq - ModifyNatGatewayAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyNatGatewayAttributeResponse
     *
     * @param ModifyNatGatewayAttributeRequest $tmpReq
     * @param RuntimeOptions                   $runtime
     *
     * @return ModifyNatGatewayAttributeResponse
     */
    public function modifyNatGatewayAttributeWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new ModifyNatGatewayAttributeShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->logDelivery) {
            $request->logDeliveryShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->logDelivery, 'LogDelivery', 'json');
        }

        $query = [];
        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->eipBindMode) {
            @$query['EipBindMode'] = $request->eipBindMode;
        }

        if (null !== $request->enableSessionLog) {
            @$query['EnableSessionLog'] = $request->enableSessionLog;
        }

        if (null !== $request->icmpReplyEnabled) {
            @$query['IcmpReplyEnabled'] = $request->icmpReplyEnabled;
        }

        if (null !== $request->logDeliveryShrink) {
            @$query['LogDelivery'] = $request->logDeliveryShrink;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->natGatewayId) {
            @$query['NatGatewayId'] = $request->natGatewayId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyNatGatewayAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyNatGatewayAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the name and description of a NAT gateway.
     *
     * @remarks
     * ## [](#)Description
     * You can call this operation to query an Internet NAT gateway or a virtual private cloud (VPC) NAT gateway. The term NAT gateway in this topic refers to both NAT gateway types.
     *
     * @param request - ModifyNatGatewayAttributeRequest
     *
     * @returns ModifyNatGatewayAttributeResponse
     *
     * @param ModifyNatGatewayAttributeRequest $request
     *
     * @return ModifyNatGatewayAttributeResponse
     */
    public function modifyNatGatewayAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyNatGatewayAttributeWithOptions($request, $runtime);
    }

    /**
     * Upgrades a subscription Internet NAT gateway.
     *
     * @remarks
     * - You cannot call this operation to downgrade a subscription Internet NAT gateway. You can downgrade a subscription Internet NAT gateway only in the console.
     * - When you call this operation to upgrade a subscription Internet NAT gateway, an order is generated. After you complete the payment in the order center, the Internet NAT gateway is upgraded.
     * - **ModifyNatGatewaySpec** is an asynchronous operation. After you make a request, the ID of the request is returned but the Internet NAT gateway is not upgraded. The system upgrades the NAT gateway in the background. You can call the [DescribeNatGateways](/help/en/virtual-private-cloud/latest/describenatgateways) operation to query the status of an Internet NAT gateway.    - If an Internet NAT gateway is in the **Modifying** state, the NAT gateway is being upgraded. In this case, you can only query the NAT gateway but cannot perform other operations.
     *   - If an Internet NAT gateway is in the **Available** state, the Internet NAT gateway is upgraded.
     * - You cannot repeatedly call the **ModifyNatGatewaySpec** operation to resize a pay-by-specification NAT gateway.
     * Internet NAT gateways are available in different sizes. The size of an Internet NAT gateway determines the SNAT performance, which includes the maximum number of connections and the number of new connections per second. However, the size of a NAT gateway does not affect the data throughput. The following table describes the correlations between different sizes of Internet NAT gateways and SNAT performance metrics.
     * | Size | Maximum number of connections | Number of new connections per second |
     * | ---- | ----------------------------- | ------------------------------------ |
     * | Small | 10,000 | 1,000 |
     * | Medium | 50,000 | 5,000 |
     * | Large | 200,000 | 10,000 |
     *
     * @param request - ModifyNatGatewaySpecRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyNatGatewaySpecResponse
     *
     * @param ModifyNatGatewaySpecRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return ModifyNatGatewaySpecResponse
     */
    public function modifyNatGatewaySpecWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->autoPay) {
            @$query['AutoPay'] = $request->autoPay;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->natGatewayId) {
            @$query['NatGatewayId'] = $request->natGatewayId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->spec) {
            @$query['Spec'] = $request->spec;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyNatGatewaySpec',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyNatGatewaySpecResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Upgrades a subscription Internet NAT gateway.
     *
     * @remarks
     * - You cannot call this operation to downgrade a subscription Internet NAT gateway. You can downgrade a subscription Internet NAT gateway only in the console.
     * - When you call this operation to upgrade a subscription Internet NAT gateway, an order is generated. After you complete the payment in the order center, the Internet NAT gateway is upgraded.
     * - **ModifyNatGatewaySpec** is an asynchronous operation. After you make a request, the ID of the request is returned but the Internet NAT gateway is not upgraded. The system upgrades the NAT gateway in the background. You can call the [DescribeNatGateways](/help/en/virtual-private-cloud/latest/describenatgateways) operation to query the status of an Internet NAT gateway.    - If an Internet NAT gateway is in the **Modifying** state, the NAT gateway is being upgraded. In this case, you can only query the NAT gateway but cannot perform other operations.
     *   - If an Internet NAT gateway is in the **Available** state, the Internet NAT gateway is upgraded.
     * - You cannot repeatedly call the **ModifyNatGatewaySpec** operation to resize a pay-by-specification NAT gateway.
     * Internet NAT gateways are available in different sizes. The size of an Internet NAT gateway determines the SNAT performance, which includes the maximum number of connections and the number of new connections per second. However, the size of a NAT gateway does not affect the data throughput. The following table describes the correlations between different sizes of Internet NAT gateways and SNAT performance metrics.
     * | Size | Maximum number of connections | Number of new connections per second |
     * | ---- | ----------------------------- | ------------------------------------ |
     * | Small | 10,000 | 1,000 |
     * | Medium | 50,000 | 5,000 |
     * | Large | 200,000 | 10,000 |
     *
     * @param request - ModifyNatGatewaySpecRequest
     *
     * @returns ModifyNatGatewaySpecResponse
     *
     * @param ModifyNatGatewaySpecRequest $request
     *
     * @return ModifyNatGatewaySpecResponse
     */
    public function modifyNatGatewaySpec($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyNatGatewaySpecWithOptions($request, $runtime);
    }

    /**
     * Modifies the name and description of a NAT IP address.
     *
     * @remarks
     * ## [](#)Description
     * You cannot repeatedly call the **ModifyNatIpAttribute** operation to modify the name and description of a NAT IP address within the specified period of time.
     *
     * @param request - ModifyNatIpAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyNatIpAttributeResponse
     *
     * @param ModifyNatIpAttributeRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return ModifyNatIpAttributeResponse
     */
    public function modifyNatIpAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->natIpDescription) {
            @$query['NatIpDescription'] = $request->natIpDescription;
        }

        if (null !== $request->natIpId) {
            @$query['NatIpId'] = $request->natIpId;
        }

        if (null !== $request->natIpName) {
            @$query['NatIpName'] = $request->natIpName;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyNatIpAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyNatIpAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the name and description of a NAT IP address.
     *
     * @remarks
     * ## [](#)Description
     * You cannot repeatedly call the **ModifyNatIpAttribute** operation to modify the name and description of a NAT IP address within the specified period of time.
     *
     * @param request - ModifyNatIpAttributeRequest
     *
     * @returns ModifyNatIpAttributeResponse
     *
     * @param ModifyNatIpAttributeRequest $request
     *
     * @return ModifyNatIpAttributeResponse
     */
    public function modifyNatIpAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyNatIpAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies the name and description of a NAT CIDR block.
     *
     * @param request - ModifyNatIpCidrAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyNatIpCidrAttributeResponse
     *
     * @param ModifyNatIpCidrAttributeRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return ModifyNatIpCidrAttributeResponse
     */
    public function modifyNatIpCidrAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->natGatewayId) {
            @$query['NatGatewayId'] = $request->natGatewayId;
        }

        if (null !== $request->natIpCidr) {
            @$query['NatIpCidr'] = $request->natIpCidr;
        }

        if (null !== $request->natIpCidrDescription) {
            @$query['NatIpCidrDescription'] = $request->natIpCidrDescription;
        }

        if (null !== $request->natIpCidrName) {
            @$query['NatIpCidrName'] = $request->natIpCidrName;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyNatIpCidrAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyNatIpCidrAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the name and description of a NAT CIDR block.
     *
     * @param request - ModifyNatIpCidrAttributeRequest
     *
     * @returns ModifyNatIpCidrAttributeResponse
     *
     * @param ModifyNatIpCidrAttributeRequest $request
     *
     * @return ModifyNatIpCidrAttributeResponse
     */
    public function modifyNatIpCidrAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyNatIpCidrAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies the attributes of a network access control list (ACL).
     *
     * @param request - ModifyNetworkAclAttributesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyNetworkAclAttributesResponse
     *
     * @param ModifyNetworkAclAttributesRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return ModifyNetworkAclAttributesResponse
     */
    public function modifyNetworkAclAttributesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->networkAclId) {
            @$query['NetworkAclId'] = $request->networkAclId;
        }

        if (null !== $request->networkAclName) {
            @$query['NetworkAclName'] = $request->networkAclName;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyNetworkAclAttributes',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyNetworkAclAttributesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the attributes of a network access control list (ACL).
     *
     * @param request - ModifyNetworkAclAttributesRequest
     *
     * @returns ModifyNetworkAclAttributesResponse
     *
     * @param ModifyNetworkAclAttributesRequest $request
     *
     * @return ModifyNetworkAclAttributesResponse
     */
    public function modifyNetworkAclAttributes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyNetworkAclAttributesWithOptions($request, $runtime);
    }

    /**
     * Modifies the configurations of an Express Connect circuit.
     *
     * @remarks
     * When you call this operation, take note of the following limits:
     * *   If an Express Connect circuit is in the **Initial**, **Enabled**, or **Rejected** state, you can modify the specifications of the Express Connect circuit and the ID of the redundant circuit.
     * *   If an Express Connect circuit is in the **Canceled**, **Allocating**, **AllocationFailed**, or **Terminated** state, you cannot modify the specifications of the Express Connect circuit.
     * *   After you modify the specifications of an Express Connect circuit that is in the **Rejected** state, the Express Connect circuit enters the **Initial** state.
     *
     * @param request - ModifyPhysicalConnectionAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyPhysicalConnectionAttributeResponse
     *
     * @param ModifyPhysicalConnectionAttributeRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return ModifyPhysicalConnectionAttributeResponse
     */
    public function modifyPhysicalConnectionAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->circuitCode) {
            @$query['CircuitCode'] = $request->circuitCode;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->lineOperator) {
            @$query['LineOperator'] = $request->lineOperator;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->peerLocation) {
            @$query['PeerLocation'] = $request->peerLocation;
        }

        if (null !== $request->physicalConnectionId) {
            @$query['PhysicalConnectionId'] = $request->physicalConnectionId;
        }

        if (null !== $request->portType) {
            @$query['PortType'] = $request->portType;
        }

        if (null !== $request->redundantPhysicalConnectionId) {
            @$query['RedundantPhysicalConnectionId'] = $request->redundantPhysicalConnectionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->bandwidth) {
            @$query['bandwidth'] = $request->bandwidth;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyPhysicalConnectionAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyPhysicalConnectionAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configurations of an Express Connect circuit.
     *
     * @remarks
     * When you call this operation, take note of the following limits:
     * *   If an Express Connect circuit is in the **Initial**, **Enabled**, or **Rejected** state, you can modify the specifications of the Express Connect circuit and the ID of the redundant circuit.
     * *   If an Express Connect circuit is in the **Canceled**, **Allocating**, **AllocationFailed**, or **Terminated** state, you cannot modify the specifications of the Express Connect circuit.
     * *   After you modify the specifications of an Express Connect circuit that is in the **Rejected** state, the Express Connect circuit enters the **Initial** state.
     *
     * @param request - ModifyPhysicalConnectionAttributeRequest
     *
     * @returns ModifyPhysicalConnectionAttributeResponse
     *
     * @param ModifyPhysicalConnectionAttributeRequest $request
     *
     * @return ModifyPhysicalConnectionAttributeResponse
     */
    public function modifyPhysicalConnectionAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyPhysicalConnectionAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies the name and description of a custom route entry.
     *
     * @remarks
     * You cannot repeatedly call the **ModifyRouteEntry** operation to modify the name and description of a custom route within the specified period of time.
     *
     * @param request - ModifyRouteEntryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyRouteEntryResponse
     *
     * @param ModifyRouteEntryRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return ModifyRouteEntryResponse
     */
    public function modifyRouteEntryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->destinationCidrBlock) {
            @$query['DestinationCidrBlock'] = $request->destinationCidrBlock;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->newNextHopId) {
            @$query['NewNextHopId'] = $request->newNextHopId;
        }

        if (null !== $request->newNextHopType) {
            @$query['NewNextHopType'] = $request->newNextHopType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeEntryId) {
            @$query['RouteEntryId'] = $request->routeEntryId;
        }

        if (null !== $request->routeEntryName) {
            @$query['RouteEntryName'] = $request->routeEntryName;
        }

        if (null !== $request->routeTableId) {
            @$query['RouteTableId'] = $request->routeTableId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyRouteEntry',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyRouteEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the name and description of a custom route entry.
     *
     * @remarks
     * You cannot repeatedly call the **ModifyRouteEntry** operation to modify the name and description of a custom route within the specified period of time.
     *
     * @param request - ModifyRouteEntryRequest
     *
     * @returns ModifyRouteEntryResponse
     *
     * @param ModifyRouteEntryRequest $request
     *
     * @return ModifyRouteEntryResponse
     */
    public function modifyRouteEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyRouteEntryWithOptions($request, $runtime);
    }

    /**
     * Modifies the name and description of a route table.
     *
     * @remarks
     * You cannot repeatedly call the **ModifyRouteTableAttributes** operation to modify the name and description of a route table within the specified period of time.
     *
     * @param request - ModifyRouteTableAttributesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyRouteTableAttributesResponse
     *
     * @param ModifyRouteTableAttributesRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return ModifyRouteTableAttributesResponse
     */
    public function modifyRouteTableAttributesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routePropagationEnable) {
            @$query['RoutePropagationEnable'] = $request->routePropagationEnable;
        }

        if (null !== $request->routeTableId) {
            @$query['RouteTableId'] = $request->routeTableId;
        }

        if (null !== $request->routeTableName) {
            @$query['RouteTableName'] = $request->routeTableName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyRouteTableAttributes',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyRouteTableAttributesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the name and description of a route table.
     *
     * @remarks
     * You cannot repeatedly call the **ModifyRouteTableAttributes** operation to modify the name and description of a route table within the specified period of time.
     *
     * @param request - ModifyRouteTableAttributesRequest
     *
     * @returns ModifyRouteTableAttributesResponse
     *
     * @param ModifyRouteTableAttributesRequest $request
     *
     * @return ModifyRouteTableAttributesResponse
     */
    public function modifyRouteTableAttributes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyRouteTableAttributesWithOptions($request, $runtime);
    }

    /**
     * Modifies the configuration of a router interface.
     *
     * @param request - ModifyRouterInterfaceAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyRouterInterfaceAttributeResponse
     *
     * @param ModifyRouterInterfaceAttributeRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return ModifyRouterInterfaceAttributeResponse
     */
    public function modifyRouterInterfaceAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->deleteHealthCheckIp) {
            @$query['DeleteHealthCheckIp'] = $request->deleteHealthCheckIp;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->hcRate) {
            @$query['HcRate'] = $request->hcRate;
        }

        if (null !== $request->hcThreshold) {
            @$query['HcThreshold'] = $request->hcThreshold;
        }

        if (null !== $request->healthCheckSourceIp) {
            @$query['HealthCheckSourceIp'] = $request->healthCheckSourceIp;
        }

        if (null !== $request->healthCheckTargetIp) {
            @$query['HealthCheckTargetIp'] = $request->healthCheckTargetIp;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->oppositeInterfaceId) {
            @$query['OppositeInterfaceId'] = $request->oppositeInterfaceId;
        }

        if (null !== $request->oppositeInterfaceOwnerId) {
            @$query['OppositeInterfaceOwnerId'] = $request->oppositeInterfaceOwnerId;
        }

        if (null !== $request->oppositeRouterId) {
            @$query['OppositeRouterId'] = $request->oppositeRouterId;
        }

        if (null !== $request->oppositeRouterType) {
            @$query['OppositeRouterType'] = $request->oppositeRouterType;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routerInterfaceId) {
            @$query['RouterInterfaceId'] = $request->routerInterfaceId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyRouterInterfaceAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyRouterInterfaceAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configuration of a router interface.
     *
     * @param request - ModifyRouterInterfaceAttributeRequest
     *
     * @returns ModifyRouterInterfaceAttributeResponse
     *
     * @param ModifyRouterInterfaceAttributeRequest $request
     *
     * @return ModifyRouterInterfaceAttributeResponse
     */
    public function modifyRouterInterfaceAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyRouterInterfaceAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies the specification of a router interface.
     *
     * @remarks
     * After you call this operation, the router interface enters the **Activating** state. After the router interface is activated, the router interface enters the **Active** state.
     * >  You cannot modify the specification of a router interface that has overdue payments.
     *
     * @param request - ModifyRouterInterfaceSpecRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyRouterInterfaceSpecResponse
     *
     * @param ModifyRouterInterfaceSpecRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return ModifyRouterInterfaceSpecResponse
     */
    public function modifyRouterInterfaceSpecWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routerInterfaceId) {
            @$query['RouterInterfaceId'] = $request->routerInterfaceId;
        }

        if (null !== $request->spec) {
            @$query['Spec'] = $request->spec;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyRouterInterfaceSpec',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyRouterInterfaceSpecResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the specification of a router interface.
     *
     * @remarks
     * After you call this operation, the router interface enters the **Activating** state. After the router interface is activated, the router interface enters the **Active** state.
     * >  You cannot modify the specification of a router interface that has overdue payments.
     *
     * @param request - ModifyRouterInterfaceSpecRequest
     *
     * @returns ModifyRouterInterfaceSpecResponse
     *
     * @param ModifyRouterInterfaceSpecRequest $request
     *
     * @return ModifyRouterInterfaceSpecResponse
     */
    public function modifyRouterInterfaceSpec($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyRouterInterfaceSpecWithOptions($request, $runtime);
    }

    /**
     * Modifies an SNAT entry.
     *
     * @remarks
     * ## [](#)
     * **ModifySnatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of the task.
     * *   **Pending**: indicates that the system is modifying the SNAT entry. You can only query the status of the SNAT entry, but cannot perform other operations.
     * *   **Available**: indicates that the SNAT entry is modified.
     * >  If an SNAT entry is in the **Pending** state, it indicates that you cannot modify the SNAT entry.
     * You cannot repeatedly call the **ModifySnatEntry** operation to modify an SNAT entry within a specific period of time.
     *
     * @param request - ModifySnatEntryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifySnatEntryResponse
     *
     * @param ModifySnatEntryRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return ModifySnatEntryResponse
     */
    public function modifySnatEntryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->eipAffinity) {
            @$query['EipAffinity'] = $request->eipAffinity;
        }

        if (null !== $request->networkInterfaceId) {
            @$query['NetworkInterfaceId'] = $request->networkInterfaceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->snatEntryId) {
            @$query['SnatEntryId'] = $request->snatEntryId;
        }

        if (null !== $request->snatEntryName) {
            @$query['SnatEntryName'] = $request->snatEntryName;
        }

        if (null !== $request->snatIp) {
            @$query['SnatIp'] = $request->snatIp;
        }

        if (null !== $request->snatTableId) {
            @$query['SnatTableId'] = $request->snatTableId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifySnatEntry',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifySnatEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies an SNAT entry.
     *
     * @remarks
     * ## [](#)
     * **ModifySnatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of the task.
     * *   **Pending**: indicates that the system is modifying the SNAT entry. You can only query the status of the SNAT entry, but cannot perform other operations.
     * *   **Available**: indicates that the SNAT entry is modified.
     * >  If an SNAT entry is in the **Pending** state, it indicates that you cannot modify the SNAT entry.
     * You cannot repeatedly call the **ModifySnatEntry** operation to modify an SNAT entry within a specific period of time.
     *
     * @param request - ModifySnatEntryRequest
     *
     * @returns ModifySnatEntryResponse
     *
     * @param ModifySnatEntryRequest $request
     *
     * @return ModifySnatEntryResponse
     */
    public function modifySnatEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifySnatEntryWithOptions($request, $runtime);
    }

    /**
     * Modifies the name of an SSL-VPN client certificate.
     *
     * @param request - ModifySslVpnClientCertRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifySslVpnClientCertResponse
     *
     * @param ModifySslVpnClientCertRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return ModifySslVpnClientCertResponse
     */
    public function modifySslVpnClientCertWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sslVpnClientCertId) {
            @$query['SslVpnClientCertId'] = $request->sslVpnClientCertId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifySslVpnClientCert',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifySslVpnClientCertResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the name of an SSL-VPN client certificate.
     *
     * @param request - ModifySslVpnClientCertRequest
     *
     * @returns ModifySslVpnClientCertResponse
     *
     * @param ModifySslVpnClientCertRequest $request
     *
     * @return ModifySslVpnClientCertResponse
     */
    public function modifySslVpnClientCert($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifySslVpnClientCertWithOptions($request, $runtime);
    }

    /**
     * Modifies the configurations of an SSL server.
     *
     * @remarks
     *   To enable two-factor authentication for an SSL server, make sure that the VPN gateway supports two-factor authentication. You may need to upgrade the VPN gateway. For more information, see [Two-factor authentication supports IDaaS EIAM 2.0](https://help.aliyun.com/document_detail/2785320.html).
     * *   If you modify only **Name**, this operation is synchronous. If you modify other parameters besides **Name**, this operation is asynchronous.
     * *   **ModifySslVpnServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the SSL server is being modified.
     *     *   If the VPN gateway is in the **active** state, the SSL server is modified.
     * *   You cannot repeatedly call **ModifySslVpnServer** within the specified period of time.
     *
     * @param request - ModifySslVpnServerRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifySslVpnServerResponse
     *
     * @param ModifySslVpnServerRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return ModifySslVpnServerResponse
     */
    public function modifySslVpnServerWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->cipher) {
            @$query['Cipher'] = $request->cipher;
        }

        if (null !== $request->clientIpPool) {
            @$query['ClientIpPool'] = $request->clientIpPool;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->compress) {
            @$query['Compress'] = $request->compress;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->enableMultiFactorAuth) {
            @$query['EnableMultiFactorAuth'] = $request->enableMultiFactorAuth;
        }

        if (null !== $request->IDaaSApplicationId) {
            @$query['IDaaSApplicationId'] = $request->IDaaSApplicationId;
        }

        if (null !== $request->IDaaSInstanceId) {
            @$query['IDaaSInstanceId'] = $request->IDaaSInstanceId;
        }

        if (null !== $request->IDaaSRegionId) {
            @$query['IDaaSRegionId'] = $request->IDaaSRegionId;
        }

        if (null !== $request->localSubnet) {
            @$query['LocalSubnet'] = $request->localSubnet;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->port) {
            @$query['Port'] = $request->port;
        }

        if (null !== $request->proto) {
            @$query['Proto'] = $request->proto;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sslVpnServerId) {
            @$query['SslVpnServerId'] = $request->sslVpnServerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifySslVpnServer',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifySslVpnServerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configurations of an SSL server.
     *
     * @remarks
     *   To enable two-factor authentication for an SSL server, make sure that the VPN gateway supports two-factor authentication. You may need to upgrade the VPN gateway. For more information, see [Two-factor authentication supports IDaaS EIAM 2.0](https://help.aliyun.com/document_detail/2785320.html).
     * *   If you modify only **Name**, this operation is synchronous. If you modify other parameters besides **Name**, this operation is asynchronous.
     * *   **ModifySslVpnServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the SSL server is being modified.
     *     *   If the VPN gateway is in the **active** state, the SSL server is modified.
     * *   You cannot repeatedly call **ModifySslVpnServer** within the specified period of time.
     *
     * @param request - ModifySslVpnServerRequest
     *
     * @returns ModifySslVpnServerResponse
     *
     * @param ModifySslVpnServerRequest $request
     *
     * @return ModifySslVpnServerResponse
     */
    public function modifySslVpnServer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifySslVpnServerWithOptions($request, $runtime);
    }

    /**
     * Modifies a VPN tunnel.
     *
     * @param request - ModifyTunnelAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyTunnelAttributeResponse
     *
     * @param ModifyTunnelAttributeRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return ModifyTunnelAttributeResponse
     */
    public function modifyTunnelAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tunnelId) {
            @$query['TunnelId'] = $request->tunnelId;
        }

        if (null !== $request->tunnelOptionsSpecification) {
            @$query['TunnelOptionsSpecification'] = $request->tunnelOptionsSpecification;
        }

        if (null !== $request->vpnConnectionId) {
            @$query['VpnConnectionId'] = $request->vpnConnectionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyTunnelAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyTunnelAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies a VPN tunnel.
     *
     * @param request - ModifyTunnelAttributeRequest
     *
     * @returns ModifyTunnelAttributeResponse
     *
     * @param ModifyTunnelAttributeRequest $request
     *
     * @return ModifyTunnelAttributeResponse
     */
    public function modifyTunnelAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyTunnelAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies the name and description of a vRouter.
     *
     * @remarks
     * You cannot repeatedly call the **ModifyVRouterAttribute** operation within a specific period of time.
     *
     * @param request - ModifyVRouterAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyVRouterAttributeResponse
     *
     * @param ModifyVRouterAttributeRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return ModifyVRouterAttributeResponse
     */
    public function modifyVRouterAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->VRouterId) {
            @$query['VRouterId'] = $request->VRouterId;
        }

        if (null !== $request->VRouterName) {
            @$query['VRouterName'] = $request->VRouterName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyVRouterAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyVRouterAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the name and description of a vRouter.
     *
     * @remarks
     * You cannot repeatedly call the **ModifyVRouterAttribute** operation within a specific period of time.
     *
     * @param request - ModifyVRouterAttributeRequest
     *
     * @returns ModifyVRouterAttributeResponse
     *
     * @param ModifyVRouterAttributeRequest $request
     *
     * @return ModifyVRouterAttributeResponse
     */
    public function modifyVRouterAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVRouterAttributeWithOptions($request, $runtime);
    }

    /**
     * VSwitch.
     *
     * @remarks
     *   **ModifyVSwitchAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
     *     *   If the vSwitch is in the **Pending** state, the name and description of the vSwitch are being modified.
     *     *   If the vSwitch is in the **Available** state, the name and description of the vSwitch are modified.
     * *   You cannot repeatedly call the **ModifyVSwitchAttribute** operation to modify the name and description of a vSwitch within the specified period of time.
     *
     * @param request - ModifyVSwitchAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyVSwitchAttributeResponse
     *
     * @param ModifyVSwitchAttributeRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return ModifyVSwitchAttributeResponse
     */
    public function modifyVSwitchAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->enableIPv6) {
            @$query['EnableIPv6'] = $request->enableIPv6;
        }

        if (null !== $request->ipv6CidrBlock) {
            @$query['Ipv6CidrBlock'] = $request->ipv6CidrBlock;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        if (null !== $request->vSwitchName) {
            @$query['VSwitchName'] = $request->vSwitchName;
        }

        if (null !== $request->vpcIpv6CidrBlock) {
            @$query['VpcIpv6CidrBlock'] = $request->vpcIpv6CidrBlock;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyVSwitchAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyVSwitchAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * VSwitch.
     *
     * @remarks
     *   **ModifyVSwitchAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
     *     *   If the vSwitch is in the **Pending** state, the name and description of the vSwitch are being modified.
     *     *   If the vSwitch is in the **Available** state, the name and description of the vSwitch are modified.
     * *   You cannot repeatedly call the **ModifyVSwitchAttribute** operation to modify the name and description of a vSwitch within the specified period of time.
     *
     * @param request - ModifyVSwitchAttributeRequest
     *
     * @returns ModifyVSwitchAttributeResponse
     *
     * @param ModifyVSwitchAttributeRequest $request
     *
     * @return ModifyVSwitchAttributeResponse
     */
    public function modifyVSwitchAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVSwitchAttributeWithOptions($request, $runtime);
    }

    /**
     * 
     *
     * @remarks
     * ## [](#)Usage notes
     * You cannot repeatedly call **ModifyVSwitchCidrReservationAttribute** within a specific time period.
     *
     * @param request - ModifyVSwitchCidrReservationAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyVSwitchCidrReservationAttributeResponse
     *
     * @param ModifyVSwitchCidrReservationAttributeRequest $request
     * @param RuntimeOptions                               $runtime
     *
     * @return ModifyVSwitchCidrReservationAttributeResponse
     */
    public function modifyVSwitchCidrReservationAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vSwitchCidrReservationDescription) {
            @$query['VSwitchCidrReservationDescription'] = $request->vSwitchCidrReservationDescription;
        }

        if (null !== $request->vSwitchCidrReservationId) {
            @$query['VSwitchCidrReservationId'] = $request->vSwitchCidrReservationId;
        }

        if (null !== $request->vSwitchCidrReservationName) {
            @$query['VSwitchCidrReservationName'] = $request->vSwitchCidrReservationName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyVSwitchCidrReservationAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyVSwitchCidrReservationAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 
     *
     * @remarks
     * ## [](#)Usage notes
     * You cannot repeatedly call **ModifyVSwitchCidrReservationAttribute** within a specific time period.
     *
     * @param request - ModifyVSwitchCidrReservationAttributeRequest
     *
     * @returns ModifyVSwitchCidrReservationAttributeResponse
     *
     * @param ModifyVSwitchCidrReservationAttributeRequest $request
     *
     * @return ModifyVSwitchCidrReservationAttributeResponse
     */
    public function modifyVSwitchCidrReservationAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVSwitchCidrReservationAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies the weight of a destination-based route for an IPsec-VPN connection.
     *
     * @remarks
     *   **ModifyVcoRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the associated IPsec-VPN connection and determine whether the weight of the specified destination-based route is modified.
     *     *   If the IPsec-VPN connection is in the **updating** state, the weight of the destination-based route is being modified.
     *     *   If the IPsec-VPN connection is in the **attached** state, the weight of the destination-based route is modified.
     * *   You cannot repeatedly call the **ModifyVcoRouteEntryWeight** operation for the same IPsec-VPN connection within the specified period of time.
     *
     * @param request - ModifyVcoRouteEntryWeightRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyVcoRouteEntryWeightResponse
     *
     * @param ModifyVcoRouteEntryWeightRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return ModifyVcoRouteEntryWeightResponse
     */
    public function modifyVcoRouteEntryWeightWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->newWeight) {
            @$query['NewWeight'] = $request->newWeight;
        }

        if (null !== $request->nextHop) {
            @$query['NextHop'] = $request->nextHop;
        }

        if (null !== $request->overlayMode) {
            @$query['OverlayMode'] = $request->overlayMode;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeDest) {
            @$query['RouteDest'] = $request->routeDest;
        }

        if (null !== $request->vpnConnectionId) {
            @$query['VpnConnectionId'] = $request->vpnConnectionId;
        }

        if (null !== $request->weight) {
            @$query['Weight'] = $request->weight;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyVcoRouteEntryWeight',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyVcoRouteEntryWeightResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the weight of a destination-based route for an IPsec-VPN connection.
     *
     * @remarks
     *   **ModifyVcoRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the associated IPsec-VPN connection and determine whether the weight of the specified destination-based route is modified.
     *     *   If the IPsec-VPN connection is in the **updating** state, the weight of the destination-based route is being modified.
     *     *   If the IPsec-VPN connection is in the **attached** state, the weight of the destination-based route is modified.
     * *   You cannot repeatedly call the **ModifyVcoRouteEntryWeight** operation for the same IPsec-VPN connection within the specified period of time.
     *
     * @param request - ModifyVcoRouteEntryWeightRequest
     *
     * @returns ModifyVcoRouteEntryWeightResponse
     *
     * @param ModifyVcoRouteEntryWeightRequest $request
     *
     * @return ModifyVcoRouteEntryWeightResponse
     */
    public function modifyVcoRouteEntryWeight($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVcoRouteEntryWeightWithOptions($request, $runtime);
    }

    /**
     * Modifies the configuration of a virtual border router (VBR).
     *
     * @remarks
     * # [](#)
     * *   Only the owner of an Express Connect circuit can modify the **VlanId** parameter.
     * *   One VLAN ID of an Express Connect circuit cannot be used only by one VBR at the same time.
     * *   The VLAN ID of a VBR in the **Terminated** state is reserved for seven days and cannot be used by other VBRs. The VLAN ID can be used by other VBRs after 7 days.
     * *   You cannot set **LocalGatewayIp**, **PeerGatewayIp**, or **PeeringSubnetMask** for VBRs that do not belong to your Alibaba Cloud account.
     * *   Set **PeeringSubnetMask** to a subnet mask with 24 to 30 bits in length (255.255.255.0255.255.255.252).
     * *   Set **LocalGatewayIp** and **PeerGatewayIp** to IP addresses that belong to the same CIDR block. For example, you can set LocalGatewayIp to 192.168.XX.XX, PeerGatewayIp to 192.168.XX.XX, and PeeringSubnetMask to 255.255.255.248.
     *
     * @param request - ModifyVirtualBorderRouterAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyVirtualBorderRouterAttributeResponse
     *
     * @param ModifyVirtualBorderRouterAttributeRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return ModifyVirtualBorderRouterAttributeResponse
     */
    public function modifyVirtualBorderRouterAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->associatedPhysicalConnections) {
            @$query['AssociatedPhysicalConnections'] = $request->associatedPhysicalConnections;
        }

        if (null !== $request->bandwidth) {
            @$query['Bandwidth'] = $request->bandwidth;
        }

        if (null !== $request->circuitCode) {
            @$query['CircuitCode'] = $request->circuitCode;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->detectMultiplier) {
            @$query['DetectMultiplier'] = $request->detectMultiplier;
        }

        if (null !== $request->enableIpv6) {
            @$query['EnableIpv6'] = $request->enableIpv6;
        }

        if (null !== $request->localGatewayIp) {
            @$query['LocalGatewayIp'] = $request->localGatewayIp;
        }

        if (null !== $request->localIpv6GatewayIp) {
            @$query['LocalIpv6GatewayIp'] = $request->localIpv6GatewayIp;
        }

        if (null !== $request->minRxInterval) {
            @$query['MinRxInterval'] = $request->minRxInterval;
        }

        if (null !== $request->minTxInterval) {
            @$query['MinTxInterval'] = $request->minTxInterval;
        }

        if (null !== $request->mtu) {
            @$query['Mtu'] = $request->mtu;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->peerGatewayIp) {
            @$query['PeerGatewayIp'] = $request->peerGatewayIp;
        }

        if (null !== $request->peerIpv6GatewayIp) {
            @$query['PeerIpv6GatewayIp'] = $request->peerIpv6GatewayIp;
        }

        if (null !== $request->peeringIpv6SubnetMask) {
            @$query['PeeringIpv6SubnetMask'] = $request->peeringIpv6SubnetMask;
        }

        if (null !== $request->peeringSubnetMask) {
            @$query['PeeringSubnetMask'] = $request->peeringSubnetMask;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sitelinkEnable) {
            @$query['SitelinkEnable'] = $request->sitelinkEnable;
        }

        if (null !== $request->vbrId) {
            @$query['VbrId'] = $request->vbrId;
        }

        if (null !== $request->vlanId) {
            @$query['VlanId'] = $request->vlanId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyVirtualBorderRouterAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyVirtualBorderRouterAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configuration of a virtual border router (VBR).
     *
     * @remarks
     * # [](#)
     * *   Only the owner of an Express Connect circuit can modify the **VlanId** parameter.
     * *   One VLAN ID of an Express Connect circuit cannot be used only by one VBR at the same time.
     * *   The VLAN ID of a VBR in the **Terminated** state is reserved for seven days and cannot be used by other VBRs. The VLAN ID can be used by other VBRs after 7 days.
     * *   You cannot set **LocalGatewayIp**, **PeerGatewayIp**, or **PeeringSubnetMask** for VBRs that do not belong to your Alibaba Cloud account.
     * *   Set **PeeringSubnetMask** to a subnet mask with 24 to 30 bits in length (255.255.255.0255.255.255.252).
     * *   Set **LocalGatewayIp** and **PeerGatewayIp** to IP addresses that belong to the same CIDR block. For example, you can set LocalGatewayIp to 192.168.XX.XX, PeerGatewayIp to 192.168.XX.XX, and PeeringSubnetMask to 255.255.255.248.
     *
     * @param request - ModifyVirtualBorderRouterAttributeRequest
     *
     * @returns ModifyVirtualBorderRouterAttributeResponse
     *
     * @param ModifyVirtualBorderRouterAttributeRequest $request
     *
     * @return ModifyVirtualBorderRouterAttributeResponse
     */
    public function modifyVirtualBorderRouterAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVirtualBorderRouterAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies the name and description of a virtual private cloud (VPC).
     *
     * @remarks
     * ## [](#)Description
     * You cannot repeatedly call the **ModifyVpcAttribute** operation to modify the name and description of a VPC within the specified period of time.
     *
     * @param request - ModifyVpcAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyVpcAttributeResponse
     *
     * @param ModifyVpcAttributeRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return ModifyVpcAttributeResponse
     */
    public function modifyVpcAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->cidrBlock) {
            @$query['CidrBlock'] = $request->cidrBlock;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->enableDnsHostname) {
            @$query['EnableDnsHostname'] = $request->enableDnsHostname;
        }

        if (null !== $request->enableIPv6) {
            @$query['EnableIPv6'] = $request->enableIPv6;
        }

        if (null !== $request->ipv6CidrBlock) {
            @$query['Ipv6CidrBlock'] = $request->ipv6CidrBlock;
        }

        if (null !== $request->ipv6Isp) {
            @$query['Ipv6Isp'] = $request->ipv6Isp;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        if (null !== $request->vpcName) {
            @$query['VpcName'] = $request->vpcName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyVpcAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyVpcAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the name and description of a virtual private cloud (VPC).
     *
     * @remarks
     * ## [](#)Description
     * You cannot repeatedly call the **ModifyVpcAttribute** operation to modify the name and description of a VPC within the specified period of time.
     *
     * @param request - ModifyVpcAttributeRequest
     *
     * @returns ModifyVpcAttributeResponse
     *
     * @param ModifyVpcAttributeRequest $request
     *
     * @return ModifyVpcAttributeResponse
     */
    public function modifyVpcAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVpcAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies the configuration of a prefix list.
     *
     * @remarks
     *   **ModifyVpcPrefixList** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPrefixLists](https://help.aliyun.com/document_detail/311535.html) to query the status of the task.
     *     *   If the prefix list is in the **Modifying** state, the configuration of the prefix list is being modified.
     *     *   If the prefix list is in the **Created** state, the configuration of the prefix list is modified.
     *     *   After the configuration of the prefix list is modified, you can call the [GetVpcPrefixListAssociations](https://help.aliyun.com/document_detail/445478.html) operation to query the information about the network instances that are associated with the prefix list and determine whether the associated network instances use the new CIDR blocks. If the association **status** of the prefix list is **Created**, the new CIDR blocks are used by the network instances that are associated with the prefix list.
     * *   You cannot repeatedly call **ModifyVpcPrefixList** to modify the configuration of a prefix list within the specified period of time.
     *
     * @param request - ModifyVpcPrefixListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyVpcPrefixListResponse
     *
     * @param ModifyVpcPrefixListRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ModifyVpcPrefixListResponse
     */
    public function modifyVpcPrefixListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->addPrefixListEntry) {
            @$query['AddPrefixListEntry'] = $request->addPrefixListEntry;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->maxEntries) {
            @$query['MaxEntries'] = $request->maxEntries;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->prefixListDescription) {
            @$query['PrefixListDescription'] = $request->prefixListDescription;
        }

        if (null !== $request->prefixListId) {
            @$query['PrefixListId'] = $request->prefixListId;
        }

        if (null !== $request->prefixListName) {
            @$query['PrefixListName'] = $request->prefixListName;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->removePrefixListEntry) {
            @$query['RemovePrefixListEntry'] = $request->removePrefixListEntry;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyVpcPrefixList',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyVpcPrefixListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configuration of a prefix list.
     *
     * @remarks
     *   **ModifyVpcPrefixList** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPrefixLists](https://help.aliyun.com/document_detail/311535.html) to query the status of the task.
     *     *   If the prefix list is in the **Modifying** state, the configuration of the prefix list is being modified.
     *     *   If the prefix list is in the **Created** state, the configuration of the prefix list is modified.
     *     *   After the configuration of the prefix list is modified, you can call the [GetVpcPrefixListAssociations](https://help.aliyun.com/document_detail/445478.html) operation to query the information about the network instances that are associated with the prefix list and determine whether the associated network instances use the new CIDR blocks. If the association **status** of the prefix list is **Created**, the new CIDR blocks are used by the network instances that are associated with the prefix list.
     * *   You cannot repeatedly call **ModifyVpcPrefixList** to modify the configuration of a prefix list within the specified period of time.
     *
     * @param request - ModifyVpcPrefixListRequest
     *
     * @returns ModifyVpcPrefixListResponse
     *
     * @param ModifyVpcPrefixListRequest $request
     *
     * @return ModifyVpcPrefixListResponse
     */
    public function modifyVpcPrefixList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVpcPrefixListWithOptions($request, $runtime);
    }

    /**
     * Modifies the configuration of an IPsec-VPN connection.
     *
     * @remarks
     *   When you modify a IPsec-VPN connection in dual-tunnel mode, you can configure the following parameters in addition to the required request parameters: **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **AutoConfigRoute**, **TunnelOptionsSpecification** array, and **EnableTunnelsBgp**.
     * *   When you modify a IPsec-VPN connection in single tunnel mode, you can configure the following parameters in addition to the required request parameters: **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, and **CustomerGatewayId**.
     * *   **ModifyVpnAttachmentAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the task:
     *     *   If the IPsec-VPN connection is in the **updating** state, the IPsec-VPN connection is being modified.
     *     *   If the IPsec-VPN connection is in the **attached** state, the IPsec-VPN connection is modified.
     * *   You cannot concurrently call **ModifyVpnAttachmentAttribute** within the specified period of time.
     * *   You cannot call **ModifyVpnAttachmentAttribute** to modify the gateway type of an IPsec-VPN connection.
     *
     * @param request - ModifyVpnAttachmentAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyVpnAttachmentAttributeResponse
     *
     * @param ModifyVpnAttachmentAttributeRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return ModifyVpnAttachmentAttributeResponse
     */
    public function modifyVpnAttachmentAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->autoConfigRoute) {
            @$query['AutoConfigRoute'] = $request->autoConfigRoute;
        }

        if (null !== $request->bgpConfig) {
            @$query['BgpConfig'] = $request->bgpConfig;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->customerGatewayId) {
            @$query['CustomerGatewayId'] = $request->customerGatewayId;
        }

        if (null !== $request->effectImmediately) {
            @$query['EffectImmediately'] = $request->effectImmediately;
        }

        if (null !== $request->enableDpd) {
            @$query['EnableDpd'] = $request->enableDpd;
        }

        if (null !== $request->enableNatTraversal) {
            @$query['EnableNatTraversal'] = $request->enableNatTraversal;
        }

        if (null !== $request->enableTunnelsBgp) {
            @$query['EnableTunnelsBgp'] = $request->enableTunnelsBgp;
        }

        if (null !== $request->healthCheckConfig) {
            @$query['HealthCheckConfig'] = $request->healthCheckConfig;
        }

        if (null !== $request->ikeConfig) {
            @$query['IkeConfig'] = $request->ikeConfig;
        }

        if (null !== $request->ipsecConfig) {
            @$query['IpsecConfig'] = $request->ipsecConfig;
        }

        if (null !== $request->localSubnet) {
            @$query['LocalSubnet'] = $request->localSubnet;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->networkType) {
            @$query['NetworkType'] = $request->networkType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->remoteCaCert) {
            @$query['RemoteCaCert'] = $request->remoteCaCert;
        }

        if (null !== $request->remoteSubnet) {
            @$query['RemoteSubnet'] = $request->remoteSubnet;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vpnConnectionId) {
            @$query['VpnConnectionId'] = $request->vpnConnectionId;
        }

        $body = [];
        $bodyFlat = [];
        if (null !== $request->tunnelOptionsSpecification) {
            @$bodyFlat['TunnelOptionsSpecification'] = $request->tunnelOptionsSpecification;
        }

        $body = Dara::merge([
        ], $body, Utils::query($bodyFlat));
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ModifyVpnAttachmentAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyVpnAttachmentAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configuration of an IPsec-VPN connection.
     *
     * @remarks
     *   When you modify a IPsec-VPN connection in dual-tunnel mode, you can configure the following parameters in addition to the required request parameters: **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **AutoConfigRoute**, **TunnelOptionsSpecification** array, and **EnableTunnelsBgp**.
     * *   When you modify a IPsec-VPN connection in single tunnel mode, you can configure the following parameters in addition to the required request parameters: **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, and **CustomerGatewayId**.
     * *   **ModifyVpnAttachmentAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the task:
     *     *   If the IPsec-VPN connection is in the **updating** state, the IPsec-VPN connection is being modified.
     *     *   If the IPsec-VPN connection is in the **attached** state, the IPsec-VPN connection is modified.
     * *   You cannot concurrently call **ModifyVpnAttachmentAttribute** within the specified period of time.
     * *   You cannot call **ModifyVpnAttachmentAttribute** to modify the gateway type of an IPsec-VPN connection.
     *
     * @param request - ModifyVpnAttachmentAttributeRequest
     *
     * @returns ModifyVpnAttachmentAttributeResponse
     *
     * @param ModifyVpnAttachmentAttributeRequest $request
     *
     * @return ModifyVpnAttachmentAttributeResponse
     */
    public function modifyVpnAttachmentAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVpnAttachmentAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies the configuration of an IPsec-VPN connection.
     *
     * @remarks
     *   If you want to modify a IPsec-VPN connection in dual-tunnel mode, call the `ModifyVpnConnectionAttribute` operation. You can modify the required parameters and the following request parameters:
     *     **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **AutoConfigRoute**, **TunnelOptionsSpecification**, and **EnableTunnelsBgp**.
     * *   If you want to modify a IPsec-VPN connection in single-tunnel mode, call the `ModifyVpnConnectionAttribute` operation. You can modify the required parameters and the following request parameters:
     *     **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, and **RemoteCaCertificate**.
     * *   **ModifyVpnConnectionAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and modifies the configuration of the IPsec-VPN connection in the backend. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of a VPN gateway.
     *     *   If the VPN gateway is in the **updating** state, the configuration of the IPsec-VPN connection is being modified.
     *     *   If the VPN gateway is in the **active** state, the configuration of the IPsec-VPN connection is modified.
     * *   You cannot repeatedly call the **ModifyVpnConnectionAttribute** operation for the same VPN gateway within the specified period of time.
     *
     * @param request - ModifyVpnConnectionAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyVpnConnectionAttributeResponse
     *
     * @param ModifyVpnConnectionAttributeRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return ModifyVpnConnectionAttributeResponse
     */
    public function modifyVpnConnectionAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->autoConfigRoute) {
            @$query['AutoConfigRoute'] = $request->autoConfigRoute;
        }

        if (null !== $request->bgpConfig) {
            @$query['BgpConfig'] = $request->bgpConfig;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->effectImmediately) {
            @$query['EffectImmediately'] = $request->effectImmediately;
        }

        if (null !== $request->enableDpd) {
            @$query['EnableDpd'] = $request->enableDpd;
        }

        if (null !== $request->enableNatTraversal) {
            @$query['EnableNatTraversal'] = $request->enableNatTraversal;
        }

        if (null !== $request->enableTunnelsBgp) {
            @$query['EnableTunnelsBgp'] = $request->enableTunnelsBgp;
        }

        if (null !== $request->healthCheckConfig) {
            @$query['HealthCheckConfig'] = $request->healthCheckConfig;
        }

        if (null !== $request->ikeConfig) {
            @$query['IkeConfig'] = $request->ikeConfig;
        }

        if (null !== $request->ipsecConfig) {
            @$query['IpsecConfig'] = $request->ipsecConfig;
        }

        if (null !== $request->localSubnet) {
            @$query['LocalSubnet'] = $request->localSubnet;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->remoteCaCertificate) {
            @$query['RemoteCaCertificate'] = $request->remoteCaCertificate;
        }

        if (null !== $request->remoteSubnet) {
            @$query['RemoteSubnet'] = $request->remoteSubnet;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vpnConnectionId) {
            @$query['VpnConnectionId'] = $request->vpnConnectionId;
        }

        $body = [];
        $bodyFlat = [];
        if (null !== $request->tunnelOptionsSpecification) {
            @$bodyFlat['TunnelOptionsSpecification'] = $request->tunnelOptionsSpecification;
        }

        $body = Dara::merge([
        ], $body, Utils::query($bodyFlat));
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ModifyVpnConnectionAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyVpnConnectionAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configuration of an IPsec-VPN connection.
     *
     * @remarks
     *   If you want to modify a IPsec-VPN connection in dual-tunnel mode, call the `ModifyVpnConnectionAttribute` operation. You can modify the required parameters and the following request parameters:
     *     **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **AutoConfigRoute**, **TunnelOptionsSpecification**, and **EnableTunnelsBgp**.
     * *   If you want to modify a IPsec-VPN connection in single-tunnel mode, call the `ModifyVpnConnectionAttribute` operation. You can modify the required parameters and the following request parameters:
     *     **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, and **RemoteCaCertificate**.
     * *   **ModifyVpnConnectionAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and modifies the configuration of the IPsec-VPN connection in the backend. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of a VPN gateway.
     *     *   If the VPN gateway is in the **updating** state, the configuration of the IPsec-VPN connection is being modified.
     *     *   If the VPN gateway is in the **active** state, the configuration of the IPsec-VPN connection is modified.
     * *   You cannot repeatedly call the **ModifyVpnConnectionAttribute** operation for the same VPN gateway within the specified period of time.
     *
     * @param request - ModifyVpnConnectionAttributeRequest
     *
     * @returns ModifyVpnConnectionAttributeResponse
     *
     * @param ModifyVpnConnectionAttributeRequest $request
     *
     * @return ModifyVpnConnectionAttributeResponse
     */
    public function modifyVpnConnectionAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVpnConnectionAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies the name and description of a VPN gateway.
     *
     * @remarks
     *   **ModifyVpnGatewayAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the VPN gateway is being modified.
     *     *   If the VPN gateway is in the **active** state, the VPN gateway is modified.
     * *   You cannot repeatedly call **ModifyVpnGatewayAttribute** to modify a VPN gateway within the specified period of time.
     *
     * @param request - ModifyVpnGatewayAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyVpnGatewayAttributeResponse
     *
     * @param ModifyVpnGatewayAttributeRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return ModifyVpnGatewayAttributeResponse
     */
    public function modifyVpnGatewayAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->autoPropagate) {
            @$query['AutoPropagate'] = $request->autoPropagate;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vpnGatewayId) {
            @$query['VpnGatewayId'] = $request->vpnGatewayId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyVpnGatewayAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyVpnGatewayAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the name and description of a VPN gateway.
     *
     * @remarks
     *   **ModifyVpnGatewayAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the VPN gateway is being modified.
     *     *   If the VPN gateway is in the **active** state, the VPN gateway is modified.
     * *   You cannot repeatedly call **ModifyVpnGatewayAttribute** to modify a VPN gateway within the specified period of time.
     *
     * @param request - ModifyVpnGatewayAttributeRequest
     *
     * @returns ModifyVpnGatewayAttributeResponse
     *
     * @param ModifyVpnGatewayAttributeRequest $request
     *
     * @return ModifyVpnGatewayAttributeResponse
     */
    public function modifyVpnGatewayAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVpnGatewayAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies the weight and priority of a policy-based route.
     *
     * @remarks
     *   You can call the **ModifyVpnPbrRouteEntryAttribute** operation to modify the weight and priority of a policy-based route.
     *     *   If you want to modify only the weight of a policy-based route, call [ModifyVpnPbrRouteEntryWeight](https://help.aliyun.com/document_detail/127249.html).
     *     *   If you want to modify only the priority of a policy-based route, call [ModifyVpnPbrRouteEntryPriority](https://help.aliyun.com/document_detail/466870.html).
     *     *   If a policy-based route does not support priorities, you can only call [ModifyVpnPbrRouteEntryWeight](https://help.aliyun.com/document_detail/127249.html) to modify its weight.
     * *   The **ModifyVpnPbrRouteEntryAttribute** operation is asynchronous. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of a VPN gateway.
     *     *   If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
     *     *   If a VPN gateway is in the **active** state, the policy-based route entry is modified.
     * *   You cannot repeatedly call the **ModifyVpnPbrRouteEntryAttribute** operation for the same VPN gateway within the specified period of time.
     *
     * @param request - ModifyVpnPbrRouteEntryAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyVpnPbrRouteEntryAttributeResponse
     *
     * @param ModifyVpnPbrRouteEntryAttributeRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return ModifyVpnPbrRouteEntryAttributeResponse
     */
    public function modifyVpnPbrRouteEntryAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->newPriority) {
            @$query['NewPriority'] = $request->newPriority;
        }

        if (null !== $request->newWeight) {
            @$query['NewWeight'] = $request->newWeight;
        }

        if (null !== $request->nextHop) {
            @$query['NextHop'] = $request->nextHop;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->priority) {
            @$query['Priority'] = $request->priority;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeDest) {
            @$query['RouteDest'] = $request->routeDest;
        }

        if (null !== $request->routeSource) {
            @$query['RouteSource'] = $request->routeSource;
        }

        if (null !== $request->vpnGatewayId) {
            @$query['VpnGatewayId'] = $request->vpnGatewayId;
        }

        if (null !== $request->weight) {
            @$query['Weight'] = $request->weight;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyVpnPbrRouteEntryAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyVpnPbrRouteEntryAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the weight and priority of a policy-based route.
     *
     * @remarks
     *   You can call the **ModifyVpnPbrRouteEntryAttribute** operation to modify the weight and priority of a policy-based route.
     *     *   If you want to modify only the weight of a policy-based route, call [ModifyVpnPbrRouteEntryWeight](https://help.aliyun.com/document_detail/127249.html).
     *     *   If you want to modify only the priority of a policy-based route, call [ModifyVpnPbrRouteEntryPriority](https://help.aliyun.com/document_detail/466870.html).
     *     *   If a policy-based route does not support priorities, you can only call [ModifyVpnPbrRouteEntryWeight](https://help.aliyun.com/document_detail/127249.html) to modify its weight.
     * *   The **ModifyVpnPbrRouteEntryAttribute** operation is asynchronous. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of a VPN gateway.
     *     *   If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
     *     *   If a VPN gateway is in the **active** state, the policy-based route entry is modified.
     * *   You cannot repeatedly call the **ModifyVpnPbrRouteEntryAttribute** operation for the same VPN gateway within the specified period of time.
     *
     * @param request - ModifyVpnPbrRouteEntryAttributeRequest
     *
     * @returns ModifyVpnPbrRouteEntryAttributeResponse
     *
     * @param ModifyVpnPbrRouteEntryAttributeRequest $request
     *
     * @return ModifyVpnPbrRouteEntryAttributeResponse
     */
    public function modifyVpnPbrRouteEntryAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVpnPbrRouteEntryAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies the priority of a policy-based route.
     *
     * @remarks
     *   **ModifyVpnPbrRouteEntryPriority** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
     *     *   If the VPN gateway is in the **active** state, the policy-based route is created.
     * *   You cannot repeatedly call the **ModifyVpnPbrRouteEntryPriority** operation for the same VPN gateway within the specified period of time.
     *
     * @param request - ModifyVpnPbrRouteEntryPriorityRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyVpnPbrRouteEntryPriorityResponse
     *
     * @param ModifyVpnPbrRouteEntryPriorityRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return ModifyVpnPbrRouteEntryPriorityResponse
     */
    public function modifyVpnPbrRouteEntryPriorityWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->newPriority) {
            @$query['NewPriority'] = $request->newPriority;
        }

        if (null !== $request->nextHop) {
            @$query['NextHop'] = $request->nextHop;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->priority) {
            @$query['Priority'] = $request->priority;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeDest) {
            @$query['RouteDest'] = $request->routeDest;
        }

        if (null !== $request->routeSource) {
            @$query['RouteSource'] = $request->routeSource;
        }

        if (null !== $request->vpnGatewayId) {
            @$query['VpnGatewayId'] = $request->vpnGatewayId;
        }

        if (null !== $request->weight) {
            @$query['Weight'] = $request->weight;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyVpnPbrRouteEntryPriority',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyVpnPbrRouteEntryPriorityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the priority of a policy-based route.
     *
     * @remarks
     *   **ModifyVpnPbrRouteEntryPriority** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
     *     *   If the VPN gateway is in the **active** state, the policy-based route is created.
     * *   You cannot repeatedly call the **ModifyVpnPbrRouteEntryPriority** operation for the same VPN gateway within the specified period of time.
     *
     * @param request - ModifyVpnPbrRouteEntryPriorityRequest
     *
     * @returns ModifyVpnPbrRouteEntryPriorityResponse
     *
     * @param ModifyVpnPbrRouteEntryPriorityRequest $request
     *
     * @return ModifyVpnPbrRouteEntryPriorityResponse
     */
    public function modifyVpnPbrRouteEntryPriority($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVpnPbrRouteEntryPriorityWithOptions($request, $runtime);
    }

    /**
     * Modifies the weight of a policy-based route of a VPN gateway.
     *
     * @remarks
     *   **ModifyVpnPbrRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
     *     *   If a VPN gateway is in the **active** state, the policy-based route entry is modified.
     * *   You cannot repeatedly call the **ModifyVpnPbrRouteEntryWeight** operation for the same VPN gateway within the specified period of time.
     *
     * @param request - ModifyVpnPbrRouteEntryWeightRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyVpnPbrRouteEntryWeightResponse
     *
     * @param ModifyVpnPbrRouteEntryWeightRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return ModifyVpnPbrRouteEntryWeightResponse
     */
    public function modifyVpnPbrRouteEntryWeightWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->newWeight) {
            @$query['NewWeight'] = $request->newWeight;
        }

        if (null !== $request->nextHop) {
            @$query['NextHop'] = $request->nextHop;
        }

        if (null !== $request->overlayMode) {
            @$query['OverlayMode'] = $request->overlayMode;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->priority) {
            @$query['Priority'] = $request->priority;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeDest) {
            @$query['RouteDest'] = $request->routeDest;
        }

        if (null !== $request->routeSource) {
            @$query['RouteSource'] = $request->routeSource;
        }

        if (null !== $request->vpnGatewayId) {
            @$query['VpnGatewayId'] = $request->vpnGatewayId;
        }

        if (null !== $request->weight) {
            @$query['Weight'] = $request->weight;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyVpnPbrRouteEntryWeight',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyVpnPbrRouteEntryWeightResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the weight of a policy-based route of a VPN gateway.
     *
     * @remarks
     *   **ModifyVpnPbrRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
     *     *   If a VPN gateway is in the **active** state, the policy-based route entry is modified.
     * *   You cannot repeatedly call the **ModifyVpnPbrRouteEntryWeight** operation for the same VPN gateway within the specified period of time.
     *
     * @param request - ModifyVpnPbrRouteEntryWeightRequest
     *
     * @returns ModifyVpnPbrRouteEntryWeightResponse
     *
     * @param ModifyVpnPbrRouteEntryWeightRequest $request
     *
     * @return ModifyVpnPbrRouteEntryWeightResponse
     */
    public function modifyVpnPbrRouteEntryWeight($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVpnPbrRouteEntryWeightWithOptions($request, $runtime);
    }

    /**
     * Modifies the weight of a destination-based route.
     *
     * @remarks
     *   In scenarios where a VPN gateway has an active and a standby destination-based route, if you need to modify the weight of the active destination-based route, you must first delete the standby destination-based route. After you modify the active destination-based route, configure a standby destination-based route. If you need to modify the weight of the standby destination-based route, you also need to delete the active destination-based route first. After you modify the standby destination-based route, configure an active destination-based route. For more information about how to delete a destination-based route, see [DeleteVpnRouteEntry](https://help.aliyun.com/document_detail/2526961.html).
     * *   **ModifyVpnRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the weight of the destination-based route is being modified.
     *     *   If the VPN gateway is in the **active** state, the weight of the destination-based route is modified.
     * *   You cannot repeatedly call the **ModifyVpnRouteEntryWeight** operation to modify the weight of destination-based route for the same VPN gateway within the specified period of time.
     *
     * @param request - ModifyVpnRouteEntryWeightRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyVpnRouteEntryWeightResponse
     *
     * @param ModifyVpnRouteEntryWeightRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return ModifyVpnRouteEntryWeightResponse
     */
    public function modifyVpnRouteEntryWeightWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->newWeight) {
            @$query['NewWeight'] = $request->newWeight;
        }

        if (null !== $request->nextHop) {
            @$query['NextHop'] = $request->nextHop;
        }

        if (null !== $request->overlayMode) {
            @$query['OverlayMode'] = $request->overlayMode;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeDest) {
            @$query['RouteDest'] = $request->routeDest;
        }

        if (null !== $request->vpnGatewayId) {
            @$query['VpnGatewayId'] = $request->vpnGatewayId;
        }

        if (null !== $request->weight) {
            @$query['Weight'] = $request->weight;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyVpnRouteEntryWeight',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyVpnRouteEntryWeightResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the weight of a destination-based route.
     *
     * @remarks
     *   In scenarios where a VPN gateway has an active and a standby destination-based route, if you need to modify the weight of the active destination-based route, you must first delete the standby destination-based route. After you modify the active destination-based route, configure a standby destination-based route. If you need to modify the weight of the standby destination-based route, you also need to delete the active destination-based route first. After you modify the standby destination-based route, configure an active destination-based route. For more information about how to delete a destination-based route, see [DeleteVpnRouteEntry](https://help.aliyun.com/document_detail/2526961.html).
     * *   **ModifyVpnRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the weight of the destination-based route is being modified.
     *     *   If the VPN gateway is in the **active** state, the weight of the destination-based route is modified.
     * *   You cannot repeatedly call the **ModifyVpnRouteEntryWeight** operation to modify the weight of destination-based route for the same VPN gateway within the specified period of time.
     *
     * @param request - ModifyVpnRouteEntryWeightRequest
     *
     * @returns ModifyVpnRouteEntryWeightResponse
     *
     * @param ModifyVpnRouteEntryWeightRequest $request
     *
     * @return ModifyVpnRouteEntryWeightResponse
     */
    public function modifyVpnRouteEntryWeight($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVpnRouteEntryWeightWithOptions($request, $runtime);
    }

    /**
     * Moves a resource to another resource group.
     *
     * @param request - MoveResourceGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns MoveResourceGroupResponse
     *
     * @param MoveResourceGroupRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return MoveResourceGroupResponse
     */
    public function moveResourceGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->newResourceGroupId) {
            @$query['NewResourceGroupId'] = $request->newResourceGroupId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'MoveResourceGroup',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return MoveResourceGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Moves a resource to another resource group.
     *
     * @param request - MoveResourceGroupRequest
     *
     * @returns MoveResourceGroupResponse
     *
     * @param MoveResourceGroupRequest $request
     *
     * @return MoveResourceGroupResponse
     */
    public function moveResourceGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->moveResourceGroupWithOptions($request, $runtime);
    }

    /**
     * Moves a VPN gateway resource to a new resource group.
     *
     * @param request - MoveVpnResourceGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns MoveVpnResourceGroupResponse
     *
     * @param MoveVpnResourceGroupRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return MoveVpnResourceGroupResponse
     */
    public function moveVpnResourceGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->newResourceGroupId) {
            @$query['NewResourceGroupId'] = $request->newResourceGroupId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'MoveVpnResourceGroup',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return MoveVpnResourceGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Moves a VPN gateway resource to a new resource group.
     *
     * @param request - MoveVpnResourceGroupRequest
     *
     * @returns MoveVpnResourceGroupResponse
     *
     * @param MoveVpnResourceGroupRequest $request
     *
     * @return MoveVpnResourceGroupResponse
     */
    public function moveVpnResourceGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->moveVpnResourceGroupWithOptions($request, $runtime);
    }

    /**
     * Enables the flow log feature.
     *
     * @remarks
     *   You cannot repeatedly call the **OpenFlowLogService** operation within the specified period of time by using an Alibaba Cloud account.
     * *   You can call the [GetFlowLogServiceStatus](https://help.aliyun.com/document_detail/449624.html) operation to query the status of the flow log feature.
     *
     * @param request - OpenFlowLogServiceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns OpenFlowLogServiceResponse
     *
     * @param OpenFlowLogServiceRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return OpenFlowLogServiceResponse
     */
    public function openFlowLogServiceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'OpenFlowLogService',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return OpenFlowLogServiceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables the flow log feature.
     *
     * @remarks
     *   You cannot repeatedly call the **OpenFlowLogService** operation within the specified period of time by using an Alibaba Cloud account.
     * *   You can call the [GetFlowLogServiceStatus](https://help.aliyun.com/document_detail/449624.html) operation to query the status of the flow log feature.
     *
     * @param request - OpenFlowLogServiceRequest
     *
     * @returns OpenFlowLogServiceResponse
     *
     * @param OpenFlowLogServiceRequest $request
     *
     * @return OpenFlowLogServiceResponse
     */
    public function openFlowLogService($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->openFlowLogServiceWithOptions($request, $runtime);
    }

    /**
     * Enables billing for outbound data transfer.
     *
     * @param request - OpenPhysicalConnectionServiceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns OpenPhysicalConnectionServiceResponse
     *
     * @param OpenPhysicalConnectionServiceRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return OpenPhysicalConnectionServiceResponse
     */
    public function openPhysicalConnectionServiceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'OpenPhysicalConnectionService',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return OpenPhysicalConnectionServiceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables billing for outbound data transfer.
     *
     * @param request - OpenPhysicalConnectionServiceRequest
     *
     * @returns OpenPhysicalConnectionServiceResponse
     *
     * @param OpenPhysicalConnectionServiceRequest $request
     *
     * @return OpenPhysicalConnectionServiceResponse
     */
    public function openPhysicalConnectionService($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->openPhysicalConnectionServiceWithOptions($request, $runtime);
    }

    /**
     * Enables the IP address pool feature.
     *
     * @param request - OpenPublicIpAddressPoolServiceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns OpenPublicIpAddressPoolServiceResponse
     *
     * @param OpenPublicIpAddressPoolServiceRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return OpenPublicIpAddressPoolServiceResponse
     */
    public function openPublicIpAddressPoolServiceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'OpenPublicIpAddressPoolService',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return OpenPublicIpAddressPoolServiceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables the IP address pool feature.
     *
     * @param request - OpenPublicIpAddressPoolServiceRequest
     *
     * @returns OpenPublicIpAddressPoolServiceResponse
     *
     * @param OpenPublicIpAddressPoolServiceRequest $request
     *
     * @return OpenPublicIpAddressPoolServiceResponse
     */
    public function openPublicIpAddressPoolService($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->openPublicIpAddressPoolServiceWithOptions($request, $runtime);
    }

    /**
     * Enables traffic mirror.
     *
     * @remarks
     * ## [](#)Usage notes
     * You can enable traffic mirror for different regions. You cannot repeatedly call the **OpenTrafficMirrorService** operation to enable traffic mirror for one region within the specified period of time.
     *
     * @param request - OpenTrafficMirrorServiceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns OpenTrafficMirrorServiceResponse
     *
     * @param OpenTrafficMirrorServiceRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return OpenTrafficMirrorServiceResponse
     */
    public function openTrafficMirrorServiceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'OpenTrafficMirrorService',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return OpenTrafficMirrorServiceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables traffic mirror.
     *
     * @remarks
     * ## [](#)Usage notes
     * You can enable traffic mirror for different regions. You cannot repeatedly call the **OpenTrafficMirrorService** operation to enable traffic mirror for one region within the specified period of time.
     *
     * @param request - OpenTrafficMirrorServiceRequest
     *
     * @returns OpenTrafficMirrorServiceResponse
     *
     * @param OpenTrafficMirrorServiceRequest $request
     *
     * @return OpenTrafficMirrorServiceResponse
     */
    public function openTrafficMirrorService($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->openTrafficMirrorServiceWithOptions($request, $runtime);
    }

    /**
     * Advertises VPC routes to an external component.
     *
     * @param request - PublishVpcRouteEntriesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns PublishVpcRouteEntriesResponse
     *
     * @param PublishVpcRouteEntriesRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return PublishVpcRouteEntriesResponse
     */
    public function publishVpcRouteEntriesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeEntries) {
            @$query['RouteEntries'] = $request->routeEntries;
        }

        if (null !== $request->targetInstanceId) {
            @$query['TargetInstanceId'] = $request->targetInstanceId;
        }

        if (null !== $request->targetType) {
            @$query['TargetType'] = $request->targetType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'PublishVpcRouteEntries',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return PublishVpcRouteEntriesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Advertises VPC routes to an external component.
     *
     * @param request - PublishVpcRouteEntriesRequest
     *
     * @returns PublishVpcRouteEntriesResponse
     *
     * @param PublishVpcRouteEntriesRequest $request
     *
     * @return PublishVpcRouteEntriesResponse
     */
    public function publishVpcRouteEntries($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->publishVpcRouteEntriesWithOptions($request, $runtime);
    }

    /**
     * Advertises a VPN route to a VPC.
     *
     * @param request - PublishVpnRouteEntryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns PublishVpnRouteEntryResponse
     *
     * @param PublishVpnRouteEntryRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return PublishVpnRouteEntryResponse
     */
    public function publishVpnRouteEntryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->nextHop) {
            @$query['NextHop'] = $request->nextHop;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->publishVpc) {
            @$query['PublishVpc'] = $request->publishVpc;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeDest) {
            @$query['RouteDest'] = $request->routeDest;
        }

        if (null !== $request->routeType) {
            @$query['RouteType'] = $request->routeType;
        }

        if (null !== $request->vpnGatewayId) {
            @$query['VpnGatewayId'] = $request->vpnGatewayId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'PublishVpnRouteEntry',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return PublishVpnRouteEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Advertises a VPN route to a VPC.
     *
     * @param request - PublishVpnRouteEntryRequest
     *
     * @returns PublishVpnRouteEntryResponse
     *
     * @param PublishVpnRouteEntryRequest $request
     *
     * @return PublishVpnRouteEntryResponse
     */
    public function publishVpnRouteEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->publishVpnRouteEntryWithOptions($request, $runtime);
    }

    /**
     * Resumes an Express Connect circuit.
     *
     * @remarks
     * # [](#)Description
     * You can call this API operation to resume a suspended Express Connect circuit. You can resume only shared Express Connect circuits by calling this API operation.
     *
     * @param request - RecoverPhysicalConnectionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RecoverPhysicalConnectionResponse
     *
     * @param RecoverPhysicalConnectionRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return RecoverPhysicalConnectionResponse
     */
    public function recoverPhysicalConnectionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->token) {
            @$query['Token'] = $request->token;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RecoverPhysicalConnection',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RecoverPhysicalConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Resumes an Express Connect circuit.
     *
     * @remarks
     * # [](#)Description
     * You can call this API operation to resume a suspended Express Connect circuit. You can resume only shared Express Connect circuits by calling this API operation.
     *
     * @param request - RecoverPhysicalConnectionRequest
     *
     * @returns RecoverPhysicalConnectionResponse
     *
     * @param RecoverPhysicalConnectionRequest $request
     *
     * @return RecoverPhysicalConnectionResponse
     */
    public function recoverPhysicalConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->recoverPhysicalConnectionWithOptions($request, $runtime);
    }

    /**
     * Enables a disabled virtual border router (VBR).
     *
     * @remarks
     * After you call this operation, the VBR changes from the **terminated** state to the **recovering** state. After the operation is performed, the VBR enters the **active** state.
     * When you call this operation, take note of the following items:
     * *   Only the owner of the Express Connect circuit can call this operation.
     * *   The Express Connect circuit to which the VBR connects must be in the **Enabled** state.
     *
     * @param request - RecoverVirtualBorderRouterRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RecoverVirtualBorderRouterResponse
     *
     * @param RecoverVirtualBorderRouterRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return RecoverVirtualBorderRouterResponse
     */
    public function recoverVirtualBorderRouterWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vbrId) {
            @$query['VbrId'] = $request->vbrId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RecoverVirtualBorderRouter',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RecoverVirtualBorderRouterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables a disabled virtual border router (VBR).
     *
     * @remarks
     * After you call this operation, the VBR changes from the **terminated** state to the **recovering** state. After the operation is performed, the VBR enters the **active** state.
     * When you call this operation, take note of the following items:
     * *   Only the owner of the Express Connect circuit can call this operation.
     * *   The Express Connect circuit to which the VBR connects must be in the **Enabled** state.
     *
     * @param request - RecoverVirtualBorderRouterRequest
     *
     * @returns RecoverVirtualBorderRouterResponse
     *
     * @param RecoverVirtualBorderRouterRequest $request
     *
     * @return RecoverVirtualBorderRouterResponse
     */
    public function recoverVirtualBorderRouter($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->recoverVirtualBorderRouterWithOptions($request, $runtime);
    }

    /**
     * Releases an elastic IP address (EIP).
     *
     * @remarks
     * Before you call this operation, take note of the following items:
     * *   Before you release an EIP, make sure that the EIP meets the following requirements:
     *     *   You can release only an EIP that is in the **Available** state.
     *     *   You can release only a pay-as-you-go EIP. You cannot release a subscription EIP.
     * *   **ReleaseEipAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task:
     *     *   If the EIP is in the **Releasing** state, the EIP is being released. In this state, you can only query the EIP and cannot perform other operations.
     *     *   If you cannot query the EIP, the EIP is released.
     * *   You cannot repeatedly call the **ReleaseEipAddress** operation to release an EIP within the specified period of time.
     *
     * @param request - ReleaseEipAddressRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ReleaseEipAddressResponse
     *
     * @param ReleaseEipAddressRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return ReleaseEipAddressResponse
     */
    public function releaseEipAddressWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->allocationId) {
            @$query['AllocationId'] = $request->allocationId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ReleaseEipAddress',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ReleaseEipAddressResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Releases an elastic IP address (EIP).
     *
     * @remarks
     * Before you call this operation, take note of the following items:
     * *   Before you release an EIP, make sure that the EIP meets the following requirements:
     *     *   You can release only an EIP that is in the **Available** state.
     *     *   You can release only a pay-as-you-go EIP. You cannot release a subscription EIP.
     * *   **ReleaseEipAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task:
     *     *   If the EIP is in the **Releasing** state, the EIP is being released. In this state, you can only query the EIP and cannot perform other operations.
     *     *   If you cannot query the EIP, the EIP is released.
     * *   You cannot repeatedly call the **ReleaseEipAddress** operation to release an EIP within the specified period of time.
     *
     * @param request - ReleaseEipAddressRequest
     *
     * @returns ReleaseEipAddressResponse
     *
     * @param ReleaseEipAddressRequest $request
     *
     * @return ReleaseEipAddressResponse
     */
    public function releaseEipAddress($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->releaseEipAddressWithOptions($request, $runtime);
    }

    /**
     * Releases contiguous elastic IP addresses (EIPs).
     *
     * @remarks
     *   After you call the **ReleaseEipSegmentAddress** operation, all EIPs in the specified group are released.
     * *   **ReleaseEipSegmentAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipSegment](https://help.aliyun.com/document_detail/156063.html) operation to query the status of the task.
     *     *   If the group is in the **Releasing** state, EIPs in the group are being released. In this state, you can only query the group and cannot perform other operations.
     *     *   If you cannot query the group of contiguous EIPs, the contiguous EIPs are released.
     * *   You cannot repeatedly call the **ReleaseEipSegmentAddress** operation to release a group of contiguous EIPs within the specified period of time.
     *
     * @param request - ReleaseEipSegmentAddressRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ReleaseEipSegmentAddressResponse
     *
     * @param ReleaseEipSegmentAddressRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return ReleaseEipSegmentAddressResponse
     */
    public function releaseEipSegmentAddressWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->segmentInstanceId) {
            @$query['SegmentInstanceId'] = $request->segmentInstanceId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ReleaseEipSegmentAddress',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ReleaseEipSegmentAddressResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Releases contiguous elastic IP addresses (EIPs).
     *
     * @remarks
     *   After you call the **ReleaseEipSegmentAddress** operation, all EIPs in the specified group are released.
     * *   **ReleaseEipSegmentAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipSegment](https://help.aliyun.com/document_detail/156063.html) operation to query the status of the task.
     *     *   If the group is in the **Releasing** state, EIPs in the group are being released. In this state, you can only query the group and cannot perform other operations.
     *     *   If you cannot query the group of contiguous EIPs, the contiguous EIPs are released.
     * *   You cannot repeatedly call the **ReleaseEipSegmentAddress** operation to release a group of contiguous EIPs within the specified period of time.
     *
     * @param request - ReleaseEipSegmentAddressRequest
     *
     * @returns ReleaseEipSegmentAddressResponse
     *
     * @param ReleaseEipSegmentAddressRequest $request
     *
     * @return ReleaseEipSegmentAddressResponse
     */
    public function releaseEipSegmentAddress($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->releaseEipSegmentAddressWithOptions($request, $runtime);
    }

    /**
     * Releases an idle IPv6 address.
     *
     * @param request - ReleaseIpv6AddressRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ReleaseIpv6AddressResponse
     *
     * @param ReleaseIpv6AddressRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return ReleaseIpv6AddressResponse
     */
    public function releaseIpv6AddressWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ipv6AddressId) {
            @$query['Ipv6AddressId'] = $request->ipv6AddressId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ReleaseIpv6Address',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ReleaseIpv6AddressResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Releases an idle IPv6 address.
     *
     * @param request - ReleaseIpv6AddressRequest
     *
     * @returns ReleaseIpv6AddressResponse
     *
     * @param ReleaseIpv6AddressRequest $request
     *
     * @return ReleaseIpv6AddressResponse
     */
    public function releaseIpv6Address($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->releaseIpv6AddressWithOptions($request, $runtime);
    }

    /**
     * Disassociates an EIP from an Internet Shared Bandwidth instance.
     *
     * @param request - RemoveCommonBandwidthPackageIpRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RemoveCommonBandwidthPackageIpResponse
     *
     * @param RemoveCommonBandwidthPackageIpRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return RemoveCommonBandwidthPackageIpResponse
     */
    public function removeCommonBandwidthPackageIpWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bandwidthPackageId) {
            @$query['BandwidthPackageId'] = $request->bandwidthPackageId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ipInstanceId) {
            @$query['IpInstanceId'] = $request->ipInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RemoveCommonBandwidthPackageIp',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RemoveCommonBandwidthPackageIpResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Disassociates an EIP from an Internet Shared Bandwidth instance.
     *
     * @param request - RemoveCommonBandwidthPackageIpRequest
     *
     * @returns RemoveCommonBandwidthPackageIpResponse
     *
     * @param RemoveCommonBandwidthPackageIpRequest $request
     *
     * @return RemoveCommonBandwidthPackageIpResponse
     */
    public function removeCommonBandwidthPackageIp($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->removeCommonBandwidthPackageIpWithOptions($request, $runtime);
    }

    /**
     * @param request - RemoveGlobalAccelerationInstanceIpRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RemoveGlobalAccelerationInstanceIpResponse
     *
     * @param RemoveGlobalAccelerationInstanceIpRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return RemoveGlobalAccelerationInstanceIpResponse
     */
    public function removeGlobalAccelerationInstanceIpWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->globalAccelerationInstanceId) {
            @$query['GlobalAccelerationInstanceId'] = $request->globalAccelerationInstanceId;
        }

        if (null !== $request->ipInstanceId) {
            @$query['IpInstanceId'] = $request->ipInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RemoveGlobalAccelerationInstanceIp',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RemoveGlobalAccelerationInstanceIpResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param request - RemoveGlobalAccelerationInstanceIpRequest
     *
     * @returns RemoveGlobalAccelerationInstanceIpResponse
     *
     * @param RemoveGlobalAccelerationInstanceIpRequest $request
     *
     * @return RemoveGlobalAccelerationInstanceIpResponse
     */
    public function removeGlobalAccelerationInstanceIp($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->removeGlobalAccelerationInstanceIpWithOptions($request, $runtime);
    }

    /**
     * Deletes an IP entry from an ACL.
     *
     * @param request - RemoveIPv6TranslatorAclListEntryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RemoveIPv6TranslatorAclListEntryResponse
     *
     * @param RemoveIPv6TranslatorAclListEntryRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return RemoveIPv6TranslatorAclListEntryResponse
     */
    public function removeIPv6TranslatorAclListEntryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aclEntryId) {
            @$query['AclEntryId'] = $request->aclEntryId;
        }

        if (null !== $request->aclId) {
            @$query['AclId'] = $request->aclId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RemoveIPv6TranslatorAclListEntry',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RemoveIPv6TranslatorAclListEntryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an IP entry from an ACL.
     *
     * @param request - RemoveIPv6TranslatorAclListEntryRequest
     *
     * @returns RemoveIPv6TranslatorAclListEntryResponse
     *
     * @param RemoveIPv6TranslatorAclListEntryRequest $request
     *
     * @return RemoveIPv6TranslatorAclListEntryResponse
     */
    public function removeIPv6TranslatorAclListEntry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->removeIPv6TranslatorAclListEntryWithOptions($request, $runtime);
    }

    /**
     * Deletes a traffic mirror source from a traffic mirror session.
     *
     * @remarks
     *   **RemoveSourcesFromTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
     *     *   If the traffic mirror session is in the **Modifying** state, the traffic mirror source is being deleted.
     *     *   If the traffic mirror session is in the **Created** state, the traffic mirror source is deleted.
     * *   You cannot repeatedly call **RemoveSourcesFromTrafficMirrorSession** within the specified period of time.
     *
     * @param request - RemoveSourcesFromTrafficMirrorSessionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RemoveSourcesFromTrafficMirrorSessionResponse
     *
     * @param RemoveSourcesFromTrafficMirrorSessionRequest $request
     * @param RuntimeOptions                               $runtime
     *
     * @return RemoveSourcesFromTrafficMirrorSessionResponse
     */
    public function removeSourcesFromTrafficMirrorSessionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->trafficMirrorSessionId) {
            @$query['TrafficMirrorSessionId'] = $request->trafficMirrorSessionId;
        }

        if (null !== $request->trafficMirrorSourceIds) {
            @$query['TrafficMirrorSourceIds'] = $request->trafficMirrorSourceIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RemoveSourcesFromTrafficMirrorSession',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RemoveSourcesFromTrafficMirrorSessionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a traffic mirror source from a traffic mirror session.
     *
     * @remarks
     *   **RemoveSourcesFromTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
     *     *   If the traffic mirror session is in the **Modifying** state, the traffic mirror source is being deleted.
     *     *   If the traffic mirror session is in the **Created** state, the traffic mirror source is deleted.
     * *   You cannot repeatedly call **RemoveSourcesFromTrafficMirrorSession** within the specified period of time.
     *
     * @param request - RemoveSourcesFromTrafficMirrorSessionRequest
     *
     * @returns RemoveSourcesFromTrafficMirrorSessionResponse
     *
     * @param RemoveSourcesFromTrafficMirrorSessionRequest $request
     *
     * @return RemoveSourcesFromTrafficMirrorSessionResponse
     */
    public function removeSourcesFromTrafficMirrorSession($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->removeSourcesFromTrafficMirrorSessionWithOptions($request, $runtime);
    }

    /**
     * DHCPVPC
     *
     * @remarks
     *   The **ReplaceVpcDhcpOptionsSet** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a DHCP options set:
     *     *   If the DHCP options set is in the **Pending** state, the DHCP options set is being replaced.
     *     *   If the DHCP options set is in the **InUse** state, the DHCP options set is replaced.
     * *   You cannot repeatedly call the **ReplaceVpcDhcpOptionsSet** operation to replace the DHCP options set associated with a VPC within the specified period of time.
     *
     * @param request - ReplaceVpcDhcpOptionsSetRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ReplaceVpcDhcpOptionsSetResponse
     *
     * @param ReplaceVpcDhcpOptionsSetRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return ReplaceVpcDhcpOptionsSetResponse
     */
    public function replaceVpcDhcpOptionsSetWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dhcpOptionsSetId) {
            @$query['DhcpOptionsSetId'] = $request->dhcpOptionsSetId;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ReplaceVpcDhcpOptionsSet',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ReplaceVpcDhcpOptionsSetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * DHCPVPC
     *
     * @remarks
     *   The **ReplaceVpcDhcpOptionsSet** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a DHCP options set:
     *     *   If the DHCP options set is in the **Pending** state, the DHCP options set is being replaced.
     *     *   If the DHCP options set is in the **InUse** state, the DHCP options set is replaced.
     * *   You cannot repeatedly call the **ReplaceVpcDhcpOptionsSet** operation to replace the DHCP options set associated with a VPC within the specified period of time.
     *
     * @param request - ReplaceVpcDhcpOptionsSetRequest
     *
     * @returns ReplaceVpcDhcpOptionsSetResponse
     *
     * @param ReplaceVpcDhcpOptionsSetRequest $request
     *
     * @return ReplaceVpcDhcpOptionsSetResponse
     */
    public function replaceVpcDhcpOptionsSet($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->replaceVpcDhcpOptionsSetWithOptions($request, $runtime);
    }

    /**
     * Re-applies a prefix list.
     *
     * @remarks
     *   If you modify the information about a prefix list but the modification is not automatically applied to the route table that is associated with the prefix list, you can call this operation to apply the latest prefix list to the associated route table.
     * *   The **RetryVpcPrefixListAssociation** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the background. You can call the [GetVpcPrefixListAssociations](https://help.aliyun.com/document_detail/445478.html) to check whether the prefix list is re-applied.
     *     *   If the prefix list is in the **Modifying** state, the prefix list is being re-applied.
     *     *   If the prefix list is in the **ModifyFailed** state, the prefix list fails to be re-applied.
     *     *   If the prefix list is in the **Created** state, the prefix list is re-applied.
     * *   After you call the **RetryVpcPrefixListAssociation** operation to re-apply a prefix list, you cannot call the operation again until the current task is complete.
     *
     * @param request - RetryVpcPrefixListAssociationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RetryVpcPrefixListAssociationResponse
     *
     * @param RetryVpcPrefixListAssociationRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return RetryVpcPrefixListAssociationResponse
     */
    public function retryVpcPrefixListAssociationWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->prefixListId) {
            @$query['PrefixListId'] = $request->prefixListId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RetryVpcPrefixListAssociation',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RetryVpcPrefixListAssociationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Re-applies a prefix list.
     *
     * @remarks
     *   If you modify the information about a prefix list but the modification is not automatically applied to the route table that is associated with the prefix list, you can call this operation to apply the latest prefix list to the associated route table.
     * *   The **RetryVpcPrefixListAssociation** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the background. You can call the [GetVpcPrefixListAssociations](https://help.aliyun.com/document_detail/445478.html) to check whether the prefix list is re-applied.
     *     *   If the prefix list is in the **Modifying** state, the prefix list is being re-applied.
     *     *   If the prefix list is in the **ModifyFailed** state, the prefix list fails to be re-applied.
     *     *   If the prefix list is in the **Created** state, the prefix list is re-applied.
     * *   After you call the **RetryVpcPrefixListAssociation** operation to re-apply a prefix list, you cannot call the operation again until the current task is complete.
     *
     * @param request - RetryVpcPrefixListAssociationRequest
     *
     * @returns RetryVpcPrefixListAssociationResponse
     *
     * @param RetryVpcPrefixListAssociationRequest $request
     *
     * @return RetryVpcPrefixListAssociationResponse
     */
    public function retryVpcPrefixListAssociation($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->retryVpcPrefixListAssociationWithOptions($request, $runtime);
    }

    /**
     * Revokes the permissions granted to a Cloud Enterprise Network (CEN) instance on a network instance.
     *
     * @remarks
     * ## [](#)Usage notes
     * *   **RevokeInstanceFromCen** is a Virtual Private Cloud (VPC) operation. Therefore, you must use `vpc.aliyuncs.com` as the domain name when you call this operation. The API version is `2016-04-28`.
     * *   You cannot repeatedly call the **RevokeInstanceFromCen** operation to revoke the permissions on a network instance that is attached to a CEN instance within the specified period of time. The network instance can be a VPC, virtual border router (VBR), or a Cloud Connect Network (CCN) instance.
     *
     * @param request - RevokeInstanceFromCenRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RevokeInstanceFromCenResponse
     *
     * @param RevokeInstanceFromCenRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return RevokeInstanceFromCenResponse
     */
    public function revokeInstanceFromCenWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->cenId) {
            @$query['CenId'] = $request->cenId;
        }

        if (null !== $request->cenOwnerId) {
            @$query['CenOwnerId'] = $request->cenOwnerId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->instanceType) {
            @$query['InstanceType'] = $request->instanceType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RevokeInstanceFromCen',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RevokeInstanceFromCenResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Revokes the permissions granted to a Cloud Enterprise Network (CEN) instance on a network instance.
     *
     * @remarks
     * ## [](#)Usage notes
     * *   **RevokeInstanceFromCen** is a Virtual Private Cloud (VPC) operation. Therefore, you must use `vpc.aliyuncs.com` as the domain name when you call this operation. The API version is `2016-04-28`.
     * *   You cannot repeatedly call the **RevokeInstanceFromCen** operation to revoke the permissions on a network instance that is attached to a CEN instance within the specified period of time. The network instance can be a VPC, virtual border router (VBR), or a Cloud Connect Network (CCN) instance.
     *
     * @param request - RevokeInstanceFromCenRequest
     *
     * @returns RevokeInstanceFromCenResponse
     *
     * @param RevokeInstanceFromCenRequest $request
     *
     * @return RevokeInstanceFromCenResponse
     */
    public function revokeInstanceFromCen($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->revokeInstanceFromCenWithOptions($request, $runtime);
    }

    /**
     * Revokes the permissions granted to a virtual border router (VBR) on a virtual private cloud (VPC).
     *
     * @param tmpReq - RevokeInstanceFromVbrRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RevokeInstanceFromVbrResponse
     *
     * @param RevokeInstanceFromVbrRequest $tmpReq
     * @param RuntimeOptions               $runtime
     *
     * @return RevokeInstanceFromVbrResponse
     */
    public function revokeInstanceFromVbrWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new RevokeInstanceFromVbrShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->vbrInstanceIds) {
            $request->vbrInstanceIdsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->vbrInstanceIds, 'VbrInstanceIds', 'simple');
        }

        $query = [];
        if (null !== $request->grantType) {
            @$query['GrantType'] = $request->grantType;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->vbrInstanceIdsShrink) {
            @$query['VbrInstanceIds'] = $request->vbrInstanceIdsShrink;
        }

        if (null !== $request->vbrOwnerUid) {
            @$query['VbrOwnerUid'] = $request->vbrOwnerUid;
        }

        if (null !== $request->vbrRegionNo) {
            @$query['VbrRegionNo'] = $request->vbrRegionNo;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RevokeInstanceFromVbr',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RevokeInstanceFromVbrResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Revokes the permissions granted to a virtual border router (VBR) on a virtual private cloud (VPC).
     *
     * @param request - RevokeInstanceFromVbrRequest
     *
     * @returns RevokeInstanceFromVbrResponse
     *
     * @param RevokeInstanceFromVbrRequest $request
     *
     * @return RevokeInstanceFromVbrResponse
     */
    public function revokeInstanceFromVbr($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->revokeInstanceFromVbrWithOptions($request, $runtime);
    }

    /**
     * If your application for a Letter of Authorization (LOA) by calling the ApplyPhysicalConnectionLOA operation is denied, you can call this operation to apply again.
     *
     * @param request - SecondApplyPhysicalConnectionLOARequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SecondApplyPhysicalConnectionLOAResponse
     *
     * @param SecondApplyPhysicalConnectionLOARequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return SecondApplyPhysicalConnectionLOAResponse
     */
    public function secondApplyPhysicalConnectionLOAWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bandwidth) {
            @$query['Bandwidth'] = $request->bandwidth;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->companyName) {
            @$query['CompanyName'] = $request->companyName;
        }

        if (null !== $request->constructionTime) {
            @$query['ConstructionTime'] = $request->constructionTime;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->lineType) {
            @$query['LineType'] = $request->lineType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->PMInfo) {
            @$query['PMInfo'] = $request->PMInfo;
        }

        if (null !== $request->peerLocation) {
            @$query['PeerLocation'] = $request->peerLocation;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->si) {
            @$query['Si'] = $request->si;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SecondApplyPhysicalConnectionLOA',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SecondApplyPhysicalConnectionLOAResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * If your application for a Letter of Authorization (LOA) by calling the ApplyPhysicalConnectionLOA operation is denied, you can call this operation to apply again.
     *
     * @param request - SecondApplyPhysicalConnectionLOARequest
     *
     * @returns SecondApplyPhysicalConnectionLOAResponse
     *
     * @param SecondApplyPhysicalConnectionLOARequest $request
     *
     * @return SecondApplyPhysicalConnectionLOAResponse
     */
    public function secondApplyPhysicalConnectionLOA($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->secondApplyPhysicalConnectionLOAWithOptions($request, $runtime);
    }

    /**
     * Configures fine-grained monitoring for an elastic IP address (EIP).
     *
     * @remarks
     * You cannot repeatedly call **SetHighDefinitionMonitorLogStatus** within a specific period of time.
     *
     * @param request - SetHighDefinitionMonitorLogStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetHighDefinitionMonitorLogStatusResponse
     *
     * @param SetHighDefinitionMonitorLogStatusRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return SetHighDefinitionMonitorLogStatusResponse
     */
    public function setHighDefinitionMonitorLogStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->instanceType) {
            @$query['InstanceType'] = $request->instanceType;
        }

        if (null !== $request->logProject) {
            @$query['LogProject'] = $request->logProject;
        }

        if (null !== $request->logStore) {
            @$query['LogStore'] = $request->logStore;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SetHighDefinitionMonitorLogStatus',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetHighDefinitionMonitorLogStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures fine-grained monitoring for an elastic IP address (EIP).
     *
     * @remarks
     * You cannot repeatedly call **SetHighDefinitionMonitorLogStatus** within a specific period of time.
     *
     * @param request - SetHighDefinitionMonitorLogStatusRequest
     *
     * @returns SetHighDefinitionMonitorLogStatusResponse
     *
     * @param SetHighDefinitionMonitorLogStatusRequest $request
     *
     * @return SetHighDefinitionMonitorLogStatusResponse
     */
    public function setHighDefinitionMonitorLogStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setHighDefinitionMonitorLogStatusWithOptions($request, $runtime);
    }

    /**
     * Performs a failover test.
     *
     * @remarks
     * You can perform only failover tests that are in the **Pending** state.
     *
     * @param request - StartFailoverTestJobRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StartFailoverTestJobResponse
     *
     * @param StartFailoverTestJobRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return StartFailoverTestJobResponse
     */
    public function startFailoverTestJobWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->jobId) {
            @$query['JobId'] = $request->jobId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StartFailoverTestJob',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StartFailoverTestJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Performs a failover test.
     *
     * @remarks
     * You can perform only failover tests that are in the **Pending** state.
     *
     * @param request - StartFailoverTestJobRequest
     *
     * @returns StartFailoverTestJobResponse
     *
     * @param StartFailoverTestJobRequest $request
     *
     * @return StartFailoverTestJobResponse
     */
    public function startFailoverTestJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startFailoverTestJobWithOptions($request, $runtime);
    }

    /**
     * Terminates a failover test.
     *
     * @param request - StopFailoverTestJobRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StopFailoverTestJobResponse
     *
     * @param StopFailoverTestJobRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return StopFailoverTestJobResponse
     */
    public function stopFailoverTestJobWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->jobId) {
            @$query['JobId'] = $request->jobId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StopFailoverTestJob',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StopFailoverTestJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Terminates a failover test.
     *
     * @param request - StopFailoverTestJobRequest
     *
     * @returns StopFailoverTestJobResponse
     *
     * @param StopFailoverTestJobRequest $request
     *
     * @return StopFailoverTestJobResponse
     */
    public function stopFailoverTestJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopFailoverTestJobWithOptions($request, $runtime);
    }

    /**
     * Creates and adds tags to resources.
     *
     * @remarks
     * Tags are used to classify instances. Each tag consists of a key-value pair. Before you use tags, take note of the following limits:
     * *   The keys of tags that are added to the same instance must be unique.
     * *   You cannot create tags without adding them to instances. All tags must be added to instances.
     * *   Tag information is not shared across regions.
     *     For example, you cannot view the tags that are created in the China (Hangzhou) region from the China (Shanghai) region.
     * *   Virtual private clouds (VPCs), route tables, vSwitches, and elastic IP addresses (EIPs) that belong to the same Alibaba Cloud account and are deployed in the same region share tag information with each other.
     *     For example, if you added a tag to a VPC, the tag is available to vSwitches, route tables, and EIPs that belong to the same account and are deployed in the same region in which the VPC is created. You can select this tag from the editing page without the need to enter the tag again. You can modify the key and the value of a tag or remove a tag from an instance. After you delete an instance, all tags that are added to the instance are deleted.
     * *   You can add up to 20 tags to each instance. Before you add a tag to an instance, the system automatically checks the number of existing tags. An error message is returned if the maximum number of tags is reached.
     *
     * @param request - TagResourcesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns TagResourcesResponse
     *
     * @param TagResourcesRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return TagResourcesResponse
     */
    public function tagResourcesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'TagResources',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return TagResourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates and adds tags to resources.
     *
     * @remarks
     * Tags are used to classify instances. Each tag consists of a key-value pair. Before you use tags, take note of the following limits:
     * *   The keys of tags that are added to the same instance must be unique.
     * *   You cannot create tags without adding them to instances. All tags must be added to instances.
     * *   Tag information is not shared across regions.
     *     For example, you cannot view the tags that are created in the China (Hangzhou) region from the China (Shanghai) region.
     * *   Virtual private clouds (VPCs), route tables, vSwitches, and elastic IP addresses (EIPs) that belong to the same Alibaba Cloud account and are deployed in the same region share tag information with each other.
     *     For example, if you added a tag to a VPC, the tag is available to vSwitches, route tables, and EIPs that belong to the same account and are deployed in the same region in which the VPC is created. You can select this tag from the editing page without the need to enter the tag again. You can modify the key and the value of a tag or remove a tag from an instance. After you delete an instance, all tags that are added to the instance are deleted.
     * *   You can add up to 20 tags to each instance. Before you add a tag to an instance, the system automatically checks the number of existing tags. An error message is returned if the maximum number of tags is reached.
     *
     * @param request - TagResourcesRequest
     *
     * @returns TagResourcesResponse
     *
     * @param TagResourcesRequest $request
     *
     * @return TagResourcesResponse
     */
    public function tagResources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->tagResourcesWithOptions($request, $runtime);
    }

    /**
     * Creates tags and adds the tags to an Express Connect circuit.
     *
     * @remarks
     * ## [](#)
     * Tags are used to classify instances. Each tag consists of a key-value pair. Before you use tags, take note of the following items:
     * *   Each tag key that is added to an instance must be unique.
     * *   You cannot create tags without adding them to instances. All tags must be added to instances.
     * *   Tag information is not shared across regions.
     *     For example, you cannot view the tags that are created in the China (Hangzhou) region from the China (Shanghai) region.
     * *   You can add up to 20 tags to each instance. Before you add a tag to an instance, the system automatically checks the number of existing tags. An error message is returned if the maximum number of tags is reached.
     *
     * @param request - TagResourcesForExpressConnectRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns TagResourcesForExpressConnectResponse
     *
     * @param TagResourcesForExpressConnectRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return TagResourcesForExpressConnectResponse
     */
    public function tagResourcesForExpressConnectWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'TagResourcesForExpressConnect',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return TagResourcesForExpressConnectResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates tags and adds the tags to an Express Connect circuit.
     *
     * @remarks
     * ## [](#)
     * Tags are used to classify instances. Each tag consists of a key-value pair. Before you use tags, take note of the following items:
     * *   Each tag key that is added to an instance must be unique.
     * *   You cannot create tags without adding them to instances. All tags must be added to instances.
     * *   Tag information is not shared across regions.
     *     For example, you cannot view the tags that are created in the China (Hangzhou) region from the China (Shanghai) region.
     * *   You can add up to 20 tags to each instance. Before you add a tag to an instance, the system automatically checks the number of existing tags. An error message is returned if the maximum number of tags is reached.
     *
     * @param request - TagResourcesForExpressConnectRequest
     *
     * @returns TagResourcesForExpressConnectResponse
     *
     * @param TagResourcesForExpressConnectRequest $request
     *
     * @return TagResourcesForExpressConnectResponse
     */
    public function tagResourcesForExpressConnect($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->tagResourcesForExpressConnectWithOptions($request, $runtime);
    }

    /**
     * Disables an Express Connect circuit after it is enabled.
     *
     * @remarks
     * After you call this operation, the specified Express Connect circuit changes to the **Terminating** state. After the Express Connect circuit is disabled, it changes to the **Terminated** state. When you call this operation, take note of the following limits:
     * *   You can only disable an Express Connect circuit that is in the **Enabled** state.
     * *   Before you disable an Express Connect circuit, you must delete the virtual border routers (VBRs) associated with it.
     *
     * @param request - TerminatePhysicalConnectionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns TerminatePhysicalConnectionResponse
     *
     * @param TerminatePhysicalConnectionRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return TerminatePhysicalConnectionResponse
     */
    public function terminatePhysicalConnectionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->physicalConnectionId) {
            @$query['PhysicalConnectionId'] = $request->physicalConnectionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'TerminatePhysicalConnection',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return TerminatePhysicalConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Disables an Express Connect circuit after it is enabled.
     *
     * @remarks
     * After you call this operation, the specified Express Connect circuit changes to the **Terminating** state. After the Express Connect circuit is disabled, it changes to the **Terminated** state. When you call this operation, take note of the following limits:
     * *   You can only disable an Express Connect circuit that is in the **Enabled** state.
     * *   Before you disable an Express Connect circuit, you must delete the virtual border routers (VBRs) associated with it.
     *
     * @param request - TerminatePhysicalConnectionRequest
     *
     * @returns TerminatePhysicalConnectionResponse
     *
     * @param TerminatePhysicalConnectionRequest $request
     *
     * @return TerminatePhysicalConnectionResponse
     */
    public function terminatePhysicalConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->terminatePhysicalConnectionWithOptions($request, $runtime);
    }

    /**
     * Terminates a virtual border router (VBR).
     *
     * @remarks
     * After you call this operation, the VBR enters the **terminating** state from the **active** state. After the VBR is terminated, the VBR enters the **terminated** state.
     * >  Only the owner of an Express Connect circuit can call this operation.
     *
     * @param request - TerminateVirtualBorderRouterRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns TerminateVirtualBorderRouterResponse
     *
     * @param TerminateVirtualBorderRouterRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return TerminateVirtualBorderRouterResponse
     */
    public function terminateVirtualBorderRouterWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vbrId) {
            @$query['VbrId'] = $request->vbrId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'TerminateVirtualBorderRouter',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return TerminateVirtualBorderRouterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Terminates a virtual border router (VBR).
     *
     * @remarks
     * After you call this operation, the VBR enters the **terminating** state from the **active** state. After the VBR is terminated, the VBR enters the **terminated** state.
     * >  Only the owner of an Express Connect circuit can call this operation.
     *
     * @param request - TerminateVirtualBorderRouterRequest
     *
     * @returns TerminateVirtualBorderRouterResponse
     *
     * @param TerminateVirtualBorderRouterRequest $request
     *
     * @return TerminateVirtualBorderRouterResponse
     */
    public function terminateVirtualBorderRouter($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->terminateVirtualBorderRouterWithOptions($request, $runtime);
    }

    /**
     * Migrate a contiguous EIP group to an IP address pool.
     *
     * @param request - TransformEipSegmentToPublicIpAddressPoolRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns TransformEipSegmentToPublicIpAddressPoolResponse
     *
     * @param TransformEipSegmentToPublicIpAddressPoolRequest $request
     * @param RuntimeOptions                                  $runtime
     *
     * @return TransformEipSegmentToPublicIpAddressPoolResponse
     */
    public function transformEipSegmentToPublicIpAddressPoolWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'TransformEipSegmentToPublicIpAddressPool',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return TransformEipSegmentToPublicIpAddressPoolResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Migrate a contiguous EIP group to an IP address pool.
     *
     * @param request - TransformEipSegmentToPublicIpAddressPoolRequest
     *
     * @returns TransformEipSegmentToPublicIpAddressPoolResponse
     *
     * @param TransformEipSegmentToPublicIpAddressPoolRequest $request
     *
     * @return TransformEipSegmentToPublicIpAddressPoolResponse
     */
    public function transformEipSegmentToPublicIpAddressPool($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->transformEipSegmentToPublicIpAddressPoolWithOptions($request, $runtime);
    }

    /**
     * Removes tags from resources.
     *
     * @param request - UnTagResourcesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UnTagResourcesResponse
     *
     * @param UnTagResourcesRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return UnTagResourcesResponse
     */
    public function unTagResourcesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->all) {
            @$query['All'] = $request->all;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        if (null !== $request->tagKey) {
            @$query['TagKey'] = $request->tagKey;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UnTagResources',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UnTagResourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Removes tags from resources.
     *
     * @param request - UnTagResourcesRequest
     *
     * @returns UnTagResourcesResponse
     *
     * @param UnTagResourcesRequest $request
     *
     * @return UnTagResourcesResponse
     */
    public function unTagResources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->unTagResourcesWithOptions($request, $runtime);
    }

    /**
     * Disassociates an elastic IP address (EIP) from a cloud resource.
     *
     * @remarks
     *   **UnassociateEipAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
     *     *   If the EIP is in the **Unassociating** state, the EIP is being disassociated. In this state, you can only query the EIP and cannot perform other operations.
     *     *   If the EIP is in the **Available** state, the EIP is disassociated.
     * *   You cannot repeatedly call the **UnassociateEipAddress** operation within the specified period of time.
     *
     * @param request - UnassociateEipAddressRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UnassociateEipAddressResponse
     *
     * @param UnassociateEipAddressRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return UnassociateEipAddressResponse
     */
    public function unassociateEipAddressWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->allocationId) {
            @$query['AllocationId'] = $request->allocationId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->force) {
            @$query['Force'] = $request->force;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->instanceType) {
            @$query['InstanceType'] = $request->instanceType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->privateIpAddress) {
            @$query['PrivateIpAddress'] = $request->privateIpAddress;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UnassociateEipAddress',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UnassociateEipAddressResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Disassociates an elastic IP address (EIP) from a cloud resource.
     *
     * @remarks
     *   **UnassociateEipAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
     *     *   If the EIP is in the **Unassociating** state, the EIP is being disassociated. In this state, you can only query the EIP and cannot perform other operations.
     *     *   If the EIP is in the **Available** state, the EIP is disassociated.
     * *   You cannot repeatedly call the **UnassociateEipAddress** operation within the specified period of time.
     *
     * @param request - UnassociateEipAddressRequest
     *
     * @returns UnassociateEipAddressResponse
     *
     * @param UnassociateEipAddressRequest $request
     *
     * @return UnassociateEipAddressResponse
     */
    public function unassociateEipAddress($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->unassociateEipAddressWithOptions($request, $runtime);
    }

    /**
     * Disassociates a Global Accelerator (GA) instance from a backend server.
     *
     * @param request - UnassociateGlobalAccelerationInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UnassociateGlobalAccelerationInstanceResponse
     *
     * @param UnassociateGlobalAccelerationInstanceRequest $request
     * @param RuntimeOptions                               $runtime
     *
     * @return UnassociateGlobalAccelerationInstanceResponse
     */
    public function unassociateGlobalAccelerationInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->globalAccelerationInstanceId) {
            @$query['GlobalAccelerationInstanceId'] = $request->globalAccelerationInstanceId;
        }

        if (null !== $request->instanceType) {
            @$query['InstanceType'] = $request->instanceType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UnassociateGlobalAccelerationInstance',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UnassociateGlobalAccelerationInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Disassociates a Global Accelerator (GA) instance from a backend server.
     *
     * @param request - UnassociateGlobalAccelerationInstanceRequest
     *
     * @returns UnassociateGlobalAccelerationInstanceResponse
     *
     * @param UnassociateGlobalAccelerationInstanceRequest $request
     *
     * @return UnassociateGlobalAccelerationInstanceResponse
     */
    public function unassociateGlobalAccelerationInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->unassociateGlobalAccelerationInstanceWithOptions($request, $runtime);
    }

    /**
     * Disassociates a high-availability virtual IP address (HaVip) from an Elastic Compute Service (ECS) in a virtual private cloud (VPC) or from an elastic network interface (ENI).
     *
     * @remarks
     * ## [](#)
     * When you call this operation, take note of the following limits:
     * *   The ECS instance must be in the **Running** or **Stopped** state.
     * *   The HaVip must be in the **Available** or **InUse** state.
     * *   **UnassociateHaVip** is an asynchronous operation. After a request is sent, the system returns a request ID and an instance ID and runs the task in the background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HaVip:
     *     *   If the HaVip is in the **Unassociating** state, the HaVip is being disassociated.
     *     *   If the HaVip is in the **Inuse** or **Available** state, the HaVip is disassociated.
     * *   You cannot repeatedly call the **UnassociateHaVip** operation to disassociate an HaVip within the specified period of time.
     *
     * @param request - UnassociateHaVipRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UnassociateHaVipResponse
     *
     * @param UnassociateHaVipRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return UnassociateHaVipResponse
     */
    public function unassociateHaVipWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->force) {
            @$query['Force'] = $request->force;
        }

        if (null !== $request->haVipId) {
            @$query['HaVipId'] = $request->haVipId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->instanceType) {
            @$query['InstanceType'] = $request->instanceType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UnassociateHaVip',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UnassociateHaVipResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Disassociates a high-availability virtual IP address (HaVip) from an Elastic Compute Service (ECS) in a virtual private cloud (VPC) or from an elastic network interface (ENI).
     *
     * @remarks
     * ## [](#)
     * When you call this operation, take note of the following limits:
     * *   The ECS instance must be in the **Running** or **Stopped** state.
     * *   The HaVip must be in the **Available** or **InUse** state.
     * *   **UnassociateHaVip** is an asynchronous operation. After a request is sent, the system returns a request ID and an instance ID and runs the task in the background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HaVip:
     *     *   If the HaVip is in the **Unassociating** state, the HaVip is being disassociated.
     *     *   If the HaVip is in the **Inuse** or **Available** state, the HaVip is disassociated.
     * *   You cannot repeatedly call the **UnassociateHaVip** operation to disassociate an HaVip within the specified period of time.
     *
     * @param request - UnassociateHaVipRequest
     *
     * @returns UnassociateHaVipResponse
     *
     * @param UnassociateHaVipRequest $request
     *
     * @return UnassociateHaVipResponse
     */
    public function unassociateHaVip($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->unassociateHaVipWithOptions($request, $runtime);
    }

    /**
     * Disassociates a network access control list (ACL) from a vSwitch.
     *
     * @remarks
     * ## [](#)Description
     * *   **UnassociateNetworkAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
     *     *   If the network ACL is in the **UNBINDING** state, the network ACL is being disassociated from the vSwitch.
     *     *   If the network ACL is in the **UNBINDED** state, the network ACL is disassociated from the vSwitch.
     * *   You cannot repeatedly call the **UnassociateNetworkAcl** operation to disassociate a network ACL from a vSwitch within the specified period of time.
     *
     * @param request - UnassociateNetworkAclRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UnassociateNetworkAclResponse
     *
     * @param UnassociateNetworkAclRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return UnassociateNetworkAclResponse
     */
    public function unassociateNetworkAclWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->networkAclId) {
            @$query['NetworkAclId'] = $request->networkAclId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resource) {
            @$query['Resource'] = $request->resource;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UnassociateNetworkAcl',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UnassociateNetworkAclResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Disassociates a network access control list (ACL) from a vSwitch.
     *
     * @remarks
     * ## [](#)Description
     * *   **UnassociateNetworkAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
     *     *   If the network ACL is in the **UNBINDING** state, the network ACL is being disassociated from the vSwitch.
     *     *   If the network ACL is in the **UNBINDED** state, the network ACL is disassociated from the vSwitch.
     * *   You cannot repeatedly call the **UnassociateNetworkAcl** operation to disassociate a network ACL from a vSwitch within the specified period of time.
     *
     * @param request - UnassociateNetworkAclRequest
     *
     * @returns UnassociateNetworkAclResponse
     *
     * @param UnassociateNetworkAclRequest $request
     *
     * @return UnassociateNetworkAclResponse
     */
    public function unassociateNetworkAcl($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->unassociateNetworkAclWithOptions($request, $runtime);
    }

    /**
     * Disassociates a virtual border router (VBR) from an Express Connect circuit.
     *
     * @param request - UnassociatePhysicalConnectionFromVirtualBorderRouterRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UnassociatePhysicalConnectionFromVirtualBorderRouterResponse
     *
     * @param UnassociatePhysicalConnectionFromVirtualBorderRouterRequest $request
     * @param RuntimeOptions                                              $runtime
     *
     * @return UnassociatePhysicalConnectionFromVirtualBorderRouterResponse
     */
    public function unassociatePhysicalConnectionFromVirtualBorderRouterWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->physicalConnectionId) {
            @$query['PhysicalConnectionId'] = $request->physicalConnectionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vbrId) {
            @$query['VbrId'] = $request->vbrId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UnassociatePhysicalConnectionFromVirtualBorderRouter',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UnassociatePhysicalConnectionFromVirtualBorderRouterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Disassociates a virtual border router (VBR) from an Express Connect circuit.
     *
     * @param request - UnassociatePhysicalConnectionFromVirtualBorderRouterRequest
     *
     * @returns UnassociatePhysicalConnectionFromVirtualBorderRouterResponse
     *
     * @param UnassociatePhysicalConnectionFromVirtualBorderRouterRequest $request
     *
     * @return UnassociatePhysicalConnectionFromVirtualBorderRouterResponse
     */
    public function unassociatePhysicalConnectionFromVirtualBorderRouter($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->unassociatePhysicalConnectionFromVirtualBorderRouterWithOptions($request, $runtime);
    }

    /**
     * Disassociates a route table from a vSwitch.
     *
     * @remarks
     * ## [](#)References
     * *   **UnassociateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task.
     *     *   If the vSwitch is in the **Pending** state, the route table is being disassociated.
     *     *   If the vSwitch is in the **Available** state, the route table is disassociated.
     * *   You cannot repeatedly call the **UnassociateRouteTable** operation to disassociate a route table from a vSwitch within the specified period of time.
     *
     * @param request - UnassociateRouteTableRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UnassociateRouteTableResponse
     *
     * @param UnassociateRouteTableRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return UnassociateRouteTableResponse
     */
    public function unassociateRouteTableWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeTableId) {
            @$query['RouteTableId'] = $request->routeTableId;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UnassociateRouteTable',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UnassociateRouteTableResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Disassociates a route table from a vSwitch.
     *
     * @remarks
     * ## [](#)References
     * *   **UnassociateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task.
     *     *   If the vSwitch is in the **Pending** state, the route table is being disassociated.
     *     *   If the vSwitch is in the **Available** state, the route table is disassociated.
     * *   You cannot repeatedly call the **UnassociateRouteTable** operation to disassociate a route table from a vSwitch within the specified period of time.
     *
     * @param request - UnassociateRouteTableRequest
     *
     * @returns UnassociateRouteTableResponse
     *
     * @param UnassociateRouteTableRequest $request
     *
     * @return UnassociateRouteTableResponse
     */
    public function unassociateRouteTable($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->unassociateRouteTableWithOptions($request, $runtime);
    }

    /**
     * Removes a secondary CIDR block from a virtual private cloud (VPC).
     *
     * @remarks
     *   Before you delete a secondary CIDR block from a VPC, delete the vSwitch which is created with the CIDR block. For more information, see [DeleteVSwitch](https://help.aliyun.com/document_detail/35746.html).
     * *   You cannot repeatedly call the **UnassociateVpcCidrBlock** operation to delete a secondary CIDR block from a VPC within the specified period of time.
     *
     * @param request - UnassociateVpcCidrBlockRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UnassociateVpcCidrBlockResponse
     *
     * @param UnassociateVpcCidrBlockRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return UnassociateVpcCidrBlockResponse
     */
    public function unassociateVpcCidrBlockWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->IPv6CidrBlock) {
            @$query['IPv6CidrBlock'] = $request->IPv6CidrBlock;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->secondaryCidrBlock) {
            @$query['SecondaryCidrBlock'] = $request->secondaryCidrBlock;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UnassociateVpcCidrBlock',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UnassociateVpcCidrBlockResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Removes a secondary CIDR block from a virtual private cloud (VPC).
     *
     * @remarks
     *   Before you delete a secondary CIDR block from a VPC, delete the vSwitch which is created with the CIDR block. For more information, see [DeleteVSwitch](https://help.aliyun.com/document_detail/35746.html).
     * *   You cannot repeatedly call the **UnassociateVpcCidrBlock** operation to delete a secondary CIDR block from a VPC within the specified period of time.
     *
     * @param request - UnassociateVpcCidrBlockRequest
     *
     * @returns UnassociateVpcCidrBlockResponse
     *
     * @param UnassociateVpcCidrBlockRequest $request
     *
     * @return UnassociateVpcCidrBlockResponse
     */
    public function unassociateVpcCidrBlock($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->unassociateVpcCidrBlockWithOptions($request, $runtime);
    }

    /**
     * Removes tags from an Express Connect circuit at a time.
     *
     * @param request - UntagResourcesForExpressConnectRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UntagResourcesForExpressConnectResponse
     *
     * @param UntagResourcesForExpressConnectRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return UntagResourcesForExpressConnectResponse
     */
    public function untagResourcesForExpressConnectWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->all) {
            @$query['All'] = $request->all;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        if (null !== $request->tagKey) {
            @$query['TagKey'] = $request->tagKey;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UntagResourcesForExpressConnect',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UntagResourcesForExpressConnectResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Removes tags from an Express Connect circuit at a time.
     *
     * @param request - UntagResourcesForExpressConnectRequest
     *
     * @returns UntagResourcesForExpressConnectResponse
     *
     * @param UntagResourcesForExpressConnectRequest $request
     *
     * @return UntagResourcesForExpressConnectResponse
     */
    public function untagResourcesForExpressConnect($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->untagResourcesForExpressConnectWithOptions($request, $runtime);
    }

    /**
     * Dhcp.
     *
     * @param request - UpdateDhcpOptionsSetAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateDhcpOptionsSetAttributeResponse
     *
     * @param UpdateDhcpOptionsSetAttributeRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return UpdateDhcpOptionsSetAttributeResponse
     */
    public function updateDhcpOptionsSetAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dhcpOptionsSetDescription) {
            @$query['DhcpOptionsSetDescription'] = $request->dhcpOptionsSetDescription;
        }

        if (null !== $request->dhcpOptionsSetId) {
            @$query['DhcpOptionsSetId'] = $request->dhcpOptionsSetId;
        }

        if (null !== $request->dhcpOptionsSetName) {
            @$query['DhcpOptionsSetName'] = $request->dhcpOptionsSetName;
        }

        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->domainNameServers) {
            @$query['DomainNameServers'] = $request->domainNameServers;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ipv6LeaseTime) {
            @$query['Ipv6LeaseTime'] = $request->ipv6LeaseTime;
        }

        if (null !== $request->leaseTime) {
            @$query['LeaseTime'] = $request->leaseTime;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateDhcpOptionsSetAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateDhcpOptionsSetAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Dhcp.
     *
     * @param request - UpdateDhcpOptionsSetAttributeRequest
     *
     * @returns UpdateDhcpOptionsSetAttributeResponse
     *
     * @param UpdateDhcpOptionsSetAttributeRequest $request
     *
     * @return UpdateDhcpOptionsSetAttributeResponse
     */
    public function updateDhcpOptionsSetAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateDhcpOptionsSetAttributeWithOptions($request, $runtime);
    }

    /**
     * Updates a failover test.
     *
     * @param request - UpdateFailoverTestJobRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateFailoverTestJobResponse
     *
     * @param UpdateFailoverTestJobRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return UpdateFailoverTestJobResponse
     */
    public function updateFailoverTestJobWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->jobDuration) {
            @$query['JobDuration'] = $request->jobDuration;
        }

        if (null !== $request->jobId) {
            @$query['JobId'] = $request->jobId;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateFailoverTestJob',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateFailoverTestJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates a failover test.
     *
     * @param request - UpdateFailoverTestJobRequest
     *
     * @returns UpdateFailoverTestJobResponse
     *
     * @param UpdateFailoverTestJobRequest $request
     *
     * @return UpdateFailoverTestJobResponse
     */
    public function updateFailoverTestJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateFailoverTestJobWithOptions($request, $runtime);
    }

    /**
     * Modifies the next hop type and next hop of the route entry in a gateway route table.
     *
     * @param request - UpdateGatewayRouteTableEntryAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateGatewayRouteTableEntryAttributeResponse
     *
     * @param UpdateGatewayRouteTableEntryAttributeRequest $request
     * @param RuntimeOptions                               $runtime
     *
     * @return UpdateGatewayRouteTableEntryAttributeResponse
     */
    public function updateGatewayRouteTableEntryAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->destinationCidrBlock) {
            @$query['DestinationCidrBlock'] = $request->destinationCidrBlock;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->gatewayRouteTableId) {
            @$query['GatewayRouteTableId'] = $request->gatewayRouteTableId;
        }

        if (null !== $request->IPv4GatewayRouteTableId) {
            @$query['IPv4GatewayRouteTableId'] = $request->IPv4GatewayRouteTableId;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->nextHopId) {
            @$query['NextHopId'] = $request->nextHopId;
        }

        if (null !== $request->nextHopType) {
            @$query['NextHopType'] = $request->nextHopType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateGatewayRouteTableEntryAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateGatewayRouteTableEntryAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the next hop type and next hop of the route entry in a gateway route table.
     *
     * @param request - UpdateGatewayRouteTableEntryAttributeRequest
     *
     * @returns UpdateGatewayRouteTableEntryAttributeResponse
     *
     * @param UpdateGatewayRouteTableEntryAttributeRequest $request
     *
     * @return UpdateGatewayRouteTableEntryAttributeResponse
     */
    public function updateGatewayRouteTableEntryAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateGatewayRouteTableEntryAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies the configuration of an IPsec server.
     *
     * @remarks
     *   If you modify only **IpsecServerName** of the IPsec server, this operation is synchronous. If you modify other parameters besides **IpsecServerName**, this operation is asynchronous.
     * *   If **UpdateIpsecServer** is an asynchronous operation, after a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the IPsec server is being modified.
     *     *   If the VPN gateway is in the **active** state, the IPsec server is modified.
     * *   You cannot repeatedly call **UpdateIpsecServer** within the specified period of time.
     *
     * @param request - UpdateIpsecServerRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateIpsecServerResponse
     *
     * @param UpdateIpsecServerRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return UpdateIpsecServerResponse
     */
    public function updateIpsecServerWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientIpPool) {
            @$query['ClientIpPool'] = $request->clientIpPool;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->effectImmediately) {
            @$query['EffectImmediately'] = $request->effectImmediately;
        }

        if (null !== $request->ikeConfig) {
            @$query['IkeConfig'] = $request->ikeConfig;
        }

        if (null !== $request->ipsecConfig) {
            @$query['IpsecConfig'] = $request->ipsecConfig;
        }

        if (null !== $request->ipsecServerId) {
            @$query['IpsecServerId'] = $request->ipsecServerId;
        }

        if (null !== $request->ipsecServerName) {
            @$query['IpsecServerName'] = $request->ipsecServerName;
        }

        if (null !== $request->localSubnet) {
            @$query['LocalSubnet'] = $request->localSubnet;
        }

        if (null !== $request->psk) {
            @$query['Psk'] = $request->psk;
        }

        if (null !== $request->pskEnabled) {
            @$query['PskEnabled'] = $request->pskEnabled;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateIpsecServer',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateIpsecServerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configuration of an IPsec server.
     *
     * @remarks
     *   If you modify only **IpsecServerName** of the IPsec server, this operation is synchronous. If you modify other parameters besides **IpsecServerName**, this operation is asynchronous.
     * *   If **UpdateIpsecServer** is an asynchronous operation, after a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
     *     *   If the VPN gateway is in the **updating** state, the IPsec server is being modified.
     *     *   If the VPN gateway is in the **active** state, the IPsec server is modified.
     * *   You cannot repeatedly call **UpdateIpsecServer** within the specified period of time.
     *
     * @param request - UpdateIpsecServerRequest
     *
     * @returns UpdateIpsecServerResponse
     *
     * @param UpdateIpsecServerRequest $request
     *
     * @return UpdateIpsecServerResponse
     */
    public function updateIpsecServer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateIpsecServerWithOptions($request, $runtime);
    }

    /**
     * Modifies the description or name of an IPv4 gateway.
     *
     * @remarks
     * You cannot repeatedly call the **UpdateIpv4GatewayAttribute** operation to modify the name or description of an IPv4 gateway within the specified period of time.
     *
     * @param request - UpdateIpv4GatewayAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateIpv4GatewayAttributeResponse
     *
     * @param UpdateIpv4GatewayAttributeRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return UpdateIpv4GatewayAttributeResponse
     */
    public function updateIpv4GatewayAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ipv4GatewayDescription) {
            @$query['Ipv4GatewayDescription'] = $request->ipv4GatewayDescription;
        }

        if (null !== $request->ipv4GatewayId) {
            @$query['Ipv4GatewayId'] = $request->ipv4GatewayId;
        }

        if (null !== $request->ipv4GatewayName) {
            @$query['Ipv4GatewayName'] = $request->ipv4GatewayName;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateIpv4GatewayAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateIpv4GatewayAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the description or name of an IPv4 gateway.
     *
     * @remarks
     * You cannot repeatedly call the **UpdateIpv4GatewayAttribute** operation to modify the name or description of an IPv4 gateway within the specified period of time.
     *
     * @param request - UpdateIpv4GatewayAttributeRequest
     *
     * @returns UpdateIpv4GatewayAttributeResponse
     *
     * @param UpdateIpv4GatewayAttributeRequest $request
     *
     * @return UpdateIpv4GatewayAttributeResponse
     */
    public function updateIpv4GatewayAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateIpv4GatewayAttributeWithOptions($request, $runtime);
    }

    /**
     * Upgrades a standard NAT gateway to an enhanced NAT gateway.
     *
     * @remarks
     * Before you call this operation, take note of the following limits:
     * *   **UpdateNatGatewayNatType** is an asynchronous operation. After you send a request to call this operation, the system returns a request ID and the NAT gateway is still being upgraded in the backend. You can call the GetNatGatewayConvertStatus operation to query the upgrade progress of a NAT gateway. For more information, see [GetNatGatewayConvertStatus](https://help.aliyun.com/document_detail/184744.html).
     *     *   If the NAT gateway is in the **processing** state, the NAT gateway is being upgraded. You can only query the status of the NAT gateway but cannot perform other operations.
     *     *   If the NAT gateway is in the **successful** state, the NAT gateway is upgraded.
     *     *   If the NAT gateway is in the **failed** state, the system failed to upgrade the NAT gateway.
     * *   You cannot repeatedly call the **UpdateNatGatewayNatType** operation for the same VPN gateway within the specified period of time.
     * *   The billing method and billable items remain the same after the upgrade.
     * *   It takes about five minutes to upgrade a standard NAT gateway to an enhanced NAT gateway. During the upgrade, transient connection errors may occur once or twice. The service can be recovered by reconnection. You can determine whether to enable automatic reconnection or use manual reconnection based on your business requirements.
     * *   You can only upgrade standard NAT gateways to enhanced NAT gateways. You are not allowed to downgrade enhanced NAT gateways to standard NAT gateways.
     *
     * @deprecated OpenAPI UpdateNatGatewayNatType is deprecated
     *
     * @param request - UpdateNatGatewayNatTypeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateNatGatewayNatTypeResponse
     *
     * @param UpdateNatGatewayNatTypeRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return UpdateNatGatewayNatTypeResponse
     */
    public function updateNatGatewayNatTypeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->natGatewayId) {
            @$query['NatGatewayId'] = $request->natGatewayId;
        }

        if (null !== $request->natType) {
            @$query['NatType'] = $request->natType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateNatGatewayNatType',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateNatGatewayNatTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Upgrades a standard NAT gateway to an enhanced NAT gateway.
     *
     * @remarks
     * Before you call this operation, take note of the following limits:
     * *   **UpdateNatGatewayNatType** is an asynchronous operation. After you send a request to call this operation, the system returns a request ID and the NAT gateway is still being upgraded in the backend. You can call the GetNatGatewayConvertStatus operation to query the upgrade progress of a NAT gateway. For more information, see [GetNatGatewayConvertStatus](https://help.aliyun.com/document_detail/184744.html).
     *     *   If the NAT gateway is in the **processing** state, the NAT gateway is being upgraded. You can only query the status of the NAT gateway but cannot perform other operations.
     *     *   If the NAT gateway is in the **successful** state, the NAT gateway is upgraded.
     *     *   If the NAT gateway is in the **failed** state, the system failed to upgrade the NAT gateway.
     * *   You cannot repeatedly call the **UpdateNatGatewayNatType** operation for the same VPN gateway within the specified period of time.
     * *   The billing method and billable items remain the same after the upgrade.
     * *   It takes about five minutes to upgrade a standard NAT gateway to an enhanced NAT gateway. During the upgrade, transient connection errors may occur once or twice. The service can be recovered by reconnection. You can determine whether to enable automatic reconnection or use manual reconnection based on your business requirements.
     * *   You can only upgrade standard NAT gateways to enhanced NAT gateways. You are not allowed to downgrade enhanced NAT gateways to standard NAT gateways.
     *
     * @deprecated OpenAPI UpdateNatGatewayNatType is deprecated
     *
     * @param request - UpdateNatGatewayNatTypeRequest
     *
     * @returns UpdateNatGatewayNatTypeResponse
     *
     * @param UpdateNatGatewayNatTypeRequest $request
     *
     * @return UpdateNatGatewayNatTypeResponse
     */
    public function updateNatGatewayNatType($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateNatGatewayNatTypeWithOptions($request, $runtime);
    }

    /**
     * Updates the rules of a network access control list (ACL).
     *
     * @remarks
     *   **UpdateNetworkAclEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of a network ACL:
     *     *   If the network ACL is in the **Modifying** state, the rules of the network ACL are being updated.
     *     *   If the network ACL is in the **Available** state, the rules of the network ACL are updated.
     * *   You cannot repeatedly call the **UpdateNetworkAclEntries** operation to update the rules of a network ACL within the specified period of time.
     *
     * @param request - UpdateNetworkAclEntriesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateNetworkAclEntriesResponse
     *
     * @param UpdateNetworkAclEntriesRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return UpdateNetworkAclEntriesResponse
     */
    public function updateNetworkAclEntriesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->egressAclEntries) {
            @$query['EgressAclEntries'] = $request->egressAclEntries;
        }

        if (null !== $request->ingressAclEntries) {
            @$query['IngressAclEntries'] = $request->ingressAclEntries;
        }

        if (null !== $request->networkAclId) {
            @$query['NetworkAclId'] = $request->networkAclId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->updateEgressAclEntries) {
            @$query['UpdateEgressAclEntries'] = $request->updateEgressAclEntries;
        }

        if (null !== $request->updateIngressAclEntries) {
            @$query['UpdateIngressAclEntries'] = $request->updateIngressAclEntries;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateNetworkAclEntries',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateNetworkAclEntriesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates the rules of a network access control list (ACL).
     *
     * @remarks
     *   **UpdateNetworkAclEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of a network ACL:
     *     *   If the network ACL is in the **Modifying** state, the rules of the network ACL are being updated.
     *     *   If the network ACL is in the **Available** state, the rules of the network ACL are updated.
     * *   You cannot repeatedly call the **UpdateNetworkAclEntries** operation to update the rules of a network ACL within the specified period of time.
     *
     * @param request - UpdateNetworkAclEntriesRequest
     *
     * @returns UpdateNetworkAclEntriesResponse
     *
     * @param UpdateNetworkAclEntriesRequest $request
     *
     * @return UpdateNetworkAclEntriesResponse
     */
    public function updateNetworkAclEntries($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateNetworkAclEntriesWithOptions($request, $runtime);
    }

    /**
     * Modifies the attributes of an IP address pool.
     *
     * @remarks
     * You cannot repeatedly call the **UpdatePublicIpAddressPoolAttribute** operation to modify the attributes of an IP address pool within the specified period of time.
     *
     * @param request - UpdatePublicIpAddressPoolAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdatePublicIpAddressPoolAttributeResponse
     *
     * @param UpdatePublicIpAddressPoolAttributeRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return UpdatePublicIpAddressPoolAttributeResponse
     */
    public function updatePublicIpAddressPoolAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->publicIpAddressPoolId) {
            @$query['PublicIpAddressPoolId'] = $request->publicIpAddressPoolId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdatePublicIpAddressPoolAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdatePublicIpAddressPoolAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the attributes of an IP address pool.
     *
     * @remarks
     * You cannot repeatedly call the **UpdatePublicIpAddressPoolAttribute** operation to modify the attributes of an IP address pool within the specified period of time.
     *
     * @param request - UpdatePublicIpAddressPoolAttributeRequest
     *
     * @returns UpdatePublicIpAddressPoolAttributeResponse
     *
     * @param UpdatePublicIpAddressPoolAttributeRequest $request
     *
     * @return UpdatePublicIpAddressPoolAttributeResponse
     */
    public function updatePublicIpAddressPoolAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updatePublicIpAddressPoolAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies the configuration of a filter for traffic mirror.
     *
     * @remarks
     * You cannot repeatedly call the **UpdateTrafficMirrorFilterAttribute** operation to modify the configuration of a filter for traffic mirror within the specified period of time.
     *
     * @param request - UpdateTrafficMirrorFilterAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateTrafficMirrorFilterAttributeResponse
     *
     * @param UpdateTrafficMirrorFilterAttributeRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return UpdateTrafficMirrorFilterAttributeResponse
     */
    public function updateTrafficMirrorFilterAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->trafficMirrorFilterDescription) {
            @$query['TrafficMirrorFilterDescription'] = $request->trafficMirrorFilterDescription;
        }

        if (null !== $request->trafficMirrorFilterId) {
            @$query['TrafficMirrorFilterId'] = $request->trafficMirrorFilterId;
        }

        if (null !== $request->trafficMirrorFilterName) {
            @$query['TrafficMirrorFilterName'] = $request->trafficMirrorFilterName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateTrafficMirrorFilterAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateTrafficMirrorFilterAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configuration of a filter for traffic mirror.
     *
     * @remarks
     * You cannot repeatedly call the **UpdateTrafficMirrorFilterAttribute** operation to modify the configuration of a filter for traffic mirror within the specified period of time.
     *
     * @param request - UpdateTrafficMirrorFilterAttributeRequest
     *
     * @returns UpdateTrafficMirrorFilterAttributeResponse
     *
     * @param UpdateTrafficMirrorFilterAttributeRequest $request
     *
     * @return UpdateTrafficMirrorFilterAttributeResponse
     */
    public function updateTrafficMirrorFilterAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateTrafficMirrorFilterAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies the configuration of an inbound or outbound rule for traffic mirroring.
     *
     * @remarks
     *   The **UpdateTrafficMirrorFilterRuleAttribute** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of an inbound or outbound rule:
     *     *   If the rule is in the **Modifying** state, the rule is being modified.
     *     *   If the rule is in the **Created** state, the rule is modified.
     * *   You cannot repeatedly call the **UpdateTrafficMirrorFilterRuleAttribute** operation to modify an inbound or outbound rule within the specified period of time.
     *
     * @param request - UpdateTrafficMirrorFilterRuleAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateTrafficMirrorFilterRuleAttributeResponse
     *
     * @param UpdateTrafficMirrorFilterRuleAttributeRequest $request
     * @param RuntimeOptions                                $runtime
     *
     * @return UpdateTrafficMirrorFilterRuleAttributeResponse
     */
    public function updateTrafficMirrorFilterRuleAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->destinationCidrBlock) {
            @$query['DestinationCidrBlock'] = $request->destinationCidrBlock;
        }

        if (null !== $request->destinationPortRange) {
            @$query['DestinationPortRange'] = $request->destinationPortRange;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->priority) {
            @$query['Priority'] = $request->priority;
        }

        if (null !== $request->protocol) {
            @$query['Protocol'] = $request->protocol;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->ruleAction) {
            @$query['RuleAction'] = $request->ruleAction;
        }

        if (null !== $request->sourceCidrBlock) {
            @$query['SourceCidrBlock'] = $request->sourceCidrBlock;
        }

        if (null !== $request->sourcePortRange) {
            @$query['SourcePortRange'] = $request->sourcePortRange;
        }

        if (null !== $request->trafficMirrorFilterRuleId) {
            @$query['TrafficMirrorFilterRuleId'] = $request->trafficMirrorFilterRuleId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateTrafficMirrorFilterRuleAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateTrafficMirrorFilterRuleAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configuration of an inbound or outbound rule for traffic mirroring.
     *
     * @remarks
     *   The **UpdateTrafficMirrorFilterRuleAttribute** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of an inbound or outbound rule:
     *     *   If the rule is in the **Modifying** state, the rule is being modified.
     *     *   If the rule is in the **Created** state, the rule is modified.
     * *   You cannot repeatedly call the **UpdateTrafficMirrorFilterRuleAttribute** operation to modify an inbound or outbound rule within the specified period of time.
     *
     * @param request - UpdateTrafficMirrorFilterRuleAttributeRequest
     *
     * @returns UpdateTrafficMirrorFilterRuleAttributeResponse
     *
     * @param UpdateTrafficMirrorFilterRuleAttributeRequest $request
     *
     * @return UpdateTrafficMirrorFilterRuleAttributeResponse
     */
    public function updateTrafficMirrorFilterRuleAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateTrafficMirrorFilterRuleAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies the configuration of a traffic mirror session.
     *
     * @remarks
     * ## Usage notes
     * *   **UpdateTrafficMirrorSessionAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
     *     *   If the traffic mirror session is in the **Modifying** state, the configuration of the traffic mirror session is being modified.
     *     *   If the traffic mirror session is in the **Created** state, the configuration of the traffic mirror session is modified.
     * *   You cannot repeatedly call the **UpdateTrafficMirrorSessionAttribute** operation within a specific period of time.
     *
     * @param request - UpdateTrafficMirrorSessionAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateTrafficMirrorSessionAttributeResponse
     *
     * @param UpdateTrafficMirrorSessionAttributeRequest $request
     * @param RuntimeOptions                             $runtime
     *
     * @return UpdateTrafficMirrorSessionAttributeResponse
     */
    public function updateTrafficMirrorSessionAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->enabled) {
            @$query['Enabled'] = $request->enabled;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->packetLength) {
            @$query['PacketLength'] = $request->packetLength;
        }

        if (null !== $request->priority) {
            @$query['Priority'] = $request->priority;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->trafficMirrorFilterId) {
            @$query['TrafficMirrorFilterId'] = $request->trafficMirrorFilterId;
        }

        if (null !== $request->trafficMirrorSessionDescription) {
            @$query['TrafficMirrorSessionDescription'] = $request->trafficMirrorSessionDescription;
        }

        if (null !== $request->trafficMirrorSessionId) {
            @$query['TrafficMirrorSessionId'] = $request->trafficMirrorSessionId;
        }

        if (null !== $request->trafficMirrorSessionName) {
            @$query['TrafficMirrorSessionName'] = $request->trafficMirrorSessionName;
        }

        if (null !== $request->trafficMirrorTargetId) {
            @$query['TrafficMirrorTargetId'] = $request->trafficMirrorTargetId;
        }

        if (null !== $request->trafficMirrorTargetType) {
            @$query['TrafficMirrorTargetType'] = $request->trafficMirrorTargetType;
        }

        if (null !== $request->virtualNetworkId) {
            @$query['VirtualNetworkId'] = $request->virtualNetworkId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateTrafficMirrorSessionAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateTrafficMirrorSessionAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configuration of a traffic mirror session.
     *
     * @remarks
     * ## Usage notes
     * *   **UpdateTrafficMirrorSessionAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
     *     *   If the traffic mirror session is in the **Modifying** state, the configuration of the traffic mirror session is being modified.
     *     *   If the traffic mirror session is in the **Created** state, the configuration of the traffic mirror session is modified.
     * *   You cannot repeatedly call the **UpdateTrafficMirrorSessionAttribute** operation within a specific period of time.
     *
     * @param request - UpdateTrafficMirrorSessionAttributeRequest
     *
     * @returns UpdateTrafficMirrorSessionAttributeResponse
     *
     * @param UpdateTrafficMirrorSessionAttributeRequest $request
     *
     * @return UpdateTrafficMirrorSessionAttributeResponse
     */
    public function updateTrafficMirrorSessionAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateTrafficMirrorSessionAttributeWithOptions($request, $runtime);
    }

    /**
     * Updates the maximum bandwidth value of outbound data transfer for a virtual border router (VBR).
     *
     * @param request - UpdateVirtualBorderBandwidthRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateVirtualBorderBandwidthResponse
     *
     * @param UpdateVirtualBorderBandwidthRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return UpdateVirtualBorderBandwidthResponse
     */
    public function updateVirtualBorderBandwidthWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bandwidth) {
            @$query['Bandwidth'] = $request->bandwidth;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->virtualBorderRouterId) {
            @$query['VirtualBorderRouterId'] = $request->virtualBorderRouterId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateVirtualBorderBandwidth',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateVirtualBorderBandwidthResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates the maximum bandwidth value of outbound data transfer for a virtual border router (VBR).
     *
     * @param request - UpdateVirtualBorderBandwidthRequest
     *
     * @returns UpdateVirtualBorderBandwidthResponse
     *
     * @param UpdateVirtualBorderBandwidthRequest $request
     *
     * @return UpdateVirtualBorderBandwidthResponse
     */
    public function updateVirtualBorderBandwidth($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateVirtualBorderBandwidthWithOptions($request, $runtime);
    }

    /**
     * Changes the virtual local area network (VLAN) ID of a hosted connection over Express Connect circuit.
     *
     * @param request - UpdateVirtualPhysicalConnectionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateVirtualPhysicalConnectionResponse
     *
     * @param UpdateVirtualPhysicalConnectionRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return UpdateVirtualPhysicalConnectionResponse
     */
    public function updateVirtualPhysicalConnectionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->expectSpec) {
            @$query['ExpectSpec'] = $request->expectSpec;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->token) {
            @$query['Token'] = $request->token;
        }

        if (null !== $request->vlanId) {
            @$query['VlanId'] = $request->vlanId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateVirtualPhysicalConnection',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateVirtualPhysicalConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the virtual local area network (VLAN) ID of a hosted connection over Express Connect circuit.
     *
     * @param request - UpdateVirtualPhysicalConnectionRequest
     *
     * @returns UpdateVirtualPhysicalConnectionResponse
     *
     * @param UpdateVirtualPhysicalConnectionRequest $request
     *
     * @return UpdateVirtualPhysicalConnectionResponse
     */
    public function updateVirtualPhysicalConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateVirtualPhysicalConnectionWithOptions($request, $runtime);
    }

    /**
     * Modifies the configuration of a gateway endpoint.
     *
     * @remarks
     *   **UpdateVpcGatewayEndpointAttribute** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetVpcGatewayEndpointAttribute](https://help.aliyun.com/document_detail/311017.html) operation to query the status of the task.
     *     *   If the gateway endpoint is in the **Updating** state, it is being modified.
     *     *   If the gateway endpoint is in the **Created** state, it is modified.
     * *   You cannot call the **UpdateVpcGatewayEndpointAttribute** operation within a specific period of time.
     *
     * @param request - UpdateVpcGatewayEndpointAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateVpcGatewayEndpointAttributeResponse
     *
     * @param UpdateVpcGatewayEndpointAttributeRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return UpdateVpcGatewayEndpointAttributeResponse
     */
    public function updateVpcGatewayEndpointAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->endpointDescription) {
            @$query['EndpointDescription'] = $request->endpointDescription;
        }

        if (null !== $request->endpointId) {
            @$query['EndpointId'] = $request->endpointId;
        }

        if (null !== $request->endpointName) {
            @$query['EndpointName'] = $request->endpointName;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->policyDocument) {
            @$query['PolicyDocument'] = $request->policyDocument;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateVpcGatewayEndpointAttribute',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateVpcGatewayEndpointAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configuration of a gateway endpoint.
     *
     * @remarks
     *   **UpdateVpcGatewayEndpointAttribute** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetVpcGatewayEndpointAttribute](https://help.aliyun.com/document_detail/311017.html) operation to query the status of the task.
     *     *   If the gateway endpoint is in the **Updating** state, it is being modified.
     *     *   If the gateway endpoint is in the **Created** state, it is modified.
     * *   You cannot call the **UpdateVpcGatewayEndpointAttribute** operation within a specific period of time.
     *
     * @param request - UpdateVpcGatewayEndpointAttributeRequest
     *
     * @returns UpdateVpcGatewayEndpointAttributeResponse
     *
     * @param UpdateVpcGatewayEndpointAttributeRequest $request
     *
     * @return UpdateVpcGatewayEndpointAttributeResponse
     */
    public function updateVpcGatewayEndpointAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateVpcGatewayEndpointAttributeWithOptions($request, $runtime);
    }

    /**
     * eni quota.
     *
     * @remarks
     * Before you call this operation, make sure that a VPC NAT gateway is created. For more information, see [CreateNatGateway](https://help.aliyun.com/document_detail/120219.html).
     *
     * @param request - VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse
     *
     * @param VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest $request
     * @param RuntimeOptions                                       $runtime
     *
     * @return VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse
     */
    public function vpcDescribeVpcNatGatewayNetworkInterfaceQuotaWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->natGatewayId) {
            @$query['NatGatewayId'] = $request->natGatewayId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->resourceUid) {
            @$query['ResourceUid'] = $request->resourceUid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'VpcDescribeVpcNatGatewayNetworkInterfaceQuota',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * eni quota.
     *
     * @remarks
     * Before you call this operation, make sure that a VPC NAT gateway is created. For more information, see [CreateNatGateway](https://help.aliyun.com/document_detail/120219.html).
     *
     * @param request - VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest
     *
     * @returns VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse
     *
     * @param VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest $request
     *
     * @return VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse
     */
    public function vpcDescribeVpcNatGatewayNetworkInterfaceQuota($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->vpcDescribeVpcNatGatewayNetworkInterfaceQuotaWithOptions($request, $runtime);
    }

    /**
     * Withdraw advertised Virtual Private Cloud (VPC) routes.
     *
     * @param request - WithdrawVpcPublishedRouteEntriesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns WithdrawVpcPublishedRouteEntriesResponse
     *
     * @param WithdrawVpcPublishedRouteEntriesRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return WithdrawVpcPublishedRouteEntriesResponse
     */
    public function withdrawVpcPublishedRouteEntriesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->routeEntries) {
            @$query['RouteEntries'] = $request->routeEntries;
        }

        if (null !== $request->targetInstanceId) {
            @$query['TargetInstanceId'] = $request->targetInstanceId;
        }

        if (null !== $request->targetType) {
            @$query['TargetType'] = $request->targetType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'WithdrawVpcPublishedRouteEntries',
            'version' => '2016-04-28',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return WithdrawVpcPublishedRouteEntriesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Withdraw advertised Virtual Private Cloud (VPC) routes.
     *
     * @param request - WithdrawVpcPublishedRouteEntriesRequest
     *
     * @returns WithdrawVpcPublishedRouteEntriesResponse
     *
     * @param WithdrawVpcPublishedRouteEntriesRequest $request
     *
     * @return WithdrawVpcPublishedRouteEntriesResponse
     */
    public function withdrawVpcPublishedRouteEntries($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->withdrawVpcPublishedRouteEntriesWithOptions($request, $runtime);
    }
}
