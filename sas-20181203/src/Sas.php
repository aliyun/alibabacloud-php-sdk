<?php

// This file is auto-generated, don't edit it. Thanks.

namespace AlibabaCloud\SDK\Sas\V20181203;

use AlibabaCloud\Dara\Models\RuntimeOptions;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddAssetSelectionCriteriaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddAssetSelectionCriteriaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddBaselineCheckWhiteRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddBaselineCheckWhiteRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddCheckInstanceResultWhiteListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddCheckInstanceResultWhiteListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddCheckResultWhiteListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddCheckResultWhiteListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddClientUserDefineRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddClientUserDefineRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddCloudVendorAccountAKRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddCloudVendorAccountAKResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddCloudVendorTrialConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddCloudVendorTrialConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddContainerDefenseRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddContainerDefenseRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddContainerDefenseRuleShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddContainerPluginRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddContainerPluginRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddIdcProbeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddIdcProbeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddImageEventOperationRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddImageEventOperationResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddImageVulWhiteListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddImageVulWhiteListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddInstallCodeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddInstallCodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddPrivateRegistryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddPrivateRegistryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddProtectVpcListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddProtectVpcListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddPublishBatchRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddPublishBatchResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddSasContainerWebDefenseRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddSasContainerWebDefenseRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddSasModuleTrialRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddSasModuleTrialResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddTagWithUuidRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddTagWithUuidResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddUninstallClientsByUuidsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddUninstallClientsByUuidsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddVpcHoneyPotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddVpcHoneyPotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AdvanceSecurityEventOperationsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AdvanceSecurityEventOperationsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\BatchCreateMaliciousNoteRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\BatchCreateMaliciousNoteResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\BatchDeleteMaliciousFileWhitelistConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\BatchDeleteMaliciousFileWhitelistConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\BatchOperateCommonOverallConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\BatchOperateCommonOverallConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\BatchUpdateMaliciousFileWhitelistConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\BatchUpdateMaliciousFileWhitelistConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\BindAuthToMachineRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\BindAuthToMachineResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\BindHybridProxyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\BindHybridProxyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CancelOnceTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CancelOnceTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ChangeAssetRefreshTaskConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ChangeAssetRefreshTaskConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ChangeCheckConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ChangeCheckConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ChangeCheckConfigShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ChangeCheckCustomConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ChangeCheckCustomConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ChangeSecurityScoreRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ChangeSecurityScoreRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ChangeUserLangRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ChangeUserLangResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CheckSecurityEventIdRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CheckSecurityEventIdResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CheckStsTokenAuthResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CheckTrialFixCountRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CheckTrialFixCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CheckUserHasEcsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CheckUserHasEcsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ConfirmVirusEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ConfirmVirusEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CopyCustomizeReportConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CopyCustomizeReportConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateAgentlessScanTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateAgentlessScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateAntiBruteForceRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateAntiBruteForceRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateAntiBruteForceRuleShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateAssetSelectionConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateAssetSelectionConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateAttackPathSensitiveAssetConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateAttackPathSensitiveAssetConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateAttackPathWhitelistRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateAttackPathWhitelistResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateAttestorRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateAttestorResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateBackupPolicyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateBackupPolicyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateBackupPolicyShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateBatchUploadUrlRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateBatchUploadUrlResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateBinarySecurityPolicyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateBinarySecurityPolicyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateCheckItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateCheckItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateCheckItemShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateCheckPolicyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateCheckPolicyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateContainerScanTaskByAppNameRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateContainerScanTaskByAppNameResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateContainerScanTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateContainerScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateCustomBlockRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateCustomBlockRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateCustomizedDictRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateCustomizedDictResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateCycleTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateCycleTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateDynamicDictRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateDynamicDictResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateFileDetectRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateFileDetectResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateFileDetectUploadUrlRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateFileDetectUploadUrlResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateFileProtectRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateFileProtectRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateFileUploadLimitRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateFileUploadLimitResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHoneypotNodeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHoneypotNodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHoneypotPresetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHoneypotPresetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHoneypotProbeBindRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHoneypotProbeBindResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHoneypotProbeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHoneypotProbeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHoneypotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHoneypotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHybridProxyClusterRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHybridProxyClusterResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateInterceptionRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateInterceptionRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateInterceptionRuleShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateInterceptionTargetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateInterceptionTargetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateJenkinsImageRegistryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateJenkinsImageRegistryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateJenkinsImageScanTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateJenkinsImageScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateMaliciousFileWhitelistConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateMaliciousFileWhitelistConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateMaliciousNoteRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateMaliciousNoteResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateMonitorAccountRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateMonitorAccountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOpaClusterPluginRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOpaClusterPluginResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOpaStrategyNewRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOpaStrategyNewResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOpaStrategyNewShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOrUpdateAssetGroupRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOrUpdateAssetGroupResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOrUpdateAutoTagRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOrUpdateAutoTagRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOrUpdateDingTalkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOrUpdateDingTalkResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOssBucketScanTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOssBucketScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOssScanConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOssScanConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateRdDefaultSyncListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateRdDefaultSyncListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateRestoreJobRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateRestoreJobResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateSasTrialRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateSasTrialResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateSasTrialShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateServiceLinkedRoleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateServiceLinkedRoleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateServiceTrailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateServiceTrailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateSimilarSecurityEventsQueryTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateSimilarSecurityEventsQueryTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateSoarStrategyTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateSoarStrategyTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateSuspEventNoteRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateSuspEventNoteResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateUniBackupPolicyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateUniBackupPolicyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateUniBackupPolicyShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateUniRestorePlanRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateUniRestorePlanResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateUserSettingRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateUserSettingResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateVirusScanOnceTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateVirusScanOnceTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateVulAutoRepairConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateVulAutoRepairConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteAntiBruteForceRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteAntiBruteForceRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteAttackPathSensitiveAssetConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteAttackPathSensitiveAssetConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteAttackPathWhitelistRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteAttackPathWhitelistResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteAttestorRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteAttestorResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteAutoTagRulesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteAutoTagRulesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteBackupPolicyMachineRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteBackupPolicyMachineResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteBackupPolicyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteBackupPolicyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteBackupSnapshotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteBackupSnapshotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteBaselineCheckWhiteRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteBaselineCheckWhiteRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteBinarySecurityPolicyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteBinarySecurityPolicyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteCheckItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteCheckItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteCheckPolicyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteCheckPolicyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteClientUserDefineRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteClientUserDefineRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteCloudVendorAccountAKRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteCloudVendorAccountAKResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteContainerDefenseRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteContainerDefenseRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteContainerPluginRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteContainerPluginRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteCustomBlockRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteCustomBlockRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteCustomizedDictRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteCustomizedDictResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteCustomizeReportRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteCustomizeReportResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteCycleTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteCycleTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteDingTalkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteDingTalkResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteFileProtectRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteFileProtectRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteGroupRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteGroupResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHoneypotNodeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHoneypotNodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHoneypotPresetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHoneypotPresetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHoneypotProbeBindRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHoneypotProbeBindResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHoneypotProbeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHoneypotProbeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHoneypotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHoneypotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHybridProxyClusterRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHybridProxyClusterResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHybridProxyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHybridProxyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteIdcProbeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteIdcProbeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteImageEventOperationRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteImageEventOperationResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteImageVulWhitelistRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteImageVulWhitelistResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteInstallCodeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteInstallCodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteInterceptionRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteInterceptionRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteInterceptionTargetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteInterceptionTargetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteK8sAccessInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteK8sAccessInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteLoginBaseConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteLoginBaseConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteMaliciousFileWhitelistConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteMaliciousFileWhitelistConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteMaliciousNoteRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteMaliciousNoteResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteMonitorAccountRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteMonitorAccountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteOpaStrategyNewRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteOpaStrategyNewResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteOssScanConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteOssScanConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeletePrivateRegistryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeletePrivateRegistryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteSasContainerWebDefenseRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteSasContainerWebDefenseRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteSearchConditionRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteSearchConditionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteSecurityEventMarkMissListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteSecurityEventMarkMissListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteServiceTrailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteServiceTrailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteSoarStrategyTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteSoarStrategyTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteStrategyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteStrategyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteSuspEventNodeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteSuspEventNodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteTagWithUuidRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteTagWithUuidResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteUniBackupPolicyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteUniBackupPolicyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteVpcHoneyPotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteVpcHoneyPotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteVulAutoRepairConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteVulAutoRepairConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteVulWhitelistRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteVulWhitelistResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAccessKeyLeakDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAccessKeyLeakDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAccesskeyLeakListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAccesskeyLeakListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAffectedAssetsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAffectedAssetsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAffectedMaliciousFileImagesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAffectedMaliciousFileImagesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAgentInstallStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAgentInstallStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAgentlessSensitiveFileByKeyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAgentlessSensitiveFileByKeyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAgentlessSensitiveFileByKeyShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAIAssetSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAlarmEventDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAlarmEventDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAlarmEventStackInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAlarmEventStackInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAllEntityResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAllGroupsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAllGroupsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAllImageBaselineRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAllImageBaselineResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAllRegionsStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAllRegionsStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAntiBruteForceRulesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAntiBruteForceRulesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAppVulScanCycleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAssetDetailByUuidRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAssetDetailByUuidResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAssetDetailByUuidsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAssetDetailByUuidsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAssetsScaProcessNumRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAssetsScaProcessNumResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAssetsSecurityEventSummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAssetsSecurityEventSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAssetSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAttackAnalysisDataRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAttackAnalysisDataResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAttestorsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAttestorsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAutoDelConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackupClientsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackupClientsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackUpExportInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackUpExportInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackupFilesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackupFilesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackupMachineStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackupMachineStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackupPoliciesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackupPoliciesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackupPolicyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackupPolicyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackupRestoreCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBinarySecurityPoliciesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBinarySecurityPoliciesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBruteForceRecordsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBruteForceRecordsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBruteForceSummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBruteForceSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCanAccessVpcSaleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCanFixVulListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCanFixVulListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCanTrySasResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeChartDataRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeChartDataResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeChartListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeChartListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckEcsWarningsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckEcsWarningsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckFixDetailsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckFixDetailsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckResultResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckWarningCountRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckWarningCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckWarningDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckWarningDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckWarningMachinesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckWarningMachinesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckWarningsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckWarningsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckWarningSummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckWarningSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClientConfSetupRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClientConfSetupResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClientConfStrategyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClientConfStrategyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClientProblemTypeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClientProblemTypeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCloudCenterInstancesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCloudCenterInstancesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCloudProductFieldStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCloudVendorAccountAKListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCloudVendorAccountAKListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCloudVendorTrialConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCloudVendorTrialConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterBasicInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterBasicInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterHostSecuritySummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterHostSecuritySummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterImageSecuritySummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterImageSecuritySummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterInfoListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterInfoListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterNetworkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterNetworkResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterScannerListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterScannerListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterVulStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterVulStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCommonOverallConfigListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCommonOverallConfigListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCommonOverallConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCommonOverallConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCommonTargetConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCommonTargetConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCommonTargetResultListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCommonTargetResultListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeConcernNecessityRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeConcernNecessityResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerAppsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerAppsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerCriteriaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerCriteriaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerFieldStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerGroupedFieldDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerGroupedFieldDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerInstancesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerInstancesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerScanConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerScanConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerServiceK8sClusterKritisStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerServiceK8sClusterKritisStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerServiceK8sClusterNamespacesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerServiceK8sClusterNamespacesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerServiceK8sClustersRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerServiceK8sClustersResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerTagsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerTagsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCountNotScannedImageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCountScannedImageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCriteriaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCriteriaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCustomBlockInstancesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCustomBlockInstancesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCustomBlockRecordsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCustomBlockRecordsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCustomizedDictRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCustomizedDictResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCustomizedDictUploadInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCustomizedDictUploadInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCustomizedStrategyTargetsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCustomizedStrategyTargetsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCustomizeReportConfigDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCustomizeReportConfigDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCustomizeReportListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCustomizeReportListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCycleTaskListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCycleTaskListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDataSourceRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDataSourceResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDefaultKeyInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDefaultKeyInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDefaultProxyInstallVersionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDingTalkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDingTalkResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainCountRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainSecureAlarmListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainSecureAlarmListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainSecureRiskListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainSecureRiskListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainSecureScoreRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainSecureScoreResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainSecureStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainSecureStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainSecureSuggestsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainSecureSuggestsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainSecureVulListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainSecureVulListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDynamicDictRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDynamicDictResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDynamicDictUploadInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDynamicDictUploadInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeEmgUserAgreementResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeEmgVulItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeEmgVulItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeEventLevelCountRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeEventLevelCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeEventOnStageRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeEventOnStageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExcludeSystemPathRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExcludeSystemPathResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExportInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExportInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExposedCheckWarningRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExposedCheckWarningResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExposedInstanceCriteriaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExposedInstanceCriteriaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExposedInstanceDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExposedInstanceDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExposedInstanceListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExposedInstanceListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExposedStatisticsDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExposedStatisticsDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExposedStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeFieldStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeFieldStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeFixUsedCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeFrontVulPatchListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeFrontVulPatchListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGraph4InvestigationOnlineRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGraph4InvestigationOnlineResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupedContainerInstancesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupedContainerInstancesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupedInstancesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupedInstancesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupedMaliciousFilesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupedMaliciousFilesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupedTagsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupedTagsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupedVulRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupedVulResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupStructRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupStructResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHcExportInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHcExportInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHoneyPotAuthRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHoneyPotAuthResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHoneyPotSuspStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHoneyPotSuspStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHybridProxyClusterListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHybridProxyClusterListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHybridProxyLinkedClientListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHybridProxyLinkedClientListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHybridProxyListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHybridProxyListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHybridProxyPolicyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHybridProxyPolicyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeIdcAssetCriteriaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeIdcAssetCriteriaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeIdcProbeListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeIdcProbeListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeIdcProbeScanResultListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeIdcProbeScanResultListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBaselineCheckResultRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBaselineCheckResultResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBaselineCheckSummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBaselineCheckSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBaselineDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBaselineDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBaselineItemListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBaselineItemListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBaselineStrategyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBaselineStrategyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBuildRiskByKeyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBuildRiskByKeyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBuildRiskListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBuildRiskListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageCriteriaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageCriteriaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageEventOperationConditionRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageEventOperationConditionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageEventOperationPageRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageEventOperationPageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageFixCycleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageFixTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageFixTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageGroupedVulListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageGroupedVulListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageInfoListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageInfoListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageInstancesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageInstancesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageLatestScanTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageLatestScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageListByBuildRiskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageListByBuildRiskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageListBySensitiveFileRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageListBySensitiveFileResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageListBySensitiveFileShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageListWithBaselineNameRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageListWithBaselineNameResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageRepoCriteriaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageRepoCriteriaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageRepoDetailListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageRepoDetailListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageRepoListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageRepoListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageRiskLevelStatisticResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageScanAuthCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageSecurityScanCountRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageSecurityScanCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageSensitiveFileByKeyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageSensitiveFileByKeyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageSensitiveFileByKeyShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageSensitiveFileListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageSensitiveFileListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageSensitiveFileListShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageVulListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageVulListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageVulWhiteListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageVulWhiteListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstallCaptchaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstallCaptchaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstallCodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstallCodesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstanceAntiBruteForceRulesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstanceAntiBruteForceRulesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstanceRebootStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstanceRebootStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstanceStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstanceStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstanceVulStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstanceVulStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeLatestScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeLoginBaseConfigsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeLoginBaseConfigsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeLoginSwitchConfigsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeLogMetaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeLogMetaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeLogShipperStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeLogShipperStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeLogstoreStorageRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeLogstoreStorageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeMachineCanRebootRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeMachineCanRebootResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeMatchedMaliciousNamesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeMatchedMaliciousNamesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeModuleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeMonitorAccountsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeNeedAsyncQueryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeNeedAsyncQueryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeNoticeConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeNoticeConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeNsasSuspEventTypeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeNsasSuspEventTypeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeOfflineMachinesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeOfflineMachinesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeOnceTaskLeafRecordPageRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeOnceTaskLeafRecordPageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeOnceTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeOnceTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePluginSummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePluginSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyCountRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyCronDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyCronDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyCronItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyCronItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyPortDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyPortDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyPortItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyPortItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyProcDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyProcDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyProcItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyProcItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyScaDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyScaDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyScaItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyScaItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyScaProcessDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyScaProcessDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyScheduleConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyScheduleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertySoftwareDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertySoftwareDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertySoftwareItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertySoftwareItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyTypeScaItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyTypeScaItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyUsageTopRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyUsageTopResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyUserDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyUserDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyUserItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyUserItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeQuaraFileDownloadInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeQuaraFileDownloadInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeReportExportRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeReportExportResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeReportRecipientStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeReportRecipientStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRestoreJobsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRestoreJobsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRestorePlansRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRestorePlansResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskCheckItemResultRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskCheckItemResultResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskCheckResultRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskCheckResultResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskCheckSummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskCheckSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskItemTypeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskItemTypeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskListCheckResultRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskListCheckResultResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRisksRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRisksResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskTypeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskTypeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSasPmAgentListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSasPmAgentListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeScanTaskProgressRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeScanTaskProgressResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeScanTaskStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeScanTaskStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeScreenScoreThreadRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeScreenScoreThreadResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSearchConditionRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSearchConditionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecureSuggestionRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecureSuggestionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecurityCheckScheduleConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecurityCheckScheduleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecurityEventMarkMissListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecurityEventMarkMissListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecurityEventOperationsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecurityEventOperationsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecurityEventOperationStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecurityEventOperationStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecurityStatInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecurityStatInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeServiceLinkedRoleStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeServiceLinkedRoleStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSimilarEventScenariosRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSimilarEventScenariosResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSimilarSecurityEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSimilarSecurityEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSnapshotsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSnapshotsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSoarPlaybookTaskDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSoarPlaybookTaskDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSoarStrategiesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSoarStrategiesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSoarStrategyParamRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSoarStrategyParamResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSoarStrategyTaskDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSoarStrategyTaskDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSoarStrategyTaskParamsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSoarStrategyTaskParamsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSoarStrategyTaskResultRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSoarStrategyTaskResultResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSoarStrategyTasksRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSoarStrategyTasksResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSoarSubscribedStrategyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSoarSubscribedStrategyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeStrategyDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeStrategyDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeStrategyExecDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeStrategyExecDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeStrategyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeStrategyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeStrategyTargetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeStrategyTargetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeStrictEventNameRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeStrictEventNameResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSummaryInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSummaryInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSupervisonInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSupportRegionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspEventDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspEventDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspEventExportInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspEventExportInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspEventQuaraFilesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspEventQuaraFilesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspEventsShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspEventUserSettingRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspEventUserSettingResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspiciousOverallConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspiciousOverallConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspiciousUUIDConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspiciousUUIDConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSyncAssetTaskListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSyncAssetTaskListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSyncAssetTaskLogDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSyncAssetTaskLogDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeTargetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeTargetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeTaskErrorLogRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeTaskErrorLogResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeTotalStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeTotalStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeTraceInfoDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeTraceInfoDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeTraceInfoNodeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeTraceInfoNodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUniBackupDatabaseRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUniBackupDatabaseResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUniBackupPoliciesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUniBackupPoliciesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUniBackupPolicyDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUniBackupPolicyDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUniBackupStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUniRecoverableListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUniRecoverableListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUniSupportRegionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUserBackupMachinesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUserBaselineAuthorizationRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUserBaselineAuthorizationResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUserSettingRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUserSettingResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUuidsByVulNamesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUuidsByVulNamesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVendorListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVersionConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVersionConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVolDingdingMessageRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVolDingdingMessageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVpcHoneyPotCriteriaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVpcHoneyPotCriteriaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVpcHoneyPotListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVpcHoneyPotListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVpcListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulCheckTaskStatusDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulCheckTaskStatusDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulDefendCountStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulDefendCountStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulDetailsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulDetailsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulExportInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulExportInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulFixStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulListPageRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulListPageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulMetaCountStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulNumStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulNumStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulTargetConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulTargetConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulTargetStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulTargetStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulWhitelistRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulWhitelistResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWarningExportInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWarningExportInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWarningMachinesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWarningMachinesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockBindListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockBindListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockConfigListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockConfigListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockExclusiveFileTypeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockFileChangeStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockFileChangeStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockFileEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockFileEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockFileTypeSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockInclusiveFileTypeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockProcessBlockStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockProcessBlockStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockProcessListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockProcessListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockTotalFileChangeCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebPathRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebPathResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWhiteListAssetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWhiteListAssetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWhiteListAuthorizeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWhiteListAuthorizeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWhiteListEffectiveAssetsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWhiteListEffectiveAssetsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWhiteListProcessRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWhiteListProcessResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWhiteListStrategyListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWhiteListStrategyListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWhiteListStrategyStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWhiteListStrategyStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWhiteListStrategyUuidCountRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWhiteListStrategyUuidCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DingTalkOnlineTestRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DingTalkOnlineTestResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DisableBruteForceRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DisableBruteForceRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DisableCustomBlockRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DisableCustomBlockRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\EnableBruteForceRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\EnableBruteForceRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\EnableCustomBlockRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\EnableCustomBlockRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\EnableCustomInstanceBlockRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\EnableCustomInstanceBlockRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\EnableServiceAccessResourceDirectoryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExecStrategyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExecStrategyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExportCustomizeReportRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExportCustomizeReportResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExportRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExportRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExportSuspEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExportSuspEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExportVulRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExportVulResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExportWarningRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExportWarningResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\FindContainerNetworkConnectRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\FindContainerNetworkConnectResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\FindContainerNetworkConnectShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\FinishGuidTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\FinishGuidTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\FixCheckWarningsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\FixCheckWarningsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GenerateClusterScannerWebhookYamlRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GenerateClusterScannerWebhookYamlResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GenerateDynamicDictRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GenerateDynamicDictResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GenerateK8sAccessInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GenerateK8sAccessInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GenerateOnceTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GenerateOnceTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAccountLabelRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAccountLabelResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAegisContainerPluginRuleCriteriaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAegisContainerPluginRuleCriteriaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAegisContainerPluginRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAegisContainerPluginRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAgentlessTaskCountRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAgentlessTaskCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAgentlessTaskUsedSizeEstimateRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAgentlessTaskUsedSizeEstimateResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAlarmMachineCountRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAlarmMachineCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAppNetworkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAppNetworkResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAssetDetailByUuidRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAssetDetailByUuidResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAssetSelectionConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAssetSelectionConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAssetsPropertyDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAssetsPropertyDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAssetsPropertyItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAssetsPropertyItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAttackPathEventDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAttackPathEventDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAttackPathEventStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAttackPathSensitiveAssetConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAttackPathSensitiveAssetConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAttackPathWhitelistRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAttackPathWhitelistResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAttackTypeListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAuthSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAuthVersionStatisticResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetBackupAutoConfigStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetBackupStorageCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetBuildRiskDefineRuleConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetBuildRiskDefineRuleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCanTrySasRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCanTrySasResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckCountStatisticRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckCountStatisticResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckProcessRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckProcessResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckRiskStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckRiskStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckSaleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckSaleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckStructureRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckStructureResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckSummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckTimeDimensionStatisticRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckTimeDimensionStatisticResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClientRatioStatisticRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClientRatioStatisticResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClientUserDefineRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClientUserDefineRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCloudAssetCriteriaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCloudAssetCriteriaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCloudAssetDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCloudAssetDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCloudAssetSummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCloudAssetSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClusterCheckItemWarningStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClusterCheckItemWarningStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClusterRuleSummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClusterRuleSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClusterScannerYamlRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClusterScannerYamlResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClusterStrategyCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClusterSuspEventStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClusterSuspEventStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCommonSwitchConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCommonSwitchConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetConsoleFuncGrayStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetConsoleFuncGrayStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetContainerDefenseRuleDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetContainerDefenseRuleDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCurrentVersionPublishResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetDataTrendRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetDataTrendResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetDefenceCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetDockerhubImageRiskRankInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetDockerhubImageRiskRankInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetDockerhubImageRiskStatisticRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetDockerhubImageRiskStatisticResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileDetectApiInvokeInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileDetectReportRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileDetectReportResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileDetectResultRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileDetectResultResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileProtectDashboardResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileProtectEventCountRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileProtectEventCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileProtectEventRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileProtectEventResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileProtectRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileProtectRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileUploadLimitResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFunctionTrialStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFunctionTrialStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotAttackStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotAttackStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotEventTrendRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotEventTrendResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotNodeMetricListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotNodeMetricListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotNodeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotNodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotPresetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotPresetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotProbeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotProbeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneyPotUploadPolicyInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneyPotUploadPolicyInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetImageEventOperationRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetImageEventOperationResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetImageScanNumInPeriodRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetImageScanNumInPeriodResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetInstallCodeForUuidRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetInstallCodeForUuidResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetInstanceAlarmStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetInstanceAlarmStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetInstanceAuthRangeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetInterceptionRuleDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetInterceptionRuleDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetInterceptionSummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetInterceptionSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetInterceptionTargetDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetInterceptionTargetDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetLastOnceTaskInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetLastOnceTaskInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetLocalDefaultRegionRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetLocalDefaultRegionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetLogMetaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetLogMetaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetMaliciousFileWhitelistConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetMaliciousFileWhitelistConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetModuleConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetModuleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetModuleConfigStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetModuleConfigStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetModuleConfigStatusShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetModuleTrialAuthInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetModuleTrialAuthInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetObjectScanEventRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetObjectScanEventResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOnceTaskResultInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOnceTaskResultInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaClusterBaseLineListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaClusterImageListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaClusterImageListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaClusterLabelListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaClusterLabelListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaClusterNamespaceListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaClusterNamespaceListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaPluginStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaPluginStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaStrategyDetailNewRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaStrategyDetailNewResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaStrategyTemplateSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOssBucketScanStatisticRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOssBucketScanStatisticResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOssScanConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOssScanConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetPropertyScheduleConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetPropertyScheduleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetPublishCronResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetRdTreeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetRegistryScanDayNumResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetRulesCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSasContainerWebDefenseRuleApplicationRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSasContainerWebDefenseRuleApplicationResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSasContainerWebDefenseRuleCriteriaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSasContainerWebDefenseRuleCriteriaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSasContainerWebDefenseRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSasContainerWebDefenseRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSecurityScoreRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSecurityScoreRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSensitiveDefineRuleConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSensitiveDefineRuleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetServerlessAppAuthDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetServerlessAppAuthDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetServerlessAuthSummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetServerlessAuthSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetServiceTrailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetServiceTrailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetStrategyTemplateDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetStrategyTemplateDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSupportedModulesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSupportedModulesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSuspiciousStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSuspiciousStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSwitchRegionDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSwitchRegionDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetTenantCheckAvailableResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetUserLangResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetVirusScanConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetVirusScanConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetVirusScanLatestTaskStatisticResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetVulStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetVulStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetVulWhitelistRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetVulWhitelistResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GrantSwitchAgreementRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GrantSwitchAgreementResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\HandleMaliciousFilesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\HandleMaliciousFilesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\HandleSecurityEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\HandleSecurityEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\HandleSimilarMaliciousFilesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\HandleSimilarMaliciousFilesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\HandleSimilarSecurityEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\HandleSimilarSecurityEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\IgnoreCheckItemsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\IgnoreCheckItemsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\IgnoreHcCheckWarningsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\IgnoreHcCheckWarningsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\IgnoreIdcProbeScanResultRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\IgnoreIdcProbeScanResultResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallAegisForLingjunRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallAegisForLingjunResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallAegisForLingjunShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallBackupClientRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallBackupClientResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallCloudMonitorRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallCloudMonitorResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallHybridProxyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallHybridProxyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallPmAgentRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallPmAgentResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallUniBackupAgentRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallUniBackupAgentResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\JoinWebLockProcessWhiteListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\JoinWebLockProcessWhiteListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAccountsInResourceDirectoryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAegisContainerPluginRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAegisContainerPluginRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAegisForLingjunStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAegisForLingjunStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAegisForLingjunStatusShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAgentlessAssetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAgentlessAssetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAgentlessMaliciousFilesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAgentlessMaliciousFilesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAgentlessRegionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAgentlessRelateMaliciousRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAgentlessRelateMaliciousResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAgentlessRiskUuidRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAgentlessRiskUuidResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAgentlessTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAgentlessTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAssetCleanConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAssetInfoPublishRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAssetInfoPublishResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAssetRefreshTaskConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAssetRefreshTaskConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAssetSelectionSelectedTargetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAssetSelectionSelectedTargetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAssetSelectionTargetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAssetSelectionTargetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAttackPathEventRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAttackPathEventResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAttackPathWhitelistRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAttackPathWhitelistResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAutoTagRulesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAutoTagRulesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAvailableAttackPathRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAvailableAttackPathResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAvailableHoneypotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAvailableHoneypotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListBackupRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListBackupRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListBaselineCheckWhiteRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListBaselineCheckWhiteRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListBaselineCheckWhiteRecordShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckInstanceResultRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckInstanceResultResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckItemsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckItemsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckItemWarningMachineRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckItemWarningMachineResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckItemWarningSummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckItemWarningSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckPoliciesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckPoliciesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckResultRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckResultResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckRuleInstanceRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckRuleInstanceResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckStandardRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckStandardResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckTypesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckTypesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListClientAlertModeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListClientAlertModeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListClientUserDefineRulesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListClientUserDefineRulesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListClientUserDefineRuleTypesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCloudAssetInstancesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCloudAssetInstancesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCloudAssetMatchOperatorsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCloudAssetMatchOperatorsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCloudAssetSchemasRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCloudAssetSchemasResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCloudVendorRegionsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCloudVendorRegionsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListClusterCnnfStatusDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListClusterCnnfStatusDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListClusterInterceptionConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListClusterInterceptionConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListClusterPluginInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListClusterPluginInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCompressFileDetectResultRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCompressFileDetectResultResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListContainerDefenseRuleClustersResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListContainerDefenseRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListContainerDefenseRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCriteriaStrategyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCriteriaStrategyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListDockerhubImageRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListDockerhubImageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListFileProtectEventRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListFileProtectEventResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListFileProtectPluginStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListFileProtectPluginStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListFileProtectRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListFileProtectRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListGroupsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListGroupsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotAlarmEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotAlarmEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotAttackerPortraitRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotAttackerPortraitResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotAttackerSourceRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotAttackerSourceResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotEventFlowsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotEventFlowsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotNodeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotNodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotPresetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotPresetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotProbeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotProbeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotProbeUuidRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotProbeUuidResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListImageBuildRiskItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListImageBuildRiskItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListImageRegistryExtraRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListImageRegistryExtraResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListImageRegistryRegionRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListImageRegistryRegionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListImageRiskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListImageRiskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInstanceCatalogRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInstanceCatalogResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInstanceRiskLevelsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInstanceRiskLevelsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInstanceRiskNumRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInstanceRiskNumResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInterceptionHistoryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInterceptionHistoryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInterceptionRulePageRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInterceptionRulePageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInterceptionTargetPageRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInterceptionTargetPageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListK8sAccessInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListK8sAccessInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListLogShipperRegionsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListMachineAppsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListMachineAppsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListMaliciousFileWhitelistConfigsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListMaliciousFileWhitelistConfigsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListMultiUserInstancesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListMultiUserInstancesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListObjectScanEventRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListObjectScanEventResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListOpaClusterStrategyNewRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListOpaClusterStrategyNewResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListOperationCheckRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListOperationCheckResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListOperationProcessDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListOperationProcessDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListOperationProcessRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListOperationProcessResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListOperationTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListOperationTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListOssBucketRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListOssBucketResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListOssBucketScanInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListOssBucketScanInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListOssScanConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListOssScanConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListPluginForUuidRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListPluginForUuidResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListPluginForUuidShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListPodRiskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListPodRiskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListPrivateK8sResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListPrivateRegistryListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListPrivateRegistryListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListPrivateRegistryTypeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListPrivateRegistryTypeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListPublishBatchRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListPublishBatchResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListRdDefaultSyncListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListRuleTargetAllRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListRuleTargetAllResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListSasContainerWebDefenseRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListSasContainerWebDefenseRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListSupportAttackPathAssetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListSupportAttackPathAssetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListSupportObjectSuffixResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListSystemAggregationRulesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListSystemAggregationRulesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListSystemClientRulesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListSystemClientRulesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListSystemClientRuleTypesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListSystemRuleAggregationTypesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListSystemRuleAggregationTypesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListTargetByBatchRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListTargetByBatchResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListUnfinishedOnceTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListUnfinishedOnceTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListUniBackupRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListUniBackupRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListUninstallAegisMachinesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListUninstallAegisMachinesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListUserVpcRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListUserVpcResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListUuidsByAppIdRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListUuidsByAppIdResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListUuidsByWebPathRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListUuidsByWebPathResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListVirusScanMachineEventRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListVirusScanMachineEventResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListVirusScanMachineRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListVirusScanMachineResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListVirusScanTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListVirusScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListVulAutoRepairConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListVulAutoRepairConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListVulGlobalConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListVulGlobalConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\MarkMonitorAccountsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\MarkMonitorAccountsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAccessKeyLeakDealRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAccessKeyLeakDealResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAntiBruteForceRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAntiBruteForceRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAntiBruteForceRuleShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAppVulScanCycleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAppVulScanCycleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAssetCleanConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAssetCleanConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAssetGroupRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAssetGroupResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAssetImportantRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAssetImportantResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAttestorRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAttestorResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAutoDelConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAutoDelConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyBackupPolicyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyBackupPolicyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyBackupPolicyShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyBackupPolicyStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyBackupPolicyStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyBinarySecurityPolicyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyBinarySecurityPolicyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyCheckRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyCheckRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyClearLogstoreStorageRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyClearLogstoreStorageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyClientConfSetupRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyClientConfSetupResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyClientConfStrategyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyClientConfStrategyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyClientUserDefineRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyClientUserDefineRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyCloudVendorAccountAKRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyCloudVendorAccountAKResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyCloudVendorTrialConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyCloudVendorTrialConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyClusterCnnfStatusUserConfirmRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyClusterCnnfStatusUserConfirmResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyConcernNecessityRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyConcernNecessityResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyContainerDefenseRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyContainerDefenseRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyContainerDefenseRuleShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyContainerDefenseRuleSwitchRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyContainerDefenseRuleSwitchResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyContainerPluginRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyContainerPluginRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyContainerScanConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyContainerScanConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyCreateVulWhitelistRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyCreateVulWhitelistResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyCustomBlockRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyCustomBlockRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyCycleTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyCycleTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyDingTalkStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyDingTalkStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyEmgVulSubmitRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyEmgVulSubmitResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyGroupPropertyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyGroupPropertyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyHybridProxyClusterRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyHybridProxyClusterResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyHybridProxyPolicyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyHybridProxyPolicyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyIdcProbeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyIdcProbeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyImageFixCycleConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyImageFixCycleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyImageRegistryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyImageRegistryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyInstanceAntiBruteForceRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyInstanceAntiBruteForceRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyInterceptionRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyInterceptionRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyInterceptionRuleShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyInterceptionRuleSwitchRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyInterceptionRuleSwitchResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyInterceptionTargetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyInterceptionTargetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyLoginBaseConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyLoginBaseConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyLoginSwitchConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyLoginSwitchConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyLogMetaStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyLogMetaStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyNoticeConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyNoticeConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyOpenLogShipperRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyOpenLogShipperResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyOperateVulRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyOperateVulResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyPostPayModuleSwitchRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyPostPayModuleSwitchResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyProcessWhiteListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyProcessWhiteListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyPropertyScheduleConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyPropertyScheduleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyPushAllTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyPushAllTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyRefreshProcessInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyRefreshProcessInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifySasContainerWebDefenseRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifySasContainerWebDefenseRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifySearchConditionRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifySearchConditionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifySecurityCheckScheduleConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifySecurityCheckScheduleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifySecurityEventMarkMissIndividuallyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifySecurityEventMarkMissIndividuallyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyServerlessAuthToMachineRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyServerlessAuthToMachineResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifySoarStrategySubscribeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifySoarStrategySubscribeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyStartVulScanRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyStartVulScanResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyStrategyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyStrategyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyStrategyTargetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyStrategyTargetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyTagWithUuidRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyTagWithUuidResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyUniBackupPolicyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyUniBackupPolicyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyUniBackupPolicyShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyVpcHoneyPotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyVpcHoneyPotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyVulConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyVulConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyVulTargetConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyVulTargetConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyVulTargetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyVulTargetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyVulWhitelistTargetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyVulWhitelistTargetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockCreateConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockCreateConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockDeleteConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockDeleteConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockProcessStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockProcessStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockRefreshRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockRefreshResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockStartRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockStartResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockUnbindRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockUnbindResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockUpdateConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockUpdateConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebPathRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebPathResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OpenBackupAutoConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OpenBackupAutoConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OpenPartialBuyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OpenPartialBuyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OpenSensitiveFileScanRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OpenSensitiveFileScanResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateAgentClientInstallRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateAgentClientInstallResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateApplicationRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateApplicationResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateBucketScanTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateBucketScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateCommonOverallConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateCommonOverallConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateCommonTargetConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateCommonTargetConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateImageBaselineWhitelistRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateImageBaselineWhitelistResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateImageVulRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateImageVulResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateSuspiciousOverallConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateSuspiciousOverallConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateSuspiciousTargetConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateSuspiciousTargetConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateSwitchStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateSwitchStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateVirusEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateVirusEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateVulsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateVulsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateWebLockFileEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateWebLockFileEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperationCancelIgnoreSuspEventRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperationCancelIgnoreSuspEventResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperationCustomizeReportChartRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperationCustomizeReportChartResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperationSuspEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperationSuspEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\PageImageRegistryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\PageImageRegistryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\PauseClientRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\PauseClientResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ProcessSoarStrategyTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ProcessSoarStrategyTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\PublicCreateImageScanTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\PublicCreateImageScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\PublicPreCheckImageScanTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\PublicPreCheckImageScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\PublicSyncAndCreateImageScanTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\PublicSyncAndCreateImageScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryAttackCountRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryAttackCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryDiscoverDatabaseRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryDiscoverDatabaseResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryGroupedSecurityEventMarkMissListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryGroupedSecurityEventMarkMissListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryGroupIdByGroupNameRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryGroupIdByGroupNameResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryGuidTaskListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryJenkinsImageRegistryPersistenceDayRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryJenkinsImageRegistryPersistenceDayResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryPreCheckDatabaseRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryPreCheckDatabaseResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\RebootMachineRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\RebootMachineResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ReceiveFunctionTrialRewardByAliUidRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ReceiveFunctionTrialRewardByAliUidResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\RefreshAssetsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\RefreshAssetsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\RefreshContainerAssetsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\RefreshContainerAssetsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\RefreshOssBucketScanInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\RefreshRegistryTokenRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\RefreshRegistryTokenResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ReleaseSasInstanceRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ReleaseSasInstanceResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\RemoveCheckInstanceResultWhiteListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\RemoveCheckInstanceResultWhiteListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\RemoveCheckResultWhiteListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\RemoveCheckResultWhiteListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ResetHoneypotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ResetHoneypotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ResetLogShipperRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ResetLogShipperResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\RetryAgentlessTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\RetryAgentlessTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\RetryInstallProbeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\RetryInstallProbeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\RollbackSuspEventQuaraFileRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\RollbackSuspEventQuaraFileResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SasInstallCodeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SasInstallCodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SaveCustomizeReportConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SaveCustomizeReportConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SaveImageBaselineStrategyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SaveImageBaselineStrategyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SaveSuspEventUserSettingRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SaveSuspEventUserSettingResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SaveWhiteListStrategyAssetsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SaveWhiteListStrategyAssetsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SaveWhiteListStrategyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SaveWhiteListStrategyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SendCustomizeReportRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SendCustomizeReportResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetBuildRiskDefineRuleConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetBuildRiskDefineRuleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetClusterInterceptionConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetClusterInterceptionConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetImageBuildRiskStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetImageBuildRiskStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetImageSensitiveFileStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetImageSensitiveFileStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetImageSensitiveFileStatusShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetRegistryScanDayNumRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetRegistryScanDayNumResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetSensitiveDefineRuleConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetSensitiveDefineRuleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetSyncRefreshRegionRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetSyncRefreshRegionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\StartBaselineSecurityCheckRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\StartBaselineSecurityCheckResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\StartDiscoverDatabaseTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\StartHoneypotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\StartHoneypotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\StartIdcProbeScanResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\StartPreCheckDatabaseRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\StartPreCheckDatabaseResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\StartVirusScanTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\StartVirusScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\StopHoneypotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\StopHoneypotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SubmitCheckRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SubmitCheckResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SubmitOperationTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SubmitOperationTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SubmitTenantCheckResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\TriggerCheckResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UnbindAegisRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UnbindAegisResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UnBindHybridProxyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UnBindHybridProxyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UninstallBackupClientRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UninstallBackupClientResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UninstallUniBackupAgentRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UninstallUniBackupAgentResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UnMarkMonitorAccountsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UnMarkMonitorAccountsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateAlarmEventRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateAlarmEventResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateAttackPathSensitiveAssetConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateAttackPathSensitiveAssetConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateAttackPathWhitelistRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateAttackPathWhitelistResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateBaselineCheckWhiteRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateBaselineCheckWhiteRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateCheckItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateCheckItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateCheckItemShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateCheckPolicyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateCheckPolicyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateClientAlertModeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateClientAlertModeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateCommonSwitchConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateCommonSwitchConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateCustomizeReportStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateCustomizeReportStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateFileProtectEventStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateFileProtectEventStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateFileProtectRemarkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateFileProtectRemarkResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateFileProtectRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateFileProtectRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateFileUploadLimitRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateFileUploadLimitResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateHoneypotNodeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateHoneypotNodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateHoneypotPresetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateHoneypotPresetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateHoneypotProbeBindRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateHoneypotProbeBindResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateHoneypotProbeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateHoneypotProbeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateHoneypotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateHoneypotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateHybridProxyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateHybridProxyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateImageEventOperationRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateImageEventOperationResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateImageVulWhitelistTargetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateImageVulWhitelistTargetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateJenkinsImageRegistryNameRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateJenkinsImageRegistryNameResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateJenkinsImageRegistryPersistenceDayRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateJenkinsImageRegistryPersistenceDayResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateMaliciousFileWhitelistConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateMaliciousFileWhitelistConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateMultiUserInstancesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateMultiUserInstancesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateOpaStrategyNewRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateOpaStrategyNewResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateOpaStrategyNewShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateOssScanConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateOssScanConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdatePostPaidBindRelRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdatePostPaidBindRelResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdatePublishAutoUpgradeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdatePublishAutoUpgradeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdatePublishBatchRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdatePublishBatchResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdatePublishCronRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdatePublishCronResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdatePublishGraySwitchRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdatePublishGraySwitchResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateSelectionKeyByTypeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateSelectionKeyByTypeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateStrictEventNameRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateStrictEventNameResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateTargetListByBatchRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateTargetListByBatchResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateWhiteListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateWhiteListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateWhiteListStrategyStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateWhiteListStrategyStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpgradeBackupPolicyVersionRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpgradeBackupPolicyVersionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpgradeHoneypotNodeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpgradeHoneypotNodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpgradeVersionByUuidsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpgradeVersionByUuidsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UploadedHoneyPotFileRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UploadedHoneyPotFileResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ValidateHcWarningsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ValidateHcWarningsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\VerifyCheckCustomConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\VerifyCheckCustomConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\VerifyCheckCustomConfigShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\VerifyCheckInstanceResultRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\VerifyCheckInstanceResultResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\VerifyCheckResultRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\VerifyCheckResultResponse;
use Darabonba\OpenApi\Models\OpenApiRequest;
use Darabonba\OpenApi\Models\Params;
use Darabonba\OpenApi\OpenApiClient;
use Darabonba\OpenApi\Utils;

class Sas extends OpenApiClient
{
    public function __construct($config)
    {
        parent::__construct($config);
        $this->_endpointRule = 'regional';
        $this->_endpointMap = [
            'cn-qingdao' => 'tds.cn-shanghai.aliyuncs.com',
            'cn-beijing' => 'tds.cn-shanghai.aliyuncs.com',
            'cn-zhangjiakou' => 'tds.cn-shanghai.aliyuncs.com',
            'cn-huhehaote' => 'tds.cn-shanghai.aliyuncs.com',
            'cn-wulanchabu' => 'tds.cn-shanghai.aliyuncs.com',
            'cn-hangzhou' => 'tds.cn-shanghai.aliyuncs.com',
            'cn-shanghai' => 'tds.cn-shanghai.aliyuncs.com',
            'cn-nanjing' => 'tds.cn-shanghai.aliyuncs.com',
            'cn-fuzhou' => 'tds.cn-shanghai.aliyuncs.com',
            'cn-shenzhen' => 'tds.cn-shanghai.aliyuncs.com',
            'cn-heyuan' => 'tds.cn-shanghai.aliyuncs.com',
            'cn-guangzhou' => 'tds.cn-shanghai.aliyuncs.com',
            'ap-southeast-2' => 'tds.ap-southeast-1.aliyuncs.com',
            'ap-southeast-6' => 'tds.ap-southeast-1.aliyuncs.com',
            'ap-northeast-2' => 'tds.ap-southeast-1.aliyuncs.com',
            'ap-southeast-3' => 'tds.ap-southeast-1.aliyuncs.com',
            'ap-northeast-1' => 'tds.ap-southeast-1.aliyuncs.com',
            'ap-southeast-7' => 'tds.ap-southeast-1.aliyuncs.com',
            'cn-chengdu' => 'tds.cn-shanghai.aliyuncs.com',
            'ap-southeast-1' => 'tds.ap-southeast-1.aliyuncs.com',
            'ap-southeast-5' => 'tds.ap-southeast-1.aliyuncs.com',
            'cn-hongkong' => 'tds.cn-shanghai.aliyuncs.com',
            'eu-central-1' => 'tds.ap-southeast-1.aliyuncs.com',
            'us-east-1' => 'tds.ap-southeast-1.aliyuncs.com',
            'us-west-1' => 'tds.ap-southeast-1.aliyuncs.com',
            'eu-west-1' => 'tds.ap-southeast-1.aliyuncs.com',
            'me-east-1' => 'tds.ap-southeast-1.aliyuncs.com',
            'me-central-1' => 'tds.ap-southeast-1.aliyuncs.com',
            'ap-south-1' => 'tds.ap-southeast-1.aliyuncs.com',
            'cn-beijing-finance-1' => 'tds.cn-shanghai.aliyuncs.com',
            'cn-hangzhou-finance' => 'tds.cn-shanghai.aliyuncs.com',
            'cn-shanghai-finance-1' => 'tds.cn-shanghai.aliyuncs.com',
            'cn-shenzhen-finance-1' => 'tds.cn-shanghai.aliyuncs.com',
            'cn-heyuan-acdr-1' => 'tds.cn-shanghai.aliyuncs.com',
            'cn-north-2-gov-1' => 'tds.cn-shanghai.aliyuncs.com',
            'cn-qingdao-acdr-ut-1' => 'tds.cn-shanghai.aliyuncs.com',
            'cn-shanghai-mybk' => 'tds.cn-shanghai.aliyuncs.com',
            'cn-wuhan-lr' => 'tds.cn-shanghai.aliyuncs.com',
            'cn-zhengzhou-jva' => 'tds.cn-shanghai.aliyuncs.com',
        ];
        $this->checkConfig($config);
        $this->_endpoint = $this->getEndpoint('sas', $this->_regionId, $this->_endpointRule, $this->_network, $this->_suffix, $this->_endpointMap, $this->_endpoint);
    }

    /**
     * @param string   $productId
     * @param string   $regionId
     * @param string   $endpointRule
     * @param string   $network
     * @param string   $suffix
     * @param string[] $endpointMap
     * @param string   $endpoint
     *
     * @return string
     */
    public function getEndpoint($productId, $regionId, $endpointRule, $network, $suffix, $endpointMap, $endpoint)
    {
        if (null !== $endpoint) {
            return $endpoint;
        }

        if (null !== $endpointMap && null !== @$endpointMap[$regionId]) {
            return @$endpointMap[$regionId];
        }

        return Utils::getEndpointRules($productId, $regionId, $endpointRule, $network, $suffix);
    }

    /**
     * Select an operation for assets.
     *
     * @param request - AddAssetSelectionCriteriaRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddAssetSelectionCriteriaResponse
     *
     * @param AddAssetSelectionCriteriaRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return AddAssetSelectionCriteriaResponse
     */
    public function addAssetSelectionCriteriaWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->criteria) {
            @$query['Criteria'] = $request->criteria;
        }

        if (null !== $request->criteriaOperation) {
            @$query['CriteriaOperation'] = $request->criteriaOperation;
        }

        if (null !== $request->selectionKey) {
            @$query['SelectionKey'] = $request->selectionKey;
        }

        if (null !== $request->targetOperationList) {
            @$query['TargetOperationList'] = $request->targetOperationList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddAssetSelectionCriteria',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddAssetSelectionCriteriaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Select an operation for assets.
     *
     * @param request - AddAssetSelectionCriteriaRequest
     *
     * @returns AddAssetSelectionCriteriaResponse
     *
     * @param AddAssetSelectionCriteriaRequest $request
     *
     * @return AddAssetSelectionCriteriaResponse
     */
    public function addAssetSelectionCriteria($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addAssetSelectionCriteriaWithOptions($request, $runtime);
    }

    /**
     * Creates a whitelist rule for a baseline check item.
     *
     * @param request - AddBaselineCheckWhiteRecordRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddBaselineCheckWhiteRecordResponse
     *
     * @param AddBaselineCheckWhiteRecordRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return AddBaselineCheckWhiteRecordResponse
     */
    public function addBaselineCheckWhiteRecordWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->checkId) {
            @$query['CheckId'] = $request->checkId;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->reason) {
            @$query['Reason'] = $request->reason;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        if (null !== $request->targetType) {
            @$query['TargetType'] = $request->targetType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddBaselineCheckWhiteRecord',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddBaselineCheckWhiteRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a whitelist rule for a baseline check item.
     *
     * @param request - AddBaselineCheckWhiteRecordRequest
     *
     * @returns AddBaselineCheckWhiteRecordResponse
     *
     * @param AddBaselineCheckWhiteRecordRequest $request
     *
     * @return AddBaselineCheckWhiteRecordResponse
     */
    public function addBaselineCheckWhiteRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addBaselineCheckWhiteRecordWithOptions($request, $runtime);
    }

    /**
     * Adds instances on which risks are detected based on check items of the configuration assessment feature to a whitelist.
     *
     * @param request - AddCheckInstanceResultWhiteListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddCheckInstanceResultWhiteListResponse
     *
     * @param AddCheckInstanceResultWhiteListRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return AddCheckInstanceResultWhiteListResponse
     */
    public function addCheckInstanceResultWhiteListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->checkGroupId) {
            @$query['CheckGroupId'] = $request->checkGroupId;
        }

        if (null !== $request->checkId) {
            @$query['CheckId'] = $request->checkId;
        }

        if (null !== $request->instanceIds) {
            @$query['InstanceIds'] = $request->instanceIds;
        }

        if (null !== $request->instanceList) {
            @$query['InstanceList'] = $request->instanceList;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->ruleType) {
            @$query['RuleType'] = $request->ruleType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddCheckInstanceResultWhiteList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddCheckInstanceResultWhiteListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds instances on which risks are detected based on check items of the configuration assessment feature to a whitelist.
     *
     * @param request - AddCheckInstanceResultWhiteListRequest
     *
     * @returns AddCheckInstanceResultWhiteListResponse
     *
     * @param AddCheckInstanceResultWhiteListRequest $request
     *
     * @return AddCheckInstanceResultWhiteListResponse
     */
    public function addCheckInstanceResultWhiteList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addCheckInstanceResultWhiteListWithOptions($request, $runtime);
    }

    /**
     * Adds the check items of the configuration assessment feature to the whitelist.
     *
     * @param request - AddCheckResultWhiteListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddCheckResultWhiteListResponse
     *
     * @param AddCheckResultWhiteListRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return AddCheckResultWhiteListResponse
     */
    public function addCheckResultWhiteListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->checkIds) {
            @$query['CheckIds'] = $request->checkIds;
        }

        if (null !== $request->instanceIds) {
            @$query['InstanceIds'] = $request->instanceIds;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->ruleType) {
            @$query['RuleType'] = $request->ruleType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddCheckResultWhiteList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddCheckResultWhiteListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds the check items of the configuration assessment feature to the whitelist.
     *
     * @param request - AddCheckResultWhiteListRequest
     *
     * @returns AddCheckResultWhiteListResponse
     *
     * @param AddCheckResultWhiteListRequest $request
     *
     * @return AddCheckResultWhiteListResponse
     */
    public function addCheckResultWhiteList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addCheckResultWhiteListWithOptions($request, $runtime);
    }

    /**
     * Creates a custom defense rule.
     *
     * @param request - AddClientUserDefineRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddClientUserDefineRuleResponse
     *
     * @param AddClientUserDefineRuleRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return AddClientUserDefineRuleResponse
     */
    public function addClientUserDefineRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->actionType) {
            @$query['ActionType'] = $request->actionType;
        }

        if (null !== $request->cmdline) {
            @$query['Cmdline'] = $request->cmdline;
        }

        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->filePath) {
            @$query['FilePath'] = $request->filePath;
        }

        if (null !== $request->IP) {
            @$query['IP'] = $request->IP;
        }

        if (null !== $request->md5List) {
            @$query['Md5List'] = $request->md5List;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->newFilePath) {
            @$query['NewFilePath'] = $request->newFilePath;
        }

        if (null !== $request->parentCmdline) {
            @$query['ParentCmdline'] = $request->parentCmdline;
        }

        if (null !== $request->parentProcPath) {
            @$query['ParentProcPath'] = $request->parentProcPath;
        }

        if (null !== $request->platform) {
            @$query['Platform'] = $request->platform;
        }

        if (null !== $request->port) {
            @$query['Port'] = $request->port;
        }

        if (null !== $request->portStr) {
            @$query['PortStr'] = $request->portStr;
        }

        if (null !== $request->procPath) {
            @$query['ProcPath'] = $request->procPath;
        }

        if (null !== $request->registryContent) {
            @$query['RegistryContent'] = $request->registryContent;
        }

        if (null !== $request->registryKey) {
            @$query['RegistryKey'] = $request->registryKey;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddClientUserDefineRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddClientUserDefineRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a custom defense rule.
     *
     * @param request - AddClientUserDefineRuleRequest
     *
     * @returns AddClientUserDefineRuleResponse
     *
     * @param AddClientUserDefineRuleRequest $request
     *
     * @return AddClientUserDefineRuleResponse
     */
    public function addClientUserDefineRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addClientUserDefineRuleWithOptions($request, $runtime);
    }

    /**
     * Adds the configuration information of multi-cloud assets.
     *
     * @param request - AddCloudVendorAccountAKRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddCloudVendorAccountAKResponse
     *
     * @param AddCloudVendorAccountAKRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return AddCloudVendorAccountAKResponse
     */
    public function addCloudVendorAccountAKWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->akType) {
            @$query['AkType'] = $request->akType;
        }

        if (null !== $request->authModules) {
            @$query['AuthModules'] = $request->authModules;
        }

        if (null !== $request->ctdrCloudUserId) {
            @$query['CtdrCloudUserId'] = $request->ctdrCloudUserId;
        }

        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->extendInfo) {
            @$query['ExtendInfo'] = $request->extendInfo;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->regions) {
            @$query['Regions'] = $request->regions;
        }

        if (null !== $request->secretId) {
            @$query['SecretId'] = $request->secretId;
        }

        if (null !== $request->secretKey) {
            @$query['SecretKey'] = $request->secretKey;
        }

        if (null !== $request->subscriptionIds) {
            @$query['SubscriptionIds'] = $request->subscriptionIds;
        }

        if (null !== $request->tenantId) {
            @$query['TenantId'] = $request->tenantId;
        }

        if (null !== $request->vendor) {
            @$query['Vendor'] = $request->vendor;
        }

        if (null !== $request->vendorAuthAlias) {
            @$query['VendorAuthAlias'] = $request->vendorAuthAlias;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddCloudVendorAccountAK',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddCloudVendorAccountAKResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds the configuration information of multi-cloud assets.
     *
     * @param request - AddCloudVendorAccountAKRequest
     *
     * @returns AddCloudVendorAccountAKResponse
     *
     * @param AddCloudVendorAccountAKRequest $request
     *
     * @return AddCloudVendorAccountAKResponse
     */
    public function addCloudVendorAccountAK($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addCloudVendorAccountAKWithOptions($request, $runtime);
    }

    /**
     * Adds configurations of connecting the audit logs of a third-party cloud asset.
     *
     * @param request - AddCloudVendorTrialConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddCloudVendorTrialConfigResponse
     *
     * @param AddCloudVendorTrialConfigRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return AddCloudVendorTrialConfigResponse
     */
    public function addCloudVendorTrialConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->authId) {
            @$query['AuthId'] = $request->authId;
        }

        if (null !== $request->authInfo) {
            @$query['AuthInfo'] = $request->authInfo;
        }

        if (null !== $request->vendor) {
            @$query['Vendor'] = $request->vendor;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddCloudVendorTrialConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddCloudVendorTrialConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds configurations of connecting the audit logs of a third-party cloud asset.
     *
     * @param request - AddCloudVendorTrialConfigRequest
     *
     * @returns AddCloudVendorTrialConfigResponse
     *
     * @param AddCloudVendorTrialConfigRequest $request
     *
     * @return AddCloudVendorTrialConfigResponse
     */
    public function addCloudVendorTrialConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addCloudVendorTrialConfigWithOptions($request, $runtime);
    }

    /**
     * Creates a rule for non-image program defense.
     *
     * @param tmpReq - AddContainerDefenseRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddContainerDefenseRuleResponse
     *
     * @param AddContainerDefenseRuleRequest $tmpReq
     * @param RuntimeOptions                 $runtime
     *
     * @return AddContainerDefenseRuleResponse
     */
    public function addContainerDefenseRuleWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new AddContainerDefenseRuleShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->whitelist) {
            $request->whitelistShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->whitelist, 'Whitelist', 'json');
        }

        $query = [];
        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->ruleAction) {
            @$query['RuleAction'] = $request->ruleAction;
        }

        if (null !== $request->ruleId) {
            @$query['RuleId'] = $request->ruleId;
        }

        if (null !== $request->ruleName) {
            @$query['RuleName'] = $request->ruleName;
        }

        if (null !== $request->ruleSwitch) {
            @$query['RuleSwitch'] = $request->ruleSwitch;
        }

        if (null !== $request->ruleType) {
            @$query['RuleType'] = $request->ruleType;
        }

        if (null !== $request->scope) {
            @$query['Scope'] = $request->scope;
        }

        if (null !== $request->whitelistShrink) {
            @$query['Whitelist'] = $request->whitelistShrink;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddContainerDefenseRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddContainerDefenseRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a rule for non-image program defense.
     *
     * @param request - AddContainerDefenseRuleRequest
     *
     * @returns AddContainerDefenseRuleResponse
     *
     * @param AddContainerDefenseRuleRequest $request
     *
     * @return AddContainerDefenseRuleResponse
     */
    public function addContainerDefenseRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addContainerDefenseRuleWithOptions($request, $runtime);
    }

    /**
     * Creates a defense rule against container escapes.
     *
     * @param request - AddContainerPluginRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddContainerPluginRuleResponse
     *
     * @param AddContainerPluginRuleRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return AddContainerPluginRuleResponse
     */
    public function addContainerPluginRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->mode) {
            @$query['Mode'] = $request->mode;
        }

        if (null !== $request->ruleName) {
            @$query['RuleName'] = $request->ruleName;
        }

        if (null !== $request->ruleTemplateId) {
            @$query['RuleTemplateId'] = $request->ruleTemplateId;
        }

        if (null !== $request->ruleType) {
            @$query['RuleType'] = $request->ruleType;
        }

        if (null !== $request->selectedPolicy) {
            @$query['SelectedPolicy'] = $request->selectedPolicy;
        }

        if (null !== $request->whiteImages) {
            @$query['WhiteImages'] = $request->whiteImages;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddContainerPluginRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddContainerPluginRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a defense rule against container escapes.
     *
     * @param request - AddContainerPluginRuleRequest
     *
     * @returns AddContainerPluginRuleResponse
     *
     * @param AddContainerPluginRuleRequest $request
     *
     * @return AddContainerPluginRuleResponse
     */
    public function addContainerPluginRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addContainerPluginRuleWithOptions($request, $runtime);
    }

    /**
     * Creates an IDC probe to add assets in a data center to Security Center and manage the assets by using the Security Center console.
     *
     * @remarks
     * Security Center allows you to create an IDC probe only on servers on which the Security Center agent is installed.
     *
     * @param request - AddIdcProbeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddIdcProbeResponse
     *
     * @param AddIdcProbeRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return AddIdcProbeResponse
     */
    public function addIdcProbeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->idcName) {
            @$query['IdcName'] = $request->idcName;
        }

        if (null !== $request->idcRegion) {
            @$query['IdcRegion'] = $request->idcRegion;
        }

        if (null !== $request->intervalPeriod) {
            @$query['IntervalPeriod'] = $request->intervalPeriod;
        }

        if (null !== $request->ipSegments) {
            @$query['IpSegments'] = $request->ipSegments;
        }

        if (null !== $request->linuxPort) {
            @$query['LinuxPort'] = $request->linuxPort;
        }

        if (null !== $request->periodUnit) {
            @$query['PeriodUnit'] = $request->periodUnit;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        if (null !== $request->winPort) {
            @$query['WinPort'] = $request->winPort;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddIdcProbe',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddIdcProbeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an IDC probe to add assets in a data center to Security Center and manage the assets by using the Security Center console.
     *
     * @remarks
     * Security Center allows you to create an IDC probe only on servers on which the Security Center agent is installed.
     *
     * @param request - AddIdcProbeRequest
     *
     * @returns AddIdcProbeResponse
     *
     * @param AddIdcProbeRequest $request
     *
     * @return AddIdcProbeResponse
     */
    public function addIdcProbe($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addIdcProbeWithOptions($request, $runtime);
    }

    /**
     * Creates an alert handling rule.
     *
     * @param request - AddImageEventOperationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddImageEventOperationResponse
     *
     * @param AddImageEventOperationRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return AddImageEventOperationResponse
     */
    public function addImageEventOperationWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->conditions) {
            @$query['Conditions'] = $request->conditions;
        }

        if (null !== $request->eventKey) {
            @$query['EventKey'] = $request->eventKey;
        }

        if (null !== $request->eventName) {
            @$query['EventName'] = $request->eventName;
        }

        if (null !== $request->eventType) {
            @$query['EventType'] = $request->eventType;
        }

        if (null !== $request->note) {
            @$query['Note'] = $request->note;
        }

        if (null !== $request->operationCode) {
            @$query['OperationCode'] = $request->operationCode;
        }

        if (null !== $request->scenarios) {
            @$query['Scenarios'] = $request->scenarios;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddImageEventOperation',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddImageEventOperationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an alert handling rule.
     *
     * @param request - AddImageEventOperationRequest
     *
     * @returns AddImageEventOperationResponse
     *
     * @param AddImageEventOperationRequest $request
     *
     * @return AddImageEventOperationResponse
     */
    public function addImageEventOperation($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addImageEventOperationWithOptions($request, $runtime);
    }

    /**
     * Adds image vulnerabilities to the whitelist.
     *
     * @param request - AddImageVulWhiteListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddImageVulWhiteListResponse
     *
     * @param AddImageVulWhiteListRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return AddImageVulWhiteListResponse
     */
    public function addImageVulWhiteListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->reason) {
            @$query['Reason'] = $request->reason;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        if (null !== $request->target) {
            @$query['Target'] = $request->target;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        if (null !== $request->whitelist) {
            @$query['Whitelist'] = $request->whitelist;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddImageVulWhiteList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddImageVulWhiteListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds image vulnerabilities to the whitelist.
     *
     * @param request - AddImageVulWhiteListRequest
     *
     * @returns AddImageVulWhiteListResponse
     *
     * @param AddImageVulWhiteListRequest $request
     *
     * @return AddImageVulWhiteListResponse
     */
    public function addImageVulWhiteList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addImageVulWhiteListWithOptions($request, $runtime);
    }

    /**
     * Creates a command that is used to install the Security Center agent.
     *
     * @param request - AddInstallCodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddInstallCodeResponse
     *
     * @param AddInstallCodeRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return AddInstallCodeResponse
     */
    public function addInstallCodeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->expiredDate) {
            @$query['ExpiredDate'] = $request->expiredDate;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        if (null !== $request->onlyImage) {
            @$query['OnlyImage'] = $request->onlyImage;
        }

        if (null !== $request->os) {
            @$query['Os'] = $request->os;
        }

        if (null !== $request->privateLinkId) {
            @$query['PrivateLinkId'] = $request->privateLinkId;
        }

        if (null !== $request->proxyCluster) {
            @$query['ProxyCluster'] = $request->proxyCluster;
        }

        if (null !== $request->vendorName) {
            @$query['VendorName'] = $request->vendorName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddInstallCode',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddInstallCodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a command that is used to install the Security Center agent.
     *
     * @param request - AddInstallCodeRequest
     *
     * @returns AddInstallCodeResponse
     *
     * @param AddInstallCodeRequest $request
     *
     * @return AddInstallCodeResponse
     */
    public function addInstallCode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addInstallCodeWithOptions($request, $runtime);
    }

    /**
     * Adds a self-managed image repository.
     *
     * @param request - AddPrivateRegistryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddPrivateRegistryResponse
     *
     * @param AddPrivateRegistryRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return AddPrivateRegistryResponse
     */
    public function addPrivateRegistryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->extraParam) {
            @$query['ExtraParam'] = $request->extraParam;
        }

        if (null !== $request->netType) {
            @$query['NetType'] = $request->netType;
        }

        if (null !== $request->password) {
            @$query['Password'] = $request->password;
        }

        if (null !== $request->port) {
            @$query['Port'] = $request->port;
        }

        if (null !== $request->protocolType) {
            @$query['ProtocolType'] = $request->protocolType;
        }

        if (null !== $request->registryHostIp) {
            @$query['RegistryHostIp'] = $request->registryHostIp;
        }

        if (null !== $request->registryRegionId) {
            @$query['RegistryRegionId'] = $request->registryRegionId;
        }

        if (null !== $request->registryType) {
            @$query['RegistryType'] = $request->registryType;
        }

        if (null !== $request->registryVersion) {
            @$query['RegistryVersion'] = $request->registryVersion;
        }

        if (null !== $request->transPerHour) {
            @$query['TransPerHour'] = $request->transPerHour;
        }

        if (null !== $request->userName) {
            @$query['UserName'] = $request->userName;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddPrivateRegistry',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddPrivateRegistryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds a self-managed image repository.
     *
     * @param request - AddPrivateRegistryRequest
     *
     * @returns AddPrivateRegistryResponse
     *
     * @param AddPrivateRegistryRequest $request
     *
     * @return AddPrivateRegistryResponse
     */
    public function addPrivateRegistry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addPrivateRegistryWithOptions($request, $runtime);
    }

    /**
     * Add or update the whitelist for VPC purchases.
     *
     * @param request - AddProtectVpcListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddProtectVpcListResponse
     *
     * @param AddProtectVpcListRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return AddProtectVpcListResponse
     */
    public function addProtectVpcListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->addVpcInstanceIdList) {
            @$query['AddVpcInstanceIdList'] = $request->addVpcInstanceIdList;
        }

        if (null !== $request->delVpcInstanceIdList) {
            @$query['DelVpcInstanceIdList'] = $request->delVpcInstanceIdList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddProtectVpcList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddProtectVpcListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Add or update the whitelist for VPC purchases.
     *
     * @param request - AddProtectVpcListRequest
     *
     * @returns AddProtectVpcListResponse
     *
     * @param AddProtectVpcListRequest $request
     *
     * @return AddProtectVpcListResponse
     */
    public function addProtectVpcList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addProtectVpcListWithOptions($request, $runtime);
    }

    /**
     * Upgrades the Security Center agent in batches.
     *
     * @param request - AddPublishBatchRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddPublishBatchResponse
     *
     * @param AddPublishBatchRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return AddPublishBatchResponse
     */
    public function addPublishBatchWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->batchName) {
            @$query['BatchName'] = $request->batchName;
        }

        if (null !== $request->interval) {
            @$query['Interval'] = $request->interval;
        }

        if (null !== $request->operationBase) {
            @$query['OperationBase'] = $request->operationBase;
        }

        if (null !== $request->upgradeVersion) {
            @$query['UpgradeVersion'] = $request->upgradeVersion;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddPublishBatch',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddPublishBatchResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Upgrades the Security Center agent in batches.
     *
     * @param request - AddPublishBatchRequest
     *
     * @returns AddPublishBatchResponse
     *
     * @param AddPublishBatchRequest $request
     *
     * @return AddPublishBatchResponse
     */
    public function addPublishBatch($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addPublishBatchWithOptions($request, $runtime);
    }

    /**
     * Creates a rule for container tamper-proofing.
     *
     * @param request - AddSasContainerWebDefenseRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddSasContainerWebDefenseRuleResponse
     *
     * @param AddSasContainerWebDefenseRuleRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return AddSasContainerWebDefenseRuleResponse
     */
    public function addSasContainerWebDefenseRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->pathConfDTOList) {
            @$query['PathConfDTOList'] = $request->pathConfDTOList;
        }

        if (null !== $request->ruleName) {
            @$query['RuleName'] = $request->ruleName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddSasContainerWebDefenseRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddSasContainerWebDefenseRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a rule for container tamper-proofing.
     *
     * @param request - AddSasContainerWebDefenseRuleRequest
     *
     * @returns AddSasContainerWebDefenseRuleResponse
     *
     * @param AddSasContainerWebDefenseRuleRequest $request
     *
     * @return AddSasContainerWebDefenseRuleResponse
     */
    public function addSasContainerWebDefenseRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addSasContainerWebDefenseRuleWithOptions($request, $runtime);
    }

    /**
     * Enables the trial use of Security Center value-added features, including vulnerability fixing and threat analysis and response.
     *
     * @param request - AddSasModuleTrialRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddSasModuleTrialResponse
     *
     * @param AddSasModuleTrialRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return AddSasModuleTrialResponse
     */
    public function addSasModuleTrialWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->moduleCode) {
            @$query['ModuleCode'] = $request->moduleCode;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddSasModuleTrial',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddSasModuleTrialResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables the trial use of Security Center value-added features, including vulnerability fixing and threat analysis and response.
     *
     * @param request - AddSasModuleTrialRequest
     *
     * @returns AddSasModuleTrialResponse
     *
     * @param AddSasModuleTrialRequest $request
     *
     * @return AddSasModuleTrialResponse
     */
    public function addSasModuleTrial($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addSasModuleTrialWithOptions($request, $runtime);
    }

    /**
     * Adds a tag to assets.
     *
     * @remarks
     * Security Center provides asset importance tags and custom tags. You can call the AddTagWithUuid operation to add only a custom tag to assets.
     *
     * @param request - AddTagWithUuidRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddTagWithUuidResponse
     *
     * @param AddTagWithUuidRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return AddTagWithUuidResponse
     */
    public function addTagWithUuidWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->tagName) {
            @$query['TagName'] = $request->tagName;
        }

        if (null !== $request->uuidList) {
            @$query['UuidList'] = $request->uuidList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddTagWithUuid',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddTagWithUuidResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds a tag to assets.
     *
     * @remarks
     * Security Center provides asset importance tags and custom tags. You can call the AddTagWithUuid operation to add only a custom tag to assets.
     *
     * @param request - AddTagWithUuidRequest
     *
     * @returns AddTagWithUuidResponse
     *
     * @param AddTagWithUuidRequest $request
     *
     * @return AddTagWithUuidResponse
     */
    public function addTagWithUuid($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addTagWithUuidWithOptions($request, $runtime);
    }

    /**
     * Adds servers from which you want to uninstall the Security Center agent.
     *
     * @param request - AddUninstallClientsByUuidsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddUninstallClientsByUuidsResponse
     *
     * @param AddUninstallClientsByUuidsRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return AddUninstallClientsByUuidsResponse
     */
    public function addUninstallClientsByUuidsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->callMethod) {
            @$query['CallMethod'] = $request->callMethod;
        }

        if (null !== $request->feedback) {
            @$query['Feedback'] = $request->feedback;
        }

        if (null !== $request->region) {
            @$query['Region'] = $request->region;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddUninstallClientsByUuids',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddUninstallClientsByUuidsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds servers from which you want to uninstall the Security Center agent.
     *
     * @param request - AddUninstallClientsByUuidsRequest
     *
     * @returns AddUninstallClientsByUuidsResponse
     *
     * @param AddUninstallClientsByUuidsRequest $request
     *
     * @return AddUninstallClientsByUuidsResponse
     */
    public function addUninstallClientsByUuids($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addUninstallClientsByUuidsWithOptions($request, $runtime);
    }

    /**
     * Creates a honeypot.
     *
     * @param request - AddVpcHoneyPotRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddVpcHoneyPotResponse
     *
     * @param AddVpcHoneyPotRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return AddVpcHoneyPotResponse
     */
    public function addVpcHoneyPotWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddVpcHoneyPot',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddVpcHoneyPotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a honeypot.
     *
     * @param request - AddVpcHoneyPotRequest
     *
     * @returns AddVpcHoneyPotResponse
     *
     * @param AddVpcHoneyPotRequest $request
     *
     * @return AddVpcHoneyPotResponse
     */
    public function addVpcHoneyPot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addVpcHoneyPotWithOptions($request, $runtime);
    }

    /**
     * Queries the configurations of an advanced whitelist rule.
     *
     * @param request - AdvanceSecurityEventOperationsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AdvanceSecurityEventOperationsResponse
     *
     * @param AdvanceSecurityEventOperationsRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return AdvanceSecurityEventOperationsResponse
     */
    public function advanceSecurityEventOperationsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->eventName) {
            @$query['EventName'] = $request->eventName;
        }

        if (null !== $request->eventType) {
            @$query['EventType'] = $request->eventType;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->ruleId) {
            @$query['RuleId'] = $request->ruleId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AdvanceSecurityEventOperations',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AdvanceSecurityEventOperationsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configurations of an advanced whitelist rule.
     *
     * @param request - AdvanceSecurityEventOperationsRequest
     *
     * @returns AdvanceSecurityEventOperationsResponse
     *
     * @param AdvanceSecurityEventOperationsRequest $request
     *
     * @return AdvanceSecurityEventOperationsResponse
     */
    public function advanceSecurityEventOperations($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->advanceSecurityEventOperationsWithOptions($request, $runtime);
    }

    /**
     * Adds alert description in batches.
     *
     * @param request - BatchCreateMaliciousNoteRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns BatchCreateMaliciousNoteResponse
     *
     * @param BatchCreateMaliciousNoteRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return BatchCreateMaliciousNoteResponse
     */
    public function batchCreateMaliciousNoteWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->imageMaliciousFileList) {
            @$query['ImageMaliciousFileList'] = $request->imageMaliciousFileList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'BatchCreateMaliciousNote',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return BatchCreateMaliciousNoteResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds alert description in batches.
     *
     * @param request - BatchCreateMaliciousNoteRequest
     *
     * @returns BatchCreateMaliciousNoteResponse
     *
     * @param BatchCreateMaliciousNoteRequest $request
     *
     * @return BatchCreateMaliciousNoteResponse
     */
    public function batchCreateMaliciousNote($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->batchCreateMaliciousNoteWithOptions($request, $runtime);
    }

    /**
     * Deletes whitelist rules for alerts generated for sensitive files that are detected by using the agentless detection feature in batches.
     *
     * @param request - BatchDeleteMaliciousFileWhitelistConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns BatchDeleteMaliciousFileWhitelistConfigResponse
     *
     * @param BatchDeleteMaliciousFileWhitelistConfigRequest $request
     * @param RuntimeOptions                                 $runtime
     *
     * @return BatchDeleteMaliciousFileWhitelistConfigResponse
     */
    public function batchDeleteMaliciousFileWhitelistConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->configIdList) {
            @$query['ConfigIdList'] = $request->configIdList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'BatchDeleteMaliciousFileWhitelistConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return BatchDeleteMaliciousFileWhitelistConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes whitelist rules for alerts generated for sensitive files that are detected by using the agentless detection feature in batches.
     *
     * @param request - BatchDeleteMaliciousFileWhitelistConfigRequest
     *
     * @returns BatchDeleteMaliciousFileWhitelistConfigResponse
     *
     * @param BatchDeleteMaliciousFileWhitelistConfigRequest $request
     *
     * @return BatchDeleteMaliciousFileWhitelistConfigResponse
     */
    public function batchDeleteMaliciousFileWhitelistConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->batchDeleteMaliciousFileWhitelistConfigWithOptions($request, $runtime);
    }

    /**
     * Enables or disables multiple features in proactive defense at a time.
     *
     * @param request - BatchOperateCommonOverallConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns BatchOperateCommonOverallConfigResponse
     *
     * @param BatchOperateCommonOverallConfigRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return BatchOperateCommonOverallConfigResponse
     */
    public function batchOperateCommonOverallConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->config) {
            @$query['Config'] = $request->config;
        }

        if (null !== $request->typeList) {
            @$query['TypeList'] = $request->typeList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'BatchOperateCommonOverallConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return BatchOperateCommonOverallConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables or disables multiple features in proactive defense at a time.
     *
     * @param request - BatchOperateCommonOverallConfigRequest
     *
     * @returns BatchOperateCommonOverallConfigResponse
     *
     * @param BatchOperateCommonOverallConfigRequest $request
     *
     * @return BatchOperateCommonOverallConfigResponse
     */
    public function batchOperateCommonOverallConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->batchOperateCommonOverallConfigWithOptions($request, $runtime);
    }

    /**
     * Modifies multiple alert whitelist rules of sensitive files that are detected by using the agentless detection feature at a time.
     *
     * @param request - BatchUpdateMaliciousFileWhitelistConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns BatchUpdateMaliciousFileWhitelistConfigResponse
     *
     * @param BatchUpdateMaliciousFileWhitelistConfigRequest $request
     * @param RuntimeOptions                                 $runtime
     *
     * @return BatchUpdateMaliciousFileWhitelistConfigResponse
     */
    public function batchUpdateMaliciousFileWhitelistConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->configList) {
            @$query['ConfigList'] = $request->configList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'BatchUpdateMaliciousFileWhitelistConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return BatchUpdateMaliciousFileWhitelistConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies multiple alert whitelist rules of sensitive files that are detected by using the agentless detection feature at a time.
     *
     * @param request - BatchUpdateMaliciousFileWhitelistConfigRequest
     *
     * @returns BatchUpdateMaliciousFileWhitelistConfigResponse
     *
     * @param BatchUpdateMaliciousFileWhitelistConfigRequest $request
     *
     * @return BatchUpdateMaliciousFileWhitelistConfigResponse
     */
    public function batchUpdateMaliciousFileWhitelistConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->batchUpdateMaliciousFileWhitelistConfigWithOptions($request, $runtime);
    }

    /**
     * Binds servers to Security Center or unbinds servers from Security Center.
     *
     * @param request - BindAuthToMachineRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns BindAuthToMachineResponse
     *
     * @param BindAuthToMachineRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return BindAuthToMachineResponse
     */
    public function bindAuthToMachineWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->authVersion) {
            @$query['AuthVersion'] = $request->authVersion;
        }

        if (null !== $request->autoBind) {
            @$query['AutoBind'] = $request->autoBind;
        }

        if (null !== $request->bind) {
            @$query['Bind'] = $request->bind;
        }

        if (null !== $request->bindAll) {
            @$query['BindAll'] = $request->bindAll;
        }

        if (null !== $request->criteria) {
            @$query['Criteria'] = $request->criteria;
        }

        if (null !== $request->isPreBind) {
            @$query['IsPreBind'] = $request->isPreBind;
        }

        if (null !== $request->logicalExp) {
            @$query['LogicalExp'] = $request->logicalExp;
        }

        if (null !== $request->ntmVersion) {
            @$query['NtmVersion'] = $request->ntmVersion;
        }

        if (null !== $request->preBindOrderId) {
            @$query['PreBindOrderId'] = $request->preBindOrderId;
        }

        if (null !== $request->unBind) {
            @$query['UnBind'] = $request->unBind;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'BindAuthToMachine',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return BindAuthToMachineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Binds servers to Security Center or unbinds servers from Security Center.
     *
     * @param request - BindAuthToMachineRequest
     *
     * @returns BindAuthToMachineResponse
     *
     * @param BindAuthToMachineRequest $request
     *
     * @return BindAuthToMachineResponse
     */
    public function bindAuthToMachine($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->bindAuthToMachineWithOptions($request, $runtime);
    }

    /**
     * Adds servers to Security Center over a proxy server. After you create a proxy cluster and deploy a proxy server, you can connect a server to the proxy cluster as a client. This way, the server is added to Security Center over the proxy server and is protected.
     *
     * @param request - BindHybridProxyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns BindHybridProxyResponse
     *
     * @param BindHybridProxyRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return BindHybridProxyResponse
     */
    public function bindHybridProxyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterName) {
            @$query['ClusterName'] = $request->clusterName;
        }

        if (null !== $request->yundunUuids) {
            @$query['YundunUuids'] = $request->yundunUuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'BindHybridProxy',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return BindHybridProxyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds servers to Security Center over a proxy server. After you create a proxy cluster and deploy a proxy server, you can connect a server to the proxy cluster as a client. This way, the server is added to Security Center over the proxy server and is protected.
     *
     * @param request - BindHybridProxyRequest
     *
     * @returns BindHybridProxyResponse
     *
     * @param BindHybridProxyRequest $request
     *
     * @return BindHybridProxyResponse
     */
    public function bindHybridProxy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->bindHybridProxyWithOptions($request, $runtime);
    }

    /**
     * Cancels the main task.
     *
     * @param request - CancelOnceTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CancelOnceTaskResponse
     *
     * @param CancelOnceTaskRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return CancelOnceTaskResponse
     */
    public function cancelOnceTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CancelOnceTask',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CancelOnceTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Cancels the main task.
     *
     * @param request - CancelOnceTaskRequest
     *
     * @returns CancelOnceTaskResponse
     *
     * @param CancelOnceTaskRequest $request
     *
     * @return CancelOnceTaskResponse
     */
    public function cancelOnceTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->cancelOnceTaskWithOptions($request, $runtime);
    }

    /**
     * Modifies the interval of asset synchronization configurations.
     *
     * @param request - ChangeAssetRefreshTaskConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ChangeAssetRefreshTaskConfigResponse
     *
     * @param ChangeAssetRefreshTaskConfigRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return ChangeAssetRefreshTaskConfigResponse
     */
    public function changeAssetRefreshTaskConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->assetRefreshConfigs) {
            @$query['AssetRefreshConfigs'] = $request->assetRefreshConfigs;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ChangeAssetRefreshTaskConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ChangeAssetRefreshTaskConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the interval of asset synchronization configurations.
     *
     * @param request - ChangeAssetRefreshTaskConfigRequest
     *
     * @returns ChangeAssetRefreshTaskConfigResponse
     *
     * @param ChangeAssetRefreshTaskConfigRequest $request
     *
     * @return ChangeAssetRefreshTaskConfigResponse
     */
    public function changeAssetRefreshTaskConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->changeAssetRefreshTaskConfigWithOptions($request, $runtime);
    }

    /**
     * Modifies the configuration items of the configuration assessment feature.
     *
     * @param tmpReq - ChangeCheckConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ChangeCheckConfigResponse
     *
     * @param ChangeCheckConfigRequest $tmpReq
     * @param RuntimeOptions           $runtime
     *
     * @return ChangeCheckConfigResponse
     */
    public function changeCheckConfigWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new ChangeCheckConfigShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->configRequirementIds) {
            $request->configRequirementIdsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->configRequirementIds, 'ConfigRequirementIds', 'json');
        }

        if (null !== $tmpReq->configStandardIds) {
            $request->configStandardIdsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->configStandardIds, 'ConfigStandardIds', 'json');
        }

        $query = [];
        if (null !== $request->addedCheck) {
            @$query['AddedCheck'] = $request->addedCheck;
        }

        if (null !== $request->configRequirementIdsShrink) {
            @$query['ConfigRequirementIds'] = $request->configRequirementIdsShrink;
        }

        if (null !== $request->configStandardIdsShrink) {
            @$query['ConfigStandardIds'] = $request->configStandardIdsShrink;
        }

        if (null !== $request->configure) {
            @$query['Configure'] = $request->configure;
        }

        if (null !== $request->cycleDays) {
            @$query['CycleDays'] = $request->cycleDays;
        }

        if (null !== $request->enableAddCheck) {
            @$query['EnableAddCheck'] = $request->enableAddCheck;
        }

        if (null !== $request->enableAutoCheck) {
            @$query['EnableAutoCheck'] = $request->enableAutoCheck;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->removedCheck) {
            @$query['RemovedCheck'] = $request->removedCheck;
        }

        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        if (null !== $request->standardIds) {
            @$query['StandardIds'] = $request->standardIds;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->systemConfig) {
            @$query['SystemConfig'] = $request->systemConfig;
        }

        if (null !== $request->vendors) {
            @$query['Vendors'] = $request->vendors;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ChangeCheckConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ChangeCheckConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configuration items of the configuration assessment feature.
     *
     * @param request - ChangeCheckConfigRequest
     *
     * @returns ChangeCheckConfigResponse
     *
     * @param ChangeCheckConfigRequest $request
     *
     * @return ChangeCheckConfigResponse
     */
    public function changeCheckConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->changeCheckConfigWithOptions($request, $runtime);
    }

    /**
     * Modifies the custom configuration items of a check item.
     *
     * @param request - ChangeCheckCustomConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ChangeCheckCustomConfigResponse
     *
     * @param ChangeCheckCustomConfigRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ChangeCheckCustomConfigResponse
     */
    public function changeCheckCustomConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->checkId) {
            @$query['CheckId'] = $request->checkId;
        }

        if (null !== $request->customConfigs) {
            @$query['CustomConfigs'] = $request->customConfigs;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->repairConfigs) {
            @$query['RepairConfigs'] = $request->repairConfigs;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ChangeCheckCustomConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ChangeCheckCustomConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the custom configuration items of a check item.
     *
     * @param request - ChangeCheckCustomConfigRequest
     *
     * @returns ChangeCheckCustomConfigResponse
     *
     * @param ChangeCheckCustomConfigRequest $request
     *
     * @return ChangeCheckCustomConfigResponse
     */
    public function changeCheckCustomConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->changeCheckCustomConfigWithOptions($request, $runtime);
    }

    /**
     * Modifies the details of the deduction modules of the security score feature, including custom settings.
     *
     * @param request - ChangeSecurityScoreRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ChangeSecurityScoreRuleResponse
     *
     * @param ChangeSecurityScoreRuleRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ChangeSecurityScoreRuleResponse
     */
    public function changeSecurityScoreRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->calType) {
            @$query['CalType'] = $request->calType;
        }

        if (null !== $request->resetSecurityScoreRule) {
            @$query['ResetSecurityScoreRule'] = $request->resetSecurityScoreRule;
        }

        if (null !== $request->securityScoreCategoryList) {
            @$query['SecurityScoreCategoryList'] = $request->securityScoreCategoryList;
        }

        if (null !== $request->securityScoreRuleList) {
            @$query['SecurityScoreRuleList'] = $request->securityScoreRuleList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ChangeSecurityScoreRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ChangeSecurityScoreRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the details of the deduction modules of the security score feature, including custom settings.
     *
     * @param request - ChangeSecurityScoreRuleRequest
     *
     * @returns ChangeSecurityScoreRuleResponse
     *
     * @param ChangeSecurityScoreRuleRequest $request
     *
     * @return ChangeSecurityScoreRuleResponse
     */
    public function changeSecurityScoreRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->changeSecurityScoreRuleWithOptions($request, $runtime);
    }

    /**
     * Modifies the language settings of log analysis. The modification on the language settings takes effect within 12 hours and affects only the language of the descriptions for security events in security logs.
     *
     * @param request - ChangeUserLangRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ChangeUserLangResponse
     *
     * @param ChangeUserLangRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return ChangeUserLangResponse
     */
    public function changeUserLangWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->userLang) {
            @$query['UserLang'] = $request->userLang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ChangeUserLang',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ChangeUserLangResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the language settings of log analysis. The modification on the language settings takes effect within 12 hours and affects only the language of the descriptions for security events in security logs.
     *
     * @param request - ChangeUserLangRequest
     *
     * @returns ChangeUserLangResponse
     *
     * @param ChangeUserLangRequest $request
     *
     * @return ChangeUserLangResponse
     */
    public function changeUserLang($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->changeUserLangWithOptions($request, $runtime);
    }

    /**
     * Checks whether one or more alert events are generated on a specified server based on the IDs of the alert events.
     *
     * @param request - CheckSecurityEventIdRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CheckSecurityEventIdResponse
     *
     * @param CheckSecurityEventIdRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return CheckSecurityEventIdResponse
     */
    public function checkSecurityEventIdWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->securityEventIds) {
            @$query['SecurityEventIds'] = $request->securityEventIds;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CheckSecurityEventId',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CheckSecurityEventIdResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Checks whether one or more alert events are generated on a specified server based on the IDs of the alert events.
     *
     * @param request - CheckSecurityEventIdRequest
     *
     * @returns CheckSecurityEventIdResponse
     *
     * @param CheckSecurityEventIdRequest $request
     *
     * @return CheckSecurityEventIdResponse
     */
    public function checkSecurityEventId($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkSecurityEventIdWithOptions($request, $runtime);
    }

    /**
     * Checks a Security Token Service (STS) token and returns the ID of the Alibaba Cloud account.
     *
     * @param request - CheckStsTokenAuthRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CheckStsTokenAuthResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return CheckStsTokenAuthResponse
     */
    public function checkStsTokenAuthWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'CheckStsTokenAuth',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CheckStsTokenAuthResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Checks a Security Token Service (STS) token and returns the ID of the Alibaba Cloud account.
     *
     * @returns CheckStsTokenAuthResponse
     *
     * @return CheckStsTokenAuthResponse
     */
    public function checkStsTokenAuth()
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkStsTokenAuthWithOptions($runtime);
    }

    /**
     * Checks whether the remaining quota of the vulnerability fixing feature is sufficient for a free trial user of Security Center and queries the quota usage required for the current fix operation.
     *
     * @remarks
     * You can call this operation to check whether the remaining quota of the vulnerability fixing feature is sufficient in free trial scenarios. This operation does not trigger vulnerability fixing.
     *
     * @param request - CheckTrialFixCountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CheckTrialFixCountResponse
     *
     * @param CheckTrialFixCountRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return CheckTrialFixCountResponse
     */
    public function checkTrialFixCountWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->info) {
            @$query['Info'] = $request->info;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        if (null !== $request->vulNames) {
            @$query['VulNames'] = $request->vulNames;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CheckTrialFixCount',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CheckTrialFixCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Checks whether the remaining quota of the vulnerability fixing feature is sufficient for a free trial user of Security Center and queries the quota usage required for the current fix operation.
     *
     * @remarks
     * You can call this operation to check whether the remaining quota of the vulnerability fixing feature is sufficient in free trial scenarios. This operation does not trigger vulnerability fixing.
     *
     * @param request - CheckTrialFixCountRequest
     *
     * @returns CheckTrialFixCountResponse
     *
     * @param CheckTrialFixCountRequest $request
     *
     * @return CheckTrialFixCountResponse
     */
    public function checkTrialFixCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkTrialFixCountWithOptions($request, $runtime);
    }

    /**
     * Checks whether Elastic Compute Service (ECS) instances exist.
     *
     * @param request - CheckUserHasEcsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CheckUserHasEcsResponse
     *
     * @param CheckUserHasEcsRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return CheckUserHasEcsResponse
     */
    public function checkUserHasEcsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CheckUserHasEcs',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CheckUserHasEcsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Checks whether Elastic Compute Service (ECS) instances exist.
     *
     * @param request - CheckUserHasEcsRequest
     *
     * @returns CheckUserHasEcsResponse
     *
     * @param CheckUserHasEcsRequest $request
     *
     * @return CheckUserHasEcsResponse
     */
    public function checkUserHasEcs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkUserHasEcsWithOptions($request, $runtime);
    }

    /**
     * Confirms the alert events that you want to handle.
     *
     * @param request - ConfirmVirusEventsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ConfirmVirusEventsResponse
     *
     * @param ConfirmVirusEventsRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return ConfirmVirusEventsResponse
     */
    public function confirmVirusEventsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->operationAll) {
            @$query['OperationAll'] = $request->operationAll;
        }

        if (null !== $request->operationCode) {
            @$query['OperationCode'] = $request->operationCode;
        }

        if (null !== $request->operationRange) {
            @$query['OperationRange'] = $request->operationRange;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ConfirmVirusEvents',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ConfirmVirusEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Confirms the alert events that you want to handle.
     *
     * @param request - ConfirmVirusEventsRequest
     *
     * @returns ConfirmVirusEventsResponse
     *
     * @param ConfirmVirusEventsRequest $request
     *
     * @return ConfirmVirusEventsResponse
     */
    public function confirmVirusEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->confirmVirusEventsWithOptions($request, $runtime);
    }

    /**
     * Clones an existing security report. The new security report has the same configuration as the existing security report.
     *
     * @param request - CopyCustomizeReportConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CopyCustomizeReportConfigResponse
     *
     * @param CopyCustomizeReportConfigRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return CopyCustomizeReportConfigResponse
     */
    public function copyCustomizeReportConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->reportId) {
            @$query['ReportId'] = $request->reportId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CopyCustomizeReportConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CopyCustomizeReportConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Clones an existing security report. The new security report has the same configuration as the existing security report.
     *
     * @param request - CopyCustomizeReportConfigRequest
     *
     * @returns CopyCustomizeReportConfigResponse
     *
     * @param CopyCustomizeReportConfigRequest $request
     *
     * @return CopyCustomizeReportConfigResponse
     */
    public function copyCustomizeReportConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->copyCustomizeReportConfigWithOptions($request, $runtime);
    }

    /**
     * Creates an agentless detection task.
     *
     * @param request - CreateAgentlessScanTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateAgentlessScanTaskResponse
     *
     * @param CreateAgentlessScanTaskRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return CreateAgentlessScanTaskResponse
     */
    public function createAgentlessScanTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->assetSelectionType) {
            @$query['AssetSelectionType'] = $request->assetSelectionType;
        }

        if (null !== $request->autoDeleteDays) {
            @$query['AutoDeleteDays'] = $request->autoDeleteDays;
        }

        if (null !== $request->releaseAfterScan) {
            @$query['ReleaseAfterScan'] = $request->releaseAfterScan;
        }

        if (null !== $request->scanDataDisk) {
            @$query['ScanDataDisk'] = $request->scanDataDisk;
        }

        if (null !== $request->targetType) {
            @$query['TargetType'] = $request->targetType;
        }

        if (null !== $request->uuidList) {
            @$query['UuidList'] = $request->uuidList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateAgentlessScanTask',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateAgentlessScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an agentless detection task.
     *
     * @param request - CreateAgentlessScanTaskRequest
     *
     * @returns CreateAgentlessScanTaskResponse
     *
     * @param CreateAgentlessScanTaskRequest $request
     *
     * @return CreateAgentlessScanTaskResponse
     */
    public function createAgentlessScanTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createAgentlessScanTaskWithOptions($request, $runtime);
    }

    /**
     * Creates a defense rule against brute-force attacks.
     *
     * @param tmpReq - CreateAntiBruteForceRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateAntiBruteForceRuleResponse
     *
     * @param CreateAntiBruteForceRuleRequest $tmpReq
     * @param RuntimeOptions                  $runtime
     *
     * @return CreateAntiBruteForceRuleResponse
     */
    public function createAntiBruteForceRuleWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new CreateAntiBruteForceRuleShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->protocolType) {
            $request->protocolTypeShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->protocolType, 'ProtocolType', 'json');
        }

        $query = [];
        if (null !== $request->defaultRule) {
            @$query['DefaultRule'] = $request->defaultRule;
        }

        if (null !== $request->failCount) {
            @$query['FailCount'] = $request->failCount;
        }

        if (null !== $request->forbiddenTime) {
            @$query['ForbiddenTime'] = $request->forbiddenTime;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->protocolTypeShrink) {
            @$query['ProtocolType'] = $request->protocolTypeShrink;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->span) {
            @$query['Span'] = $request->span;
        }

        if (null !== $request->uuidList) {
            @$query['UuidList'] = $request->uuidList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateAntiBruteForceRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateAntiBruteForceRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a defense rule against brute-force attacks.
     *
     * @param request - CreateAntiBruteForceRuleRequest
     *
     * @returns CreateAntiBruteForceRuleResponse
     *
     * @param CreateAntiBruteForceRuleRequest $request
     *
     * @return CreateAntiBruteForceRuleResponse
     */
    public function createAntiBruteForceRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createAntiBruteForceRuleWithOptions($request, $runtime);
    }

    /**
     * Create asset selection configurations.
     *
     * @param request - CreateAssetSelectionConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateAssetSelectionConfigResponse
     *
     * @param CreateAssetSelectionConfigRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return CreateAssetSelectionConfigResponse
     */
    public function createAssetSelectionConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->businessType) {
            @$query['BusinessType'] = $request->businessType;
        }

        if (null !== $request->platform) {
            @$query['Platform'] = $request->platform;
        }

        if (null !== $request->targetType) {
            @$query['TargetType'] = $request->targetType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateAssetSelectionConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateAssetSelectionConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Create asset selection configurations.
     *
     * @param request - CreateAssetSelectionConfigRequest
     *
     * @returns CreateAssetSelectionConfigResponse
     *
     * @param CreateAssetSelectionConfigRequest $request
     *
     * @return CreateAssetSelectionConfigResponse
     */
    public function createAssetSelectionConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createAssetSelectionConfigWithOptions($request, $runtime);
    }

    /**
     * Create attack path sensitive asset configuration.
     *
     * @param request - CreateAttackPathSensitiveAssetConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateAttackPathSensitiveAssetConfigResponse
     *
     * @param CreateAttackPathSensitiveAssetConfigRequest $request
     * @param RuntimeOptions                              $runtime
     *
     * @return CreateAttackPathSensitiveAssetConfigResponse
     */
    public function createAttackPathSensitiveAssetConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->attackPathAssetList) {
            @$query['AttackPathAssetList'] = $request->attackPathAssetList;
        }

        if (null !== $request->configType) {
            @$query['ConfigType'] = $request->configType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateAttackPathSensitiveAssetConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateAttackPathSensitiveAssetConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Create attack path sensitive asset configuration.
     *
     * @param request - CreateAttackPathSensitiveAssetConfigRequest
     *
     * @returns CreateAttackPathSensitiveAssetConfigResponse
     *
     * @param CreateAttackPathSensitiveAssetConfigRequest $request
     *
     * @return CreateAttackPathSensitiveAssetConfigResponse
     */
    public function createAttackPathSensitiveAssetConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createAttackPathSensitiveAssetConfigWithOptions($request, $runtime);
    }

    /**
     * Create Attack Path Whitelist.
     *
     * @param request - CreateAttackPathWhitelistRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateAttackPathWhitelistResponse
     *
     * @param CreateAttackPathWhitelistRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return CreateAttackPathWhitelistResponse
     */
    public function createAttackPathWhitelistWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->attackPathAssetList) {
            @$query['AttackPathAssetList'] = $request->attackPathAssetList;
        }

        if (null !== $request->pathName) {
            @$query['PathName'] = $request->pathName;
        }

        if (null !== $request->pathType) {
            @$query['PathType'] = $request->pathType;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->whitelistName) {
            @$query['WhitelistName'] = $request->whitelistName;
        }

        if (null !== $request->whitelistType) {
            @$query['WhitelistType'] = $request->whitelistType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateAttackPathWhitelist',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateAttackPathWhitelistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Create Attack Path Whitelist.
     *
     * @param request - CreateAttackPathWhitelistRequest
     *
     * @returns CreateAttackPathWhitelistResponse
     *
     * @param CreateAttackPathWhitelistRequest $request
     *
     * @return CreateAttackPathWhitelistResponse
     */
    public function createAttackPathWhitelist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createAttackPathWhitelistWithOptions($request, $runtime);
    }

    /**
     * Creates a witness.
     *
     * @param request - CreateAttestorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateAttestorResponse
     *
     * @param CreateAttestorRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return CreateAttestorResponse
     */
    public function createAttestorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->keyId) {
            @$query['KeyId'] = $request->keyId;
        }

        if (null !== $request->keyRegionId) {
            @$query['KeyRegionId'] = $request->keyRegionId;
        }

        if (null !== $request->keyVersionId) {
            @$query['KeyVersionId'] = $request->keyVersionId;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateAttestor',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateAttestorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a witness.
     *
     * @param request - CreateAttestorRequest
     *
     * @returns CreateAttestorResponse
     *
     * @param CreateAttestorRequest $request
     *
     * @return CreateAttestorResponse
     */
    public function createAttestor($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createAttestorWithOptions($request, $runtime);
    }

    /**
     * Creates an anti-ransomware policy for servers.
     *
     * @param tmpReq - CreateBackupPolicyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateBackupPolicyResponse
     *
     * @param CreateBackupPolicyRequest $tmpReq
     * @param RuntimeOptions            $runtime
     *
     * @return CreateBackupPolicyResponse
     */
    public function createBackupPolicyWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new CreateBackupPolicyShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->policy) {
            $request->policyShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->policy, 'Policy', 'json');
        }

        $query = [];
        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->policyShrink) {
            @$query['Policy'] = $request->policyShrink;
        }

        if (null !== $request->policyRegionId) {
            @$query['PolicyRegionId'] = $request->policyRegionId;
        }

        if (null !== $request->policyVersion) {
            @$query['PolicyVersion'] = $request->policyVersion;
        }

        if (null !== $request->uuidList) {
            @$query['UuidList'] = $request->uuidList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateBackupPolicy',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateBackupPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an anti-ransomware policy for servers.
     *
     * @param request - CreateBackupPolicyRequest
     *
     * @returns CreateBackupPolicyResponse
     *
     * @param CreateBackupPolicyRequest $request
     *
     * @return CreateBackupPolicyResponse
     */
    public function createBackupPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createBackupPolicyWithOptions($request, $runtime);
    }

    /**
     * Queries the parameters that are required to upload a file for detection.
     *
     * @param request - CreateBatchUploadUrlRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateBatchUploadUrlResponse
     *
     * @param CreateBatchUploadUrlRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return CreateBatchUploadUrlResponse
     */
    public function createBatchUploadUrlWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->md5List) {
            @$query['Md5List'] = $request->md5List;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateBatchUploadUrl',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateBatchUploadUrlResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the parameters that are required to upload a file for detection.
     *
     * @param request - CreateBatchUploadUrlRequest
     *
     * @returns CreateBatchUploadUrlResponse
     *
     * @param CreateBatchUploadUrlRequest $request
     *
     * @return CreateBatchUploadUrlResponse
     */
    public function createBatchUploadUrl($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createBatchUploadUrlWithOptions($request, $runtime);
    }

    /**
     * Creates a binary security policy.
     *
     * @param request - CreateBinarySecurityPolicyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateBinarySecurityPolicyResponse
     *
     * @param CreateBinarySecurityPolicyRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return CreateBinarySecurityPolicyResponse
     */
    public function createBinarySecurityPolicyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusters) {
            @$query['Clusters'] = $request->clusters;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->policy) {
            @$query['Policy'] = $request->policy;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateBinarySecurityPolicy',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateBinarySecurityPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a binary security policy.
     *
     * @param request - CreateBinarySecurityPolicyRequest
     *
     * @returns CreateBinarySecurityPolicyResponse
     *
     * @param CreateBinarySecurityPolicyRequest $request
     *
     * @return CreateBinarySecurityPolicyResponse
     */
    public function createBinarySecurityPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createBinarySecurityPolicyWithOptions($request, $runtime);
    }

    /**
     * User creates a custom check item.
     *
     * @param tmpReq - CreateCheckItemRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateCheckItemResponse
     *
     * @param CreateCheckItemRequest $tmpReq
     * @param RuntimeOptions         $runtime
     *
     * @return CreateCheckItemResponse
     */
    public function createCheckItemWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new CreateCheckItemShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->assistInfo) {
            $request->assistInfoShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->assistInfo, 'AssistInfo', 'json');
        }

        if (null !== $tmpReq->description) {
            $request->descriptionShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->description, 'Description', 'json');
        }

        if (null !== $tmpReq->solution) {
            $request->solutionShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->solution, 'Solution', 'json');
        }

        $query = [];
        if (null !== $request->assistInfoShrink) {
            @$query['AssistInfo'] = $request->assistInfoShrink;
        }

        if (null !== $request->checkRule) {
            @$query['CheckRule'] = $request->checkRule;
        }

        if (null !== $request->checkShowName) {
            @$query['CheckShowName'] = $request->checkShowName;
        }

        if (null !== $request->descriptionShrink) {
            @$query['Description'] = $request->descriptionShrink;
        }

        if (null !== $request->instanceSubType) {
            @$query['InstanceSubType'] = $request->instanceSubType;
        }

        if (null !== $request->instanceType) {
            @$query['InstanceType'] = $request->instanceType;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->riskLevel) {
            @$query['RiskLevel'] = $request->riskLevel;
        }

        if (null !== $request->sectionIds) {
            @$query['SectionIds'] = $request->sectionIds;
        }

        if (null !== $request->solutionShrink) {
            @$query['Solution'] = $request->solutionShrink;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->vendor) {
            @$query['Vendor'] = $request->vendor;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateCheckItem',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateCheckItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * User creates a custom check item.
     *
     * @param request - CreateCheckItemRequest
     *
     * @returns CreateCheckItemResponse
     *
     * @param CreateCheckItemRequest $request
     *
     * @return CreateCheckItemResponse
     */
    public function createCheckItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createCheckItemWithOptions($request, $runtime);
    }

    /**
     * Create Policy.
     *
     * @param request - CreateCheckPolicyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateCheckPolicyResponse
     *
     * @param CreateCheckPolicyRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return CreateCheckPolicyResponse
     */
    public function createCheckPolicyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dependentPolicyId) {
            @$query['DependentPolicyId'] = $request->dependentPolicyId;
        }

        if (null !== $request->policyShowName) {
            @$query['PolicyShowName'] = $request->policyShowName;
        }

        if (null !== $request->policyType) {
            @$query['PolicyType'] = $request->policyType;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateCheckPolicy',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateCheckPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Create Policy.
     *
     * @param request - CreateCheckPolicyRequest
     *
     * @returns CreateCheckPolicyResponse
     *
     * @param CreateCheckPolicyRequest $request
     *
     * @return CreateCheckPolicyResponse
     */
    public function createCheckPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createCheckPolicyWithOptions($request, $runtime);
    }

    /**
     * Creates a container scan task.
     *
     * @param request - CreateContainerScanTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateContainerScanTaskResponse
     *
     * @param CreateContainerScanTaskRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return CreateContainerScanTaskResponse
     */
    public function createContainerScanTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->containerIds) {
            @$query['ContainerIds'] = $request->containerIds;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateContainerScanTask',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateContainerScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a container scan task.
     *
     * @param request - CreateContainerScanTaskRequest
     *
     * @returns CreateContainerScanTaskResponse
     *
     * @param CreateContainerScanTaskRequest $request
     *
     * @return CreateContainerScanTaskResponse
     */
    public function createContainerScanTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createContainerScanTaskWithOptions($request, $runtime);
    }

    /**
     * Creates a scan task for a running container application based on the application name.
     *
     * @param request - CreateContainerScanTaskByAppNameRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateContainerScanTaskByAppNameResponse
     *
     * @param CreateContainerScanTaskByAppNameRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return CreateContainerScanTaskByAppNameResponse
     */
    public function createContainerScanTaskByAppNameWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appNames) {
            @$query['AppNames'] = $request->appNames;
        }

        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateContainerScanTaskByAppName',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateContainerScanTaskByAppNameResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a scan task for a running container application based on the application name.
     *
     * @param request - CreateContainerScanTaskByAppNameRequest
     *
     * @returns CreateContainerScanTaskByAppNameResponse
     *
     * @param CreateContainerScanTaskByAppNameRequest $request
     *
     * @return CreateContainerScanTaskByAppNameResponse
     */
    public function createContainerScanTaskByAppName($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createContainerScanTaskByAppNameWithOptions($request, $runtime);
    }

    /**
     * Creates an IP address blocking policy for one or more servers.
     *
     * @param request - CreateCustomBlockRecordRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateCustomBlockRecordResponse
     *
     * @param CreateCustomBlockRecordRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return CreateCustomBlockRecordResponse
     */
    public function createCustomBlockRecordWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->blockIp) {
            @$query['BlockIp'] = $request->blockIp;
        }

        if (null !== $request->bound) {
            @$query['Bound'] = $request->bound;
        }

        if (null !== $request->expireTime) {
            @$query['ExpireTime'] = $request->expireTime;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateCustomBlockRecord',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateCustomBlockRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an IP address blocking policy for one or more servers.
     *
     * @param request - CreateCustomBlockRecordRequest
     *
     * @returns CreateCustomBlockRecordResponse
     *
     * @param CreateCustomBlockRecordRequest $request
     *
     * @return CreateCustomBlockRecordResponse
     */
    public function createCustomBlockRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createCustomBlockRecordWithOptions($request, $runtime);
    }

    /**
     * Creates custom weak password rules.
     *
     * @param request - CreateCustomizedDictRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateCustomizedDictResponse
     *
     * @param CreateCustomizedDictRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return CreateCustomizedDictResponse
     */
    public function createCustomizedDictWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->override) {
            @$query['Override'] = $request->override;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateCustomizedDict',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateCustomizedDictResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates custom weak password rules.
     *
     * @param request - CreateCustomizedDictRequest
     *
     * @returns CreateCustomizedDictResponse
     *
     * @param CreateCustomizedDictRequest $request
     *
     * @return CreateCustomizedDictResponse
     */
    public function createCustomizedDict($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createCustomizedDictWithOptions($request, $runtime);
    }

    /**
     * Creates a periodic scan task. The task can be an image scan task, urgent vulnerability scan task, or virus scan task.
     *
     * @param request - CreateCycleTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateCycleTaskResponse
     *
     * @param CreateCycleTaskRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return CreateCycleTaskResponse
     */
    public function createCycleTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->enable) {
            @$query['Enable'] = $request->enable;
        }

        if (null !== $request->firstDateStr) {
            @$query['FirstDateStr'] = $request->firstDateStr;
        }

        if (null !== $request->intervalPeriod) {
            @$query['IntervalPeriod'] = $request->intervalPeriod;
        }

        if (null !== $request->param) {
            @$query['Param'] = $request->param;
        }

        if (null !== $request->periodUnit) {
            @$query['PeriodUnit'] = $request->periodUnit;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        if (null !== $request->targetEndTime) {
            @$query['TargetEndTime'] = $request->targetEndTime;
        }

        if (null !== $request->targetStartTime) {
            @$query['TargetStartTime'] = $request->targetStartTime;
        }

        if (null !== $request->taskName) {
            @$query['TaskName'] = $request->taskName;
        }

        if (null !== $request->taskType) {
            @$query['TaskType'] = $request->taskType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateCycleTask',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateCycleTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a periodic scan task. The task can be an image scan task, urgent vulnerability scan task, or virus scan task.
     *
     * @param request - CreateCycleTaskRequest
     *
     * @returns CreateCycleTaskResponse
     *
     * @param CreateCycleTaskRequest $request
     *
     * @return CreateCycleTaskResponse
     */
    public function createCycleTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createCycleTaskWithOptions($request, $runtime);
    }

    /**
     * Creates a dynamic dictionary of weak passwords.
     *
     * @deprecated openAPI CreateDynamicDict is deprecated, please use Sas::2018-12-03::CreateCustomizedDict instead
     *
     * @param request - CreateDynamicDictRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateDynamicDictResponse
     *
     * @param CreateDynamicDictRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return CreateDynamicDictResponse
     */
    public function createDynamicDictWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->override) {
            @$query['Override'] = $request->override;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateDynamicDict',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateDynamicDictResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Creates a dynamic dictionary of weak passwords.
     *
     * @deprecated openAPI CreateDynamicDict is deprecated, please use Sas::2018-12-03::CreateCustomizedDict instead
     *
     * @param request - CreateDynamicDictRequest
     *
     * @returns CreateDynamicDictResponse
     *
     * @param CreateDynamicDictRequest $request
     *
     * @return CreateDynamicDictResponse
     */
    public function createDynamicDict($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDynamicDictWithOptions($request, $runtime);
    }

    /**
     * Pushes a file to the cloud for detection.
     *
     * @remarks
     * You can call this operation to push a file to the cloud for detection. Before you call this operation, make sure that the file is uploaded. You can call the CreateFileDetectUploadUrl operation to upload the file.
     * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
     *
     * @param request - CreateFileDetectRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateFileDetectResponse
     *
     * @param CreateFileDetectRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return CreateFileDetectResponse
     */
    public function createFileDetectWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->decompress) {
            @$query['Decompress'] = $request->decompress;
        }

        if (null !== $request->decompressMaxFileCount) {
            @$query['DecompressMaxFileCount'] = $request->decompressMaxFileCount;
        }

        if (null !== $request->decompressMaxLayer) {
            @$query['DecompressMaxLayer'] = $request->decompressMaxLayer;
        }

        if (null !== $request->downloadUrl) {
            @$query['DownloadUrl'] = $request->downloadUrl;
        }

        if (null !== $request->hashKey) {
            @$query['HashKey'] = $request->hashKey;
        }

        if (null !== $request->ossKey) {
            @$query['OssKey'] = $request->ossKey;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateFileDetect',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateFileDetectResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Pushes a file to the cloud for detection.
     *
     * @remarks
     * You can call this operation to push a file to the cloud for detection. Before you call this operation, make sure that the file is uploaded. You can call the CreateFileDetectUploadUrl operation to upload the file.
     * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
     *
     * @param request - CreateFileDetectRequest
     *
     * @returns CreateFileDetectResponse
     *
     * @param CreateFileDetectRequest $request
     *
     * @return CreateFileDetectResponse
     */
    public function createFileDetect($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createFileDetectWithOptions($request, $runtime);
    }

    /**
     * Queries the parameters that are required to upload a file for detection.
     *
     * @remarks
     * You can call this operation to query the parameters that are required to upload a file for detection. If the value of the response parameter FileExist is true, the file that you want to upload for detection already exists in the cloud. In this case, you can directly push the file for detection. If the value of the response parameter FileExist is false, you must use the form upload method to upload the file to the specified Object Storage Service (OSS) bucket based on the response parameters of this operation.
     * The form upload method is provided by OSS. For more information, see [Form upload](https://help.aliyun.com/document_detail/84788.html).
     * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
     *
     * @param request - CreateFileDetectUploadUrlRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateFileDetectUploadUrlResponse
     *
     * @param CreateFileDetectUploadUrlRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return CreateFileDetectUploadUrlResponse
     */
    public function createFileDetectUploadUrlWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hashKeyContextList) {
            @$query['HashKeyContextList'] = $request->hashKeyContextList;
        }

        if (null !== $request->hashKeyList) {
            @$query['HashKeyList'] = $request->hashKeyList;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateFileDetectUploadUrl',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateFileDetectUploadUrlResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the parameters that are required to upload a file for detection.
     *
     * @remarks
     * You can call this operation to query the parameters that are required to upload a file for detection. If the value of the response parameter FileExist is true, the file that you want to upload for detection already exists in the cloud. In this case, you can directly push the file for detection. If the value of the response parameter FileExist is false, you must use the form upload method to upload the file to the specified Object Storage Service (OSS) bucket based on the response parameters of this operation.
     * The form upload method is provided by OSS. For more information, see [Form upload](https://help.aliyun.com/document_detail/84788.html).
     * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
     *
     * @param request - CreateFileDetectUploadUrlRequest
     *
     * @returns CreateFileDetectUploadUrlResponse
     *
     * @param CreateFileDetectUploadUrlRequest $request
     *
     * @return CreateFileDetectUploadUrlResponse
     */
    public function createFileDetectUploadUrl($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createFileDetectUploadUrlWithOptions($request, $runtime);
    }

    /**
     * Creates a core file monitoring rule.
     *
     * @param request - CreateFileProtectRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateFileProtectRuleResponse
     *
     * @param CreateFileProtectRuleRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return CreateFileProtectRuleResponse
     */
    public function createFileProtectRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->alertLevel) {
            @$query['AlertLevel'] = $request->alertLevel;
        }

        if (null !== $request->fileOps) {
            @$query['FileOps'] = $request->fileOps;
        }

        if (null !== $request->filePaths) {
            @$query['FilePaths'] = $request->filePaths;
        }

        if (null !== $request->platform) {
            @$query['Platform'] = $request->platform;
        }

        if (null !== $request->procPaths) {
            @$query['ProcPaths'] = $request->procPaths;
        }

        if (null !== $request->ruleAction) {
            @$query['RuleAction'] = $request->ruleAction;
        }

        if (null !== $request->ruleName) {
            @$query['RuleName'] = $request->ruleName;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->switchId) {
            @$query['SwitchId'] = $request->switchId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateFileProtectRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateFileProtectRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a core file monitoring rule.
     *
     * @param request - CreateFileProtectRuleRequest
     *
     * @returns CreateFileProtectRuleResponse
     *
     * @param CreateFileProtectRuleRequest $request
     *
     * @return CreateFileProtectRuleResponse
     */
    public function createFileProtectRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createFileProtectRuleWithOptions($request, $runtime);
    }

    /**
     * Specifies the queries per second (QPS) limit on the files uploaded from the client.
     *
     * @param request - CreateFileUploadLimitRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateFileUploadLimitResponse
     *
     * @param CreateFileUploadLimitRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return CreateFileUploadLimitResponse
     */
    public function createFileUploadLimitWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->limit) {
            @$query['Limit'] = $request->limit;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateFileUploadLimit',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateFileUploadLimitResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Specifies the queries per second (QPS) limit on the files uploaded from the client.
     *
     * @param request - CreateFileUploadLimitRequest
     *
     * @returns CreateFileUploadLimitResponse
     *
     * @param CreateFileUploadLimitRequest $request
     *
     * @return CreateFileUploadLimitResponse
     */
    public function createFileUploadLimit($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createFileUploadLimitWithOptions($request, $runtime);
    }

    /**
     * Creates a honeypot.
     *
     * @param request - CreateHoneypotRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateHoneypotResponse
     *
     * @param CreateHoneypotRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return CreateHoneypotResponse
     */
    public function createHoneypotWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->honeypotImageId) {
            @$query['HoneypotImageId'] = $request->honeypotImageId;
        }

        if (null !== $request->honeypotImageName) {
            @$query['HoneypotImageName'] = $request->honeypotImageName;
        }

        if (null !== $request->honeypotName) {
            @$query['HoneypotName'] = $request->honeypotName;
        }

        if (null !== $request->meta) {
            @$query['Meta'] = $request->meta;
        }

        if (null !== $request->nodeId) {
            @$query['NodeId'] = $request->nodeId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateHoneypot',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateHoneypotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a honeypot.
     *
     * @param request - CreateHoneypotRequest
     *
     * @returns CreateHoneypotResponse
     *
     * @param CreateHoneypotRequest $request
     *
     * @return CreateHoneypotResponse
     */
    public function createHoneypot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createHoneypotWithOptions($request, $runtime);
    }

    /**
     * Creates a management node.
     *
     * @param request - CreateHoneypotNodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateHoneypotNodeResponse
     *
     * @param CreateHoneypotNodeRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return CreateHoneypotNodeResponse
     */
    public function createHoneypotNodeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->allowHoneypotAccessInternet) {
            @$query['AllowHoneypotAccessInternet'] = $request->allowHoneypotAccessInternet;
        }

        if (null !== $request->availableProbeNum) {
            @$query['AvailableProbeNum'] = $request->availableProbeNum;
        }

        if (null !== $request->nodeName) {
            @$query['NodeName'] = $request->nodeName;
        }

        if (null !== $request->securityGroupProbeIpList) {
            @$query['SecurityGroupProbeIpList'] = $request->securityGroupProbeIpList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateHoneypotNode',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateHoneypotNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a management node.
     *
     * @param request - CreateHoneypotNodeRequest
     *
     * @returns CreateHoneypotNodeResponse
     *
     * @param CreateHoneypotNodeRequest $request
     *
     * @return CreateHoneypotNodeResponse
     */
    public function createHoneypotNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createHoneypotNodeWithOptions($request, $runtime);
    }

    /**
     * Creates a honeypot template.
     *
     * @param request - CreateHoneypotPresetRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateHoneypotPresetResponse
     *
     * @param CreateHoneypotPresetRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return CreateHoneypotPresetResponse
     */
    public function createHoneypotPresetWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->honeypotImageName) {
            @$query['HoneypotImageName'] = $request->honeypotImageName;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->meta) {
            @$query['Meta'] = $request->meta;
        }

        if (null !== $request->nodeId) {
            @$query['NodeId'] = $request->nodeId;
        }

        if (null !== $request->presetName) {
            @$query['PresetName'] = $request->presetName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateHoneypotPreset',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateHoneypotPresetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a honeypot template.
     *
     * @param request - CreateHoneypotPresetRequest
     *
     * @returns CreateHoneypotPresetResponse
     *
     * @param CreateHoneypotPresetRequest $request
     *
     * @return CreateHoneypotPresetResponse
     */
    public function createHoneypotPreset($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createHoneypotPresetWithOptions($request, $runtime);
    }

    /**
     * Creates a probe.
     *
     * @param request - CreateHoneypotProbeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateHoneypotProbeResponse
     *
     * @param CreateHoneypotProbeRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return CreateHoneypotProbeResponse
     */
    public function createHoneypotProbeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->arp) {
            @$query['Arp'] = $request->arp;
        }

        if (null !== $request->businessGroupId) {
            @$query['BusinessGroupId'] = $request->businessGroupId;
        }

        if (null !== $request->controlNodeId) {
            @$query['ControlNodeId'] = $request->controlNodeId;
        }

        if (null !== $request->displayName) {
            @$query['DisplayName'] = $request->displayName;
        }

        if (null !== $request->honeypotBindList) {
            @$query['HoneypotBindList'] = $request->honeypotBindList;
        }

        if (null !== $request->ping) {
            @$query['Ping'] = $request->ping;
        }

        if (null !== $request->probeType) {
            @$query['ProbeType'] = $request->probeType;
        }

        if (null !== $request->probeVersion) {
            @$query['ProbeVersion'] = $request->probeVersion;
        }

        if (null !== $request->proxyIp) {
            @$query['ProxyIp'] = $request->proxyIp;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateHoneypotProbe',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateHoneypotProbeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a probe.
     *
     * @param request - CreateHoneypotProbeRequest
     *
     * @returns CreateHoneypotProbeResponse
     *
     * @param CreateHoneypotProbeRequest $request
     *
     * @return CreateHoneypotProbeResponse
     */
    public function createHoneypotProbe($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createHoneypotProbeWithOptions($request, $runtime);
    }

    /**
     * Creates a monitoring or forwarding service for a probe.
     *
     * @param request - CreateHoneypotProbeBindRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateHoneypotProbeBindResponse
     *
     * @param CreateHoneypotProbeBindRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return CreateHoneypotProbeBindResponse
     */
    public function createHoneypotProbeBindWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bindPortList) {
            @$query['BindPortList'] = $request->bindPortList;
        }

        if (null !== $request->honeypotId) {
            @$query['HoneypotId'] = $request->honeypotId;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->probeId) {
            @$query['ProbeId'] = $request->probeId;
        }

        if (null !== $request->serviceIpList) {
            @$query['ServiceIpList'] = $request->serviceIpList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateHoneypotProbeBind',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateHoneypotProbeBindResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a monitoring or forwarding service for a probe.
     *
     * @param request - CreateHoneypotProbeBindRequest
     *
     * @returns CreateHoneypotProbeBindResponse
     *
     * @param CreateHoneypotProbeBindRequest $request
     *
     * @return CreateHoneypotProbeBindResponse
     */
    public function createHoneypotProbeBind($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createHoneypotProbeBindWithOptions($request, $runtime);
    }

    /**
     * Creates a hybrid-cloud proxy cluster.
     *
     * @param request - CreateHybridProxyClusterRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateHybridProxyClusterResponse
     *
     * @param CreateHybridProxyClusterRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return CreateHybridProxyClusterResponse
     */
    public function createHybridProxyClusterWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterName) {
            @$query['ClusterName'] = $request->clusterName;
        }

        if (null !== $request->ip) {
            @$query['Ip'] = $request->ip;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateHybridProxyCluster',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateHybridProxyClusterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a hybrid-cloud proxy cluster.
     *
     * @param request - CreateHybridProxyClusterRequest
     *
     * @returns CreateHybridProxyClusterResponse
     *
     * @param CreateHybridProxyClusterRequest $request
     *
     * @return CreateHybridProxyClusterResponse
     */
    public function createHybridProxyCluster($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createHybridProxyClusterWithOptions($request, $runtime);
    }

    /**
     * Creates a defense rule in the container firewall module.
     *
     * @param tmpReq - CreateInterceptionRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateInterceptionRuleResponse
     *
     * @param CreateInterceptionRuleRequest $tmpReq
     * @param RuntimeOptions                $runtime
     *
     * @return CreateInterceptionRuleResponse
     */
    public function createInterceptionRuleWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new CreateInterceptionRuleShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->dstTargetList) {
            $request->dstTargetListShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->dstTargetList, 'DstTargetList', 'json');
        }

        if (null !== $tmpReq->srcTarget) {
            $request->srcTargetShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->srcTarget, 'SrcTarget', 'json');
        }

        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->clusterName) {
            @$query['ClusterName'] = $request->clusterName;
        }

        if (null !== $request->dstTargetListShrink) {
            @$query['DstTargetList'] = $request->dstTargetListShrink;
        }

        if (null !== $request->interceptType) {
            @$query['InterceptType'] = $request->interceptType;
        }

        if (null !== $request->orderIndex) {
            @$query['OrderIndex'] = $request->orderIndex;
        }

        if (null !== $request->ruleName) {
            @$query['RuleName'] = $request->ruleName;
        }

        if (null !== $request->ruleSwitch) {
            @$query['RuleSwitch'] = $request->ruleSwitch;
        }

        if (null !== $request->ruleType) {
            @$query['RuleType'] = $request->ruleType;
        }

        if (null !== $request->srcTargetShrink) {
            @$query['SrcTarget'] = $request->srcTargetShrink;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateInterceptionRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateInterceptionRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a defense rule in the container firewall module.
     *
     * @param request - CreateInterceptionRuleRequest
     *
     * @returns CreateInterceptionRuleResponse
     *
     * @param CreateInterceptionRuleRequest $request
     *
     * @return CreateInterceptionRuleResponse
     */
    public function createInterceptionRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createInterceptionRuleWithOptions($request, $runtime);
    }

    /**
     * Creates a defense object.
     *
     * @param request - CreateInterceptionTargetRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateInterceptionTargetResponse
     *
     * @param CreateInterceptionTargetRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return CreateInterceptionTargetResponse
     */
    public function createInterceptionTargetWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->clusterName) {
            @$query['ClusterName'] = $request->clusterName;
        }

        if (null !== $request->imageList) {
            @$query['ImageList'] = $request->imageList;
        }

        if (null !== $request->namespace) {
            @$query['Namespace'] = $request->namespace;
        }

        if (null !== $request->tagList) {
            @$query['TagList'] = $request->tagList;
        }

        if (null !== $request->targetName) {
            @$query['TargetName'] = $request->targetName;
        }

        if (null !== $request->targetType) {
            @$query['TargetType'] = $request->targetType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateInterceptionTarget',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateInterceptionTargetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a defense object.
     *
     * @param request - CreateInterceptionTargetRequest
     *
     * @returns CreateInterceptionTargetResponse
     *
     * @param CreateInterceptionTargetRequest $request
     *
     * @return CreateInterceptionTargetResponse
     */
    public function createInterceptionTarget($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createInterceptionTargetWithOptions($request, $runtime);
    }

    /**
     * Creates a Jenkins image repository.
     *
     * @param request - CreateJenkinsImageRegistryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateJenkinsImageRegistryResponse
     *
     * @param CreateJenkinsImageRegistryRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return CreateJenkinsImageRegistryResponse
     */
    public function createJenkinsImageRegistryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $body = [];
        if (null !== $request->domainName) {
            @$body['DomainName'] = $request->domainName;
        }

        if (null !== $request->extraParam) {
            @$body['ExtraParam'] = $request->extraParam;
        }

        if (null !== $request->netType) {
            @$body['NetType'] = $request->netType;
        }

        if (null !== $request->password) {
            @$body['Password'] = $request->password;
        }

        if (null !== $request->persistenceDay) {
            @$body['PersistenceDay'] = $request->persistenceDay;
        }

        if (null !== $request->protocolType) {
            @$body['ProtocolType'] = $request->protocolType;
        }

        if (null !== $request->regionId) {
            @$body['RegionId'] = $request->regionId;
        }

        if (null !== $request->registryHostIp) {
            @$body['RegistryHostIp'] = $request->registryHostIp;
        }

        if (null !== $request->registryName) {
            @$body['RegistryName'] = $request->registryName;
        }

        if (null !== $request->registryType) {
            @$body['RegistryType'] = $request->registryType;
        }

        if (null !== $request->registryVersion) {
            @$body['RegistryVersion'] = $request->registryVersion;
        }

        if (null !== $request->transPerHour) {
            @$body['TransPerHour'] = $request->transPerHour;
        }

        if (null !== $request->userName) {
            @$body['UserName'] = $request->userName;
        }

        if (null !== $request->vpcId) {
            @$body['VpcId'] = $request->vpcId;
        }

        if (null !== $request->whiteList) {
            @$body['WhiteList'] = $request->whiteList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateJenkinsImageRegistry',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateJenkinsImageRegistryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a Jenkins image repository.
     *
     * @param request - CreateJenkinsImageRegistryRequest
     *
     * @returns CreateJenkinsImageRegistryResponse
     *
     * @param CreateJenkinsImageRegistryRequest $request
     *
     * @return CreateJenkinsImageRegistryResponse
     */
    public function createJenkinsImageRegistry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createJenkinsImageRegistryWithOptions($request, $runtime);
    }

    /**
     * Creates a Jenkins scan task.
     *
     * @param request - CreateJenkinsImageScanTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateJenkinsImageScanTaskResponse
     *
     * @param CreateJenkinsImageScanTaskRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return CreateJenkinsImageScanTaskResponse
     */
    public function createJenkinsImageScanTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->jenkinsEnv) {
            @$query['JenkinsEnv'] = $request->jenkinsEnv;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $body = [];
        if (null !== $request->digest) {
            @$body['Digest'] = $request->digest;
        }

        if (null !== $request->imageCreate) {
            @$body['ImageCreate'] = $request->imageCreate;
        }

        if (null !== $request->imageId) {
            @$body['ImageId'] = $request->imageId;
        }

        if (null !== $request->imageSize) {
            @$body['ImageSize'] = $request->imageSize;
        }

        if (null !== $request->imageUpdate) {
            @$body['ImageUpdate'] = $request->imageUpdate;
        }

        if (null !== $request->namespace) {
            @$body['Namespace'] = $request->namespace;
        }

        if (null !== $request->repoName) {
            @$body['RepoName'] = $request->repoName;
        }

        if (null !== $request->tag) {
            @$body['Tag'] = $request->tag;
        }

        if (null !== $request->token) {
            @$body['Token'] = $request->token;
        }

        if (null !== $request->uuid) {
            @$body['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateJenkinsImageScanTask',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateJenkinsImageScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a Jenkins scan task.
     *
     * @param request - CreateJenkinsImageScanTaskRequest
     *
     * @returns CreateJenkinsImageScanTaskResponse
     *
     * @param CreateJenkinsImageScanTaskRequest $request
     *
     * @return CreateJenkinsImageScanTaskResponse
     */
    public function createJenkinsImageScanTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createJenkinsImageScanTaskWithOptions($request, $runtime);
    }

    /**
     * Get alert whitelist configuration details.
     *
     * @param request - CreateMaliciousFileWhitelistConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateMaliciousFileWhitelistConfigResponse
     *
     * @param CreateMaliciousFileWhitelistConfigRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return CreateMaliciousFileWhitelistConfigResponse
     */
    public function createMaliciousFileWhitelistConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->eventName) {
            @$query['EventName'] = $request->eventName;
        }

        if (null !== $request->field) {
            @$query['Field'] = $request->field;
        }

        if (null !== $request->fieldValue) {
            @$query['FieldValue'] = $request->fieldValue;
        }

        if (null !== $request->operator) {
            @$query['Operator'] = $request->operator;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        if (null !== $request->targetType) {
            @$query['TargetType'] = $request->targetType;
        }

        if (null !== $request->targetValue) {
            @$query['TargetValue'] = $request->targetValue;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateMaliciousFileWhitelistConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateMaliciousFileWhitelistConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Get alert whitelist configuration details.
     *
     * @param request - CreateMaliciousFileWhitelistConfigRequest
     *
     * @returns CreateMaliciousFileWhitelistConfigResponse
     *
     * @param CreateMaliciousFileWhitelistConfigRequest $request
     *
     * @return CreateMaliciousFileWhitelistConfigResponse
     */
    public function createMaliciousFileWhitelistConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createMaliciousFileWhitelistConfigWithOptions($request, $runtime);
    }

    /**
     * Adds remarks to alert events for agentless detection.
     *
     * @param request - CreateMaliciousNoteRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateMaliciousNoteResponse
     *
     * @param CreateMaliciousNoteRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return CreateMaliciousNoteResponse
     */
    public function createMaliciousNoteWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->eventId) {
            @$query['EventId'] = $request->eventId;
        }

        if (null !== $request->note) {
            @$query['Note'] = $request->note;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateMaliciousNote',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateMaliciousNoteResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds remarks to alert events for agentless detection.
     *
     * @param request - CreateMaliciousNoteRequest
     *
     * @returns CreateMaliciousNoteResponse
     *
     * @param CreateMaliciousNoteRequest $request
     *
     * @return CreateMaliciousNoteResponse
     */
    public function createMaliciousNote($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createMaliciousNoteWithOptions($request, $runtime);
    }

    /**
     * Creates a list of members of the account monitored by Security Center type by using the multi-account management feature.
     *
     * @remarks
     * You can call this operation only by using the management account of a resource directory or a delegated administrator account of Security Center.
     *
     * @param request - CreateMonitorAccountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateMonitorAccountResponse
     *
     * @param CreateMonitorAccountRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return CreateMonitorAccountResponse
     */
    public function createMonitorAccountWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accountIds) {
            @$query['AccountIds'] = $request->accountIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateMonitorAccount',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateMonitorAccountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a list of members of the account monitored by Security Center type by using the multi-account management feature.
     *
     * @remarks
     * You can call this operation only by using the management account of a resource directory or a delegated administrator account of Security Center.
     *
     * @param request - CreateMonitorAccountRequest
     *
     * @returns CreateMonitorAccountResponse
     *
     * @param CreateMonitorAccountRequest $request
     *
     * @return CreateMonitorAccountResponse
     */
    public function createMonitorAccount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createMonitorAccountWithOptions($request, $runtime);
    }

    /**
     * Installs the components that are required by at-risk image blocking. The components are policy-template-controller, gatekeeper, and logtail-ds.
     *
     * @param request - CreateOpaClusterPluginRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateOpaClusterPluginResponse
     *
     * @param CreateOpaClusterPluginRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return CreateOpaClusterPluginResponse
     */
    public function createOpaClusterPluginWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterIds) {
            @$query['ClusterIds'] = $request->clusterIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateOpaClusterPlugin',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateOpaClusterPluginResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Installs the components that are required by at-risk image blocking. The components are policy-template-controller, gatekeeper, and logtail-ds.
     *
     * @param request - CreateOpaClusterPluginRequest
     *
     * @returns CreateOpaClusterPluginResponse
     *
     * @param CreateOpaClusterPluginRequest $request
     *
     * @return CreateOpaClusterPluginResponse
     */
    public function createOpaClusterPlugin($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createOpaClusterPluginWithOptions($request, $runtime);
    }

    /**
     * Creates a rule to block at-risk images.
     *
     * @param tmpReq - CreateOpaStrategyNewRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateOpaStrategyNewResponse
     *
     * @param CreateOpaStrategyNewRequest $tmpReq
     * @param RuntimeOptions              $runtime
     *
     * @return CreateOpaStrategyNewResponse
     */
    public function createOpaStrategyNewWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new CreateOpaStrategyNewShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->alarmDetail) {
            $request->alarmDetailShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->alarmDetail, 'AlarmDetail', 'json');
        }

        $query = [];
        if (null !== $request->alarmDetailShrink) {
            @$query['AlarmDetail'] = $request->alarmDetailShrink;
        }

        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->clusterName) {
            @$query['ClusterName'] = $request->clusterName;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->imageName) {
            @$query['ImageName'] = $request->imageName;
        }

        if (null !== $request->label) {
            @$query['Label'] = $request->label;
        }

        if (null !== $request->maliciousImage) {
            @$query['MaliciousImage'] = $request->maliciousImage;
        }

        if (null !== $request->ruleAction) {
            @$query['RuleAction'] = $request->ruleAction;
        }

        if (null !== $request->scopes) {
            @$query['Scopes'] = $request->scopes;
        }

        if (null !== $request->strategyId) {
            @$query['StrategyId'] = $request->strategyId;
        }

        if (null !== $request->strategyName) {
            @$query['StrategyName'] = $request->strategyName;
        }

        if (null !== $request->strategyTemplateId) {
            @$query['StrategyTemplateId'] = $request->strategyTemplateId;
        }

        if (null !== $request->unScanedImage) {
            @$query['UnScanedImage'] = $request->unScanedImage;
        }

        if (null !== $request->whiteList) {
            @$query['WhiteList'] = $request->whiteList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateOpaStrategyNew',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateOpaStrategyNewResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a rule to block at-risk images.
     *
     * @param request - CreateOpaStrategyNewRequest
     *
     * @returns CreateOpaStrategyNewResponse
     *
     * @param CreateOpaStrategyNewRequest $request
     *
     * @return CreateOpaStrategyNewResponse
     */
    public function createOpaStrategyNew($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createOpaStrategyNewWithOptions($request, $runtime);
    }

    /**
     * Modifies the mapping between an asset and an asset group. For example, you can call this operation to modify the server group to which the asset belongs or the asset list of the asset group.
     *
     * @remarks
     * A server can belong only to one server group. If you call the CreateOrUpdateAssetGroup operation and the server specified in request parameters belongs to Server Group A, the server is removed from Server Group A and then added to the newly created or specified server group after the call is complete.
     *
     * @param request - CreateOrUpdateAssetGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateOrUpdateAssetGroupResponse
     *
     * @param CreateOrUpdateAssetGroupRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return CreateOrUpdateAssetGroupResponse
     */
    public function createOrUpdateAssetGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        if (null !== $request->groupName) {
            @$query['GroupName'] = $request->groupName;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateOrUpdateAssetGroup',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateOrUpdateAssetGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the mapping between an asset and an asset group. For example, you can call this operation to modify the server group to which the asset belongs or the asset list of the asset group.
     *
     * @remarks
     * A server can belong only to one server group. If you call the CreateOrUpdateAssetGroup operation and the server specified in request parameters belongs to Server Group A, the server is removed from Server Group A and then added to the newly created or specified server group after the call is complete.
     *
     * @param request - CreateOrUpdateAssetGroupRequest
     *
     * @returns CreateOrUpdateAssetGroupResponse
     *
     * @param CreateOrUpdateAssetGroupRequest $request
     *
     * @return CreateOrUpdateAssetGroupResponse
     */
    public function createOrUpdateAssetGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createOrUpdateAssetGroupWithOptions($request, $runtime);
    }

    /**
     * Creates an asset auto-tagging rule or modifies an asset auto-tagging rule that is created on the Asset Management Rule tab.
     *
     * @param request - CreateOrUpdateAutoTagRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateOrUpdateAutoTagRuleResponse
     *
     * @param CreateOrUpdateAutoTagRuleRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return CreateOrUpdateAutoTagRuleResponse
     */
    public function createOrUpdateAutoTagRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->checkAll) {
            @$query['CheckAll'] = $request->checkAll;
        }

        if (null !== $request->expression) {
            @$query['Expression'] = $request->expression;
        }

        if (null !== $request->ruleDesc) {
            @$query['RuleDesc'] = $request->ruleDesc;
        }

        if (null !== $request->ruleId) {
            @$query['RuleId'] = $request->ruleId;
        }

        if (null !== $request->ruleName) {
            @$query['RuleName'] = $request->ruleName;
        }

        if (null !== $request->tagContext) {
            @$query['TagContext'] = $request->tagContext;
        }

        if (null !== $request->tagType) {
            @$query['TagType'] = $request->tagType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateOrUpdateAutoTagRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateOrUpdateAutoTagRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an asset auto-tagging rule or modifies an asset auto-tagging rule that is created on the Asset Management Rule tab.
     *
     * @param request - CreateOrUpdateAutoTagRuleRequest
     *
     * @returns CreateOrUpdateAutoTagRuleResponse
     *
     * @param CreateOrUpdateAutoTagRuleRequest $request
     *
     * @return CreateOrUpdateAutoTagRuleResponse
     */
    public function createOrUpdateAutoTagRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createOrUpdateAutoTagRuleWithOptions($request, $runtime);
    }

    /**
     * Creates or modifies a DingTalk chatbot that sends notifications.
     *
     * @param request - CreateOrUpdateDingTalkRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateOrUpdateDingTalkResponse
     *
     * @param CreateOrUpdateDingTalkRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return CreateOrUpdateDingTalkResponse
     */
    public function createOrUpdateDingTalkWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->configList) {
            @$query['ConfigList'] = $request->configList;
        }

        if (null !== $request->dingTalkLang) {
            @$query['DingTalkLang'] = $request->dingTalkLang;
        }

        if (null !== $request->groupIdList) {
            @$query['GroupIdList'] = $request->groupIdList;
        }

        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        if (null !== $request->intervalTime) {
            @$query['IntervalTime'] = $request->intervalTime;
        }

        if (null !== $request->ruleActionName) {
            @$query['RuleActionName'] = $request->ruleActionName;
        }

        if (null !== $request->sendUrl) {
            @$query['SendUrl'] = $request->sendUrl;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateOrUpdateDingTalk',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateOrUpdateDingTalkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates or modifies a DingTalk chatbot that sends notifications.
     *
     * @param request - CreateOrUpdateDingTalkRequest
     *
     * @returns CreateOrUpdateDingTalkResponse
     *
     * @param CreateOrUpdateDingTalkRequest $request
     *
     * @return CreateOrUpdateDingTalkResponse
     */
    public function createOrUpdateDingTalk($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createOrUpdateDingTalkWithOptions($request, $runtime);
    }

    /**
     * Creates a bucket check task.
     *
     * @param request - CreateOssBucketScanTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateOssBucketScanTaskResponse
     *
     * @param CreateOssBucketScanTaskRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return CreateOssBucketScanTaskResponse
     */
    public function createOssBucketScanTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->allKeyPrefix) {
            @$query['AllKeyPrefix'] = $request->allKeyPrefix;
        }

        if (null !== $request->bucketNameList) {
            @$query['BucketNameList'] = $request->bucketNameList;
        }

        if (null !== $request->decompressMaxFileCount) {
            @$query['DecompressMaxFileCount'] = $request->decompressMaxFileCount;
        }

        if (null !== $request->decompressMaxLayer) {
            @$query['DecompressMaxLayer'] = $request->decompressMaxLayer;
        }

        if (null !== $request->decryptionList) {
            @$query['DecryptionList'] = $request->decryptionList;
        }

        if (null !== $request->excludeKeySuffixList) {
            @$query['ExcludeKeySuffixList'] = $request->excludeKeySuffixList;
        }

        if (null !== $request->keyPrefixList) {
            @$query['KeyPrefixList'] = $request->keyPrefixList;
        }

        if (null !== $request->keySuffixList) {
            @$query['KeySuffixList'] = $request->keySuffixList;
        }

        if (null !== $request->lastModifiedStartTime) {
            @$query['LastModifiedStartTime'] = $request->lastModifiedStartTime;
        }

        if (null !== $request->scanMode) {
            @$query['ScanMode'] = $request->scanMode;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateOssBucketScanTask',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateOssBucketScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a bucket check task.
     *
     * @param request - CreateOssBucketScanTaskRequest
     *
     * @returns CreateOssBucketScanTaskResponse
     *
     * @param CreateOssBucketScanTaskRequest $request
     *
     * @return CreateOssBucketScanTaskResponse
     */
    public function createOssBucketScanTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createOssBucketScanTaskWithOptions($request, $runtime);
    }

    /**
     * Creates a policy for detecting malicious Object Storage Service (OSS) objects by using the SDK for malicious file detection feature.
     *
     * @param request - CreateOssScanConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateOssScanConfigResponse
     *
     * @param CreateOssScanConfigRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return CreateOssScanConfigResponse
     */
    public function createOssScanConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->allKeyPrefix) {
            @$query['AllKeyPrefix'] = $request->allKeyPrefix;
        }

        if (null !== $request->bucketNameList) {
            @$query['BucketNameList'] = $request->bucketNameList;
        }

        if (null !== $request->decompressMaxFileCount) {
            @$query['DecompressMaxFileCount'] = $request->decompressMaxFileCount;
        }

        if (null !== $request->decompressMaxLayer) {
            @$query['DecompressMaxLayer'] = $request->decompressMaxLayer;
        }

        if (null !== $request->decryptionList) {
            @$query['DecryptionList'] = $request->decryptionList;
        }

        if (null !== $request->enable) {
            @$query['Enable'] = $request->enable;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->keyPrefixList) {
            @$query['KeyPrefixList'] = $request->keyPrefixList;
        }

        if (null !== $request->keySuffixList) {
            @$query['KeySuffixList'] = $request->keySuffixList;
        }

        if (null !== $request->lastModifiedStartTime) {
            @$query['LastModifiedStartTime'] = $request->lastModifiedStartTime;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->realTimeIncr) {
            @$query['RealTimeIncr'] = $request->realTimeIncr;
        }

        if (null !== $request->scanDayList) {
            @$query['ScanDayList'] = $request->scanDayList;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateOssScanConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateOssScanConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a policy for detecting malicious Object Storage Service (OSS) objects by using the SDK for malicious file detection feature.
     *
     * @param request - CreateOssScanConfigRequest
     *
     * @returns CreateOssScanConfigResponse
     *
     * @param CreateOssScanConfigRequest $request
     *
     * @return CreateOssScanConfigResponse
     */
    public function createOssScanConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createOssScanConfigWithOptions($request, $runtime);
    }

    /**
     * Creates an automatic account management policy for members of the account monitored by Security Center type by using the multi-account management feature. After the policy is created, the members that are newly added to the specified resource directory are automatically added to the list of members of the account monitored by Security Center type.
     *
     * @remarks
     * You can call this operation only by using the management account of a resource directory or a delegated administrator account of Security Center.
     *
     * @param request - CreateRdDefaultSyncListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateRdDefaultSyncListResponse
     *
     * @param CreateRdDefaultSyncListRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return CreateRdDefaultSyncListResponse
     */
    public function createRdDefaultSyncListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->folderIds) {
            @$query['FolderIds'] = $request->folderIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateRdDefaultSyncList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateRdDefaultSyncListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an automatic account management policy for members of the account monitored by Security Center type by using the multi-account management feature. After the policy is created, the members that are newly added to the specified resource directory are automatically added to the list of members of the account monitored by Security Center type.
     *
     * @remarks
     * You can call this operation only by using the management account of a resource directory or a delegated administrator account of Security Center.
     *
     * @param request - CreateRdDefaultSyncListRequest
     *
     * @returns CreateRdDefaultSyncListResponse
     *
     * @param CreateRdDefaultSyncListRequest $request
     *
     * @return CreateRdDefaultSyncListResponse
     */
    public function createRdDefaultSyncList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createRdDefaultSyncListWithOptions($request, $runtime);
    }

    /**
     * Creates a restoration task.
     *
     * @param request - CreateRestoreJobRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateRestoreJobResponse
     *
     * @param CreateRestoreJobRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return CreateRestoreJobResponse
     */
    public function createRestoreJobWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->includes) {
            @$query['Includes'] = $request->includes;
        }

        if (null !== $request->snapshotHash) {
            @$query['SnapshotHash'] = $request->snapshotHash;
        }

        if (null !== $request->snapshotId) {
            @$query['SnapshotId'] = $request->snapshotId;
        }

        if (null !== $request->snapshotVersion) {
            @$query['SnapshotVersion'] = $request->snapshotVersion;
        }

        if (null !== $request->sourceType) {
            @$query['SourceType'] = $request->sourceType;
        }

        if (null !== $request->target) {
            @$query['Target'] = $request->target;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        if (null !== $request->vaultId) {
            @$query['VaultId'] = $request->vaultId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateRestoreJob',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateRestoreJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a restoration task.
     *
     * @param request - CreateRestoreJobRequest
     *
     * @returns CreateRestoreJobResponse
     *
     * @param CreateRestoreJobRequest $request
     *
     * @return CreateRestoreJobResponse
     */
    public function createRestoreJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createRestoreJobWithOptions($request, $runtime);
    }

    /**
     * Applies for a trial of Security Center.
     *
     * @param tmpReq - CreateSasTrialRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateSasTrialResponse
     *
     * @param CreateSasTrialRequest $tmpReq
     * @param RuntimeOptions        $runtime
     *
     * @return CreateSasTrialResponse
     */
    public function createSasTrialWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new CreateSasTrialShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->requestForm) {
            $request->requestFormShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->requestForm, 'RequestForm', 'json');
        }

        $body = [];
        if (null !== $request->fromEcs) {
            @$body['FromEcs'] = $request->fromEcs;
        }

        if (null !== $request->lang) {
            @$body['Lang'] = $request->lang;
        }

        if (null !== $request->requestFormShrink) {
            @$body['RequestForm'] = $request->requestFormShrink;
        }

        if (null !== $request->tryType) {
            @$body['TryType'] = $request->tryType;
        }

        if (null !== $request->tryVersion) {
            @$body['TryVersion'] = $request->tryVersion;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateSasTrial',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateSasTrialResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Applies for a trial of Security Center.
     *
     * @param request - CreateSasTrialRequest
     *
     * @returns CreateSasTrialResponse
     *
     * @param CreateSasTrialRequest $request
     *
     * @return CreateSasTrialResponse
     */
    public function createSasTrial($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createSasTrialWithOptions($request, $runtime);
    }

    /**
     * Creates a service-linked role and authorizes Security Center to access cloud resources.
     *
     * @remarks
     * For more information about service-linked roles, see [Service-linked roles](https://help.aliyun.com/document_detail/160674.html).
     *
     * @param request - CreateServiceLinkedRoleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateServiceLinkedRoleResponse
     *
     * @param CreateServiceLinkedRoleRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return CreateServiceLinkedRoleResponse
     */
    public function createServiceLinkedRoleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->serviceLinkedRole) {
            @$query['ServiceLinkedRole'] = $request->serviceLinkedRole;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateServiceLinkedRole',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateServiceLinkedRoleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a service-linked role and authorizes Security Center to access cloud resources.
     *
     * @remarks
     * For more information about service-linked roles, see [Service-linked roles](https://help.aliyun.com/document_detail/160674.html).
     *
     * @param request - CreateServiceLinkedRoleRequest
     *
     * @returns CreateServiceLinkedRoleResponse
     *
     * @param CreateServiceLinkedRoleRequest $request
     *
     * @return CreateServiceLinkedRoleResponse
     */
    public function createServiceLinkedRole($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createServiceLinkedRoleWithOptions($request, $runtime);
    }

    /**
     * Create a service trail.
     *
     * @param request - CreateServiceTrailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateServiceTrailResponse
     *
     * @param CreateServiceTrailRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return CreateServiceTrailResponse
     */
    public function createServiceTrailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateServiceTrail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateServiceTrailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Create a service trail.
     *
     * @param request - CreateServiceTrailRequest
     *
     * @returns CreateServiceTrailResponse
     *
     * @param CreateServiceTrailRequest $request
     *
     * @return CreateServiceTrailResponse
     */
    public function createServiceTrail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createServiceTrailWithOptions($request, $runtime);
    }

    /**
     * Creates a task to query alert events that are triggered by the same rule or of the same alert type.
     *
     * @param request - CreateSimilarSecurityEventsQueryTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateSimilarSecurityEventsQueryTaskResponse
     *
     * @param CreateSimilarSecurityEventsQueryTaskRequest $request
     * @param RuntimeOptions                              $runtime
     *
     * @return CreateSimilarSecurityEventsQueryTaskResponse
     */
    public function createSimilarSecurityEventsQueryTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->securityEventId) {
            @$query['SecurityEventId'] = $request->securityEventId;
        }

        if (null !== $request->similarEventScenarioCode) {
            @$query['SimilarEventScenarioCode'] = $request->similarEventScenarioCode;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateSimilarSecurityEventsQueryTask',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateSimilarSecurityEventsQueryTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a task to query alert events that are triggered by the same rule or of the same alert type.
     *
     * @param request - CreateSimilarSecurityEventsQueryTaskRequest
     *
     * @returns CreateSimilarSecurityEventsQueryTaskResponse
     *
     * @param CreateSimilarSecurityEventsQueryTaskRequest $request
     *
     * @return CreateSimilarSecurityEventsQueryTaskResponse
     */
    public function createSimilarSecurityEventsQueryTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createSimilarSecurityEventsQueryTaskWithOptions($request, $runtime);
    }

    /**
     * Creates a task on the My Policies tab of the Playbook page.
     *
     * @remarks
     * Only the Enterprise and Ultimate editions of Security Center support this API operation.
     *
     * @param request - CreateSoarStrategyTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateSoarStrategyTaskResponse
     *
     * @param CreateSoarStrategyTaskRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return CreateSoarStrategyTaskResponse
     */
    public function createSoarStrategyTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->strategyId) {
            @$query['StrategyId'] = $request->strategyId;
        }

        if (null !== $request->strategyName) {
            @$query['StrategyName'] = $request->strategyName;
        }

        if (null !== $request->strategyTaskName) {
            @$query['StrategyTaskName'] = $request->strategyTaskName;
        }

        if (null !== $request->strategyTaskParams) {
            @$query['StrategyTaskParams'] = $request->strategyTaskParams;
        }

        if (null !== $request->strategyTaskPlanExeTime) {
            @$query['StrategyTaskPlanExeTime'] = $request->strategyTaskPlanExeTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateSoarStrategyTask',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateSoarStrategyTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a task on the My Policies tab of the Playbook page.
     *
     * @remarks
     * Only the Enterprise and Ultimate editions of Security Center support this API operation.
     *
     * @param request - CreateSoarStrategyTaskRequest
     *
     * @returns CreateSoarStrategyTaskResponse
     *
     * @param CreateSoarStrategyTaskRequest $request
     *
     * @return CreateSoarStrategyTaskResponse
     */
    public function createSoarStrategyTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createSoarStrategyTaskWithOptions($request, $runtime);
    }

    /**
     * Adds remarks to an alert event.
     *
     * @param request - CreateSuspEventNoteRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateSuspEventNoteResponse
     *
     * @param CreateSuspEventNoteRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return CreateSuspEventNoteResponse
     */
    public function createSuspEventNoteWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->eventId) {
            @$query['EventId'] = $request->eventId;
        }

        if (null !== $request->note) {
            @$query['Note'] = $request->note;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateSuspEventNote',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateSuspEventNoteResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds remarks to an alert event.
     *
     * @param request - CreateSuspEventNoteRequest
     *
     * @returns CreateSuspEventNoteResponse
     *
     * @param CreateSuspEventNoteRequest $request
     *
     * @return CreateSuspEventNoteResponse
     */
    public function createSuspEventNote($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createSuspEventNoteWithOptions($request, $runtime);
    }

    /**
     * Creates an anti-ransomware policy for a database.
     *
     * @param tmpReq - CreateUniBackupPolicyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateUniBackupPolicyResponse
     *
     * @param CreateUniBackupPolicyRequest $tmpReq
     * @param RuntimeOptions               $runtime
     *
     * @return CreateUniBackupPolicyResponse
     */
    public function createUniBackupPolicyWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new CreateUniBackupPolicyShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->fullPlan) {
            $request->fullPlanShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->fullPlan, 'FullPlan', 'json');
        }

        if (null !== $tmpReq->incPlan) {
            $request->incPlanShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->incPlan, 'IncPlan', 'json');
        }

        $query = [];
        if (null !== $request->accountName) {
            @$query['AccountName'] = $request->accountName;
        }

        if (null !== $request->accountPassword) {
            @$query['AccountPassword'] = $request->accountPassword;
        }

        if (null !== $request->databaseAddByUser) {
            @$query['DatabaseAddByUser'] = $request->databaseAddByUser;
        }

        if (null !== $request->databaseType) {
            @$query['DatabaseType'] = $request->databaseType;
        }

        if (null !== $request->fullPlanShrink) {
            @$query['FullPlan'] = $request->fullPlanShrink;
        }

        if (null !== $request->incPlanShrink) {
            @$query['IncPlan'] = $request->incPlanShrink;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->policyName) {
            @$query['PolicyName'] = $request->policyName;
        }

        if (null !== $request->retention) {
            @$query['Retention'] = $request->retention;
        }

        if (null !== $request->speedLimiter) {
            @$query['SpeedLimiter'] = $request->speedLimiter;
        }

        if (null !== $request->uniRegionId) {
            @$query['UniRegionId'] = $request->uniRegionId;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateUniBackupPolicy',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateUniBackupPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an anti-ransomware policy for a database.
     *
     * @param request - CreateUniBackupPolicyRequest
     *
     * @returns CreateUniBackupPolicyResponse
     *
     * @param CreateUniBackupPolicyRequest $request
     *
     * @return CreateUniBackupPolicyResponse
     */
    public function createUniBackupPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createUniBackupPolicyWithOptions($request, $runtime);
    }

    /**
     * Creates a restoration task for a database.
     *
     * @param request - CreateUniRestorePlanRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateUniRestorePlanResponse
     *
     * @param CreateUniRestorePlanRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return CreateUniRestorePlanResponse
     */
    public function createUniRestorePlanWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->database) {
            @$query['Database'] = $request->database;
        }

        if (null !== $request->instanceUuid) {
            @$query['InstanceUuid'] = $request->instanceUuid;
        }

        if (null !== $request->policyId) {
            @$query['PolicyId'] = $request->policyId;
        }

        if (null !== $request->resetScn) {
            @$query['ResetScn'] = $request->resetScn;
        }

        if (null !== $request->resetTime) {
            @$query['ResetTime'] = $request->resetTime;
        }

        if (null !== $request->restoreInfo) {
            @$query['RestoreInfo'] = $request->restoreInfo;
        }

        if (null !== $request->timePoint) {
            @$query['TimePoint'] = $request->timePoint;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateUniRestorePlan',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateUniRestorePlanResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a restoration task for a database.
     *
     * @param request - CreateUniRestorePlanRequest
     *
     * @returns CreateUniRestorePlanResponse
     *
     * @param CreateUniRestorePlanRequest $request
     *
     * @return CreateUniRestorePlanResponse
     */
    public function createUniRestorePlan($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createUniRestorePlanWithOptions($request, $runtime);
    }

    /**
     * Creates the risk level settings for baseline check items.
     *
     * @param request - CreateUserSettingRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateUserSettingResponse
     *
     * @param CreateUserSettingRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return CreateUserSettingResponse
     */
    public function createUserSettingWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->alertLevels) {
            @$query['AlertLevels'] = $request->alertLevels;
        }

        if (null !== $request->invalidWarningKeepDays) {
            @$query['InvalidWarningKeepDays'] = $request->invalidWarningKeepDays;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateUserSetting',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateUserSettingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates the risk level settings for baseline check items.
     *
     * @param request - CreateUserSettingRequest
     *
     * @returns CreateUserSettingResponse
     *
     * @param CreateUserSettingRequest $request
     *
     * @return CreateUserSettingResponse
     */
    public function createUserSetting($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createUserSettingWithOptions($request, $runtime);
    }

    /**
     * Creates a one-time virus scan task that is immediately executed.
     *
     * @param request - CreateVirusScanOnceTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateVirusScanOnceTaskResponse
     *
     * @param CreateVirusScanOnceTaskRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return CreateVirusScanOnceTaskResponse
     */
    public function createVirusScanOnceTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->param) {
            @$query['Param'] = $request->param;
        }

        if (null !== $request->scanPath) {
            @$query['ScanPath'] = $request->scanPath;
        }

        if (null !== $request->scanType) {
            @$query['ScanType'] = $request->scanType;
        }

        if (null !== $request->selectionKey) {
            @$query['SelectionKey'] = $request->selectionKey;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateVirusScanOnceTask',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateVirusScanOnceTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a one-time virus scan task that is immediately executed.
     *
     * @param request - CreateVirusScanOnceTaskRequest
     *
     * @returns CreateVirusScanOnceTaskResponse
     *
     * @param CreateVirusScanOnceTaskRequest $request
     *
     * @return CreateVirusScanOnceTaskResponse
     */
    public function createVirusScanOnceTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVirusScanOnceTaskWithOptions($request, $runtime);
    }

    /**
     * Creates a list of vulnerabilities that can be automatically fixed. After the list is created, you can select the list when you create a vulnerability fixing task on the Playbook page.
     *
     * @param request - CreateVulAutoRepairConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateVulAutoRepairConfigResponse
     *
     * @param CreateVulAutoRepairConfigRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return CreateVulAutoRepairConfigResponse
     */
    public function createVulAutoRepairConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->reason) {
            @$query['Reason'] = $request->reason;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        if (null !== $request->vulAutoRepairConfigList) {
            @$query['VulAutoRepairConfigList'] = $request->vulAutoRepairConfigList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateVulAutoRepairConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateVulAutoRepairConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a list of vulnerabilities that can be automatically fixed. After the list is created, you can select the list when you create a vulnerability fixing task on the Playbook page.
     *
     * @param request - CreateVulAutoRepairConfigRequest
     *
     * @returns CreateVulAutoRepairConfigResponse
     *
     * @param CreateVulAutoRepairConfigRequest $request
     *
     * @return CreateVulAutoRepairConfigResponse
     */
    public function createVulAutoRepairConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVulAutoRepairConfigWithOptions($request, $runtime);
    }

    /**
     * Deletes the specified defense rules against brute-force attacks.
     *
     * @param request - DeleteAntiBruteForceRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteAntiBruteForceRuleResponse
     *
     * @param DeleteAntiBruteForceRuleRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DeleteAntiBruteForceRuleResponse
     */
    public function deleteAntiBruteForceRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ids) {
            @$query['Ids'] = $request->ids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteAntiBruteForceRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteAntiBruteForceRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the specified defense rules against brute-force attacks.
     *
     * @param request - DeleteAntiBruteForceRuleRequest
     *
     * @returns DeleteAntiBruteForceRuleResponse
     *
     * @param DeleteAntiBruteForceRuleRequest $request
     *
     * @return DeleteAntiBruteForceRuleResponse
     */
    public function deleteAntiBruteForceRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteAntiBruteForceRuleWithOptions($request, $runtime);
    }

    /**
     * Delete attack path sensitive asset.
     *
     * @param request - DeleteAttackPathSensitiveAssetConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteAttackPathSensitiveAssetConfigResponse
     *
     * @param DeleteAttackPathSensitiveAssetConfigRequest $request
     * @param RuntimeOptions                              $runtime
     *
     * @return DeleteAttackPathSensitiveAssetConfigResponse
     */
    public function deleteAttackPathSensitiveAssetConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->attackPathSensitiveAssetConfigId) {
            @$query['AttackPathSensitiveAssetConfigId'] = $request->attackPathSensitiveAssetConfigId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteAttackPathSensitiveAssetConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteAttackPathSensitiveAssetConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Delete attack path sensitive asset.
     *
     * @param request - DeleteAttackPathSensitiveAssetConfigRequest
     *
     * @returns DeleteAttackPathSensitiveAssetConfigResponse
     *
     * @param DeleteAttackPathSensitiveAssetConfigRequest $request
     *
     * @return DeleteAttackPathSensitiveAssetConfigResponse
     */
    public function deleteAttackPathSensitiveAssetConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteAttackPathSensitiveAssetConfigWithOptions($request, $runtime);
    }

    /**
     * Delete Attack Path Whitelist.
     *
     * @param request - DeleteAttackPathWhitelistRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteAttackPathWhitelistResponse
     *
     * @param DeleteAttackPathWhitelistRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DeleteAttackPathWhitelistResponse
     */
    public function deleteAttackPathWhitelistWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->attackPathWhitelistId) {
            @$query['AttackPathWhitelistId'] = $request->attackPathWhitelistId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteAttackPathWhitelist',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteAttackPathWhitelistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Delete Attack Path Whitelist.
     *
     * @param request - DeleteAttackPathWhitelistRequest
     *
     * @returns DeleteAttackPathWhitelistResponse
     *
     * @param DeleteAttackPathWhitelistRequest $request
     *
     * @return DeleteAttackPathWhitelistResponse
     */
    public function deleteAttackPathWhitelist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteAttackPathWhitelistWithOptions($request, $runtime);
    }

    /**
     * Deletes a witness.
     *
     * @param request - DeleteAttestorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteAttestorResponse
     *
     * @param DeleteAttestorRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return DeleteAttestorResponse
     */
    public function deleteAttestorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteAttestor',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteAttestorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a witness.
     *
     * @param request - DeleteAttestorRequest
     *
     * @returns DeleteAttestorResponse
     *
     * @param DeleteAttestorRequest $request
     *
     * @return DeleteAttestorResponse
     */
    public function deleteAttestor($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteAttestorWithOptions($request, $runtime);
    }

    /**
     * Deletes asset auto-tagging rules that are created by using the feature of asset management rules. You can create rules on the System Configuration > Feature Settings > Multi-cloud Configuration Management > Asset Management Rule page in the Security Center console.
     *
     * @param request - DeleteAutoTagRulesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteAutoTagRulesResponse
     *
     * @param DeleteAutoTagRulesRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return DeleteAutoTagRulesResponse
     */
    public function deleteAutoTagRulesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ruleIdList) {
            @$query['RuleIdList'] = $request->ruleIdList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteAutoTagRules',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteAutoTagRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes asset auto-tagging rules that are created by using the feature of asset management rules. You can create rules on the System Configuration > Feature Settings > Multi-cloud Configuration Management > Asset Management Rule page in the Security Center console.
     *
     * @param request - DeleteAutoTagRulesRequest
     *
     * @returns DeleteAutoTagRulesResponse
     *
     * @param DeleteAutoTagRulesRequest $request
     *
     * @return DeleteAutoTagRulesResponse
     */
    public function deleteAutoTagRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteAutoTagRulesWithOptions($request, $runtime);
    }

    /**
     * Deletes an anti-ransomware policy.
     *
     * @param request - DeleteBackupPolicyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteBackupPolicyResponse
     *
     * @param DeleteBackupPolicyRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return DeleteBackupPolicyResponse
     */
    public function deleteBackupPolicyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        if (null !== $request->policyVersion) {
            @$query['PolicyVersion'] = $request->policyVersion;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteBackupPolicy',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteBackupPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an anti-ransomware policy.
     *
     * @param request - DeleteBackupPolicyRequest
     *
     * @returns DeleteBackupPolicyResponse
     *
     * @param DeleteBackupPolicyRequest $request
     *
     * @return DeleteBackupPolicyResponse
     */
    public function deleteBackupPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBackupPolicyWithOptions($request, $runtime);
    }

    /**
     * Disables a specified anti-ransomware policy that is applied to specified servers and uninstalls the anti-ransomware agent from the servers. If the backup vaults of the servers contain only backup data of the servers, the backup vaults are deleted.
     *
     * @param request - DeleteBackupPolicyMachineRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteBackupPolicyMachineResponse
     *
     * @param DeleteBackupPolicyMachineRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DeleteBackupPolicyMachineResponse
     */
    public function deleteBackupPolicyMachineWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->policyId) {
            @$query['PolicyId'] = $request->policyId;
        }

        if (null !== $request->policyVersion) {
            @$query['PolicyVersion'] = $request->policyVersion;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        if (null !== $request->uuidList) {
            @$query['UuidList'] = $request->uuidList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteBackupPolicyMachine',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteBackupPolicyMachineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Disables a specified anti-ransomware policy that is applied to specified servers and uninstalls the anti-ransomware agent from the servers. If the backup vaults of the servers contain only backup data of the servers, the backup vaults are deleted.
     *
     * @param request - DeleteBackupPolicyMachineRequest
     *
     * @returns DeleteBackupPolicyMachineResponse
     *
     * @param DeleteBackupPolicyMachineRequest $request
     *
     * @return DeleteBackupPolicyMachineResponse
     */
    public function deleteBackupPolicyMachine($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBackupPolicyMachineWithOptions($request, $runtime);
    }

    /**
     * Deletes a backup snapshot that is created for anti-ransomware.
     *
     * @param request - DeleteBackupSnapshotRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteBackupSnapshotResponse
     *
     * @param DeleteBackupSnapshotRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DeleteBackupSnapshotResponse
     */
    public function deleteBackupSnapshotWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->backupRegionIdList) {
            @$query['BackupRegionIdList'] = $request->backupRegionIdList;
        }

        if (null !== $request->backupSnapshotList) {
            @$query['BackupSnapshotList'] = $request->backupSnapshotList;
        }

        if (null !== $request->retainLatestSnapshot) {
            @$query['RetainLatestSnapshot'] = $request->retainLatestSnapshot;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteBackupSnapshot',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteBackupSnapshotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a backup snapshot that is created for anti-ransomware.
     *
     * @param request - DeleteBackupSnapshotRequest
     *
     * @returns DeleteBackupSnapshotResponse
     *
     * @param DeleteBackupSnapshotRequest $request
     *
     * @return DeleteBackupSnapshotResponse
     */
    public function deleteBackupSnapshot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBackupSnapshotWithOptions($request, $runtime);
    }

    /**
     * Deletes the whitelist record for a baseline check item.
     *
     * @param request - DeleteBaselineCheckWhiteRecordRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteBaselineCheckWhiteRecordResponse
     *
     * @param DeleteBaselineCheckWhiteRecordRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DeleteBaselineCheckWhiteRecordResponse
     */
    public function deleteBaselineCheckWhiteRecordWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->checkIds) {
            @$query['CheckIds'] = $request->checkIds;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->recordIds) {
            @$query['RecordIds'] = $request->recordIds;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteBaselineCheckWhiteRecord',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteBaselineCheckWhiteRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the whitelist record for a baseline check item.
     *
     * @param request - DeleteBaselineCheckWhiteRecordRequest
     *
     * @returns DeleteBaselineCheckWhiteRecordResponse
     *
     * @param DeleteBaselineCheckWhiteRecordRequest $request
     *
     * @return DeleteBaselineCheckWhiteRecordResponse
     */
    public function deleteBaselineCheckWhiteRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBaselineCheckWhiteRecordWithOptions($request, $runtime);
    }

    /**
     * Deletes a binary security policy from the container signature feature.
     *
     * @param request - DeleteBinarySecurityPolicyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteBinarySecurityPolicyResponse
     *
     * @param DeleteBinarySecurityPolicyRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DeleteBinarySecurityPolicyResponse
     */
    public function deleteBinarySecurityPolicyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteBinarySecurityPolicy',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteBinarySecurityPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a binary security policy from the container signature feature.
     *
     * @param request - DeleteBinarySecurityPolicyRequest
     *
     * @returns DeleteBinarySecurityPolicyResponse
     *
     * @param DeleteBinarySecurityPolicyRequest $request
     *
     * @return DeleteBinarySecurityPolicyResponse
     */
    public function deleteBinarySecurityPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBinarySecurityPolicyWithOptions($request, $runtime);
    }

    /**
     * Delete custom check item for Situation Awareness.
     *
     * @param request - DeleteCheckItemRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteCheckItemResponse
     *
     * @param DeleteCheckItemRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return DeleteCheckItemResponse
     */
    public function deleteCheckItemWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->checkIds) {
            @$query['CheckIds'] = $request->checkIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteCheckItem',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteCheckItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Delete custom check item for Situation Awareness.
     *
     * @param request - DeleteCheckItemRequest
     *
     * @returns DeleteCheckItemResponse
     *
     * @param DeleteCheckItemRequest $request
     *
     * @return DeleteCheckItemResponse
     */
    public function deleteCheckItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCheckItemWithOptions($request, $runtime);
    }

    /**
     * Delete custom scope directories in Cloud Security Posture Management (CSPM) custom checks. You can remove assigned standards, requirements, or sections.
     *
     * @param request - DeleteCheckPolicyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteCheckPolicyResponse
     *
     * @param DeleteCheckPolicyRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return DeleteCheckPolicyResponse
     */
    public function deleteCheckPolicyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->policyIds) {
            @$query['PolicyIds'] = $request->policyIds;
        }

        if (null !== $request->policyType) {
            @$query['PolicyType'] = $request->policyType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteCheckPolicy',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteCheckPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Delete custom scope directories in Cloud Security Posture Management (CSPM) custom checks. You can remove assigned standards, requirements, or sections.
     *
     * @param request - DeleteCheckPolicyRequest
     *
     * @returns DeleteCheckPolicyResponse
     *
     * @param DeleteCheckPolicyRequest $request
     *
     * @return DeleteCheckPolicyResponse
     */
    public function deleteCheckPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCheckPolicyWithOptions($request, $runtime);
    }

    /**
     * Deletes specified custom defense rules.
     *
     * @param request - DeleteClientUserDefineRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteClientUserDefineRuleResponse
     *
     * @param DeleteClientUserDefineRuleRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DeleteClientUserDefineRuleResponse
     */
    public function deleteClientUserDefineRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->idList) {
            @$query['IdList'] = $request->idList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteClientUserDefineRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteClientUserDefineRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes specified custom defense rules.
     *
     * @param request - DeleteClientUserDefineRuleRequest
     *
     * @returns DeleteClientUserDefineRuleResponse
     *
     * @param DeleteClientUserDefineRuleRequest $request
     *
     * @return DeleteClientUserDefineRuleResponse
     */
    public function deleteClientUserDefineRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteClientUserDefineRuleWithOptions($request, $runtime);
    }

    /**
     * Delete multi-cloud asset synchronization configuration.
     *
     * @param request - DeleteCloudVendorAccountAKRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteCloudVendorAccountAKResponse
     *
     * @param DeleteCloudVendorAccountAKRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DeleteCloudVendorAccountAKResponse
     */
    public function deleteCloudVendorAccountAKWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->authId) {
            @$query['AuthId'] = $request->authId;
        }

        if (null !== $request->authModules) {
            @$query['AuthModules'] = $request->authModules;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteCloudVendorAccountAK',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteCloudVendorAccountAKResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Delete multi-cloud asset synchronization configuration.
     *
     * @param request - DeleteCloudVendorAccountAKRequest
     *
     * @returns DeleteCloudVendorAccountAKResponse
     *
     * @param DeleteCloudVendorAccountAKRequest $request
     *
     * @return DeleteCloudVendorAccountAKResponse
     */
    public function deleteCloudVendorAccountAK($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCloudVendorAccountAKWithOptions($request, $runtime);
    }

    /**
     * Deletes a rule for non-image program defense.
     *
     * @param request - DeleteContainerDefenseRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteContainerDefenseRuleResponse
     *
     * @param DeleteContainerDefenseRuleRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DeleteContainerDefenseRuleResponse
     */
    public function deleteContainerDefenseRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ruleIds) {
            @$query['RuleIds'] = $request->ruleIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteContainerDefenseRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteContainerDefenseRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a rule for non-image program defense.
     *
     * @param request - DeleteContainerDefenseRuleRequest
     *
     * @returns DeleteContainerDefenseRuleResponse
     *
     * @param DeleteContainerDefenseRuleRequest $request
     *
     * @return DeleteContainerDefenseRuleResponse
     */
    public function deleteContainerDefenseRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteContainerDefenseRuleWithOptions($request, $runtime);
    }

    /**
     * Deletes a defense rule against container escapes.
     *
     * @param request - DeleteContainerPluginRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteContainerPluginRuleResponse
     *
     * @param DeleteContainerPluginRuleRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DeleteContainerPluginRuleResponse
     */
    public function deleteContainerPluginRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->ruleId) {
            @$query['RuleId'] = $request->ruleId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteContainerPluginRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteContainerPluginRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a defense rule against container escapes.
     *
     * @param request - DeleteContainerPluginRuleRequest
     *
     * @returns DeleteContainerPluginRuleResponse
     *
     * @param DeleteContainerPluginRuleRequest $request
     *
     * @return DeleteContainerPluginRuleResponse
     */
    public function deleteContainerPluginRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteContainerPluginRuleWithOptions($request, $runtime);
    }

    /**
     * Deletes a specified IP address blocking policy from one or more servers.
     *
     * @param request - DeleteCustomBlockRecordRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteCustomBlockRecordResponse
     *
     * @param DeleteCustomBlockRecordRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DeleteCustomBlockRecordResponse
     */
    public function deleteCustomBlockRecordWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteCustomBlockRecord',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteCustomBlockRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a specified IP address blocking policy from one or more servers.
     *
     * @param request - DeleteCustomBlockRecordRequest
     *
     * @returns DeleteCustomBlockRecordResponse
     *
     * @param DeleteCustomBlockRecordRequest $request
     *
     * @return DeleteCustomBlockRecordResponse
     */
    public function deleteCustomBlockRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCustomBlockRecordWithOptions($request, $runtime);
    }

    /**
     * Deletes a custom security report.
     *
     * @param request - DeleteCustomizeReportRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteCustomizeReportResponse
     *
     * @param DeleteCustomizeReportRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DeleteCustomizeReportResponse
     */
    public function deleteCustomizeReportWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->reportId) {
            @$query['ReportId'] = $request->reportId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteCustomizeReport',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteCustomizeReportResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a custom security report.
     *
     * @param request - DeleteCustomizeReportRequest
     *
     * @returns DeleteCustomizeReportResponse
     *
     * @param DeleteCustomizeReportRequest $request
     *
     * @return DeleteCustomizeReportResponse
     */
    public function deleteCustomizeReport($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCustomizeReportWithOptions($request, $runtime);
    }

    /**
     * Deletes the file that is uploaded to create custom weak password rules.
     *
     * @param request - DeleteCustomizedDictRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteCustomizedDictResponse
     *
     * @param DeleteCustomizedDictRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DeleteCustomizedDictResponse
     */
    public function deleteCustomizedDictWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteCustomizedDict',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteCustomizedDictResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the file that is uploaded to create custom weak password rules.
     *
     * @param request - DeleteCustomizedDictRequest
     *
     * @returns DeleteCustomizedDictResponse
     *
     * @param DeleteCustomizedDictRequest $request
     *
     * @return DeleteCustomizedDictResponse
     */
    public function deleteCustomizedDict($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCustomizedDictWithOptions($request, $runtime);
    }

    /**
     * Deletes a periodic scan task. The task can be an image scan task, urgent vulnerability scan task, or virus scan task.
     *
     * @param request - DeleteCycleTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteCycleTaskResponse
     *
     * @param DeleteCycleTaskRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return DeleteCycleTaskResponse
     */
    public function deleteCycleTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->configId) {
            @$query['ConfigId'] = $request->configId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteCycleTask',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteCycleTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a periodic scan task. The task can be an image scan task, urgent vulnerability scan task, or virus scan task.
     *
     * @param request - DeleteCycleTaskRequest
     *
     * @returns DeleteCycleTaskResponse
     *
     * @param DeleteCycleTaskRequest $request
     *
     * @return DeleteCycleTaskResponse
     */
    public function deleteCycleTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCycleTaskWithOptions($request, $runtime);
    }

    /**
     * Deletes a DingTalk chatbot on the DingTalk Chatbot tab of the Notification Settings page.
     *
     * @param request - DeleteDingTalkRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteDingTalkResponse
     *
     * @param DeleteDingTalkRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return DeleteDingTalkResponse
     */
    public function deleteDingTalkWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ids) {
            @$query['Ids'] = $request->ids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteDingTalk',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteDingTalkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a DingTalk chatbot on the DingTalk Chatbot tab of the Notification Settings page.
     *
     * @param request - DeleteDingTalkRequest
     *
     * @returns DeleteDingTalkResponse
     *
     * @param DeleteDingTalkRequest $request
     *
     * @return DeleteDingTalkResponse
     */
    public function deleteDingTalk($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteDingTalkWithOptions($request, $runtime);
    }

    /**
     * Deletes core file monitoring rules.
     *
     * @param request - DeleteFileProtectRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteFileProtectRuleResponse
     *
     * @param DeleteFileProtectRuleRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DeleteFileProtectRuleResponse
     */
    public function deleteFileProtectRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteFileProtectRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteFileProtectRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes core file monitoring rules.
     *
     * @param request - DeleteFileProtectRuleRequest
     *
     * @returns DeleteFileProtectRuleResponse
     *
     * @param DeleteFileProtectRuleRequest $request
     *
     * @return DeleteFileProtectRuleResponse
     */
    public function deleteFileProtectRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteFileProtectRuleWithOptions($request, $runtime);
    }

    /**
     * Deletes a server group.
     *
     * @remarks
     * The **Default** server group that is provided by Security Center cannot be deleted. After you delete a group, the assets in this group are moved to the **Default** group.
     *
     * @param request - DeleteGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteGroupResponse
     *
     * @param DeleteGroupRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return DeleteGroupResponse
     */
    public function deleteGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteGroup',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a server group.
     *
     * @remarks
     * The **Default** server group that is provided by Security Center cannot be deleted. After you delete a group, the assets in this group are moved to the **Default** group.
     *
     * @param request - DeleteGroupRequest
     *
     * @returns DeleteGroupResponse
     *
     * @param DeleteGroupRequest $request
     *
     * @return DeleteGroupResponse
     */
    public function deleteGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteGroupWithOptions($request, $runtime);
    }

    /**
     * Deletes a specified honeypot.
     *
     * @param request - DeleteHoneypotRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteHoneypotResponse
     *
     * @param DeleteHoneypotRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return DeleteHoneypotResponse
     */
    public function deleteHoneypotWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->honeypotId) {
            @$query['HoneypotId'] = $request->honeypotId;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteHoneypot',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteHoneypotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a specified honeypot.
     *
     * @param request - DeleteHoneypotRequest
     *
     * @returns DeleteHoneypotResponse
     *
     * @param DeleteHoneypotRequest $request
     *
     * @return DeleteHoneypotResponse
     */
    public function deleteHoneypot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteHoneypotWithOptions($request, $runtime);
    }

    /**
     * Deletes a specified management node.
     *
     * @param request - DeleteHoneypotNodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteHoneypotNodeResponse
     *
     * @param DeleteHoneypotNodeRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return DeleteHoneypotNodeResponse
     */
    public function deleteHoneypotNodeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->nodeId) {
            @$query['NodeId'] = $request->nodeId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteHoneypotNode',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteHoneypotNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a specified management node.
     *
     * @param request - DeleteHoneypotNodeRequest
     *
     * @returns DeleteHoneypotNodeResponse
     *
     * @param DeleteHoneypotNodeRequest $request
     *
     * @return DeleteHoneypotNodeResponse
     */
    public function deleteHoneypotNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteHoneypotNodeWithOptions($request, $runtime);
    }

    /**
     * Deletes a specified honeypot template.
     *
     * @param request - DeleteHoneypotPresetRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteHoneypotPresetResponse
     *
     * @param DeleteHoneypotPresetRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DeleteHoneypotPresetResponse
     */
    public function deleteHoneypotPresetWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->honeypotPresetId) {
            @$query['HoneypotPresetId'] = $request->honeypotPresetId;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteHoneypotPreset',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteHoneypotPresetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a specified honeypot template.
     *
     * @param request - DeleteHoneypotPresetRequest
     *
     * @returns DeleteHoneypotPresetResponse
     *
     * @param DeleteHoneypotPresetRequest $request
     *
     * @return DeleteHoneypotPresetResponse
     */
    public function deleteHoneypotPreset($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteHoneypotPresetWithOptions($request, $runtime);
    }

    /**
     * Deletes a specified probe.
     *
     * @param request - DeleteHoneypotProbeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteHoneypotProbeResponse
     *
     * @param DeleteHoneypotProbeRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DeleteHoneypotProbeResponse
     */
    public function deleteHoneypotProbeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->probeId) {
            @$query['ProbeId'] = $request->probeId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteHoneypotProbe',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteHoneypotProbeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a specified probe.
     *
     * @param request - DeleteHoneypotProbeRequest
     *
     * @returns DeleteHoneypotProbeResponse
     *
     * @param DeleteHoneypotProbeRequest $request
     *
     * @return DeleteHoneypotProbeResponse
     */
    public function deleteHoneypotProbe($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteHoneypotProbeWithOptions($request, $runtime);
    }

    /**
     * Delete the probe service.
     *
     * @param request - DeleteHoneypotProbeBindRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteHoneypotProbeBindResponse
     *
     * @param DeleteHoneypotProbeBindRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DeleteHoneypotProbeBindResponse
     */
    public function deleteHoneypotProbeBindWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bindId) {
            @$query['BindId'] = $request->bindId;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->probeId) {
            @$query['ProbeId'] = $request->probeId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteHoneypotProbeBind',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteHoneypotProbeBindResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Delete the probe service.
     *
     * @param request - DeleteHoneypotProbeBindRequest
     *
     * @returns DeleteHoneypotProbeBindResponse
     *
     * @param DeleteHoneypotProbeBindRequest $request
     *
     * @return DeleteHoneypotProbeBindResponse
     */
    public function deleteHoneypotProbeBind($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteHoneypotProbeBindWithOptions($request, $runtime);
    }

    /**
     * Removes a proxy node from a specified proxy cluster.
     *
     * @param request - DeleteHybridProxyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteHybridProxyResponse
     *
     * @param DeleteHybridProxyRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return DeleteHybridProxyResponse
     */
    public function deleteHybridProxyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterName) {
            @$query['ClusterName'] = $request->clusterName;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteHybridProxy',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteHybridProxyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Removes a proxy node from a specified proxy cluster.
     *
     * @param request - DeleteHybridProxyRequest
     *
     * @returns DeleteHybridProxyResponse
     *
     * @param DeleteHybridProxyRequest $request
     *
     * @return DeleteHybridProxyResponse
     */
    public function deleteHybridProxy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteHybridProxyWithOptions($request, $runtime);
    }

    /**
     * Deletes a proxy cluster based on the name of the proxy cluster.
     *
     * @param request - DeleteHybridProxyClusterRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteHybridProxyClusterResponse
     *
     * @param DeleteHybridProxyClusterRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DeleteHybridProxyClusterResponse
     */
    public function deleteHybridProxyClusterWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterName) {
            @$query['ClusterName'] = $request->clusterName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteHybridProxyCluster',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteHybridProxyClusterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a proxy cluster based on the name of the proxy cluster.
     *
     * @param request - DeleteHybridProxyClusterRequest
     *
     * @returns DeleteHybridProxyClusterResponse
     *
     * @param DeleteHybridProxyClusterRequest $request
     *
     * @return DeleteHybridProxyClusterResponse
     */
    public function deleteHybridProxyCluster($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteHybridProxyClusterWithOptions($request, $runtime);
    }

    /**
     * Deletes an IDC probe that is created in Security Center.
     *
     * @param request - DeleteIdcProbeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteIdcProbeResponse
     *
     * @param DeleteIdcProbeRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return DeleteIdcProbeResponse
     */
    public function deleteIdcProbeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteIdcProbe',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteIdcProbeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an IDC probe that is created in Security Center.
     *
     * @param request - DeleteIdcProbeRequest
     *
     * @returns DeleteIdcProbeResponse
     *
     * @param DeleteIdcProbeRequest $request
     *
     * @return DeleteIdcProbeResponse
     */
    public function deleteIdcProbe($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteIdcProbeWithOptions($request, $runtime);
    }

    /**
     * Deletes an alert handling rule.
     *
     * @param request - DeleteImageEventOperationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteImageEventOperationResponse
     *
     * @param DeleteImageEventOperationRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DeleteImageEventOperationResponse
     */
    public function deleteImageEventOperationWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteImageEventOperation',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteImageEventOperationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an alert handling rule.
     *
     * @param request - DeleteImageEventOperationRequest
     *
     * @returns DeleteImageEventOperationResponse
     *
     * @param DeleteImageEventOperationRequest $request
     *
     * @return DeleteImageEventOperationResponse
     */
    public function deleteImageEventOperation($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteImageEventOperationWithOptions($request, $runtime);
    }

    /**
     * Deletes an image vulnerability whitelist.
     *
     * @param request - DeleteImageVulWhitelistRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteImageVulWhitelistResponse
     *
     * @param DeleteImageVulWhitelistRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DeleteImageVulWhitelistResponse
     */
    public function deleteImageVulWhitelistWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ids) {
            @$query['Ids'] = $request->ids;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteImageVulWhitelist',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteImageVulWhitelistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an image vulnerability whitelist.
     *
     * @param request - DeleteImageVulWhitelistRequest
     *
     * @returns DeleteImageVulWhitelistResponse
     *
     * @param DeleteImageVulWhitelistRequest $request
     *
     * @return DeleteImageVulWhitelistResponse
     */
    public function deleteImageVulWhitelist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteImageVulWhitelistWithOptions($request, $runtime);
    }

    /**
     * Deletes the command that is used to install the Security Center agent.
     *
     * @param request - DeleteInstallCodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteInstallCodeResponse
     *
     * @param DeleteInstallCodeRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return DeleteInstallCodeResponse
     */
    public function deleteInstallCodeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->captchaCode) {
            @$query['CaptchaCode'] = $request->captchaCode;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteInstallCode',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteInstallCodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the command that is used to install the Security Center agent.
     *
     * @param request - DeleteInstallCodeRequest
     *
     * @returns DeleteInstallCodeResponse
     *
     * @param DeleteInstallCodeRequest $request
     *
     * @return DeleteInstallCodeResponse
     */
    public function deleteInstallCode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteInstallCodeWithOptions($request, $runtime);
    }

    /**
     * Deletes a defense rule in the container firewall module.
     *
     * @param request - DeleteInterceptionRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteInterceptionRuleResponse
     *
     * @param DeleteInterceptionRuleRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DeleteInterceptionRuleResponse
     */
    public function deleteInterceptionRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->ruleIds) {
            @$query['RuleIds'] = $request->ruleIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteInterceptionRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteInterceptionRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a defense rule in the container firewall module.
     *
     * @param request - DeleteInterceptionRuleRequest
     *
     * @returns DeleteInterceptionRuleResponse
     *
     * @param DeleteInterceptionRuleRequest $request
     *
     * @return DeleteInterceptionRuleResponse
     */
    public function deleteInterceptionRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteInterceptionRuleWithOptions($request, $runtime);
    }

    /**
     * Removes the network objects that are in effect in the container firewall.
     *
     * @param request - DeleteInterceptionTargetRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteInterceptionTargetResponse
     *
     * @param DeleteInterceptionTargetRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DeleteInterceptionTargetResponse
     */
    public function deleteInterceptionTargetWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->targetIds) {
            @$query['TargetIds'] = $request->targetIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteInterceptionTarget',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteInterceptionTargetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Removes the network objects that are in effect in the container firewall.
     *
     * @param request - DeleteInterceptionTargetRequest
     *
     * @returns DeleteInterceptionTargetResponse
     *
     * @param DeleteInterceptionTargetRequest $request
     *
     * @return DeleteInterceptionTargetResponse
     */
    public function deleteInterceptionTarget($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteInterceptionTargetWithOptions($request, $runtime);
    }

    /**
     * Deletes the Kubernetes access information.
     *
     * @param request - DeleteK8sAccessInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteK8sAccessInfoResponse
     *
     * @param DeleteK8sAccessInfoRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DeleteK8sAccessInfoResponse
     */
    public function deleteK8sAccessInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aliyunYundunGatewayApiName) {
            @$query['AliyunYundunGatewayApiName'] = $request->aliyunYundunGatewayApiName;
        }

        if (null !== $request->aliyunYundunGatewayPopName) {
            @$query['AliyunYundunGatewayPopName'] = $request->aliyunYundunGatewayPopName;
        }

        if (null !== $request->aliyunYundunGatewayProjectName) {
            @$query['AliyunYundunGatewayProjectName'] = $request->aliyunYundunGatewayProjectName;
        }

        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteK8sAccessInfo',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteK8sAccessInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the Kubernetes access information.
     *
     * @param request - DeleteK8sAccessInfoRequest
     *
     * @returns DeleteK8sAccessInfoResponse
     *
     * @param DeleteK8sAccessInfoRequest $request
     *
     * @return DeleteK8sAccessInfoResponse
     */
    public function deleteK8sAccessInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteK8sAccessInfoWithOptions($request, $runtime);
    }

    /**
     * Deletes the basic configuration information from the logon security configurations for a specific asset.
     *
     * @param request - DeleteLoginBaseConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLoginBaseConfigResponse
     *
     * @param DeleteLoginBaseConfigRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DeleteLoginBaseConfigResponse
     */
    public function deleteLoginBaseConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->config) {
            @$query['Config'] = $request->config;
        }

        if (null !== $request->target) {
            @$query['Target'] = $request->target;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLoginBaseConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLoginBaseConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the basic configuration information from the logon security configurations for a specific asset.
     *
     * @param request - DeleteLoginBaseConfigRequest
     *
     * @returns DeleteLoginBaseConfigResponse
     *
     * @param DeleteLoginBaseConfigRequest $request
     *
     * @return DeleteLoginBaseConfigResponse
     */
    public function deleteLoginBaseConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLoginBaseConfigWithOptions($request, $runtime);
    }

    /**
     * Deletes a whitelist rule for alerts generated for sensitive files that are detected by using the agentless detection feature.
     *
     * @param request - DeleteMaliciousFileWhitelistConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteMaliciousFileWhitelistConfigResponse
     *
     * @param DeleteMaliciousFileWhitelistConfigRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return DeleteMaliciousFileWhitelistConfigResponse
     */
    public function deleteMaliciousFileWhitelistConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->configId) {
            @$query['ConfigId'] = $request->configId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteMaliciousFileWhitelistConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteMaliciousFileWhitelistConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a whitelist rule for alerts generated for sensitive files that are detected by using the agentless detection feature.
     *
     * @param request - DeleteMaliciousFileWhitelistConfigRequest
     *
     * @returns DeleteMaliciousFileWhitelistConfigResponse
     *
     * @param DeleteMaliciousFileWhitelistConfigRequest $request
     *
     * @return DeleteMaliciousFileWhitelistConfigResponse
     */
    public function deleteMaliciousFileWhitelistConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteMaliciousFileWhitelistConfigWithOptions($request, $runtime);
    }

    /**
     * Removes the remarks added to alert events that are generated by the agentless detection feature.
     *
     * @param request - DeleteMaliciousNoteRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteMaliciousNoteResponse
     *
     * @param DeleteMaliciousNoteRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DeleteMaliciousNoteResponse
     */
    public function deleteMaliciousNoteWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->noteId) {
            @$query['NoteId'] = $request->noteId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteMaliciousNote',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteMaliciousNoteResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Removes the remarks added to alert events that are generated by the agentless detection feature.
     *
     * @param request - DeleteMaliciousNoteRequest
     *
     * @returns DeleteMaliciousNoteResponse
     *
     * @param DeleteMaliciousNoteRequest $request
     *
     * @return DeleteMaliciousNoteResponse
     */
    public function deleteMaliciousNote($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteMaliciousNoteWithOptions($request, $runtime);
    }

    /**
     * Deletes a member of the account managed by Security Center type of the multi-account management feature.
     *
     * @remarks
     * You must use the management account of your resource directory or a delegated administrator account of Security Center to call this operation.
     *
     * @param request - DeleteMonitorAccountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteMonitorAccountResponse
     *
     * @param DeleteMonitorAccountRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DeleteMonitorAccountResponse
     */
    public function deleteMonitorAccountWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accountId) {
            @$query['AccountId'] = $request->accountId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteMonitorAccount',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteMonitorAccountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a member of the account managed by Security Center type of the multi-account management feature.
     *
     * @remarks
     * You must use the management account of your resource directory or a delegated administrator account of Security Center to call this operation.
     *
     * @param request - DeleteMonitorAccountRequest
     *
     * @returns DeleteMonitorAccountResponse
     *
     * @param DeleteMonitorAccountRequest $request
     *
     * @return DeleteMonitorAccountResponse
     */
    public function deleteMonitorAccount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteMonitorAccountWithOptions($request, $runtime);
    }

    /**
     * Deletes rules of the at-risk image blocking type.
     *
     * @param request - DeleteOpaStrategyNewRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteOpaStrategyNewResponse
     *
     * @param DeleteOpaStrategyNewRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DeleteOpaStrategyNewResponse
     */
    public function deleteOpaStrategyNewWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->strategyIds) {
            @$query['StrategyIds'] = $request->strategyIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteOpaStrategyNew',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteOpaStrategyNewResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes rules of the at-risk image blocking type.
     *
     * @param request - DeleteOpaStrategyNewRequest
     *
     * @returns DeleteOpaStrategyNewResponse
     *
     * @param DeleteOpaStrategyNewRequest $request
     *
     * @return DeleteOpaStrategyNewResponse
     */
    public function deleteOpaStrategyNew($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteOpaStrategyNewWithOptions($request, $runtime);
    }

    /**
     * Deletes the configuration of an Object Storage Service (OSS) file detection policy.
     *
     * @param request - DeleteOssScanConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteOssScanConfigResponse
     *
     * @param DeleteOssScanConfigRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DeleteOssScanConfigResponse
     */
    public function deleteOssScanConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteOssScanConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteOssScanConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the configuration of an Object Storage Service (OSS) file detection policy.
     *
     * @param request - DeleteOssScanConfigRequest
     *
     * @returns DeleteOssScanConfigResponse
     *
     * @param DeleteOssScanConfigRequest $request
     *
     * @return DeleteOssScanConfigResponse
     */
    public function deleteOssScanConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteOssScanConfigWithOptions($request, $runtime);
    }

    /**
     * Deletes a private image repository by using the ID of the image repository.
     *
     * @param request - DeletePrivateRegistryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeletePrivateRegistryResponse
     *
     * @param DeletePrivateRegistryRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DeletePrivateRegistryResponse
     */
    public function deletePrivateRegistryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->registryId) {
            @$query['RegistryId'] = $request->registryId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeletePrivateRegistry',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeletePrivateRegistryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a private image repository by using the ID of the image repository.
     *
     * @param request - DeletePrivateRegistryRequest
     *
     * @returns DeletePrivateRegistryResponse
     *
     * @param DeletePrivateRegistryRequest $request
     *
     * @return DeletePrivateRegistryResponse
     */
    public function deletePrivateRegistry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deletePrivateRegistryWithOptions($request, $runtime);
    }

    /**
     * Deletes a rule for container tamper-proofing.
     *
     * @param request - DeleteSasContainerWebDefenseRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteSasContainerWebDefenseRuleResponse
     *
     * @param DeleteSasContainerWebDefenseRuleRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return DeleteSasContainerWebDefenseRuleResponse
     */
    public function deleteSasContainerWebDefenseRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ruleId) {
            @$query['RuleId'] = $request->ruleId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteSasContainerWebDefenseRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteSasContainerWebDefenseRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a rule for container tamper-proofing.
     *
     * @param request - DeleteSasContainerWebDefenseRuleRequest
     *
     * @returns DeleteSasContainerWebDefenseRuleResponse
     *
     * @param DeleteSasContainerWebDefenseRuleRequest $request
     *
     * @return DeleteSasContainerWebDefenseRuleResponse
     */
    public function deleteSasContainerWebDefenseRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteSasContainerWebDefenseRuleWithOptions($request, $runtime);
    }

    /**
     * Deletes a frequently used search condition by using the asset management feature of the Assets module in the Security Center console.
     *
     * @param request - DeleteSearchConditionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteSearchConditionResponse
     *
     * @param DeleteSearchConditionRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DeleteSearchConditionResponse
     */
    public function deleteSearchConditionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteSearchCondition',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteSearchConditionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a frequently used search condition by using the asset management feature of the Assets module in the Security Center console.
     *
     * @param request - DeleteSearchConditionRequest
     *
     * @returns DeleteSearchConditionResponse
     *
     * @param DeleteSearchConditionRequest $request
     *
     * @return DeleteSearchConditionResponse
     */
    public function deleteSearchCondition($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteSearchConditionWithOptions($request, $runtime);
    }

    /**
     * Deletes multiple custom defense rules at a time. The custom defense rules are used to add false positive alerts to the whitelist.
     *
     * @deprecated openAPI DeleteSecurityEventMarkMissList is deprecated, please use Sas::2018-12-03::ModifySecurityEventMarkMissIndividually instead
     *
     * @param request - DeleteSecurityEventMarkMissListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteSecurityEventMarkMissListResponse
     *
     * @param DeleteSecurityEventMarkMissListRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return DeleteSecurityEventMarkMissListResponse
     */
    public function deleteSecurityEventMarkMissListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ids) {
            @$query['Ids'] = $request->ids;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteSecurityEventMarkMissList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteSecurityEventMarkMissListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Deletes multiple custom defense rules at a time. The custom defense rules are used to add false positive alerts to the whitelist.
     *
     * @deprecated openAPI DeleteSecurityEventMarkMissList is deprecated, please use Sas::2018-12-03::ModifySecurityEventMarkMissIndividually instead
     *
     * @param request - DeleteSecurityEventMarkMissListRequest
     *
     * @returns DeleteSecurityEventMarkMissListResponse
     *
     * @param DeleteSecurityEventMarkMissListRequest $request
     *
     * @return DeleteSecurityEventMarkMissListResponse
     */
    public function deleteSecurityEventMarkMissList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteSecurityEventMarkMissListWithOptions($request, $runtime);
    }

    /**
     * Deletes a service trail.
     *
     * @param request - DeleteServiceTrailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteServiceTrailResponse
     *
     * @param DeleteServiceTrailRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return DeleteServiceTrailResponse
     */
    public function deleteServiceTrailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteServiceTrail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteServiceTrailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a service trail.
     *
     * @param request - DeleteServiceTrailRequest
     *
     * @returns DeleteServiceTrailResponse
     *
     * @param DeleteServiceTrailRequest $request
     *
     * @return DeleteServiceTrailResponse
     */
    public function deleteServiceTrail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteServiceTrailWithOptions($request, $runtime);
    }

    /**
     * Deletes a policy task that is in the waiting state on the Playbook page.
     *
     * @remarks
     * Only the Enterprise and Ultimate editions of Security Center support this API operation.
     *
     * @param request - DeleteSoarStrategyTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteSoarStrategyTaskResponse
     *
     * @param DeleteSoarStrategyTaskRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DeleteSoarStrategyTaskResponse
     */
    public function deleteSoarStrategyTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->strategyTaskId) {
            @$query['StrategyTaskId'] = $request->strategyTaskId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteSoarStrategyTask',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteSoarStrategyTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a policy task that is in the waiting state on the Playbook page.
     *
     * @remarks
     * Only the Enterprise and Ultimate editions of Security Center support this API operation.
     *
     * @param request - DeleteSoarStrategyTaskRequest
     *
     * @returns DeleteSoarStrategyTaskResponse
     *
     * @param DeleteSoarStrategyTaskRequest $request
     *
     * @return DeleteSoarStrategyTaskResponse
     */
    public function deleteSoarStrategyTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteSoarStrategyTaskWithOptions($request, $runtime);
    }

    /**
     * Deletes a baseline check policy.
     *
     * @param request - DeleteStrategyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteStrategyResponse
     *
     * @param DeleteStrategyRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return DeleteStrategyResponse
     */
    public function deleteStrategyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteStrategy',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteStrategyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a baseline check policy.
     *
     * @param request - DeleteStrategyRequest
     *
     * @returns DeleteStrategyResponse
     *
     * @param DeleteStrategyRequest $request
     *
     * @return DeleteStrategyResponse
     */
    public function deleteStrategy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteStrategyWithOptions($request, $runtime);
    }

    /**
     * Deletes the description of an alert.
     *
     * @param request - DeleteSuspEventNodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteSuspEventNodeResponse
     *
     * @param DeleteSuspEventNodeRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DeleteSuspEventNodeResponse
     */
    public function deleteSuspEventNodeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->noteId) {
            @$query['NoteId'] = $request->noteId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteSuspEventNode',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteSuspEventNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the description of an alert.
     *
     * @param request - DeleteSuspEventNodeRequest
     *
     * @returns DeleteSuspEventNodeResponse
     *
     * @param DeleteSuspEventNodeRequest $request
     *
     * @return DeleteSuspEventNodeResponse
     */
    public function deleteSuspEventNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteSuspEventNodeWithOptions($request, $runtime);
    }

    /**
     * Removes custom tags from assets.
     *
     * @remarks
     * Security Center provides asset importance tags and custom tags. You can call this operation to remove only the custom tag that is added to an asset.
     *
     * @param request - DeleteTagWithUuidRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteTagWithUuidResponse
     *
     * @param DeleteTagWithUuidRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return DeleteTagWithUuidResponse
     */
    public function deleteTagWithUuidWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->tagName) {
            @$query['TagName'] = $request->tagName;
        }

        if (null !== $request->uuidList) {
            @$query['UuidList'] = $request->uuidList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteTagWithUuid',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteTagWithUuidResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Removes custom tags from assets.
     *
     * @remarks
     * Security Center provides asset importance tags and custom tags. You can call this operation to remove only the custom tag that is added to an asset.
     *
     * @param request - DeleteTagWithUuidRequest
     *
     * @returns DeleteTagWithUuidResponse
     *
     * @param DeleteTagWithUuidRequest $request
     *
     * @return DeleteTagWithUuidResponse
     */
    public function deleteTagWithUuid($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteTagWithUuidWithOptions($request, $runtime);
    }

    /**
     * Deletes anti-ransomware policies that are created for databases.
     *
     * @param request - DeleteUniBackupPolicyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteUniBackupPolicyResponse
     *
     * @param DeleteUniBackupPolicyRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DeleteUniBackupPolicyResponse
     */
    public function deleteUniBackupPolicyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->policyId) {
            @$query['PolicyId'] = $request->policyId;
        }

        if (null !== $request->policyIds) {
            @$query['PolicyIds'] = $request->policyIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteUniBackupPolicy',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteUniBackupPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes anti-ransomware policies that are created for databases.
     *
     * @param request - DeleteUniBackupPolicyRequest
     *
     * @returns DeleteUniBackupPolicyResponse
     *
     * @param DeleteUniBackupPolicyRequest $request
     *
     * @return DeleteUniBackupPolicyResponse
     */
    public function deleteUniBackupPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteUniBackupPolicyWithOptions($request, $runtime);
    }

    /**
     * Deletes a honeypot.
     *
     * @param request - DeleteVpcHoneyPotRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteVpcHoneyPotResponse
     *
     * @param DeleteVpcHoneyPotRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return DeleteVpcHoneyPotResponse
     */
    public function deleteVpcHoneyPotWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteVpcHoneyPot',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteVpcHoneyPotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a honeypot.
     *
     * @param request - DeleteVpcHoneyPotRequest
     *
     * @returns DeleteVpcHoneyPotResponse
     *
     * @param DeleteVpcHoneyPotRequest $request
     *
     * @return DeleteVpcHoneyPotResponse
     */
    public function deleteVpcHoneyPot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVpcHoneyPotWithOptions($request, $runtime);
    }

    /**
     * Deletes configurations of of an automatic vulnerability fixing task at a time on the Playbook page.
     *
     * @param request - DeleteVulAutoRepairConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteVulAutoRepairConfigResponse
     *
     * @param DeleteVulAutoRepairConfigRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DeleteVulAutoRepairConfigResponse
     */
    public function deleteVulAutoRepairConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aliasName) {
            @$query['AliasName'] = $request->aliasName;
        }

        if (null !== $request->configIdList) {
            @$query['ConfigIdList'] = $request->configIdList;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteVulAutoRepairConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteVulAutoRepairConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes configurations of of an automatic vulnerability fixing task at a time on the Playbook page.
     *
     * @param request - DeleteVulAutoRepairConfigRequest
     *
     * @returns DeleteVulAutoRepairConfigResponse
     *
     * @param DeleteVulAutoRepairConfigRequest $request
     *
     * @return DeleteVulAutoRepairConfigResponse
     */
    public function deleteVulAutoRepairConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVulAutoRepairConfigWithOptions($request, $runtime);
    }

    /**
     * Deletes a specified vulnerability whitelist.
     *
     * @param request - DeleteVulWhitelistRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteVulWhitelistResponse
     *
     * @param DeleteVulWhitelistRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return DeleteVulWhitelistResponse
     */
    public function deleteVulWhitelistWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        if (null !== $request->whitelist) {
            @$query['Whitelist'] = $request->whitelist;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteVulWhitelist',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteVulWhitelistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a specified vulnerability whitelist.
     *
     * @param request - DeleteVulWhitelistRequest
     *
     * @returns DeleteVulWhitelistResponse
     *
     * @param DeleteVulWhitelistRequest $request
     *
     * @return DeleteVulWhitelistResponse
     */
    public function deleteVulWhitelist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVulWhitelistWithOptions($request, $runtime);
    }

    /**
     * Queries the overview of user AI assets.
     *
     * @param request - DescribeAIAssetSummaryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAIAssetSummaryResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeAIAssetSummaryResponse
     */
    public function describeAIAssetSummaryWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeAIAssetSummary',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAIAssetSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the overview of user AI assets.
     *
     * @returns DescribeAIAssetSummaryResponse
     *
     * @return DescribeAIAssetSummaryResponse
     */
    public function describeAIAssetSummary()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAIAssetSummaryWithOptions($runtime);
    }

    /**
     * Queries the details of AccessKey pair leaks.
     *
     * @param request - DescribeAccessKeyLeakDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAccessKeyLeakDetailResponse
     *
     * @param DescribeAccessKeyLeakDetailRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeAccessKeyLeakDetailResponse
     */
    public function describeAccessKeyLeakDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeAccessKeyLeakDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAccessKeyLeakDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of AccessKey pair leaks.
     *
     * @param request - DescribeAccessKeyLeakDetailRequest
     *
     * @returns DescribeAccessKeyLeakDetailResponse
     *
     * @param DescribeAccessKeyLeakDetailRequest $request
     *
     * @return DescribeAccessKeyLeakDetailResponse
     */
    public function describeAccessKeyLeakDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAccessKeyLeakDetailWithOptions($request, $runtime);
    }

    /**
     * Queries the AccessKey pair leaks that are detected on your assets.
     *
     * @param request - DescribeAccesskeyLeakListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAccesskeyLeakListResponse
     *
     * @param DescribeAccesskeyLeakListRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeAccesskeyLeakListResponse
     */
    public function describeAccesskeyLeakListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->query) {
            @$query['Query'] = $request->query;
        }

        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        if (null !== $request->startTs) {
            @$query['StartTs'] = $request->startTs;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeAccesskeyLeakList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAccesskeyLeakListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the AccessKey pair leaks that are detected on your assets.
     *
     * @param request - DescribeAccesskeyLeakListRequest
     *
     * @returns DescribeAccesskeyLeakListResponse
     *
     * @param DescribeAccesskeyLeakListRequest $request
     *
     * @return DescribeAccesskeyLeakListResponse
     */
    public function describeAccesskeyLeakList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAccesskeyLeakListWithOptions($request, $runtime);
    }

    /**
     * Queries the affected servers in the result of a virus scan task.
     *
     * @param request - DescribeAffectedAssetsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAffectedAssetsResponse
     *
     * @param DescribeAffectedAssetsRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DescribeAffectedAssetsResponse
     */
    public function describeAffectedAssetsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->current) {
            @$query['Current'] = $request->current;
        }

        if (null !== $request->levels) {
            @$query['Levels'] = $request->levels;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeAffectedAssets',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAffectedAssetsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the affected servers in the result of a virus scan task.
     *
     * @param request - DescribeAffectedAssetsRequest
     *
     * @returns DescribeAffectedAssetsResponse
     *
     * @param DescribeAffectedAssetsRequest $request
     *
     * @return DescribeAffectedAssetsResponse
     */
    public function describeAffectedAssets($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAffectedAssetsWithOptions($request, $runtime);
    }

    /**
     * Queries the details of malicious image samples.
     *
     * @param request - DescribeAffectedMaliciousFileImagesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAffectedMaliciousFileImagesResponse
     *
     * @param DescribeAffectedMaliciousFileImagesRequest $request
     * @param RuntimeOptions                             $runtime
     *
     * @return DescribeAffectedMaliciousFileImagesResponse
     */
    public function describeAffectedMaliciousFileImagesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->clusterName) {
            @$query['ClusterName'] = $request->clusterName;
        }

        if (null !== $request->containerId) {
            @$query['ContainerId'] = $request->containerId;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->image) {
            @$query['Image'] = $request->image;
        }

        if (null !== $request->imageDigest) {
            @$query['ImageDigest'] = $request->imageDigest;
        }

        if (null !== $request->imageLayer) {
            @$query['ImageLayer'] = $request->imageLayer;
        }

        if (null !== $request->imageTag) {
            @$query['ImageTag'] = $request->imageTag;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->levels) {
            @$query['Levels'] = $request->levels;
        }

        if (null !== $request->maliciousMd5) {
            @$query['MaliciousMd5'] = $request->maliciousMd5;
        }

        if (null !== $request->namespace) {
            @$query['Namespace'] = $request->namespace;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->pod) {
            @$query['Pod'] = $request->pod;
        }

        if (null !== $request->repoId) {
            @$query['RepoId'] = $request->repoId;
        }

        if (null !== $request->repoInstanceId) {
            @$query['RepoInstanceId'] = $request->repoInstanceId;
        }

        if (null !== $request->repoName) {
            @$query['RepoName'] = $request->repoName;
        }

        if (null !== $request->repoNamespace) {
            @$query['RepoNamespace'] = $request->repoNamespace;
        }

        if (null !== $request->repoRegionId) {
            @$query['RepoRegionId'] = $request->repoRegionId;
        }

        if (null !== $request->scanRange) {
            @$query['ScanRange'] = $request->scanRange;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeAffectedMaliciousFileImages',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAffectedMaliciousFileImagesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of malicious image samples.
     *
     * @param request - DescribeAffectedMaliciousFileImagesRequest
     *
     * @returns DescribeAffectedMaliciousFileImagesResponse
     *
     * @param DescribeAffectedMaliciousFileImagesRequest $request
     *
     * @return DescribeAffectedMaliciousFileImagesResponse
     */
    public function describeAffectedMaliciousFileImages($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAffectedMaliciousFileImagesWithOptions($request, $runtime);
    }

    /**
     * Queries the installation status of the Security Center agent after you run an installation command by using Cloud Assistant. You can call this operation to query the installation status only if the installation request is initiated within 2 minutes.
     *
     * @param request - DescribeAgentInstallStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAgentInstallStatusResponse
     *
     * @param DescribeAgentInstallStatusRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeAgentInstallStatusResponse
     */
    public function describeAgentInstallStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeAgentInstallStatus',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAgentInstallStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the installation status of the Security Center agent after you run an installation command by using Cloud Assistant. You can call this operation to query the installation status only if the installation request is initiated within 2 minutes.
     *
     * @param request - DescribeAgentInstallStatusRequest
     *
     * @returns DescribeAgentInstallStatusResponse
     *
     * @param DescribeAgentInstallStatusRequest $request
     *
     * @return DescribeAgentInstallStatusResponse
     */
    public function describeAgentInstallStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAgentInstallStatusWithOptions($request, $runtime);
    }

    /**
     * Queries the list of assets on which a specific type of sensitive files are detected by using the agentless detection feature.
     *
     * @remarks
     * You can call this operation only when the agentless detection feature is purchased by using the pay-as-you-go billing method within your Alibaba Cloud account.
     *
     * @param tmpReq - DescribeAgentlessSensitiveFileByKeyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAgentlessSensitiveFileByKeyResponse
     *
     * @param DescribeAgentlessSensitiveFileByKeyRequest $tmpReq
     * @param RuntimeOptions                             $runtime
     *
     * @return DescribeAgentlessSensitiveFileByKeyResponse
     */
    public function describeAgentlessSensitiveFileByKeyWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new DescribeAgentlessSensitiveFileByKeyShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->scanRange) {
            $request->scanRangeShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->scanRange, 'ScanRange', 'json');
        }

        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeAgentlessSensitiveFileByKey',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAgentlessSensitiveFileByKeyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the list of assets on which a specific type of sensitive files are detected by using the agentless detection feature.
     *
     * @remarks
     * You can call this operation only when the agentless detection feature is purchased by using the pay-as-you-go billing method within your Alibaba Cloud account.
     *
     * @param request - DescribeAgentlessSensitiveFileByKeyRequest
     *
     * @returns DescribeAgentlessSensitiveFileByKeyResponse
     *
     * @param DescribeAgentlessSensitiveFileByKeyRequest $request
     *
     * @return DescribeAgentlessSensitiveFileByKeyResponse
     */
    public function describeAgentlessSensitiveFileByKey($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAgentlessSensitiveFileByKeyWithOptions($request, $runtime);
    }

    /**
     * Queries the details of an alert event. An alert event consists of alerts and exceptions. Each alert event is associated with multiple exceptions.
     *
     * @param request - DescribeAlarmEventDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAlarmEventDetailResponse
     *
     * @param DescribeAlarmEventDetailRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeAlarmEventDetailResponse
     */
    public function describeAlarmEventDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->alarmUniqueInfo) {
            @$query['AlarmUniqueInfo'] = $request->alarmUniqueInfo;
        }

        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeAlarmEventDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAlarmEventDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of an alert event. An alert event consists of alerts and exceptions. Each alert event is associated with multiple exceptions.
     *
     * @param request - DescribeAlarmEventDetailRequest
     *
     * @returns DescribeAlarmEventDetailResponse
     *
     * @param DescribeAlarmEventDetailRequest $request
     *
     * @return DescribeAlarmEventDetailResponse
     */
    public function describeAlarmEventDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAlarmEventDetailWithOptions($request, $runtime);
    }

    /**
     * Queries the stack information about an alert event.
     *
     * @deprecated OpenAPI DescribeAlarmEventStackInfo is deprecated
     *
     * @param request - DescribeAlarmEventStackInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAlarmEventStackInfoResponse
     *
     * @param DescribeAlarmEventStackInfoRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeAlarmEventStackInfoResponse
     */
    public function describeAlarmEventStackInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->eventName) {
            @$query['EventName'] = $request->eventName;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->uniqueInfo) {
            @$query['UniqueInfo'] = $request->uniqueInfo;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeAlarmEventStackInfo',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAlarmEventStackInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Queries the stack information about an alert event.
     *
     * @deprecated OpenAPI DescribeAlarmEventStackInfo is deprecated
     *
     * @param request - DescribeAlarmEventStackInfoRequest
     *
     * @returns DescribeAlarmEventStackInfoResponse
     *
     * @param DescribeAlarmEventStackInfoRequest $request
     *
     * @return DescribeAlarmEventStackInfoResponse
     */
    public function describeAlarmEventStackInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAlarmEventStackInfoWithOptions($request, $runtime);
    }

    /**
     * Queries the information about all server assets, including the asset group IDs and asset names.
     *
     * @param request - DescribeAllEntityRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAllEntityResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeAllEntityResponse
     */
    public function describeAllEntityWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeAllEntity',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAllEntityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about all server assets, including the asset group IDs and asset names.
     *
     * @returns DescribeAllEntityResponse
     *
     * @return DescribeAllEntityResponse
     */
    public function describeAllEntity()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAllEntityWithOptions($runtime);
    }

    /**
     * Queries the information about all server groups.
     *
     * @param request - DescribeAllGroupsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAllGroupsResponse
     *
     * @param DescribeAllGroupsRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return DescribeAllGroupsResponse
     */
    public function describeAllGroupsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeAllGroups',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAllGroupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about all server groups.
     *
     * @param request - DescribeAllGroupsRequest
     *
     * @returns DescribeAllGroupsResponse
     *
     * @param DescribeAllGroupsRequest $request
     *
     * @return DescribeAllGroupsResponse
     */
    public function describeAllGroups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAllGroupsWithOptions($request, $runtime);
    }

    /**
     * Queries baselines that are used in image baseline checks.
     *
     * @param request - DescribeAllImageBaselineRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAllImageBaselineResponse
     *
     * @param DescribeAllImageBaselineRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeAllImageBaselineResponse
     */
    public function describeAllImageBaselineWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeAllImageBaseline',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAllImageBaselineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries baselines that are used in image baseline checks.
     *
     * @param request - DescribeAllImageBaselineRequest
     *
     * @returns DescribeAllImageBaselineResponse
     *
     * @param DescribeAllImageBaselineRequest $request
     *
     * @return DescribeAllImageBaselineResponse
     */
    public function describeAllImageBaseline($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAllImageBaselineWithOptions($request, $runtime);
    }

    /**
     * Queries the statistics on global security events, including the numbers of unfixed vulnerabilities, baseline risks, and alerts.
     *
     * @param request - DescribeAllRegionsStatisticsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAllRegionsStatisticsResponse
     *
     * @param DescribeAllRegionsStatisticsRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribeAllRegionsStatisticsResponse
     */
    public function describeAllRegionsStatisticsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeAllRegionsStatistics',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAllRegionsStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics on global security events, including the numbers of unfixed vulnerabilities, baseline risks, and alerts.
     *
     * @param request - DescribeAllRegionsStatisticsRequest
     *
     * @returns DescribeAllRegionsStatisticsResponse
     *
     * @param DescribeAllRegionsStatisticsRequest $request
     *
     * @return DescribeAllRegionsStatisticsResponse
     */
    public function describeAllRegionsStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAllRegionsStatisticsWithOptions($request, $runtime);
    }

    /**
     * Queries created defense rules against brute-force attacks.
     *
     * @param request - DescribeAntiBruteForceRulesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAntiBruteForceRulesResponse
     *
     * @param DescribeAntiBruteForceRulesRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeAntiBruteForceRulesResponse
     */
    public function describeAntiBruteForceRulesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeAntiBruteForceRules',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAntiBruteForceRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries created defense rules against brute-force attacks.
     *
     * @param request - DescribeAntiBruteForceRulesRequest
     *
     * @returns DescribeAntiBruteForceRulesResponse
     *
     * @param DescribeAntiBruteForceRulesRequest $request
     *
     * @return DescribeAntiBruteForceRulesResponse
     */
    public function describeAntiBruteForceRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAntiBruteForceRulesWithOptions($request, $runtime);
    }

    /**
     * Queries the scan cycle for application vulnerabilities.
     *
     * @param request - DescribeAppVulScanCycleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAppVulScanCycleResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeAppVulScanCycleResponse
     */
    public function describeAppVulScanCycleWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeAppVulScanCycle',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAppVulScanCycleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the scan cycle for application vulnerabilities.
     *
     * @returns DescribeAppVulScanCycleResponse
     *
     * @return DescribeAppVulScanCycleResponse
     */
    public function describeAppVulScanCycle()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAppVulScanCycleWithOptions($runtime);
    }

    /**
     * Queries the details of a server and the extended information about the server by using the UUID of the server.
     *
     * @remarks
     * This operation will be discontinued soon. You must call the [GetAssetDetailByUuid](~~GetAssetDetailByUuid~~) operation to query the details of the server.
     *
     * @deprecated openAPI DescribeAssetDetailByUuid is deprecated, please use Sas::2018-12-03::GetAssetDetailByUuid instead
     *
     * @param request - DescribeAssetDetailByUuidRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAssetDetailByUuidResponse
     *
     * @param DescribeAssetDetailByUuidRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeAssetDetailByUuidResponse
     */
    public function describeAssetDetailByUuidWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeAssetDetailByUuid',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAssetDetailByUuidResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Queries the details of a server and the extended information about the server by using the UUID of the server.
     *
     * @remarks
     * This operation will be discontinued soon. You must call the [GetAssetDetailByUuid](~~GetAssetDetailByUuid~~) operation to query the details of the server.
     *
     * @deprecated openAPI DescribeAssetDetailByUuid is deprecated, please use Sas::2018-12-03::GetAssetDetailByUuid instead
     *
     * @param request - DescribeAssetDetailByUuidRequest
     *
     * @returns DescribeAssetDetailByUuidResponse
     *
     * @param DescribeAssetDetailByUuidRequest $request
     *
     * @return DescribeAssetDetailByUuidResponse
     */
    public function describeAssetDetailByUuid($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAssetDetailByUuidWithOptions($request, $runtime);
    }

    /**
     * Queries the details of Elastic Compute Service (ECS) instances.
     *
     * @param request - DescribeAssetDetailByUuidsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAssetDetailByUuidsResponse
     *
     * @param DescribeAssetDetailByUuidsRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeAssetDetailByUuidsResponse
     */
    public function describeAssetDetailByUuidsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeAssetDetailByUuids',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAssetDetailByUuidsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of Elastic Compute Service (ECS) instances.
     *
     * @param request - DescribeAssetDetailByUuidsRequest
     *
     * @returns DescribeAssetDetailByUuidsResponse
     *
     * @param DescribeAssetDetailByUuidsRequest $request
     *
     * @return DescribeAssetDetailByUuidsResponse
     */
    public function describeAssetDetailByUuids($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAssetDetailByUuidsWithOptions($request, $runtime);
    }

    /**
     * The ID of the request, which is used to locate and troubleshoot issues.
     *
     * @param request - DescribeAssetSummaryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAssetSummaryResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeAssetSummaryResponse
     */
    public function describeAssetSummaryWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeAssetSummary',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAssetSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * The ID of the request, which is used to locate and troubleshoot issues.
     *
     * @returns DescribeAssetSummaryResponse
     *
     * @return DescribeAssetSummaryResponse
     */
    public function describeAssetSummary()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAssetSummaryWithOptions($runtime);
    }

    /**
     * Queries the number of Java processes in an asset by using the asset fingerprints feature of Security Center.
     *
     * @param request - DescribeAssetsScaProcessNumRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAssetsScaProcessNumResponse
     *
     * @param DescribeAssetsScaProcessNumRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeAssetsScaProcessNumResponse
     */
    public function describeAssetsScaProcessNumWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bizType) {
            @$query['BizType'] = $request->bizType;
        }

        if (null !== $request->uuidList) {
            @$query['UuidList'] = $request->uuidList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeAssetsScaProcessNum',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAssetsScaProcessNumResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the number of Java processes in an asset by using the asset fingerprints feature of Security Center.
     *
     * @param request - DescribeAssetsScaProcessNumRequest
     *
     * @returns DescribeAssetsScaProcessNumResponse
     *
     * @param DescribeAssetsScaProcessNumRequest $request
     *
     * @return DescribeAssetsScaProcessNumResponse
     */
    public function describeAssetsScaProcessNum($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAssetsScaProcessNumWithOptions($request, $runtime);
    }

    /**
     * Queries the risk information about containers.
     *
     * @param request - DescribeAssetsSecurityEventSummaryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAssetsSecurityEventSummaryResponse
     *
     * @param DescribeAssetsSecurityEventSummaryRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return DescribeAssetsSecurityEventSummaryResponse
     */
    public function describeAssetsSecurityEventSummaryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->containerFieldName) {
            @$query['ContainerFieldName'] = $request->containerFieldName;
        }

        if (null !== $request->containerFieldValue) {
            @$query['ContainerFieldValue'] = $request->containerFieldValue;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeAssetsSecurityEventSummary',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAssetsSecurityEventSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the risk information about containers.
     *
     * @param request - DescribeAssetsSecurityEventSummaryRequest
     *
     * @returns DescribeAssetsSecurityEventSummaryResponse
     *
     * @param DescribeAssetsSecurityEventSummaryRequest $request
     *
     * @return DescribeAssetsSecurityEventSummaryResponse
     */
    public function describeAssetsSecurityEventSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAssetsSecurityEventSummaryWithOptions($request, $runtime);
    }

    /**
     * Queries the statistics of attack analysis.
     *
     * @param request - DescribeAttackAnalysisDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAttackAnalysisDataResponse
     *
     * @param DescribeAttackAnalysisDataRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeAttackAnalysisDataResponse
     */
    public function describeAttackAnalysisDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->base64) {
            @$query['Base64'] = $request->base64;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->data) {
            @$query['Data'] = $request->data;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeAttackAnalysisData',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAttackAnalysisDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics of attack analysis.
     *
     * @param request - DescribeAttackAnalysisDataRequest
     *
     * @returns DescribeAttackAnalysisDataResponse
     *
     * @param DescribeAttackAnalysisDataRequest $request
     *
     * @return DescribeAttackAnalysisDataResponse
     */
    public function describeAttackAnalysisData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAttackAnalysisDataWithOptions($request, $runtime);
    }

    /**
     * Queries a list of witnesses.
     *
     * @param request - DescribeAttestorsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAttestorsResponse
     *
     * @param DescribeAttestorsRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return DescribeAttestorsResponse
     */
    public function describeAttestorsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeAttestors',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAttestorsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of witnesses.
     *
     * @param request - DescribeAttestorsRequest
     *
     * @returns DescribeAttestorsResponse
     *
     * @param DescribeAttestorsRequest $request
     *
     * @return DescribeAttestorsResponse
     */
    public function describeAttestors($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAttestorsWithOptions($request, $runtime);
    }

    /**
     * Queries the number of days during which a detected vulnerability is retained before the vulnerability is automatically deleted.
     *
     * @param request - DescribeAutoDelConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAutoDelConfigResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeAutoDelConfigResponse
     */
    public function describeAutoDelConfigWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeAutoDelConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAutoDelConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the number of days during which a detected vulnerability is retained before the vulnerability is automatically deleted.
     *
     * @returns DescribeAutoDelConfigResponse
     *
     * @return DescribeAutoDelConfigResponse
     */
    public function describeAutoDelConfig()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAutoDelConfigWithOptions($runtime);
    }

    /**
     * Queries the information about a file to which archived alert events are exported.
     *
     * @param request - DescribeBackUpExportInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeBackUpExportInfoResponse
     *
     * @param DescribeBackUpExportInfoRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeBackUpExportInfoResponse
     */
    public function describeBackUpExportInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->exportType) {
            @$query['ExportType'] = $request->exportType;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeBackUpExportInfo',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeBackUpExportInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a file to which archived alert events are exported.
     *
     * @param request - DescribeBackUpExportInfoRequest
     *
     * @returns DescribeBackUpExportInfoResponse
     *
     * @param DescribeBackUpExportInfoRequest $request
     *
     * @return DescribeBackUpExportInfoResponse
     */
    public function describeBackUpExportInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBackUpExportInfoWithOptions($request, $runtime);
    }

    /**
     * Queries the servers on which the anti-ransomware agent is installed in a specified region.
     *
     * @remarks
     * You can call the DescribeBackupClients operation to query the servers on which the anti-ransomware agent is installed in a specified region.
     *
     * @param request - DescribeBackupClientsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeBackupClientsResponse
     *
     * @param DescribeBackupClientsRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DescribeBackupClientsResponse
     */
    public function describeBackupClientsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->supportRegionId) {
            @$query['SupportRegionId'] = $request->supportRegionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeBackupClients',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeBackupClientsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the servers on which the anti-ransomware agent is installed in a specified region.
     *
     * @remarks
     * You can call the DescribeBackupClients operation to query the servers on which the anti-ransomware agent is installed in a specified region.
     *
     * @param request - DescribeBackupClientsRequest
     *
     * @returns DescribeBackupClientsResponse
     *
     * @param DescribeBackupClientsRequest $request
     *
     * @return DescribeBackupClientsResponse
     */
    public function describeBackupClients($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBackupClientsWithOptions($request, $runtime);
    }

    /**
     * Queries backup files.
     *
     * @param request - DescribeBackupFilesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeBackupFilesResponse
     *
     * @param DescribeBackupFilesRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DescribeBackupFilesResponse
     */
    public function describeBackupFilesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->path) {
            @$query['Path'] = $request->path;
        }

        if (null !== $request->snapshotHash) {
            @$query['SnapshotHash'] = $request->snapshotHash;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeBackupFiles',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeBackupFilesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries backup files.
     *
     * @param request - DescribeBackupFilesRequest
     *
     * @returns DescribeBackupFilesResponse
     *
     * @param DescribeBackupFilesRequest $request
     *
     * @return DescribeBackupFilesResponse
     */
    public function describeBackupFiles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBackupFilesWithOptions($request, $runtime);
    }

    /**
     * Queries the backup status of a sever to which an anti-ransomware policy is applied.
     *
     * @param request - DescribeBackupMachineStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeBackupMachineStatusResponse
     *
     * @param DescribeBackupMachineStatusRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeBackupMachineStatusResponse
     */
    public function describeBackupMachineStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->policyId) {
            @$query['PolicyId'] = $request->policyId;
        }

        if (null !== $request->policyVersion) {
            @$query['PolicyVersion'] = $request->policyVersion;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeBackupMachineStatus',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeBackupMachineStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the backup status of a sever to which an anti-ransomware policy is applied.
     *
     * @param request - DescribeBackupMachineStatusRequest
     *
     * @returns DescribeBackupMachineStatusResponse
     *
     * @param DescribeBackupMachineStatusRequest $request
     *
     * @return DescribeBackupMachineStatusResponse
     */
    public function describeBackupMachineStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBackupMachineStatusWithOptions($request, $runtime);
    }

    /**
     * Queries anti-ransomware policies.
     *
     * @param request - DescribeBackupPoliciesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeBackupPoliciesResponse
     *
     * @param DescribeBackupPoliciesRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DescribeBackupPoliciesResponse
     */
    public function describeBackupPoliciesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->machineRemark) {
            @$query['MachineRemark'] = $request->machineRemark;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeBackupPolicies',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeBackupPoliciesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries anti-ransomware policies.
     *
     * @param request - DescribeBackupPoliciesRequest
     *
     * @returns DescribeBackupPoliciesResponse
     *
     * @param DescribeBackupPoliciesRequest $request
     *
     * @return DescribeBackupPoliciesResponse
     */
    public function describeBackupPolicies($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBackupPoliciesWithOptions($request, $runtime);
    }

    /**
     * Queries the details of an anti-ransomware policy for servers.
     *
     * @param request - DescribeBackupPolicyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeBackupPolicyResponse
     *
     * @param DescribeBackupPolicyRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DescribeBackupPolicyResponse
     */
    public function describeBackupPolicyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeBackupPolicy',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeBackupPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of an anti-ransomware policy for servers.
     *
     * @param request - DescribeBackupPolicyRequest
     *
     * @returns DescribeBackupPolicyResponse
     *
     * @param DescribeBackupPolicyRequest $request
     *
     * @return DescribeBackupPolicyResponse
     */
    public function describeBackupPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBackupPolicyWithOptions($request, $runtime);
    }

    /**
     * Queries the statistics of restoration tasks.
     *
     * @remarks
     * If you have created restoration tasks, you can call this operation to query the number of restoration tasks that are in the **restored** or **being restored** state.
     *
     * @param request - DescribeBackupRestoreCountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeBackupRestoreCountResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeBackupRestoreCountResponse
     */
    public function describeBackupRestoreCountWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeBackupRestoreCount',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeBackupRestoreCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics of restoration tasks.
     *
     * @remarks
     * If you have created restoration tasks, you can call this operation to query the number of restoration tasks that are in the **restored** or **being restored** state.
     *
     * @returns DescribeBackupRestoreCountResponse
     *
     * @return DescribeBackupRestoreCountResponse
     */
    public function describeBackupRestoreCount()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBackupRestoreCountWithOptions($runtime);
    }

    /**
     * Queries binary security policies.
     *
     * @param request - DescribeBinarySecurityPoliciesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeBinarySecurityPoliciesResponse
     *
     * @param DescribeBinarySecurityPoliciesRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DescribeBinarySecurityPoliciesResponse
     */
    public function describeBinarySecurityPoliciesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeBinarySecurityPolicies',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeBinarySecurityPoliciesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries binary security policies.
     *
     * @param request - DescribeBinarySecurityPoliciesRequest
     *
     * @returns DescribeBinarySecurityPoliciesResponse
     *
     * @param DescribeBinarySecurityPoliciesRequest $request
     *
     * @return DescribeBinarySecurityPoliciesResponse
     */
    public function describeBinarySecurityPolicies($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBinarySecurityPoliciesWithOptions($request, $runtime);
    }

    /**
     * Queries the IP addresses that are blocked by a defense rule against brute-force attacks.
     *
     * @param request - DescribeBruteForceRecordsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeBruteForceRecordsResponse
     *
     * @param DescribeBruteForceRecordsRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeBruteForceRecordsResponse
     */
    public function describeBruteForceRecordsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->blockIp) {
            @$query['BlockIp'] = $request->blockIp;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeBruteForceRecords',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeBruteForceRecordsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the IP addresses that are blocked by a defense rule against brute-force attacks.
     *
     * @param request - DescribeBruteForceRecordsRequest
     *
     * @returns DescribeBruteForceRecordsResponse
     *
     * @param DescribeBruteForceRecordsRequest $request
     *
     * @return DescribeBruteForceRecordsResponse
     */
    public function describeBruteForceRecords($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBruteForceRecordsWithOptions($request, $runtime);
    }

    /**
     * The source IP address of the request.
     *
     * @param request - DescribeBruteForceSummaryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeBruteForceSummaryResponse
     *
     * @param DescribeBruteForceSummaryRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeBruteForceSummaryResponse
     */
    public function describeBruteForceSummaryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeBruteForceSummary',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeBruteForceSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * The source IP address of the request.
     *
     * @param request - DescribeBruteForceSummaryRequest
     *
     * @returns DescribeBruteForceSummaryResponse
     *
     * @param DescribeBruteForceSummaryRequest $request
     *
     * @return DescribeBruteForceSummaryResponse
     */
    public function describeBruteForceSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBruteForceSummaryWithOptions($request, $runtime);
    }

    /**
     * Check if the asset can be sold by VPC.
     *
     * @param request - DescribeCanAccessVpcSaleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCanAccessVpcSaleResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeCanAccessVpcSaleResponse
     */
    public function describeCanAccessVpcSaleWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeCanAccessVpcSale',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCanAccessVpcSaleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Check if the asset can be sold by VPC.
     *
     * @returns DescribeCanAccessVpcSaleResponse
     *
     * @return DescribeCanAccessVpcSaleResponse
     */
    public function describeCanAccessVpcSale()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCanAccessVpcSaleWithOptions($runtime);
    }

    /**
     * Queries the list of fixable vulnerabilities.
     *
     * @param request - DescribeCanFixVulListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCanFixVulListResponse
     *
     * @param DescribeCanFixVulListRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DescribeCanFixVulListResponse
     */
    public function describeCanFixVulListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aliasName) {
            @$query['AliasName'] = $request->aliasName;
        }

        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->clusterName) {
            @$query['ClusterName'] = $request->clusterName;
        }

        if (null !== $request->containerId) {
            @$query['ContainerId'] = $request->containerId;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->dealed) {
            @$query['Dealed'] = $request->dealed;
        }

        if (null !== $request->digest) {
            @$query['Digest'] = $request->digest;
        }

        if (null !== $request->image) {
            @$query['Image'] = $request->image;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->namespace) {
            @$query['Namespace'] = $request->namespace;
        }

        if (null !== $request->necessity) {
            @$query['Necessity'] = $request->necessity;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->pod) {
            @$query['Pod'] = $request->pod;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->repoId) {
            @$query['RepoId'] = $request->repoId;
        }

        if (null !== $request->repoId) {
            @$query['RepoId'] = $request->repoId;
        }

        if (null !== $request->repoInstanceId) {
            @$query['RepoInstanceId'] = $request->repoInstanceId;
        }

        if (null !== $request->repoName) {
            @$query['RepoName'] = $request->repoName;
        }

        if (null !== $request->repoName) {
            @$query['RepoName'] = $request->repoName;
        }

        if (null !== $request->repoNamespace) {
            @$query['RepoNamespace'] = $request->repoNamespace;
        }

        if (null !== $request->repoRegionId) {
            @$query['RepoRegionId'] = $request->repoRegionId;
        }

        if (null !== $request->scanRange) {
            @$query['ScanRange'] = $request->scanRange;
        }

        if (null !== $request->statusList) {
            @$query['StatusList'] = $request->statusList;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCanFixVulList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCanFixVulListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the list of fixable vulnerabilities.
     *
     * @param request - DescribeCanFixVulListRequest
     *
     * @returns DescribeCanFixVulListResponse
     *
     * @param DescribeCanFixVulListRequest $request
     *
     * @return DescribeCanFixVulListResponse
     */
    public function describeCanFixVulList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCanFixVulListWithOptions($request, $runtime);
    }

    /**
     * Checks the permissions on the trial use of Security Center.
     *
     * @param request - DescribeCanTrySasRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCanTrySasResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeCanTrySasResponse
     */
    public function describeCanTrySasWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeCanTrySas',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCanTrySasResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Checks the permissions on the trial use of Security Center.
     *
     * @returns DescribeCanTrySasResponse
     *
     * @return DescribeCanTrySasResponse
     */
    public function describeCanTrySas()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCanTrySasWithOptions($runtime);
    }

    /**
     * Queries the chart data of a security report.
     *
     * @param request - DescribeChartDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeChartDataResponse
     *
     * @param DescribeChartDataRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return DescribeChartDataResponse
     */
    public function describeChartDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->charId) {
            @$query['CharId'] = $request->charId;
        }

        if (null !== $request->chartId) {
            @$query['ChartId'] = $request->chartId;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->reportId) {
            @$query['ReportId'] = $request->reportId;
        }

        if (null !== $request->timeEnd) {
            @$query['TimeEnd'] = $request->timeEnd;
        }

        if (null !== $request->timeStart) {
            @$query['TimeStart'] = $request->timeStart;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeChartData',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeChartDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the chart data of a security report.
     *
     * @param request - DescribeChartDataRequest
     *
     * @returns DescribeChartDataResponse
     *
     * @param DescribeChartDataRequest $request
     *
     * @return DescribeChartDataResponse
     */
    public function describeChartData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeChartDataWithOptions($request, $runtime);
    }

    /**
     * Queries the charts that are supported by using the security report feature of Security Center.
     *
     * @param request - DescribeChartListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeChartListResponse
     *
     * @param DescribeChartListRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return DescribeChartListResponse
     */
    public function describeChartListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->projectCode) {
            @$query['ProjectCode'] = $request->projectCode;
        }

        if (null !== $request->reportId) {
            @$query['ReportId'] = $request->reportId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeChartList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeChartListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the charts that are supported by using the security report feature of Security Center.
     *
     * @param request - DescribeChartListRequest
     *
     * @returns DescribeChartListResponse
     *
     * @param DescribeChartListRequest $request
     *
     * @return DescribeChartListResponse
     */
    public function describeChartList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeChartListWithOptions($request, $runtime);
    }

    /**
     * Queries the number of weak passwords that can cause high risks to your assets.
     *
     * @param request - DescribeCheckEcsWarningsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCheckEcsWarningsResponse
     *
     * @param DescribeCheckEcsWarningsRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeCheckEcsWarningsResponse
     */
    public function describeCheckEcsWarningsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCheckEcsWarnings',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCheckEcsWarningsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the number of weak passwords that can cause high risks to your assets.
     *
     * @param request - DescribeCheckEcsWarningsRequest
     *
     * @returns DescribeCheckEcsWarningsResponse
     *
     * @param DescribeCheckEcsWarningsRequest $request
     *
     * @return DescribeCheckEcsWarningsResponse
     */
    public function describeCheckEcsWarnings($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCheckEcsWarningsWithOptions($request, $runtime);
    }

    /**
     * Queries the parameters that you can configure to fix specified risk items.
     *
     * @param request - DescribeCheckFixDetailsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCheckFixDetailsResponse
     *
     * @param DescribeCheckFixDetailsRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeCheckFixDetailsResponse
     */
    public function describeCheckFixDetailsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->checkIds) {
            @$query['CheckIds'] = $request->checkIds;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->riskId) {
            @$query['RiskId'] = $request->riskId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCheckFixDetails',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCheckFixDetailsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the parameters that you can configure to fix specified risk items.
     *
     * @param request - DescribeCheckFixDetailsRequest
     *
     * @returns DescribeCheckFixDetailsResponse
     *
     * @param DescribeCheckFixDetailsRequest $request
     *
     * @return DescribeCheckFixDetailsResponse
     */
    public function describeCheckFixDetails($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCheckFixDetailsWithOptions($request, $runtime);
    }

    /**
     * Queries the result of the ISO 27001 compliance check.
     *
     * @param request - DescribeCheckResultRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCheckResultResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeCheckResultResponse
     */
    public function describeCheckResultWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeCheckResult',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCheckResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the result of the ISO 27001 compliance check.
     *
     * @returns DescribeCheckResultResponse
     *
     * @return DescribeCheckResultResponse
     */
    public function describeCheckResult()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCheckResultWithOptions($runtime);
    }

    /**
     * Queries the number of alerts that are triggered by a check item.
     *
     * @param request - DescribeCheckWarningCountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCheckWarningCountResponse
     *
     * @param DescribeCheckWarningCountRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeCheckWarningCountResponse
     */
    public function describeCheckWarningCountWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aliUid) {
            @$query['AliUid'] = $request->aliUid;
        }

        if (null !== $request->checkId) {
            @$query['CheckId'] = $request->checkId;
        }

        if (null !== $request->riskId) {
            @$query['RiskId'] = $request->riskId;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCheckWarningCount',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCheckWarningCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the number of alerts that are triggered by a check item.
     *
     * @param request - DescribeCheckWarningCountRequest
     *
     * @returns DescribeCheckWarningCountResponse
     *
     * @param DescribeCheckWarningCountRequest $request
     *
     * @return DescribeCheckWarningCountResponse
     */
    public function describeCheckWarningCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCheckWarningCountWithOptions($request, $runtime);
    }

    /**
     * Queries the details about a specified check item.
     *
     * @param request - DescribeCheckWarningDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCheckWarningDetailResponse
     *
     * @param DescribeCheckWarningDetailRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeCheckWarningDetailResponse
     */
    public function describeCheckWarningDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->checkId) {
            @$query['CheckId'] = $request->checkId;
        }

        if (null !== $request->checkWarningId) {
            @$query['CheckWarningId'] = $request->checkWarningId;
        }

        if (null !== $request->containerName) {
            @$query['ContainerName'] = $request->containerName;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCheckWarningDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCheckWarningDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details about a specified check item.
     *
     * @param request - DescribeCheckWarningDetailRequest
     *
     * @returns DescribeCheckWarningDetailResponse
     *
     * @param DescribeCheckWarningDetailRequest $request
     *
     * @return DescribeCheckWarningDetailResponse
     */
    public function describeCheckWarningDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCheckWarningDetailWithOptions($request, $runtime);
    }

    /**
     * Queries the servers on which the same risk item is detected by specifying a baseline and a check item.
     *
     * @param request - DescribeCheckWarningMachinesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCheckWarningMachinesResponse
     *
     * @param DescribeCheckWarningMachinesRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribeCheckWarningMachinesResponse
     */
    public function describeCheckWarningMachinesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->checkId) {
            @$query['CheckId'] = $request->checkId;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->filterUuid) {
            @$query['FilterUuid'] = $request->filterUuid;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        if (null !== $request->riskId) {
            @$query['RiskId'] = $request->riskId;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCheckWarningMachines',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCheckWarningMachinesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the servers on which the same risk item is detected by specifying a baseline and a check item.
     *
     * @param request - DescribeCheckWarningMachinesRequest
     *
     * @returns DescribeCheckWarningMachinesResponse
     *
     * @param DescribeCheckWarningMachinesRequest $request
     *
     * @return DescribeCheckWarningMachinesResponse
     */
    public function describeCheckWarningMachines($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCheckWarningMachinesWithOptions($request, $runtime);
    }

    /**
     * Queries the statistical information about baseline check results. The information includes the number of servers on which a baseline check is performed, the number of baseline check items, and the pass rate of check items in the last baseline check.
     *
     * @param request - DescribeCheckWarningSummaryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCheckWarningSummaryResponse
     *
     * @param DescribeCheckWarningSummaryRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeCheckWarningSummaryResponse
     */
    public function describeCheckWarningSummaryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->containerFieldName) {
            @$query['ContainerFieldName'] = $request->containerFieldName;
        }

        if (null !== $request->containerFieldValue) {
            @$query['ContainerFieldValue'] = $request->containerFieldValue;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->riskName) {
            @$query['RiskName'] = $request->riskName;
        }

        if (null !== $request->riskStatus) {
            @$query['RiskStatus'] = $request->riskStatus;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->strategyId) {
            @$query['StrategyId'] = $request->strategyId;
        }

        if (null !== $request->targetType) {
            @$query['TargetType'] = $request->targetType;
        }

        if (null !== $request->typeName) {
            @$query['TypeName'] = $request->typeName;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCheckWarningSummary',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCheckWarningSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistical information about baseline check results. The information includes the number of servers on which a baseline check is performed, the number of baseline check items, and the pass rate of check items in the last baseline check.
     *
     * @param request - DescribeCheckWarningSummaryRequest
     *
     * @returns DescribeCheckWarningSummaryResponse
     *
     * @param DescribeCheckWarningSummaryRequest $request
     *
     * @return DescribeCheckWarningSummaryResponse
     */
    public function describeCheckWarningSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCheckWarningSummaryWithOptions($request, $runtime);
    }

    /**
     * Queries information about specified risk items and the check items of a specified server.
     *
     * @param request - DescribeCheckWarningsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCheckWarningsResponse
     *
     * @param DescribeCheckWarningsRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DescribeCheckWarningsResponse
     */
    public function describeCheckWarningsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->checkId) {
            @$query['CheckId'] = $request->checkId;
        }

        if (null !== $request->checkType) {
            @$query['CheckType'] = $request->checkType;
        }

        if (null !== $request->containerName) {
            @$query['ContainerName'] = $request->containerName;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        if (null !== $request->riskId) {
            @$query['RiskId'] = $request->riskId;
        }

        if (null !== $request->riskStatus) {
            @$query['RiskStatus'] = $request->riskStatus;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCheckWarnings',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCheckWarningsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries information about specified risk items and the check items of a specified server.
     *
     * @param request - DescribeCheckWarningsRequest
     *
     * @returns DescribeCheckWarningsResponse
     *
     * @param DescribeCheckWarningsRequest $request
     *
     * @return DescribeCheckWarningsResponse
     */
    public function describeCheckWarnings($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCheckWarningsWithOptions($request, $runtime);
    }

    /**
     * Queries the configurations of the Security Center agent.
     *
     * @param request - DescribeClientConfSetupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeClientConfSetupResponse
     *
     * @param DescribeClientConfSetupRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeClientConfSetupResponse
     */
    public function describeClientConfSetupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->strategyTag) {
            @$query['StrategyTag'] = $request->strategyTag;
        }

        if (null !== $request->strategyTagValue) {
            @$query['StrategyTagValue'] = $request->strategyTagValue;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeClientConfSetup',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeClientConfSetupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configurations of the Security Center agent.
     *
     * @param request - DescribeClientConfSetupRequest
     *
     * @returns DescribeClientConfSetupResponse
     *
     * @param DescribeClientConfSetupRequest $request
     *
     * @return DescribeClientConfSetupResponse
     */
    public function describeClientConfSetup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeClientConfSetupWithOptions($request, $runtime);
    }

    /**
     * Queries the configurations of servers to which different tags are added.
     *
     * @param request - DescribeClientConfStrategyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeClientConfStrategyResponse
     *
     * @param DescribeClientConfStrategyRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeClientConfStrategyResponse
     */
    public function describeClientConfStrategyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->tagValue) {
            @$query['TagValue'] = $request->tagValue;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeClientConfStrategy',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeClientConfStrategyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configurations of servers to which different tags are added.
     *
     * @param request - DescribeClientConfStrategyRequest
     *
     * @returns DescribeClientConfStrategyResponse
     *
     * @param DescribeClientConfStrategyRequest $request
     *
     * @return DescribeClientConfStrategyResponse
     */
    public function describeClientConfStrategy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeClientConfStrategyWithOptions($request, $runtime);
    }

    /**
     * Queries a list of agent issue types.
     *
     * @param request - DescribeClientProblemTypeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeClientProblemTypeResponse
     *
     * @param DescribeClientProblemTypeRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeClientProblemTypeResponse
     */
    public function describeClientProblemTypeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeClientProblemType',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeClientProblemTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of agent issue types.
     *
     * @param request - DescribeClientProblemTypeRequest
     *
     * @returns DescribeClientProblemTypeResponse
     *
     * @param DescribeClientProblemTypeRequest $request
     *
     * @return DescribeClientProblemTypeResponse
     */
    public function describeClientProblemType($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeClientProblemTypeWithOptions($request, $runtime);
    }

    /**
     * Queries the information about assets that meet specific search conditions. For example, you can search for assets by the instance name or region of the asset.
     *
     * @remarks
     * You can search for an asset by using search conditions, such as the instance ID, instance name, virtual private cloud (VPC) ID, region, and public IP address. You can also configure a logical relationship between multiple search conditions to search for the assets that meet the search conditions.
     *
     * @param request - DescribeCloudCenterInstancesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCloudCenterInstancesResponse
     *
     * @param DescribeCloudCenterInstancesRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribeCloudCenterInstancesResponse
     */
    public function describeCloudCenterInstancesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->criteria) {
            @$query['Criteria'] = $request->criteria;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->flags) {
            @$query['Flags'] = $request->flags;
        }

        if (null !== $request->importance) {
            @$query['Importance'] = $request->importance;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->logicalExp) {
            @$query['LogicalExp'] = $request->logicalExp;
        }

        if (null !== $request->machineTypes) {
            @$query['MachineTypes'] = $request->machineTypes;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->noGroupTrace) {
            @$query['NoGroupTrace'] = $request->noGroupTrace;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        if (null !== $request->useNextToken) {
            @$query['UseNextToken'] = $request->useNextToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCloudCenterInstances',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCloudCenterInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about assets that meet specific search conditions. For example, you can search for assets by the instance name or region of the asset.
     *
     * @remarks
     * You can search for an asset by using search conditions, such as the instance ID, instance name, virtual private cloud (VPC) ID, region, and public IP address. You can also configure a logical relationship between multiple search conditions to search for the assets that meet the search conditions.
     *
     * @param request - DescribeCloudCenterInstancesRequest
     *
     * @returns DescribeCloudCenterInstancesResponse
     *
     * @param DescribeCloudCenterInstancesRequest $request
     *
     * @return DescribeCloudCenterInstancesResponse
     */
    public function describeCloudCenterInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCloudCenterInstancesWithOptions($request, $runtime);
    }

    // Deprecated
    /**
     * Queries the statistics of cloud services.
     *
     * @deprecated openAPI DescribeCloudProductFieldStatistics is deprecated, please use Sas::2018-12-03::GetCloudAssetSummary instead
     *
     * @param request - DescribeCloudProductFieldStatisticsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCloudProductFieldStatisticsResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeCloudProductFieldStatisticsResponse
     */
    public function describeCloudProductFieldStatisticsWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeCloudProductFieldStatistics',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCloudProductFieldStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Queries the statistics of cloud services.
     *
     * @deprecated openAPI DescribeCloudProductFieldStatistics is deprecated, please use Sas::2018-12-03::GetCloudAssetSummary instead
     *
     * @returns DescribeCloudProductFieldStatisticsResponse
     *
     * @return DescribeCloudProductFieldStatisticsResponse
     */
    public function describeCloudProductFieldStatistics()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCloudProductFieldStatisticsWithOptions($runtime);
    }

    /**
     * Queries the multi-cloud assets added to Security Center.
     *
     * @param request - DescribeCloudVendorAccountAKListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCloudVendorAccountAKListResponse
     *
     * @param DescribeCloudVendorAccountAKListRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return DescribeCloudVendorAccountAKListResponse
     */
    public function describeCloudVendorAccountAKListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->authIds) {
            @$query['AuthIds'] = $request->authIds;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->subAccountName) {
            @$query['SubAccountName'] = $request->subAccountName;
        }

        if (null !== $request->vendorAuthAlias) {
            @$query['VendorAuthAlias'] = $request->vendorAuthAlias;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCloudVendorAccountAKList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCloudVendorAccountAKListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the multi-cloud assets added to Security Center.
     *
     * @param request - DescribeCloudVendorAccountAKListRequest
     *
     * @returns DescribeCloudVendorAccountAKListResponse
     *
     * @param DescribeCloudVendorAccountAKListRequest $request
     *
     * @return DescribeCloudVendorAccountAKListResponse
     */
    public function describeCloudVendorAccountAKList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCloudVendorAccountAKListWithOptions($request, $runtime);
    }

    /**
     * Query the trail configuration attributes of the corresponding AK configuration.
     *
     * @param request - DescribeCloudVendorTrialConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCloudVendorTrialConfigResponse
     *
     * @param DescribeCloudVendorTrialConfigRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DescribeCloudVendorTrialConfigResponse
     */
    public function describeCloudVendorTrialConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCloudVendorTrialConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCloudVendorTrialConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Query the trail configuration attributes of the corresponding AK configuration.
     *
     * @param request - DescribeCloudVendorTrialConfigRequest
     *
     * @returns DescribeCloudVendorTrialConfigResponse
     *
     * @param DescribeCloudVendorTrialConfigRequest $request
     *
     * @return DescribeCloudVendorTrialConfigResponse
     */
    public function describeCloudVendorTrialConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCloudVendorTrialConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the information about an cluster based on the cluster ID.
     *
     * @param request - DescribeClusterBasicInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeClusterBasicInfoResponse
     *
     * @param DescribeClusterBasicInfoRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeClusterBasicInfoResponse
     */
    public function describeClusterBasicInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->targetType) {
            @$query['TargetType'] = $request->targetType;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeClusterBasicInfo',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeClusterBasicInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about an cluster based on the cluster ID.
     *
     * @param request - DescribeClusterBasicInfoRequest
     *
     * @returns DescribeClusterBasicInfoResponse
     *
     * @param DescribeClusterBasicInfoRequest $request
     *
     * @return DescribeClusterBasicInfoResponse
     */
    public function describeClusterBasicInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeClusterBasicInfoWithOptions($request, $runtime);
    }

    /**
     * Queries the statistical information about host security.
     *
     * @param request - DescribeClusterHostSecuritySummaryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeClusterHostSecuritySummaryResponse
     *
     * @param DescribeClusterHostSecuritySummaryRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return DescribeClusterHostSecuritySummaryResponse
     */
    public function describeClusterHostSecuritySummaryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->containerFieldName) {
            @$query['ContainerFieldName'] = $request->containerFieldName;
        }

        if (null !== $request->containerFieldValue) {
            @$query['ContainerFieldValue'] = $request->containerFieldValue;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->targetType) {
            @$query['TargetType'] = $request->targetType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeClusterHostSecuritySummary',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeClusterHostSecuritySummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistical information about host security.
     *
     * @param request - DescribeClusterHostSecuritySummaryRequest
     *
     * @returns DescribeClusterHostSecuritySummaryResponse
     *
     * @param DescribeClusterHostSecuritySummaryRequest $request
     *
     * @return DescribeClusterHostSecuritySummaryResponse
     */
    public function describeClusterHostSecuritySummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeClusterHostSecuritySummaryWithOptions($request, $runtime);
    }

    /**
     * Queries the statistical information about image security.
     *
     * @param request - DescribeClusterImageSecuritySummaryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeClusterImageSecuritySummaryResponse
     *
     * @param DescribeClusterImageSecuritySummaryRequest $request
     * @param RuntimeOptions                             $runtime
     *
     * @return DescribeClusterImageSecuritySummaryResponse
     */
    public function describeClusterImageSecuritySummaryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->containerFieldName) {
            @$query['ContainerFieldName'] = $request->containerFieldName;
        }

        if (null !== $request->containerFieldValue) {
            @$query['ContainerFieldValue'] = $request->containerFieldValue;
        }

        if (null !== $request->imageDigest) {
            @$query['ImageDigest'] = $request->imageDigest;
        }

        if (null !== $request->imageRepoName) {
            @$query['ImageRepoName'] = $request->imageRepoName;
        }

        if (null !== $request->imageRepoNamespace) {
            @$query['ImageRepoNamespace'] = $request->imageRepoNamespace;
        }

        if (null !== $request->imageTag) {
            @$query['ImageTag'] = $request->imageTag;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeClusterImageSecuritySummary',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeClusterImageSecuritySummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistical information about image security.
     *
     * @param request - DescribeClusterImageSecuritySummaryRequest
     *
     * @returns DescribeClusterImageSecuritySummaryResponse
     *
     * @param DescribeClusterImageSecuritySummaryRequest $request
     *
     * @return DescribeClusterImageSecuritySummaryResponse
     */
    public function describeClusterImageSecuritySummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeClusterImageSecuritySummaryWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a cluster.
     *
     * @param request - DescribeClusterInfoListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeClusterInfoListResponse
     *
     * @param DescribeClusterInfoListRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeClusterInfoListResponse
     */
    public function describeClusterInfoListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->target) {
            @$query['Target'] = $request->target;
        }

        if (null !== $request->targetType) {
            @$query['TargetType'] = $request->targetType;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeClusterInfoList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeClusterInfoListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a cluster.
     *
     * @param request - DescribeClusterInfoListRequest
     *
     * @returns DescribeClusterInfoListResponse
     *
     * @param DescribeClusterInfoListRequest $request
     *
     * @return DescribeClusterInfoListResponse
     */
    public function describeClusterInfoList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeClusterInfoListWithOptions($request, $runtime);
    }

    /**
     * Queries information about the network topology edge by cluster.
     *
     * @param request - DescribeClusterNetworkRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeClusterNetworkResponse
     *
     * @param DescribeClusterNetworkRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DescribeClusterNetworkResponse
     */
    public function describeClusterNetworkWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeClusterNetwork',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeClusterNetworkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries information about the network topology edge by cluster.
     *
     * @param request - DescribeClusterNetworkRequest
     *
     * @returns DescribeClusterNetworkResponse
     *
     * @param DescribeClusterNetworkRequest $request
     *
     * @return DescribeClusterNetworkResponse
     */
    public function describeClusterNetwork($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeClusterNetworkWithOptions($request, $runtime);
    }

    /**
     * Query the status of cluster scanning components.
     *
     * @param request - DescribeClusterScannerListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeClusterScannerListResponse
     *
     * @param DescribeClusterScannerListRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeClusterScannerListResponse
     */
    public function describeClusterScannerListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterIdList) {
            @$query['ClusterIdList'] = $request->clusterIdList;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->statusList) {
            @$query['StatusList'] = $request->statusList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeClusterScannerList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeClusterScannerListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Query the status of cluster scanning components.
     *
     * @param request - DescribeClusterScannerListRequest
     *
     * @returns DescribeClusterScannerListResponse
     *
     * @param DescribeClusterScannerListRequest $request
     *
     * @return DescribeClusterScannerListResponse
     */
    public function describeClusterScannerList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeClusterScannerListWithOptions($request, $runtime);
    }

    /**
     * Queries the statistics of vulnerabilities that are detected on a cluster.
     *
     * @param request - DescribeClusterVulStatisticsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeClusterVulStatisticsResponse
     *
     * @param DescribeClusterVulStatisticsRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribeClusterVulStatisticsResponse
     */
    public function describeClusterVulStatisticsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->types) {
            @$query['Types'] = $request->types;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeClusterVulStatistics',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeClusterVulStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics of vulnerabilities that are detected on a cluster.
     *
     * @param request - DescribeClusterVulStatisticsRequest
     *
     * @returns DescribeClusterVulStatisticsResponse
     *
     * @param DescribeClusterVulStatisticsRequest $request
     *
     * @return DescribeClusterVulStatisticsResponse
     */
    public function describeClusterVulStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeClusterVulStatisticsWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a specified feature.
     *
     * @param request - DescribeCommonOverallConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCommonOverallConfigResponse
     *
     * @param DescribeCommonOverallConfigRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeCommonOverallConfigResponse
     */
    public function describeCommonOverallConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCommonOverallConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCommonOverallConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a specified feature.
     *
     * @param request - DescribeCommonOverallConfigRequest
     *
     * @returns DescribeCommonOverallConfigResponse
     *
     * @param DescribeCommonOverallConfigRequest $request
     *
     * @return DescribeCommonOverallConfigResponse
     */
    public function describeCommonOverallConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCommonOverallConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the configurations of features in proactive defense.
     *
     * @param request - DescribeCommonOverallConfigListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCommonOverallConfigListResponse
     *
     * @param DescribeCommonOverallConfigListRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return DescribeCommonOverallConfigListResponse
     */
    public function describeCommonOverallConfigListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->typeList) {
            @$query['TypeList'] = $request->typeList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCommonOverallConfigList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCommonOverallConfigListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configurations of features in proactive defense.
     *
     * @param request - DescribeCommonOverallConfigListRequest
     *
     * @returns DescribeCommonOverallConfigListResponse
     *
     * @param DescribeCommonOverallConfigListRequest $request
     *
     * @return DescribeCommonOverallConfigListResponse
     */
    public function describeCommonOverallConfigList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCommonOverallConfigListWithOptions($request, $runtime);
    }

    /**
     * Queries the configurations of the proactive defense feature.
     *
     * @param request - DescribeCommonTargetConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCommonTargetConfigResponse
     *
     * @param DescribeCommonTargetConfigRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeCommonTargetConfigResponse
     */
    public function describeCommonTargetConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCommonTargetConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCommonTargetConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configurations of the proactive defense feature.
     *
     * @param request - DescribeCommonTargetConfigRequest
     *
     * @returns DescribeCommonTargetConfigResponse
     *
     * @param DescribeCommonTargetConfigRequest $request
     *
     * @return DescribeCommonTargetConfigResponse
     */
    public function describeCommonTargetConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCommonTargetConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the information about the servers based on the specified configuration item.
     *
     * @param request - DescribeCommonTargetResultListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCommonTargetResultListResponse
     *
     * @param DescribeCommonTargetResultListRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DescribeCommonTargetResultListResponse
     */
    public function describeCommonTargetResultListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCommonTargetResultList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCommonTargetResultListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about the servers based on the specified configuration item.
     *
     * @param request - DescribeCommonTargetResultListRequest
     *
     * @returns DescribeCommonTargetResultListResponse
     *
     * @param DescribeCommonTargetResultListRequest $request
     *
     * @return DescribeCommonTargetResultListResponse
     */
    public function describeCommonTargetResultList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCommonTargetResultListWithOptions($request, $runtime);
    }

    /**
     * Queries the priorities to fix vulnerabilities.
     *
     * @param request - DescribeConcernNecessityRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeConcernNecessityResponse
     *
     * @param DescribeConcernNecessityRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeConcernNecessityResponse
     */
    public function describeConcernNecessityWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeConcernNecessity',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeConcernNecessityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the priorities to fix vulnerabilities.
     *
     * @param request - DescribeConcernNecessityRequest
     *
     * @returns DescribeConcernNecessityResponse
     *
     * @param DescribeConcernNecessityRequest $request
     *
     * @return DescribeConcernNecessityResponse
     */
    public function describeConcernNecessity($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeConcernNecessityWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a containerized application.
     *
     * @param request - DescribeContainerAppsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeContainerAppsResponse
     *
     * @param DescribeContainerAppsRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DescribeContainerAppsResponse
     */
    public function describeContainerAppsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->fieldValue) {
            @$query['FieldValue'] = $request->fieldValue;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeContainerApps',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeContainerAppsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a containerized application.
     *
     * @param request - DescribeContainerAppsRequest
     *
     * @returns DescribeContainerAppsResponse
     *
     * @param DescribeContainerAppsRequest $request
     *
     * @return DescribeContainerAppsResponse
     */
    public function describeContainerApps($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeContainerAppsWithOptions($request, $runtime);
    }

    /**
     * Obtains the filter conditions that you can use to filter the containers.
     *
     * @param request - DescribeContainerCriteriaRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeContainerCriteriaResponse
     *
     * @param DescribeContainerCriteriaRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeContainerCriteriaResponse
     */
    public function describeContainerCriteriaWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->groupField) {
            @$query['GroupField'] = $request->groupField;
        }

        if (null !== $request->value) {
            @$query['Value'] = $request->value;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeContainerCriteria',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeContainerCriteriaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Obtains the filter conditions that you can use to filter the containers.
     *
     * @param request - DescribeContainerCriteriaRequest
     *
     * @returns DescribeContainerCriteriaResponse
     *
     * @param DescribeContainerCriteriaRequest $request
     *
     * @return DescribeContainerCriteriaResponse
     */
    public function describeContainerCriteria($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeContainerCriteriaWithOptions($request, $runtime);
    }

    /**
     * Queries the statistical information about containers.
     *
     * @param request - DescribeContainerFieldStatisticsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeContainerFieldStatisticsResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeContainerFieldStatisticsResponse
     */
    public function describeContainerFieldStatisticsWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeContainerFieldStatistics',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeContainerFieldStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistical information about containers.
     *
     * @returns DescribeContainerFieldStatisticsResponse
     *
     * @return DescribeContainerFieldStatisticsResponse
     */
    public function describeContainerFieldStatistics()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeContainerFieldStatisticsWithOptions($runtime);
    }

    /**
     * Queries the attribute details of containers.
     *
     * @param request - DescribeContainerGroupedFieldDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeContainerGroupedFieldDetailResponse
     *
     * @param DescribeContainerGroupedFieldDetailRequest $request
     * @param RuntimeOptions                             $runtime
     *
     * @return DescribeContainerGroupedFieldDetailResponse
     */
    public function describeContainerGroupedFieldDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->criteria) {
            @$query['Criteria'] = $request->criteria;
        }

        if (null !== $request->groupField) {
            @$query['GroupField'] = $request->groupField;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeContainerGroupedFieldDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeContainerGroupedFieldDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the attribute details of containers.
     *
     * @param request - DescribeContainerGroupedFieldDetailRequest
     *
     * @returns DescribeContainerGroupedFieldDetailResponse
     *
     * @param DescribeContainerGroupedFieldDetailRequest $request
     *
     * @return DescribeContainerGroupedFieldDetailResponse
     */
    public function describeContainerGroupedFieldDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeContainerGroupedFieldDetailWithOptions($request, $runtime);
    }

    /**
     * Queries the information about containers.
     *
     * @param request - DescribeContainerInstancesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeContainerInstancesResponse
     *
     * @param DescribeContainerInstancesRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeContainerInstancesResponse
     */
    public function describeContainerInstancesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->criteria) {
            @$query['Criteria'] = $request->criteria;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->logicalExp) {
            @$query['LogicalExp'] = $request->logicalExp;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeContainerInstances',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeContainerInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about containers.
     *
     * @param request - DescribeContainerInstancesRequest
     *
     * @returns DescribeContainerInstancesResponse
     *
     * @param DescribeContainerInstancesRequest $request
     *
     * @return DescribeContainerInstancesResponse
     */
    public function describeContainerInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeContainerInstancesWithOptions($request, $runtime);
    }

    /**
     * Queries the configurations of the vulnerability scan of one or more running container applications.
     *
     * @param request - DescribeContainerScanConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeContainerScanConfigResponse
     *
     * @param DescribeContainerScanConfigRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeContainerScanConfigResponse
     */
    public function describeContainerScanConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeContainerScanConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeContainerScanConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configurations of the vulnerability scan of one or more running container applications.
     *
     * @param request - DescribeContainerScanConfigRequest
     *
     * @returns DescribeContainerScanConfigResponse
     *
     * @param DescribeContainerScanConfigRequest $request
     *
     * @return DescribeContainerScanConfigResponse
     */
    public function describeContainerScanConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeContainerScanConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the Kritis status of a Container Service for Kubernetes (ACK) cluster.
     *
     * @param request - DescribeContainerServiceK8sClusterKritisStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeContainerServiceK8sClusterKritisStatusResponse
     *
     * @param DescribeContainerServiceK8sClusterKritisStatusRequest $request
     * @param RuntimeOptions                                        $runtime
     *
     * @return DescribeContainerServiceK8sClusterKritisStatusResponse
     */
    public function describeContainerServiceK8sClusterKritisStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeContainerServiceK8sClusterKritisStatus',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeContainerServiceK8sClusterKritisStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the Kritis status of a Container Service for Kubernetes (ACK) cluster.
     *
     * @param request - DescribeContainerServiceK8sClusterKritisStatusRequest
     *
     * @returns DescribeContainerServiceK8sClusterKritisStatusResponse
     *
     * @param DescribeContainerServiceK8sClusterKritisStatusRequest $request
     *
     * @return DescribeContainerServiceK8sClusterKritisStatusResponse
     */
    public function describeContainerServiceK8sClusterKritisStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeContainerServiceK8sClusterKritisStatusWithOptions($request, $runtime);
    }

    /**
     * Queries the namespace of a Container Service for Kubernetes (ACK) cluster.
     *
     * @param request - DescribeContainerServiceK8sClusterNamespacesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeContainerServiceK8sClusterNamespacesResponse
     *
     * @param DescribeContainerServiceK8sClusterNamespacesRequest $request
     * @param RuntimeOptions                                      $runtime
     *
     * @return DescribeContainerServiceK8sClusterNamespacesResponse
     */
    public function describeContainerServiceK8sClusterNamespacesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeContainerServiceK8sClusterNamespaces',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeContainerServiceK8sClusterNamespacesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the namespace of a Container Service for Kubernetes (ACK) cluster.
     *
     * @param request - DescribeContainerServiceK8sClusterNamespacesRequest
     *
     * @returns DescribeContainerServiceK8sClusterNamespacesResponse
     *
     * @param DescribeContainerServiceK8sClusterNamespacesRequest $request
     *
     * @return DescribeContainerServiceK8sClusterNamespacesResponse
     */
    public function describeContainerServiceK8sClusterNamespaces($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeContainerServiceK8sClusterNamespacesWithOptions($request, $runtime);
    }

    /**
     * Queries a list of Container Service for Kubernetes (ACK) clusters.
     *
     * @param request - DescribeContainerServiceK8sClustersRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeContainerServiceK8sClustersResponse
     *
     * @param DescribeContainerServiceK8sClustersRequest $request
     * @param RuntimeOptions                             $runtime
     *
     * @return DescribeContainerServiceK8sClustersResponse
     */
    public function describeContainerServiceK8sClustersWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeContainerServiceK8sClusters',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeContainerServiceK8sClustersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of Container Service for Kubernetes (ACK) clusters.
     *
     * @param request - DescribeContainerServiceK8sClustersRequest
     *
     * @returns DescribeContainerServiceK8sClustersResponse
     *
     * @param DescribeContainerServiceK8sClustersRequest $request
     *
     * @return DescribeContainerServiceK8sClustersResponse
     */
    public function describeContainerServiceK8sClusters($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeContainerServiceK8sClustersWithOptions($request, $runtime);
    }

    /**
     * Queries the alert statistics on container assets.
     *
     * @remarks
     * Only users who created a Container Registry Enterprise Edition instance can call this operation.
     *
     * @param request - DescribeContainerStatisticsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeContainerStatisticsResponse
     *
     * @param DescribeContainerStatisticsRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeContainerStatisticsResponse
     */
    public function describeContainerStatisticsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeContainerStatistics',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeContainerStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the alert statistics on container assets.
     *
     * @remarks
     * Only users who created a Container Registry Enterprise Edition instance can call this operation.
     *
     * @param request - DescribeContainerStatisticsRequest
     *
     * @returns DescribeContainerStatisticsResponse
     *
     * @param DescribeContainerStatisticsRequest $request
     *
     * @return DescribeContainerStatisticsResponse
     */
    public function describeContainerStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeContainerStatisticsWithOptions($request, $runtime);
    }

    /**
     * Queries the details of container assets by using an attribute.
     *
     * @param request - DescribeContainerTagsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeContainerTagsResponse
     *
     * @param DescribeContainerTagsRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DescribeContainerTagsResponse
     */
    public function describeContainerTagsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->fieldName) {
            @$query['FieldName'] = $request->fieldName;
        }

        if (null !== $request->fieldValue) {
            @$query['FieldValue'] = $request->fieldValue;
        }

        if (null !== $request->namespace) {
            @$query['Namespace'] = $request->namespace;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeContainerTags',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeContainerTagsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of container assets by using an attribute.
     *
     * @param request - DescribeContainerTagsRequest
     *
     * @returns DescribeContainerTagsResponse
     *
     * @param DescribeContainerTagsRequest $request
     *
     * @return DescribeContainerTagsResponse
     */
    public function describeContainerTags($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeContainerTagsWithOptions($request, $runtime);
    }

    /**
     * Queries the number of images that are not scanned.
     *
     * @param request - DescribeCountNotScannedImageRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCountNotScannedImageResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeCountNotScannedImageResponse
     */
    public function describeCountNotScannedImageWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeCountNotScannedImage',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCountNotScannedImageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the number of images that are not scanned.
     *
     * @returns DescribeCountNotScannedImageResponse
     *
     * @return DescribeCountNotScannedImageResponse
     */
    public function describeCountNotScannedImage()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCountNotScannedImageWithOptions($runtime);
    }

    /**
     * Queries the number of images that are scanned.
     *
     * @param request - DescribeCountScannedImageRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCountScannedImageResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeCountScannedImageResponse
     */
    public function describeCountScannedImageWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeCountScannedImage',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCountScannedImageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the number of images that are scanned.
     *
     * @returns DescribeCountScannedImageResponse
     *
     * @return DescribeCountScannedImageResponse
     */
    public function describeCountScannedImage()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCountScannedImageWithOptions($runtime);
    }

    /**
     * Queries the filter conditions that are used to search for assets in fuzzy match mode.
     *
     * @param request - DescribeCriteriaRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCriteriaResponse
     *
     * @param DescribeCriteriaRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DescribeCriteriaResponse
     */
    public function describeCriteriaWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->machineTypes) {
            @$query['MachineTypes'] = $request->machineTypes;
        }

        if (null !== $request->supportAutoTag) {
            @$query['SupportAutoTag'] = $request->supportAutoTag;
        }

        if (null !== $request->value) {
            @$query['Value'] = $request->value;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCriteria',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCriteriaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the filter conditions that are used to search for assets in fuzzy match mode.
     *
     * @param request - DescribeCriteriaRequest
     *
     * @returns DescribeCriteriaResponse
     *
     * @param DescribeCriteriaRequest $request
     *
     * @return DescribeCriteriaResponse
     */
    public function describeCriteria($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCriteriaWithOptions($request, $runtime);
    }

    /**
     * Queries the list of servers on which the custom defense rule against brute-force attacks takes effect.
     *
     * @param request - DescribeCustomBlockInstancesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCustomBlockInstancesResponse
     *
     * @param DescribeCustomBlockInstancesRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribeCustomBlockInstancesResponse
     */
    public function describeCustomBlockInstancesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->blockIp) {
            @$query['BlockIp'] = $request->blockIp;
        }

        if (null !== $request->bound) {
            @$query['Bound'] = $request->bound;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCustomBlockInstances',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCustomBlockInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the list of servers on which the custom defense rule against brute-force attacks takes effect.
     *
     * @param request - DescribeCustomBlockInstancesRequest
     *
     * @returns DescribeCustomBlockInstancesResponse
     *
     * @param DescribeCustomBlockInstancesRequest $request
     *
     * @return DescribeCustomBlockInstancesResponse
     */
    public function describeCustomBlockInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCustomBlockInstancesWithOptions($request, $runtime);
    }

    /**
     * Queries the defense rules against brute-force attacks that are applied to one or more servers.
     *
     * @param request - DescribeCustomBlockRecordsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCustomBlockRecordsResponse
     *
     * @param DescribeCustomBlockRecordsRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeCustomBlockRecordsResponse
     */
    public function describeCustomBlockRecordsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->blockIp) {
            @$query['BlockIp'] = $request->blockIp;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCustomBlockRecords',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCustomBlockRecordsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the defense rules against brute-force attacks that are applied to one or more servers.
     *
     * @param request - DescribeCustomBlockRecordsRequest
     *
     * @returns DescribeCustomBlockRecordsResponse
     *
     * @param DescribeCustomBlockRecordsRequest $request
     *
     * @return DescribeCustomBlockRecordsResponse
     */
    public function describeCustomBlockRecords($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCustomBlockRecordsWithOptions($request, $runtime);
    }

    /**
     * Obtains the configurations of a security report.
     *
     * @param request - DescribeCustomizeReportConfigDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCustomizeReportConfigDetailResponse
     *
     * @param DescribeCustomizeReportConfigDetailRequest $request
     * @param RuntimeOptions                             $runtime
     *
     * @return DescribeCustomizeReportConfigDetailResponse
     */
    public function describeCustomizeReportConfigDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->reportId) {
            @$query['ReportId'] = $request->reportId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCustomizeReportConfigDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCustomizeReportConfigDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Obtains the configurations of a security report.
     *
     * @param request - DescribeCustomizeReportConfigDetailRequest
     *
     * @returns DescribeCustomizeReportConfigDetailResponse
     *
     * @param DescribeCustomizeReportConfigDetailRequest $request
     *
     * @return DescribeCustomizeReportConfigDetailResponse
     */
    public function describeCustomizeReportConfigDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCustomizeReportConfigDetailWithOptions($request, $runtime);
    }

    /**
     * Queries security reports.
     *
     * @param request - DescribeCustomizeReportListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCustomizeReportListResponse
     *
     * @param DescribeCustomizeReportListRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeCustomizeReportListResponse
     */
    public function describeCustomizeReportListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pinned) {
            @$query['Pinned'] = $request->pinned;
        }

        if (null !== $request->reportStatus) {
            @$query['ReportStatus'] = $request->reportStatus;
        }

        if (null !== $request->reportType) {
            @$query['ReportType'] = $request->reportType;
        }

        if (null !== $request->reportVersion) {
            @$query['ReportVersion'] = $request->reportVersion;
        }

        if (null !== $request->title) {
            @$query['Title'] = $request->title;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCustomizeReportList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCustomizeReportListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries security reports.
     *
     * @param request - DescribeCustomizeReportListRequest
     *
     * @returns DescribeCustomizeReportListResponse
     *
     * @param DescribeCustomizeReportListRequest $request
     *
     * @return DescribeCustomizeReportListResponse
     */
    public function describeCustomizeReportList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCustomizeReportListWithOptions($request, $runtime);
    }

    /**
     * View the result of custom weak password uploads.
     *
     * @param request - DescribeCustomizedDictRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCustomizedDictResponse
     *
     * @param DescribeCustomizedDictRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DescribeCustomizedDictResponse
     */
    public function describeCustomizedDictWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCustomizedDict',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCustomizedDictResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * View the result of custom weak password uploads.
     *
     * @param request - DescribeCustomizedDictRequest
     *
     * @returns DescribeCustomizedDictResponse
     *
     * @param DescribeCustomizedDictRequest $request
     *
     * @return DescribeCustomizedDictResponse
     */
    public function describeCustomizedDict($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCustomizedDictWithOptions($request, $runtime);
    }

    /**
     * Queries the Object Storage Service (OSS) information of the file that is uploaded to create custom weak password rules.
     *
     * @param request - DescribeCustomizedDictUploadInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCustomizedDictUploadInfoResponse
     *
     * @param DescribeCustomizedDictUploadInfoRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return DescribeCustomizedDictUploadInfoResponse
     */
    public function describeCustomizedDictUploadInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCustomizedDictUploadInfo',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCustomizedDictUploadInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the Object Storage Service (OSS) information of the file that is uploaded to create custom weak password rules.
     *
     * @param request - DescribeCustomizedDictUploadInfoRequest
     *
     * @returns DescribeCustomizedDictUploadInfoResponse
     *
     * @param DescribeCustomizedDictUploadInfoRequest $request
     *
     * @return DescribeCustomizedDictUploadInfoResponse
     */
    public function describeCustomizedDictUploadInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCustomizedDictUploadInfoWithOptions($request, $runtime);
    }

    /**
     * Queries the servers to which custom policies are applied.
     *
     * @param request - DescribeCustomizedStrategyTargetsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCustomizedStrategyTargetsResponse
     *
     * @param DescribeCustomizedStrategyTargetsRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return DescribeCustomizedStrategyTargetsResponse
     */
    public function describeCustomizedStrategyTargetsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCustomizedStrategyTargets',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCustomizedStrategyTargetsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the servers to which custom policies are applied.
     *
     * @param request - DescribeCustomizedStrategyTargetsRequest
     *
     * @returns DescribeCustomizedStrategyTargetsResponse
     *
     * @param DescribeCustomizedStrategyTargetsRequest $request
     *
     * @return DescribeCustomizedStrategyTargetsResponse
     */
    public function describeCustomizedStrategyTargets($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCustomizedStrategyTargetsWithOptions($request, $runtime);
    }

    /**
     * Queries periodic scan tasks. The tasks include image scan tasks, urgent vulnerability scan tasks, and virus scan tasks.
     *
     * @param request - DescribeCycleTaskListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCycleTaskListResponse
     *
     * @param DescribeCycleTaskListRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DescribeCycleTaskListResponse
     */
    public function describeCycleTaskListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->configId) {
            @$query['ConfigId'] = $request->configId;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->taskName) {
            @$query['TaskName'] = $request->taskName;
        }

        if (null !== $request->taskType) {
            @$query['TaskType'] = $request->taskType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCycleTaskList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCycleTaskListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries periodic scan tasks. The tasks include image scan tasks, urgent vulnerability scan tasks, and virus scan tasks.
     *
     * @param request - DescribeCycleTaskListRequest
     *
     * @returns DescribeCycleTaskListResponse
     *
     * @param DescribeCycleTaskListRequest $request
     *
     * @return DescribeCycleTaskListResponse
     */
    public function describeCycleTaskList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCycleTaskListWithOptions($request, $runtime);
    }

    /**
     * Queries data sources for DingTalk notifications. You can configure the types of alerts for which you want to use a DingTalk chatbot to send notifications based on the data sources.
     *
     * @param request - DescribeDataSourceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDataSourceResponse
     *
     * @param DescribeDataSourceRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return DescribeDataSourceResponse
     */
    public function describeDataSourceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->configType) {
            @$query['ConfigType'] = $request->configType;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDataSource',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDataSourceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries data sources for DingTalk notifications. You can configure the types of alerts for which you want to use a DingTalk chatbot to send notifications based on the data sources.
     *
     * @param request - DescribeDataSourceRequest
     *
     * @returns DescribeDataSourceResponse
     *
     * @param DescribeDataSourceRequest $request
     *
     * @return DescribeDataSourceResponse
     */
    public function describeDataSource($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDataSourceWithOptions($request, $runtime);
    }

    /**
     * Queries the keywords of a custom dictionary that is generated by using weak passwords.
     *
     * @param request - DescribeDefaultKeyInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDefaultKeyInfoResponse
     *
     * @param DescribeDefaultKeyInfoRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DescribeDefaultKeyInfoResponse
     */
    public function describeDefaultKeyInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDefaultKeyInfo',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDefaultKeyInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the keywords of a custom dictionary that is generated by using weak passwords.
     *
     * @param request - DescribeDefaultKeyInfoRequest
     *
     * @returns DescribeDefaultKeyInfoResponse
     *
     * @param DescribeDefaultKeyInfoRequest $request
     *
     * @return DescribeDefaultKeyInfoResponse
     */
    public function describeDefaultKeyInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDefaultKeyInfoWithOptions($request, $runtime);
    }

    /**
     * Queries the default installation version of the proxy that is used in hybrid-cloud scenarios.
     *
     * @param request - DescribeDefaultProxyInstallVersionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDefaultProxyInstallVersionResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeDefaultProxyInstallVersionResponse
     */
    public function describeDefaultProxyInstallVersionWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeDefaultProxyInstallVersion',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDefaultProxyInstallVersionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the default installation version of the proxy that is used in hybrid-cloud scenarios.
     *
     * @returns DescribeDefaultProxyInstallVersionResponse
     *
     * @return DescribeDefaultProxyInstallVersionResponse
     */
    public function describeDefaultProxyInstallVersion()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDefaultProxyInstallVersionWithOptions($runtime);
    }

    /**
     * Obtains DingTalk notifications.
     *
     * @param request - DescribeDingTalkRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDingTalkResponse
     *
     * @param DescribeDingTalkRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DescribeDingTalkResponse
     */
    public function describeDingTalkWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->ruleActionName) {
            @$query['RuleActionName'] = $request->ruleActionName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDingTalk',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDingTalkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Obtains DingTalk notifications.
     *
     * @param request - DescribeDingTalkRequest
     *
     * @returns DescribeDingTalkResponse
     *
     * @param DescribeDingTalkRequest $request
     *
     * @return DescribeDingTalkResponse
     */
    public function describeDingTalk($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDingTalkWithOptions($request, $runtime);
    }

    /**
     * Queries the number of domain assets within your Alibaba Cloud account.
     *
     * @param request - DescribeDomainCountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDomainCountResponse
     *
     * @param DescribeDomainCountRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DescribeDomainCountResponse
     */
    public function describeDomainCountWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDomainCount',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDomainCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the number of domain assets within your Alibaba Cloud account.
     *
     * @param request - DescribeDomainCountRequest
     *
     * @returns DescribeDomainCountResponse
     *
     * @param DescribeDomainCountRequest $request
     *
     * @return DescribeDomainCountResponse
     */
    public function describeDomainCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDomainCountWithOptions($request, $runtime);
    }

    /**
     * Queries the details of domain assets within your Alibaba Cloud account.
     *
     * @param request - DescribeDomainDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDomainDetailResponse
     *
     * @param DescribeDomainDetailRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DescribeDomainDetailResponse
     */
    public function describeDomainDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domainName) {
            @$query['DomainName'] = $request->domainName;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDomainDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDomainDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of domain assets within your Alibaba Cloud account.
     *
     * @param request - DescribeDomainDetailRequest
     *
     * @returns DescribeDomainDetailResponse
     *
     * @param DescribeDomainDetailRequest $request
     *
     * @return DescribeDomainDetailResponse
     */
    public function describeDomainDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDomainDetailWithOptions($request, $runtime);
    }

    /**
     * Queries the information about the domain assets within your Alibaba Cloud account.
     *
     * @param request - DescribeDomainListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDomainListResponse
     *
     * @param DescribeDomainListRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return DescribeDomainListResponse
     */
    public function describeDomainListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->domainType) {
            @$query['DomainType'] = $request->domainType;
        }

        if (null !== $request->fuzzyDomain) {
            @$query['FuzzyDomain'] = $request->fuzzyDomain;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDomainList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDomainListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about the domain assets within your Alibaba Cloud account.
     *
     * @param request - DescribeDomainListRequest
     *
     * @returns DescribeDomainListResponse
     *
     * @param DescribeDomainListRequest $request
     *
     * @return DescribeDomainListResponse
     */
    public function describeDomainList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDomainListWithOptions($request, $runtime);
    }

    /**
     * Queries the security alert data of a website security report.
     *
     * @param request - DescribeDomainSecureAlarmListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDomainSecureAlarmListResponse
     *
     * @param DescribeDomainSecureAlarmListRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DescribeDomainSecureAlarmListResponse
     */
    public function describeDomainSecureAlarmListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDomainSecureAlarmList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDomainSecureAlarmListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the security alert data of a website security report.
     *
     * @param request - DescribeDomainSecureAlarmListRequest
     *
     * @returns DescribeDomainSecureAlarmListResponse
     *
     * @param DescribeDomainSecureAlarmListRequest $request
     *
     * @return DescribeDomainSecureAlarmListResponse
     */
    public function describeDomainSecureAlarmList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDomainSecureAlarmListWithOptions($request, $runtime);
    }

    /**
     * Queries a list of risky websites in your website security report and the security information about the websites, including the number of vulnerabilities and the number of alerts.
     *
     * @param request - DescribeDomainSecureRiskListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDomainSecureRiskListResponse
     *
     * @param DescribeDomainSecureRiskListRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribeDomainSecureRiskListResponse
     */
    public function describeDomainSecureRiskListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDomainSecureRiskList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDomainSecureRiskListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of risky websites in your website security report and the security information about the websites, including the number of vulnerabilities and the number of alerts.
     *
     * @param request - DescribeDomainSecureRiskListRequest
     *
     * @returns DescribeDomainSecureRiskListResponse
     *
     * @param DescribeDomainSecureRiskListRequest $request
     *
     * @return DescribeDomainSecureRiskListResponse
     */
    public function describeDomainSecureRiskList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDomainSecureRiskListWithOptions($request, $runtime);
    }

    /**
     * Queries the security score in your website security report. The full score is 100.
     *
     * @param request - DescribeDomainSecureScoreRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDomainSecureScoreResponse
     *
     * @param DescribeDomainSecureScoreRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeDomainSecureScoreResponse
     */
    public function describeDomainSecureScoreWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDomainSecureScore',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDomainSecureScoreResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the security score in your website security report. The full score is 100.
     *
     * @param request - DescribeDomainSecureScoreRequest
     *
     * @returns DescribeDomainSecureScoreResponse
     *
     * @param DescribeDomainSecureScoreRequest $request
     *
     * @return DescribeDomainSecureScoreResponse
     */
    public function describeDomainSecureScore($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDomainSecureScoreWithOptions($request, $runtime);
    }

    /**
     * Queries the statistics in your website security report, including the number of websites and the number of security events.
     *
     * @param request - DescribeDomainSecureStatisticsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDomainSecureStatisticsResponse
     *
     * @param DescribeDomainSecureStatisticsRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DescribeDomainSecureStatisticsResponse
     */
    public function describeDomainSecureStatisticsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDomainSecureStatistics',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDomainSecureStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics in your website security report, including the number of websites and the number of security events.
     *
     * @param request - DescribeDomainSecureStatisticsRequest
     *
     * @returns DescribeDomainSecureStatisticsResponse
     *
     * @param DescribeDomainSecureStatisticsRequest $request
     *
     * @return DescribeDomainSecureStatisticsResponse
     */
    public function describeDomainSecureStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDomainSecureStatisticsWithOptions($request, $runtime);
    }

    /**
     * Query Network Security Report - Security Suggestions.
     *
     * @param request - DescribeDomainSecureSuggestsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDomainSecureSuggestsResponse
     *
     * @param DescribeDomainSecureSuggestsRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribeDomainSecureSuggestsResponse
     */
    public function describeDomainSecureSuggestsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDomainSecureSuggests',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDomainSecureSuggestsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Query Network Security Report - Security Suggestions.
     *
     * @param request - DescribeDomainSecureSuggestsRequest
     *
     * @returns DescribeDomainSecureSuggestsResponse
     *
     * @param DescribeDomainSecureSuggestsRequest $request
     *
     * @return DescribeDomainSecureSuggestsResponse
     */
    public function describeDomainSecureSuggests($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDomainSecureSuggestsWithOptions($request, $runtime);
    }

    /**
     * Queries a list of vulnerabilities in your website security report.
     *
     * @param request - DescribeDomainSecureVulListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDomainSecureVulListResponse
     *
     * @param DescribeDomainSecureVulListRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeDomainSecureVulListResponse
     */
    public function describeDomainSecureVulListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDomainSecureVulList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDomainSecureVulListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of vulnerabilities in your website security report.
     *
     * @param request - DescribeDomainSecureVulListRequest
     *
     * @returns DescribeDomainSecureVulListResponse
     *
     * @param DescribeDomainSecureVulListRequest $request
     *
     * @return DescribeDomainSecureVulListResponse
     */
    public function describeDomainSecureVulList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDomainSecureVulListWithOptions($request, $runtime);
    }

    /**
     * Queries custom weak password rules for the baseline check feature.
     *
     * @deprecated openAPI DescribeDynamicDict is deprecated, please use Sas::2018-12-03::DescribeCustomizedDict instead
     *
     * @param request - DescribeDynamicDictRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDynamicDictResponse
     *
     * @param DescribeDynamicDictRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DescribeDynamicDictResponse
     */
    public function describeDynamicDictWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDynamicDict',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDynamicDictResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Queries custom weak password rules for the baseline check feature.
     *
     * @deprecated openAPI DescribeDynamicDict is deprecated, please use Sas::2018-12-03::DescribeCustomizedDict instead
     *
     * @param request - DescribeDynamicDictRequest
     *
     * @returns DescribeDynamicDictResponse
     *
     * @param DescribeDynamicDictRequest $request
     *
     * @return DescribeDynamicDictResponse
     */
    public function describeDynamicDict($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDynamicDictWithOptions($request, $runtime);
    }

    /**
     * Queries the information about an uploaded Object Storage Service (OSS) object that contains custom weak passwords and is used for baseline checks.
     *
     * @deprecated openAPI DescribeDynamicDictUploadInfo is deprecated, please use Sas::2018-12-03::DescribeCustomizedDictUploadInfo instead
     *
     * @param request - DescribeDynamicDictUploadInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDynamicDictUploadInfoResponse
     *
     * @param DescribeDynamicDictUploadInfoRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DescribeDynamicDictUploadInfoResponse
     */
    public function describeDynamicDictUploadInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDynamicDictUploadInfo',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDynamicDictUploadInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Queries the information about an uploaded Object Storage Service (OSS) object that contains custom weak passwords and is used for baseline checks.
     *
     * @deprecated openAPI DescribeDynamicDictUploadInfo is deprecated, please use Sas::2018-12-03::DescribeCustomizedDictUploadInfo instead
     *
     * @param request - DescribeDynamicDictUploadInfoRequest
     *
     * @returns DescribeDynamicDictUploadInfoResponse
     *
     * @param DescribeDynamicDictUploadInfoRequest $request
     *
     * @return DescribeDynamicDictUploadInfoResponse
     */
    public function describeDynamicDictUploadInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDynamicDictUploadInfoWithOptions($request, $runtime);
    }

    /**
     * Queries whether Security Center is authorized to scan for urgent vulnerabilities.
     *
     * @param request - DescribeEmgUserAgreementRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeEmgUserAgreementResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeEmgUserAgreementResponse
     */
    public function describeEmgUserAgreementWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeEmgUserAgreement',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeEmgUserAgreementResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries whether Security Center is authorized to scan for urgent vulnerabilities.
     *
     * @returns DescribeEmgUserAgreementResponse
     *
     * @return DescribeEmgUserAgreementResponse
     */
    public function describeEmgUserAgreement()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeEmgUserAgreementWithOptions($runtime);
    }

    /**
     * Queries the details of urgent vulnerabilities.
     *
     * @param request - DescribeEmgVulItemRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeEmgVulItemResponse
     *
     * @param DescribeEmgVulItemRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return DescribeEmgVulItemResponse
     */
    public function describeEmgVulItemWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->checkType) {
            @$query['CheckType'] = $request->checkType;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->riskStatus) {
            @$query['RiskStatus'] = $request->riskStatus;
        }

        if (null !== $request->scanType) {
            @$query['ScanType'] = $request->scanType;
        }

        if (null !== $request->vulName) {
            @$query['VulName'] = $request->vulName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeEmgVulItem',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeEmgVulItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of urgent vulnerabilities.
     *
     * @param request - DescribeEmgVulItemRequest
     *
     * @returns DescribeEmgVulItemResponse
     *
     * @param DescribeEmgVulItemRequest $request
     *
     * @return DescribeEmgVulItemResponse
     */
    public function describeEmgVulItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeEmgVulItemWithOptions($request, $runtime);
    }

    /**
     * Queries the statistics of alert events by risk level.
     *
     * @param request - DescribeEventLevelCountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeEventLevelCountResponse
     *
     * @param DescribeEventLevelCountRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeEventLevelCountResponse
     */
    public function describeEventLevelCountWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->containerFieldName) {
            @$query['ContainerFieldName'] = $request->containerFieldName;
        }

        if (null !== $request->containerFieldValue) {
            @$query['ContainerFieldValue'] = $request->containerFieldValue;
        }

        if (null !== $request->containerIds) {
            @$query['ContainerIds'] = $request->containerIds;
        }

        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        if (null !== $request->multiAccountActionType) {
            @$query['MultiAccountActionType'] = $request->multiAccountActionType;
        }

        if (null !== $request->targetType) {
            @$query['TargetType'] = $request->targetType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeEventLevelCount',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeEventLevelCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics of alert events by risk level.
     *
     * @param request - DescribeEventLevelCountRequest
     *
     * @returns DescribeEventLevelCountResponse
     *
     * @param DescribeEventLevelCountRequest $request
     *
     * @return DescribeEventLevelCountResponse
     */
    public function describeEventLevelCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeEventLevelCountWithOptions($request, $runtime);
    }

    /**
     * Queries the platforms that are supported by the feature of container threat detection.
     *
     * @param request - DescribeEventOnStageRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeEventOnStageResponse
     *
     * @param DescribeEventOnStageRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DescribeEventOnStageResponse
     */
    public function describeEventOnStageWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeEventOnStage',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeEventOnStageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the platforms that are supported by the feature of container threat detection.
     *
     * @param request - DescribeEventOnStageRequest
     *
     * @returns DescribeEventOnStageResponse
     *
     * @param DescribeEventOnStageRequest $request
     *
     * @return DescribeEventOnStageResponse
     */
    public function describeEventOnStage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeEventOnStageWithOptions($request, $runtime);
    }

    /**
     * Queries the directories that are excluded from anti-ransomware.
     *
     * @param request - DescribeExcludeSystemPathRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeExcludeSystemPathResponse
     *
     * @param DescribeExcludeSystemPathRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeExcludeSystemPathResponse
     */
    public function describeExcludeSystemPathWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeExcludeSystemPath',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeExcludeSystemPathResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the directories that are excluded from anti-ransomware.
     *
     * @param request - DescribeExcludeSystemPathRequest
     *
     * @returns DescribeExcludeSystemPathResponse
     *
     * @param DescribeExcludeSystemPathRequest $request
     *
     * @return DescribeExcludeSystemPathResponse
     */
    public function describeExcludeSystemPath($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeExcludeSystemPathWithOptions($request, $runtime);
    }

    /**
     * Queries the progress of a task that exports your assets to an Excel file.
     *
     * @param request - DescribeExportInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeExportInfoResponse
     *
     * @param DescribeExportInfoRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return DescribeExportInfoResponse
     */
    public function describeExportInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->exportId) {
            @$query['ExportId'] = $request->exportId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeExportInfo',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeExportInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the progress of a task that exports your assets to an Excel file.
     *
     * @param request - DescribeExportInfoRequest
     *
     * @returns DescribeExportInfoResponse
     *
     * @param DescribeExportInfoRequest $request
     *
     * @return DescribeExportInfoResponse
     */
    public function describeExportInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeExportInfoWithOptions($request, $runtime);
    }

    /**
     * Queries the weak password-related risks of a specified server that is exposed on the Internet.
     *
     * @param request - DescribeExposedCheckWarningRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeExposedCheckWarningResponse
     *
     * @param DescribeExposedCheckWarningRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeExposedCheckWarningResponse
     */
    public function describeExposedCheckWarningWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->typeName) {
            @$query['TypeName'] = $request->typeName;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeExposedCheckWarning',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeExposedCheckWarningResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the weak password-related risks of a specified server that is exposed on the Internet.
     *
     * @param request - DescribeExposedCheckWarningRequest
     *
     * @returns DescribeExposedCheckWarningResponse
     *
     * @param DescribeExposedCheckWarningRequest $request
     *
     * @return DescribeExposedCheckWarningResponse
     */
    public function describeExposedCheckWarning($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeExposedCheckWarningWithOptions($request, $runtime);
    }

    /**
     * Queries the search conditions that are used to search for exposed assets.
     *
     * @param request - DescribeExposedInstanceCriteriaRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeExposedInstanceCriteriaResponse
     *
     * @param DescribeExposedInstanceCriteriaRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return DescribeExposedInstanceCriteriaResponse
     */
    public function describeExposedInstanceCriteriaWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        if (null !== $request->value) {
            @$query['Value'] = $request->value;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeExposedInstanceCriteria',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeExposedInstanceCriteriaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the search conditions that are used to search for exposed assets.
     *
     * @param request - DescribeExposedInstanceCriteriaRequest
     *
     * @returns DescribeExposedInstanceCriteriaResponse
     *
     * @param DescribeExposedInstanceCriteriaRequest $request
     *
     * @return DescribeExposedInstanceCriteriaResponse
     */
    public function describeExposedInstanceCriteria($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeExposedInstanceCriteriaWithOptions($request, $runtime);
    }

    /**
     * Queries the details of a specified server that is exposed on the Internet.
     *
     * @param request - DescribeExposedInstanceDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeExposedInstanceDetailResponse
     *
     * @param DescribeExposedInstanceDetailRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DescribeExposedInstanceDetailResponse
     */
    public function describeExposedInstanceDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeExposedInstanceDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeExposedInstanceDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of a specified server that is exposed on the Internet.
     *
     * @param request - DescribeExposedInstanceDetailRequest
     *
     * @returns DescribeExposedInstanceDetailResponse
     *
     * @param DescribeExposedInstanceDetailRequest $request
     *
     * @return DescribeExposedInstanceDetailResponse
     */
    public function describeExposedInstanceDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeExposedInstanceDetailWithOptions($request, $runtime);
    }

    /**
     * Queries the information about the assets that are exposed on the Internet.
     *
     * @param request - DescribeExposedInstanceListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeExposedInstanceListResponse
     *
     * @param DescribeExposedInstanceListRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeExposedInstanceListResponse
     */
    public function describeExposedInstanceListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->assetType) {
            @$query['AssetType'] = $request->assetType;
        }

        if (null !== $request->cspmStatus) {
            @$query['CspmStatus'] = $request->cspmStatus;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->exposureComponent) {
            @$query['ExposureComponent'] = $request->exposureComponent;
        }

        if (null !== $request->exposureComponentBizType) {
            @$query['ExposureComponentBizType'] = $request->exposureComponentBizType;
        }

        if (null !== $request->exposureIp) {
            @$query['ExposureIp'] = $request->exposureIp;
        }

        if (null !== $request->exposurePort) {
            @$query['ExposurePort'] = $request->exposurePort;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        if (null !== $request->healthStatus) {
            @$query['HealthStatus'] = $request->healthStatus;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->instanceName) {
            @$query['InstanceName'] = $request->instanceName;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        if (null !== $request->vulStatus) {
            @$query['VulStatus'] = $request->vulStatus;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeExposedInstanceList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeExposedInstanceListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about the assets that are exposed on the Internet.
     *
     * @param request - DescribeExposedInstanceListRequest
     *
     * @returns DescribeExposedInstanceListResponse
     *
     * @param DescribeExposedInstanceListRequest $request
     *
     * @return DescribeExposedInstanceListResponse
     */
    public function describeExposedInstanceList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeExposedInstanceListWithOptions($request, $runtime);
    }

    /**
     * Queries the exposure statistics of the assets on the Internet.
     *
     * @param request - DescribeExposedStatisticsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeExposedStatisticsResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeExposedStatisticsResponse
     */
    public function describeExposedStatisticsWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeExposedStatistics',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeExposedStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the exposure statistics of the assets on the Internet.
     *
     * @returns DescribeExposedStatisticsResponse
     *
     * @return DescribeExposedStatisticsResponse
     */
    public function describeExposedStatistics()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeExposedStatisticsWithOptions($runtime);
    }

    /**
     * Queries the gateway assets, ports, system components, or public IP addresses that are exposed on the Internet.
     *
     * @param request - DescribeExposedStatisticsDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeExposedStatisticsDetailResponse
     *
     * @param DescribeExposedStatisticsDetailRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return DescribeExposedStatisticsDetailResponse
     */
    public function describeExposedStatisticsDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->criteria) {
            @$query['Criteria'] = $request->criteria;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->exposureIp) {
            @$query['ExposureIp'] = $request->exposureIp;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        if (null !== $request->statisticsType) {
            @$query['StatisticsType'] = $request->statisticsType;
        }

        if (null !== $request->statisticsTypeGatewayType) {
            @$query['StatisticsTypeGatewayType'] = $request->statisticsTypeGatewayType;
        }

        if (null !== $request->statisticsTypeInstanceValue) {
            @$query['StatisticsTypeInstanceValue'] = $request->statisticsTypeInstanceValue;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeExposedStatisticsDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeExposedStatisticsDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the gateway assets, ports, system components, or public IP addresses that are exposed on the Internet.
     *
     * @param request - DescribeExposedStatisticsDetailRequest
     *
     * @returns DescribeExposedStatisticsDetailResponse
     *
     * @param DescribeExposedStatisticsDetailRequest $request
     *
     * @return DescribeExposedStatisticsDetailResponse
     */
    public function describeExposedStatisticsDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeExposedStatisticsDetailWithOptions($request, $runtime);
    }

    /**
     * Queries the statistics of servers.
     *
     * @param request - DescribeFieldStatisticsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeFieldStatisticsResponse
     *
     * @param DescribeFieldStatisticsRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeFieldStatisticsResponse
     */
    public function describeFieldStatisticsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->machineTypes) {
            @$query['MachineTypes'] = $request->machineTypes;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeFieldStatistics',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeFieldStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics of servers.
     *
     * @param request - DescribeFieldStatisticsRequest
     *
     * @returns DescribeFieldStatisticsResponse
     *
     * @param DescribeFieldStatisticsRequest $request
     *
     * @return DescribeFieldStatisticsResponse
     */
    public function describeFieldStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeFieldStatisticsWithOptions($request, $runtime);
    }

    /**
     * Queries the number of vulnerabilities that are fixed by the pay-as-you-go vulnerability fixing feature.
     *
     * @param request - DescribeFixUsedCountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeFixUsedCountResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeFixUsedCountResponse
     */
    public function describeFixUsedCountWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeFixUsedCount',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeFixUsedCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the number of vulnerabilities that are fixed by the pay-as-you-go vulnerability fixing feature.
     *
     * @returns DescribeFixUsedCountResponse
     *
     * @return DescribeFixUsedCountResponse
     */
    public function describeFixUsedCount()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeFixUsedCountWithOptions($runtime);
    }

    /**
     * Queries the pre-patches that are required to fix a specified Windows system vulnerability.
     *
     * @param request - DescribeFrontVulPatchListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeFrontVulPatchListResponse
     *
     * @param DescribeFrontVulPatchListRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeFrontVulPatchListResponse
     */
    public function describeFrontVulPatchListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->info) {
            @$query['Info'] = $request->info;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->operateType) {
            @$query['OperateType'] = $request->operateType;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeFrontVulPatchList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeFrontVulPatchListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the pre-patches that are required to fix a specified Windows system vulnerability.
     *
     * @param request - DescribeFrontVulPatchListRequest
     *
     * @returns DescribeFrontVulPatchListResponse
     *
     * @param DescribeFrontVulPatchListRequest $request
     *
     * @return DescribeFrontVulPatchListResponse
     */
    public function describeFrontVulPatchList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeFrontVulPatchListWithOptions($request, $runtime);
    }

    /**
     * Alert Event Investigation.
     *
     * @param request - DescribeGraph4InvestigationOnlineRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeGraph4InvestigationOnlineResponse
     *
     * @param DescribeGraph4InvestigationOnlineRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return DescribeGraph4InvestigationOnlineResponse
     */
    public function describeGraph4InvestigationOnlineWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->anomalyId) {
            @$query['AnomalyId'] = $request->anomalyId;
        }

        if (null !== $request->anomalyUuid) {
            @$query['AnomalyUuid'] = $request->anomalyUuid;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->namespace) {
            @$query['Namespace'] = $request->namespace;
        }

        if (null !== $request->vertexId) {
            @$query['VertexId'] = $request->vertexId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeGraph4InvestigationOnline',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeGraph4InvestigationOnlineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Alert Event Investigation.
     *
     * @param request - DescribeGraph4InvestigationOnlineRequest
     *
     * @returns DescribeGraph4InvestigationOnlineResponse
     *
     * @param DescribeGraph4InvestigationOnlineRequest $request
     *
     * @return DescribeGraph4InvestigationOnlineResponse
     */
    public function describeGraph4InvestigationOnline($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeGraph4InvestigationOnlineWithOptions($request, $runtime);
    }

    /**
     * Queries the structure of a group.
     *
     * @param request - DescribeGroupStructRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeGroupStructResponse
     *
     * @param DescribeGroupStructRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DescribeGroupStructResponse
     */
    public function describeGroupStructWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeGroupStruct',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeGroupStructResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the structure of a group.
     *
     * @param request - DescribeGroupStructRequest
     *
     * @returns DescribeGroupStructResponse
     *
     * @param DescribeGroupStructRequest $request
     *
     * @return DescribeGroupStructResponse
     */
    public function describeGroupStruct($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeGroupStructWithOptions($request, $runtime);
    }

    /**
     * Queries containers by group type.
     *
     * @param request - DescribeGroupedContainerInstancesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeGroupedContainerInstancesResponse
     *
     * @param DescribeGroupedContainerInstancesRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return DescribeGroupedContainerInstancesResponse
     */
    public function describeGroupedContainerInstancesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->criteria) {
            @$query['Criteria'] = $request->criteria;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->fieldValue) {
            @$query['FieldValue'] = $request->fieldValue;
        }

        if (null !== $request->groupField) {
            @$query['GroupField'] = $request->groupField;
        }

        if (null !== $request->logicalExp) {
            @$query['LogicalExp'] = $request->logicalExp;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeGroupedContainerInstances',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeGroupedContainerInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries containers by group type.
     *
     * @param request - DescribeGroupedContainerInstancesRequest
     *
     * @returns DescribeGroupedContainerInstancesResponse
     *
     * @param DescribeGroupedContainerInstancesRequest $request
     *
     * @return DescribeGroupedContainerInstancesResponse
     */
    public function describeGroupedContainerInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeGroupedContainerInstancesWithOptions($request, $runtime);
    }

    /**
     * Queries the statistical information about assets based on a specified filter condition.
     *
     * @param request - DescribeGroupedInstancesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeGroupedInstancesResponse
     *
     * @param DescribeGroupedInstancesRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeGroupedInstancesResponse
     */
    public function describeGroupedInstancesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->fieldValue) {
            @$query['FieldValue'] = $request->fieldValue;
        }

        if (null !== $request->groupField) {
            @$query['GroupField'] = $request->groupField;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->machineTypes) {
            @$query['MachineTypes'] = $request->machineTypes;
        }

        if (null !== $request->noPage) {
            @$query['NoPage'] = $request->noPage;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->saleVersionCheckCode) {
            @$query['SaleVersionCheckCode'] = $request->saleVersionCheckCode;
        }

        if (null !== $request->vendor) {
            @$query['Vendor'] = $request->vendor;
        }

        if (null !== $request->vendors) {
            @$query['Vendors'] = $request->vendors;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeGroupedInstances',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeGroupedInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistical information about assets based on a specified filter condition.
     *
     * @param request - DescribeGroupedInstancesRequest
     *
     * @returns DescribeGroupedInstancesResponse
     *
     * @param DescribeGroupedInstancesRequest $request
     *
     * @return DescribeGroupedInstancesResponse
     */
    public function describeGroupedInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeGroupedInstancesWithOptions($request, $runtime);
    }

    /**
     * Queries a list of malicious image samples.
     *
     * @param request - DescribeGroupedMaliciousFilesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeGroupedMaliciousFilesResponse
     *
     * @param DescribeGroupedMaliciousFilesRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DescribeGroupedMaliciousFilesResponse
     */
    public function describeGroupedMaliciousFilesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->fuzzyMaliciousName) {
            @$query['FuzzyMaliciousName'] = $request->fuzzyMaliciousName;
        }

        if (null !== $request->imageDigest) {
            @$query['ImageDigest'] = $request->imageDigest;
        }

        if (null !== $request->imageLayer) {
            @$query['ImageLayer'] = $request->imageLayer;
        }

        if (null !== $request->imageTag) {
            @$query['ImageTag'] = $request->imageTag;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->levels) {
            @$query['Levels'] = $request->levels;
        }

        if (null !== $request->maliciousMd5) {
            @$query['MaliciousMd5'] = $request->maliciousMd5;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->repoId) {
            @$query['RepoId'] = $request->repoId;
        }

        if (null !== $request->repoInstanceId) {
            @$query['RepoInstanceId'] = $request->repoInstanceId;
        }

        if (null !== $request->repoName) {
            @$query['RepoName'] = $request->repoName;
        }

        if (null !== $request->repoNamespace) {
            @$query['RepoNamespace'] = $request->repoNamespace;
        }

        if (null !== $request->repoRegionId) {
            @$query['RepoRegionId'] = $request->repoRegionId;
        }

        if (null !== $request->scanRange) {
            @$query['ScanRange'] = $request->scanRange;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeGroupedMaliciousFiles',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeGroupedMaliciousFilesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of malicious image samples.
     *
     * @param request - DescribeGroupedMaliciousFilesRequest
     *
     * @returns DescribeGroupedMaliciousFilesResponse
     *
     * @param DescribeGroupedMaliciousFilesRequest $request
     *
     * @return DescribeGroupedMaliciousFilesResponse
     */
    public function describeGroupedMaliciousFiles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeGroupedMaliciousFilesWithOptions($request, $runtime);
    }

    /**
     * Queries the statistics of asset tags.
     *
     * @param request - DescribeGroupedTagsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeGroupedTagsResponse
     *
     * @param DescribeGroupedTagsRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DescribeGroupedTagsResponse
     */
    public function describeGroupedTagsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->machineTypes) {
            @$query['MachineTypes'] = $request->machineTypes;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeGroupedTags',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeGroupedTagsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics of asset tags.
     *
     * @param request - DescribeGroupedTagsRequest
     *
     * @returns DescribeGroupedTagsResponse
     *
     * @param DescribeGroupedTagsRequest $request
     *
     * @return DescribeGroupedTagsResponse
     */
    public function describeGroupedTags($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeGroupedTagsWithOptions($request, $runtime);
    }

    /**
     * Queries vulnerabilities by group.
     *
     * @param request - DescribeGroupedVulRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeGroupedVulResponse
     *
     * @param DescribeGroupedVulRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return DescribeGroupedVulResponse
     */
    public function describeGroupedVulWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aliasName) {
            @$query['AliasName'] = $request->aliasName;
        }

        if (null !== $request->assetType) {
            @$query['AssetType'] = $request->assetType;
        }

        if (null !== $request->attachTypes) {
            @$query['AttachTypes'] = $request->attachTypes;
        }

        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->containerFieldName) {
            @$query['ContainerFieldName'] = $request->containerFieldName;
        }

        if (null !== $request->containerFieldValue) {
            @$query['ContainerFieldValue'] = $request->containerFieldValue;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->cveId) {
            @$query['CveId'] = $request->cveId;
        }

        if (null !== $request->dealed) {
            @$query['Dealed'] = $request->dealed;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->necessity) {
            @$query['Necessity'] = $request->necessity;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->raspDefend) {
            @$query['RaspDefend'] = $request->raspDefend;
        }

        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        if (null !== $request->searchTags) {
            @$query['SearchTags'] = $request->searchTags;
        }

        if (null !== $request->targetType) {
            @$query['TargetType'] = $request->targetType;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeGroupedVul',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeGroupedVulResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries vulnerabilities by group.
     *
     * @param request - DescribeGroupedVulRequest
     *
     * @returns DescribeGroupedVulResponse
     *
     * @param DescribeGroupedVulRequest $request
     *
     * @return DescribeGroupedVulResponse
     */
    public function describeGroupedVul($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeGroupedVulWithOptions($request, $runtime);
    }

    /**
     * Queries the information about baseline export, including the name of the file to which baselines are exported and the download URL for the file.
     *
     * @param request - DescribeHcExportInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeHcExportInfoResponse
     *
     * @param DescribeHcExportInfoRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DescribeHcExportInfoResponse
     */
    public function describeHcExportInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->exportId) {
            @$query['ExportId'] = $request->exportId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeHcExportInfo',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeHcExportInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about baseline export, including the name of the file to which baselines are exported and the download URL for the file.
     *
     * @param request - DescribeHcExportInfoRequest
     *
     * @returns DescribeHcExportInfoResponse
     *
     * @param DescribeHcExportInfoRequest $request
     *
     * @return DescribeHcExportInfoResponse
     */
    public function describeHcExportInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeHcExportInfoWithOptions($request, $runtime);
    }

    /**
     * Queries statistics on the quota of honeypots.
     *
     * @param request - DescribeHoneyPotAuthRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeHoneyPotAuthResponse
     *
     * @param DescribeHoneyPotAuthRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DescribeHoneyPotAuthResponse
     */
    public function describeHoneyPotAuthWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeHoneyPotAuth',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeHoneyPotAuthResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries statistics on the quota of honeypots.
     *
     * @param request - DescribeHoneyPotAuthRequest
     *
     * @returns DescribeHoneyPotAuthResponse
     *
     * @param DescribeHoneyPotAuthRequest $request
     *
     * @return DescribeHoneyPotAuthResponse
     */
    public function describeHoneyPotAuth($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeHoneyPotAuthWithOptions($request, $runtime);
    }

    /**
     * Queries the top five virtual private clouds (VPCs) or assets for which alerts are most frequently generated.
     *
     * @param request - DescribeHoneyPotSuspStatisticsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeHoneyPotSuspStatisticsResponse
     *
     * @param DescribeHoneyPotSuspStatisticsRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DescribeHoneyPotSuspStatisticsResponse
     */
    public function describeHoneyPotSuspStatisticsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->statisticsDays) {
            @$query['StatisticsDays'] = $request->statisticsDays;
        }

        if (null !== $request->statisticsKeyType) {
            @$query['StatisticsKeyType'] = $request->statisticsKeyType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeHoneyPotSuspStatistics',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeHoneyPotSuspStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the top five virtual private clouds (VPCs) or assets for which alerts are most frequently generated.
     *
     * @param request - DescribeHoneyPotSuspStatisticsRequest
     *
     * @returns DescribeHoneyPotSuspStatisticsResponse
     *
     * @param DescribeHoneyPotSuspStatisticsRequest $request
     *
     * @return DescribeHoneyPotSuspStatisticsResponse
     */
    public function describeHoneyPotSuspStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeHoneyPotSuspStatisticsWithOptions($request, $runtime);
    }

    /**
     * Queries proxy clusters by page.
     *
     * @param request - DescribeHybridProxyClusterListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeHybridProxyClusterListResponse
     *
     * @param DescribeHybridProxyClusterListRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DescribeHybridProxyClusterListResponse
     */
    public function describeHybridProxyClusterListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterName) {
            @$query['ClusterName'] = $request->clusterName;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeHybridProxyClusterList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeHybridProxyClusterListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries proxy clusters by page.
     *
     * @param request - DescribeHybridProxyClusterListRequest
     *
     * @returns DescribeHybridProxyClusterListResponse
     *
     * @param DescribeHybridProxyClusterListRequest $request
     *
     * @return DescribeHybridProxyClusterListResponse
     */
    public function describeHybridProxyClusterList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeHybridProxyClusterListWithOptions($request, $runtime);
    }

    /**
     * Queries the servers that are connected to a proxy in a hybrid cloud by page.
     *
     * @param request - DescribeHybridProxyLinkedClientListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeHybridProxyLinkedClientListResponse
     *
     * @param DescribeHybridProxyLinkedClientListRequest $request
     * @param RuntimeOptions                             $runtime
     *
     * @return DescribeHybridProxyLinkedClientListResponse
     */
    public function describeHybridProxyLinkedClientListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterName) {
            @$query['ClusterName'] = $request->clusterName;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->proxyUuid) {
            @$query['ProxyUuid'] = $request->proxyUuid;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeHybridProxyLinkedClientList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeHybridProxyLinkedClientListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the servers that are connected to a proxy in a hybrid cloud by page.
     *
     * @param request - DescribeHybridProxyLinkedClientListRequest
     *
     * @returns DescribeHybridProxyLinkedClientListResponse
     *
     * @param DescribeHybridProxyLinkedClientListRequest $request
     *
     * @return DescribeHybridProxyLinkedClientListResponse
     */
    public function describeHybridProxyLinkedClientList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeHybridProxyLinkedClientListWithOptions($request, $runtime);
    }

    /**
     * Queries the proxy nodes that are deployed in a proxy cluster by page.
     *
     * @param request - DescribeHybridProxyListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeHybridProxyListResponse
     *
     * @param DescribeHybridProxyListRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeHybridProxyListResponse
     */
    public function describeHybridProxyListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterName) {
            @$query['ClusterName'] = $request->clusterName;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeHybridProxyList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeHybridProxyListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the proxy nodes that are deployed in a proxy cluster by page.
     *
     * @param request - DescribeHybridProxyListRequest
     *
     * @returns DescribeHybridProxyListResponse
     *
     * @param DescribeHybridProxyListRequest $request
     *
     * @return DescribeHybridProxyListResponse
     */
    public function describeHybridProxyList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeHybridProxyListWithOptions($request, $runtime);
    }

    /**
     * Queries the data collection configurations of a proxy cluster.
     *
     * @param request - DescribeHybridProxyPolicyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeHybridProxyPolicyResponse
     *
     * @param DescribeHybridProxyPolicyRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeHybridProxyPolicyResponse
     */
    public function describeHybridProxyPolicyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterName) {
            @$query['ClusterName'] = $request->clusterName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeHybridProxyPolicy',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeHybridProxyPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the data collection configurations of a proxy cluster.
     *
     * @param request - DescribeHybridProxyPolicyRequest
     *
     * @returns DescribeHybridProxyPolicyResponse
     *
     * @param DescribeHybridProxyPolicyRequest $request
     *
     * @return DescribeHybridProxyPolicyResponse
     */
    public function describeHybridProxyPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeHybridProxyPolicyWithOptions($request, $runtime);
    }

    /**
     * Queries the search conditions that can be used to query data center assets found after scanning in fuzzy match mode.
     *
     * @param request - DescribeIdcAssetCriteriaRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeIdcAssetCriteriaResponse
     *
     * @param DescribeIdcAssetCriteriaRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeIdcAssetCriteriaResponse
     */
    public function describeIdcAssetCriteriaWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->value) {
            @$query['Value'] = $request->value;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeIdcAssetCriteria',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeIdcAssetCriteriaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the search conditions that can be used to query data center assets found after scanning in fuzzy match mode.
     *
     * @param request - DescribeIdcAssetCriteriaRequest
     *
     * @returns DescribeIdcAssetCriteriaResponse
     *
     * @param DescribeIdcAssetCriteriaRequest $request
     *
     * @return DescribeIdcAssetCriteriaResponse
     */
    public function describeIdcAssetCriteria($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeIdcAssetCriteriaWithOptions($request, $runtime);
    }

    /**
     * Query IDC probe list.
     *
     * @param request - DescribeIdcProbeListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeIdcProbeListResponse
     *
     * @param DescribeIdcProbeListRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DescribeIdcProbeListResponse
     */
    public function describeIdcProbeListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->idcName) {
            @$query['IdcName'] = $request->idcName;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeIdcProbeList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeIdcProbeListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Query IDC probe list.
     *
     * @param request - DescribeIdcProbeListRequest
     *
     * @returns DescribeIdcProbeListResponse
     *
     * @param DescribeIdcProbeListRequest $request
     *
     * @return DescribeIdcProbeListResponse
     */
    public function describeIdcProbeList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeIdcProbeListWithOptions($request, $runtime);
    }

    /**
     * Queries assets that are identified by Internet Data Center (IDC) probes.
     *
     * @param request - DescribeIdcProbeScanResultListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeIdcProbeScanResultListResponse
     *
     * @param DescribeIdcProbeScanResultListRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DescribeIdcProbeScanResultListResponse
     */
    public function describeIdcProbeScanResultListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->criteria) {
            @$query['Criteria'] = $request->criteria;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->foundEndTime) {
            @$query['FoundEndTime'] = $request->foundEndTime;
        }

        if (null !== $request->foundStartTime) {
            @$query['FoundStartTime'] = $request->foundStartTime;
        }

        if (null !== $request->logicalExp) {
            @$query['LogicalExp'] = $request->logicalExp;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeIdcProbeScanResultList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeIdcProbeScanResultListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries assets that are identified by Internet Data Center (IDC) probes.
     *
     * @param request - DescribeIdcProbeScanResultListRequest
     *
     * @returns DescribeIdcProbeScanResultListResponse
     *
     * @param DescribeIdcProbeScanResultListRequest $request
     *
     * @return DescribeIdcProbeScanResultListResponse
     */
    public function describeIdcProbeScanResultList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeIdcProbeScanResultListWithOptions($request, $runtime);
    }

    /**
     * Queries an image digest.
     *
     * @param request - DescribeImageRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeImageResponse
     *
     * @param DescribeImageRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return DescribeImageResponse
     */
    public function describeImageWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->imageInstanceId) {
            @$query['ImageInstanceId'] = $request->imageInstanceId;
        }

        if (null !== $request->imageRegionId) {
            @$query['ImageRegionId'] = $request->imageRegionId;
        }

        if (null !== $request->imageRepoId) {
            @$query['ImageRepoId'] = $request->imageRepoId;
        }

        if (null !== $request->imageTag) {
            @$query['ImageTag'] = $request->imageTag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeImage',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeImageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries an image digest.
     *
     * @param request - DescribeImageRequest
     *
     * @returns DescribeImageResponse
     *
     * @param DescribeImageRequest $request
     *
     * @return DescribeImageResponse
     */
    public function describeImage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageWithOptions($request, $runtime);
    }

    /**
     * Queries the security scan results of images.
     *
     * @param request - DescribeImageBaselineCheckResultRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeImageBaselineCheckResultResponse
     *
     * @param DescribeImageBaselineCheckResultRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return DescribeImageBaselineCheckResultResponse
     */
    public function describeImageBaselineCheckResultWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->criteria) {
            @$query['Criteria'] = $request->criteria;
        }

        if (null !== $request->criteriaType) {
            @$query['CriteriaType'] = $request->criteriaType;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->imageUuid) {
            @$query['ImageUuid'] = $request->imageUuid;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->riskLevel) {
            @$query['RiskLevel'] = $request->riskLevel;
        }

        if (null !== $request->scanRange) {
            @$query['ScanRange'] = $request->scanRange;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeImageBaselineCheckResult',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeImageBaselineCheckResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the security scan results of images.
     *
     * @param request - DescribeImageBaselineCheckResultRequest
     *
     * @returns DescribeImageBaselineCheckResultResponse
     *
     * @param DescribeImageBaselineCheckResultRequest $request
     *
     * @return DescribeImageBaselineCheckResultResponse
     */
    public function describeImageBaselineCheckResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageBaselineCheckResultWithOptions($request, $runtime);
    }

    /**
     * Queries the check results of image baselines that are included in an image scan task.
     *
     * @param request - DescribeImageBaselineCheckSummaryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeImageBaselineCheckSummaryResponse
     *
     * @param DescribeImageBaselineCheckSummaryRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return DescribeImageBaselineCheckSummaryResponse
     */
    public function describeImageBaselineCheckSummaryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->criteria) {
            @$query['Criteria'] = $request->criteria;
        }

        if (null !== $request->criteriaType) {
            @$query['CriteriaType'] = $request->criteriaType;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->riskLevel) {
            @$query['RiskLevel'] = $request->riskLevel;
        }

        if (null !== $request->scanRange) {
            @$query['ScanRange'] = $request->scanRange;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeImageBaselineCheckSummary',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeImageBaselineCheckSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the check results of image baselines that are included in an image scan task.
     *
     * @param request - DescribeImageBaselineCheckSummaryRequest
     *
     * @returns DescribeImageBaselineCheckSummaryResponse
     *
     * @param DescribeImageBaselineCheckSummaryRequest $request
     *
     * @return DescribeImageBaselineCheckSummaryResponse
     */
    public function describeImageBaselineCheckSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageBaselineCheckSummaryWithOptions($request, $runtime);
    }

    /**
     * Queries the details about the baseline check result for an image.
     *
     * @param request - DescribeImageBaselineDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeImageBaselineDetailResponse
     *
     * @param DescribeImageBaselineDetailRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeImageBaselineDetailResponse
     */
    public function describeImageBaselineDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->baselineItemKey) {
            @$query['BaselineItemKey'] = $request->baselineItemKey;
        }

        if (null !== $request->imageUuid) {
            @$query['ImageUuid'] = $request->imageUuid;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeImageBaselineDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeImageBaselineDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details about the baseline check result for an image.
     *
     * @param request - DescribeImageBaselineDetailRequest
     *
     * @returns DescribeImageBaselineDetailResponse
     *
     * @param DescribeImageBaselineDetailRequest $request
     *
     * @return DescribeImageBaselineDetailResponse
     */
    public function describeImageBaselineDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageBaselineDetailWithOptions($request, $runtime);
    }

    /**
     * Queries baseline check results based on images.
     *
     * @param request - DescribeImageBaselineItemListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeImageBaselineItemListResponse
     *
     * @param DescribeImageBaselineItemListRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DescribeImageBaselineItemListResponse
     */
    public function describeImageBaselineItemListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->baselineClassKey) {
            @$query['BaselineClassKey'] = $request->baselineClassKey;
        }

        if (null !== $request->baselineNameKey) {
            @$query['BaselineNameKey'] = $request->baselineNameKey;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->imageUuid) {
            @$query['ImageUuid'] = $request->imageUuid;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->scanRange) {
            @$query['ScanRange'] = $request->scanRange;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeImageBaselineItemList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeImageBaselineItemListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries baseline check results based on images.
     *
     * @param request - DescribeImageBaselineItemListRequest
     *
     * @returns DescribeImageBaselineItemListResponse
     *
     * @param DescribeImageBaselineItemListRequest $request
     *
     * @return DescribeImageBaselineItemListResponse
     */
    public function describeImageBaselineItemList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageBaselineItemListWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a baseline check policy for images.
     *
     * @param request - DescribeImageBaselineStrategyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeImageBaselineStrategyResponse
     *
     * @param DescribeImageBaselineStrategyRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DescribeImageBaselineStrategyResponse
     */
    public function describeImageBaselineStrategyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        if (null !== $request->strategyId) {
            @$query['StrategyId'] = $request->strategyId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeImageBaselineStrategy',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeImageBaselineStrategyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a baseline check policy for images.
     *
     * @param request - DescribeImageBaselineStrategyRequest
     *
     * @returns DescribeImageBaselineStrategyResponse
     *
     * @param DescribeImageBaselineStrategyRequest $request
     *
     * @return DescribeImageBaselineStrategyResponse
     */
    public function describeImageBaselineStrategy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageBaselineStrategyWithOptions($request, $runtime);
    }

    /**
     * Queries image build command risks by page.
     *
     * @param request - DescribeImageBuildRiskByKeyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeImageBuildRiskByKeyResponse
     *
     * @param DescribeImageBuildRiskByKeyRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeImageBuildRiskByKeyResponse
     */
    public function describeImageBuildRiskByKeyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->imageUuid) {
            @$query['ImageUuid'] = $request->imageUuid;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->riskKey) {
            @$query['RiskKey'] = $request->riskKey;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeImageBuildRiskByKey',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeImageBuildRiskByKeyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries image build command risks by page.
     *
     * @param request - DescribeImageBuildRiskByKeyRequest
     *
     * @returns DescribeImageBuildRiskByKeyResponse
     *
     * @param DescribeImageBuildRiskByKeyRequest $request
     *
     * @return DescribeImageBuildRiskByKeyResponse
     */
    public function describeImageBuildRiskByKey($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageBuildRiskByKeyWithOptions($request, $runtime);
    }

    /**
     * Queries a list of image build command risks by page.
     *
     * @param request - DescribeImageBuildRiskListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeImageBuildRiskListResponse
     *
     * @param DescribeImageBuildRiskListRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeImageBuildRiskListResponse
     */
    public function describeImageBuildRiskListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->criteria) {
            @$query['Criteria'] = $request->criteria;
        }

        if (null !== $request->criteriaType) {
            @$query['CriteriaType'] = $request->criteriaType;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->riskLevel) {
            @$query['RiskLevel'] = $request->riskLevel;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeImageBuildRiskList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeImageBuildRiskListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of image build command risks by page.
     *
     * @param request - DescribeImageBuildRiskListRequest
     *
     * @returns DescribeImageBuildRiskListResponse
     *
     * @param DescribeImageBuildRiskListRequest $request
     *
     * @return DescribeImageBuildRiskListResponse
     */
    public function describeImageBuildRiskList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageBuildRiskListWithOptions($request, $runtime);
    }

    /**
     * Queries the search conditions that are used to query images.
     *
     * @param request - DescribeImageCriteriaRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeImageCriteriaResponse
     *
     * @param DescribeImageCriteriaRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DescribeImageCriteriaResponse
     */
    public function describeImageCriteriaWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->value) {
            @$query['Value'] = $request->value;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeImageCriteria',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeImageCriteriaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the search conditions that are used to query images.
     *
     * @param request - DescribeImageCriteriaRequest
     *
     * @returns DescribeImageCriteriaResponse
     *
     * @param DescribeImageCriteriaRequest $request
     *
     * @return DescribeImageCriteriaResponse
     */
    public function describeImageCriteria($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageCriteriaWithOptions($request, $runtime);
    }

    /**
     * Queries the conditions for handling alert events in an image.
     *
     * @param request - DescribeImageEventOperationConditionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeImageEventOperationConditionResponse
     *
     * @param DescribeImageEventOperationConditionRequest $request
     * @param RuntimeOptions                              $runtime
     *
     * @return DescribeImageEventOperationConditionResponse
     */
    public function describeImageEventOperationConditionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->eventType) {
            @$query['EventType'] = $request->eventType;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeImageEventOperationCondition',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeImageEventOperationConditionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the conditions for handling alert events in an image.
     *
     * @param request - DescribeImageEventOperationConditionRequest
     *
     * @returns DescribeImageEventOperationConditionResponse
     *
     * @param DescribeImageEventOperationConditionRequest $request
     *
     * @return DescribeImageEventOperationConditionResponse
     */
    public function describeImageEventOperationCondition($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageEventOperationConditionWithOptions($request, $runtime);
    }

    /**
     * Queries alert handling rules by page.
     *
     * @param request - DescribeImageEventOperationPageRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeImageEventOperationPageResponse
     *
     * @param DescribeImageEventOperationPageRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return DescribeImageEventOperationPageResponse
     */
    public function describeImageEventOperationPageWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->eventKey) {
            @$query['EventKey'] = $request->eventKey;
        }

        if (null !== $request->eventName) {
            @$query['EventName'] = $request->eventName;
        }

        if (null !== $request->eventType) {
            @$query['EventType'] = $request->eventType;
        }

        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeImageEventOperationPage',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeImageEventOperationPageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries alert handling rules by page.
     *
     * @param request - DescribeImageEventOperationPageRequest
     *
     * @returns DescribeImageEventOperationPageResponse
     *
     * @param DescribeImageEventOperationPageRequest $request
     *
     * @return DescribeImageEventOperationPageResponse
     */
    public function describeImageEventOperationPage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageEventOperationPageWithOptions($request, $runtime);
    }

    /**
     * Queries the configurations of the scheduled fix of image risks.
     *
     * @param request - DescribeImageFixCycleConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeImageFixCycleConfigResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeImageFixCycleConfigResponse
     */
    public function describeImageFixCycleConfigWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeImageFixCycleConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeImageFixCycleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configurations of the scheduled fix of image risks.
     *
     * @returns DescribeImageFixCycleConfigResponse
     *
     * @return DescribeImageFixCycleConfigResponse
     */
    public function describeImageFixCycleConfig()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageFixCycleConfigWithOptions($runtime);
    }

    /**
     * Queries the tasks that you create to fix image risks.
     *
     * @param request - DescribeImageFixTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeImageFixTaskResponse
     *
     * @param DescribeImageFixTaskRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DescribeImageFixTaskResponse
     */
    public function describeImageFixTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeImageFixTask',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeImageFixTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the tasks that you create to fix image risks.
     *
     * @param request - DescribeImageFixTaskRequest
     *
     * @returns DescribeImageFixTaskResponse
     *
     * @param DescribeImageFixTaskRequest $request
     *
     * @return DescribeImageFixTaskResponse
     */
    public function describeImageFixTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageFixTaskWithOptions($request, $runtime);
    }

    /**
     * Queries image vulnerabilities.
     *
     * @param request - DescribeImageGroupedVulListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeImageGroupedVulListResponse
     *
     * @param DescribeImageGroupedVulListRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeImageGroupedVulListResponse
     */
    public function describeImageGroupedVulListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aliasName) {
            @$query['AliasName'] = $request->aliasName;
        }

        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->cveId) {
            @$query['CveId'] = $request->cveId;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        if (null !== $request->imageDigest) {
            @$query['ImageDigest'] = $request->imageDigest;
        }

        if (null !== $request->imageLayer) {
            @$query['ImageLayer'] = $request->imageLayer;
        }

        if (null !== $request->imageTag) {
            @$query['ImageTag'] = $request->imageTag;
        }

        if (null !== $request->isLatest) {
            @$query['IsLatest'] = $request->isLatest;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->necessity) {
            @$query['Necessity'] = $request->necessity;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->patchId) {
            @$query['PatchId'] = $request->patchId;
        }

        if (null !== $request->repoId) {
            @$query['RepoId'] = $request->repoId;
        }

        if (null !== $request->repoInstanceId) {
            @$query['RepoInstanceId'] = $request->repoInstanceId;
        }

        if (null !== $request->repoName) {
            @$query['RepoName'] = $request->repoName;
        }

        if (null !== $request->repoNamespace) {
            @$query['RepoNamespace'] = $request->repoNamespace;
        }

        if (null !== $request->repoRegionId) {
            @$query['RepoRegionId'] = $request->repoRegionId;
        }

        if (null !== $request->ruleTag) {
            @$query['RuleTag'] = $request->ruleTag;
        }

        if (null !== $request->scanRange) {
            @$query['ScanRange'] = $request->scanRange;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeImageGroupedVulList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeImageGroupedVulListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries image vulnerabilities.
     *
     * @param request - DescribeImageGroupedVulListRequest
     *
     * @returns DescribeImageGroupedVulListResponse
     *
     * @param DescribeImageGroupedVulListRequest $request
     *
     * @return DescribeImageGroupedVulListResponse
     */
    public function describeImageGroupedVulList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageGroupedVulListWithOptions($request, $runtime);
    }

    /**
     * Queries images.
     *
     * @param request - DescribeImageInfoListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeImageInfoListResponse
     *
     * @param DescribeImageInfoListRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DescribeImageInfoListResponse
     */
    public function describeImageInfoListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeImageInfoList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeImageInfoListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries images.
     *
     * @param request - DescribeImageInfoListRequest
     *
     * @returns DescribeImageInfoListResponse
     *
     * @param DescribeImageInfoListRequest $request
     *
     * @return DescribeImageInfoListResponse
     */
    public function describeImageInfoList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageInfoListWithOptions($request, $runtime);
    }

    /**
     * Queries information about images.
     *
     * @param request - DescribeImageInstancesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeImageInstancesResponse
     *
     * @param DescribeImageInstancesRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DescribeImageInstancesResponse
     */
    public function describeImageInstancesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->criteria) {
            @$query['Criteria'] = $request->criteria;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->logicalExp) {
            @$query['LogicalExp'] = $request->logicalExp;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->scanned) {
            @$query['Scanned'] = $request->scanned;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeImageInstances',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeImageInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries information about images.
     *
     * @param request - DescribeImageInstancesRequest
     *
     * @returns DescribeImageInstancesResponse
     *
     * @param DescribeImageInstancesRequest $request
     *
     * @return DescribeImageInstancesResponse
     */
    public function describeImageInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageInstancesWithOptions($request, $runtime);
    }

    /**
     * Queries the most recent scan task that is created for an image.
     *
     * @param request - DescribeImageLatestScanTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeImageLatestScanTaskResponse
     *
     * @param DescribeImageLatestScanTaskRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeImageLatestScanTaskResponse
     */
    public function describeImageLatestScanTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->digest) {
            @$query['Digest'] = $request->digest;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeImageLatestScanTask',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeImageLatestScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the most recent scan task that is created for an image.
     *
     * @param request - DescribeImageLatestScanTaskRequest
     *
     * @returns DescribeImageLatestScanTaskResponse
     *
     * @param DescribeImageLatestScanTaskRequest $request
     *
     * @return DescribeImageLatestScanTaskResponse
     */
    public function describeImageLatestScanTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageLatestScanTaskWithOptions($request, $runtime);
    }

    /**
     * Queries a list of images that are affected by image build command risks by page.
     *
     * @param request - DescribeImageListByBuildRiskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeImageListByBuildRiskResponse
     *
     * @param DescribeImageListByBuildRiskRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribeImageListByBuildRiskResponse
     */
    public function describeImageListByBuildRiskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->riskKey) {
            @$query['RiskKey'] = $request->riskKey;
        }

        if (null !== $request->riskLevel) {
            @$query['RiskLevel'] = $request->riskLevel;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeImageListByBuildRisk',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeImageListByBuildRiskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of images that are affected by image build command risks by page.
     *
     * @param request - DescribeImageListByBuildRiskRequest
     *
     * @returns DescribeImageListByBuildRiskResponse
     *
     * @param DescribeImageListByBuildRiskRequest $request
     *
     * @return DescribeImageListByBuildRiskResponse
     */
    public function describeImageListByBuildRisk($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageListByBuildRiskWithOptions($request, $runtime);
    }

    /**
     * Queries information about images that are affected by sensitive files.
     *
     * @param tmpReq - DescribeImageListBySensitiveFileRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeImageListBySensitiveFileResponse
     *
     * @param DescribeImageListBySensitiveFileRequest $tmpReq
     * @param RuntimeOptions                          $runtime
     *
     * @return DescribeImageListBySensitiveFileResponse
     */
    public function describeImageListBySensitiveFileWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new DescribeImageListBySensitiveFileShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->scanRange) {
            $request->scanRangeShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->scanRange, 'ScanRange', 'json');
        }

        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->imageDigest) {
            @$query['ImageDigest'] = $request->imageDigest;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->repoInstanceId) {
            @$query['RepoInstanceId'] = $request->repoInstanceId;
        }

        if (null !== $request->repoName) {
            @$query['RepoName'] = $request->repoName;
        }

        if (null !== $request->repoNamespace) {
            @$query['RepoNamespace'] = $request->repoNamespace;
        }

        if (null !== $request->riskLevel) {
            @$query['RiskLevel'] = $request->riskLevel;
        }

        if (null !== $request->scanRangeShrink) {
            @$query['ScanRange'] = $request->scanRangeShrink;
        }

        if (null !== $request->sensitiveFileKey) {
            @$query['SensitiveFileKey'] = $request->sensitiveFileKey;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeImageListBySensitiveFile',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeImageListBySensitiveFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries information about images that are affected by sensitive files.
     *
     * @param request - DescribeImageListBySensitiveFileRequest
     *
     * @returns DescribeImageListBySensitiveFileResponse
     *
     * @param DescribeImageListBySensitiveFileRequest $request
     *
     * @return DescribeImageListBySensitiveFileResponse
     */
    public function describeImageListBySensitiveFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageListBySensitiveFileWithOptions($request, $runtime);
    }

    /**
     * Queries the details about images in the results of image baseline checks.
     *
     * @param request - DescribeImageListWithBaselineNameRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeImageListWithBaselineNameResponse
     *
     * @param DescribeImageListWithBaselineNameRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return DescribeImageListWithBaselineNameResponse
     */
    public function describeImageListWithBaselineNameWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->baselineNameKey) {
            @$query['BaselineNameKey'] = $request->baselineNameKey;
        }

        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->clusterName) {
            @$query['ClusterName'] = $request->clusterName;
        }

        if (null !== $request->containerId) {
            @$query['ContainerId'] = $request->containerId;
        }

        if (null !== $request->criteria) {
            @$query['Criteria'] = $request->criteria;
        }

        if (null !== $request->criteriaType) {
            @$query['CriteriaType'] = $request->criteriaType;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->image) {
            @$query['Image'] = $request->image;
        }

        if (null !== $request->imageDigest) {
            @$query['ImageDigest'] = $request->imageDigest;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->namespace) {
            @$query['Namespace'] = $request->namespace;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->pod) {
            @$query['Pod'] = $request->pod;
        }

        if (null !== $request->repoInstanceId) {
            @$query['RepoInstanceId'] = $request->repoInstanceId;
        }

        if (null !== $request->repoName) {
            @$query['RepoName'] = $request->repoName;
        }

        if (null !== $request->repoNamespace) {
            @$query['RepoNamespace'] = $request->repoNamespace;
        }

        if (null !== $request->scanRange) {
            @$query['ScanRange'] = $request->scanRange;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeImageListWithBaselineName',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeImageListWithBaselineNameResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details about images in the results of image baseline checks.
     *
     * @param request - DescribeImageListWithBaselineNameRequest
     *
     * @returns DescribeImageListWithBaselineNameResponse
     *
     * @param DescribeImageListWithBaselineNameRequest $request
     *
     * @return DescribeImageListWithBaselineNameResponse
     */
    public function describeImageListWithBaselineName($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageListWithBaselineNameWithOptions($request, $runtime);
    }

    /**
     * Obtains the filter conditions that are supported by the image repository.
     *
     * @param request - DescribeImageRepoCriteriaRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeImageRepoCriteriaResponse
     *
     * @param DescribeImageRepoCriteriaRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeImageRepoCriteriaResponse
     */
    public function describeImageRepoCriteriaWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->value) {
            @$query['Value'] = $request->value;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeImageRepoCriteria',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeImageRepoCriteriaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Obtains the filter conditions that are supported by the image repository.
     *
     * @param request - DescribeImageRepoCriteriaRequest
     *
     * @returns DescribeImageRepoCriteriaResponse
     *
     * @param DescribeImageRepoCriteriaRequest $request
     *
     * @return DescribeImageRepoCriteriaResponse
     */
    public function describeImageRepoCriteria($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageRepoCriteriaWithOptions($request, $runtime);
    }

    /**
     * Queries the information about image repositories.
     *
     * @param request - DescribeImageRepoDetailListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeImageRepoDetailListResponse
     *
     * @param DescribeImageRepoDetailListRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeImageRepoDetailListResponse
     */
    public function describeImageRepoDetailListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->criteria) {
            @$query['Criteria'] = $request->criteria;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->logicalExp) {
            @$query['LogicalExp'] = $request->logicalExp;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeImageRepoDetailList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeImageRepoDetailListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about image repositories.
     *
     * @param request - DescribeImageRepoDetailListRequest
     *
     * @returns DescribeImageRepoDetailListResponse
     *
     * @param DescribeImageRepoDetailListRequest $request
     *
     * @return DescribeImageRepoDetailListResponse
     */
    public function describeImageRepoDetailList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageRepoDetailListWithOptions($request, $runtime);
    }

    /**
     * Queries the statistics and configurations of the feature that protects images.
     *
     * @param request - DescribeImageRepoListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeImageRepoListResponse
     *
     * @param DescribeImageRepoListRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DescribeImageRepoListResponse
     */
    public function describeImageRepoListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->fieldName) {
            @$query['FieldName'] = $request->fieldName;
        }

        if (null !== $request->fieldValue) {
            @$query['FieldValue'] = $request->fieldValue;
        }

        if (null !== $request->operateType) {
            @$query['OperateType'] = $request->operateType;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->repoName) {
            @$query['RepoName'] = $request->repoName;
        }

        if (null !== $request->repoNamespace) {
            @$query['RepoNamespace'] = $request->repoNamespace;
        }

        if (null !== $request->selected) {
            @$query['Selected'] = $request->selected;
        }

        if (null !== $request->targetType) {
            @$query['TargetType'] = $request->targetType;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeImageRepoList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeImageRepoListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics and configurations of the feature that protects images.
     *
     * @param request - DescribeImageRepoListRequest
     *
     * @returns DescribeImageRepoListResponse
     *
     * @param DescribeImageRepoListRequest $request
     *
     * @return DescribeImageRepoListResponse
     */
    public function describeImageRepoList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageRepoListWithOptions($request, $runtime);
    }

    /**
     * Queries the number of images on which security alerts are generated. Security alerts are generated for risks such as vulnerabilities, baselines risks, and malicious samples.
     *
     * @param request - DescribeImageRiskLevelStatisticRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeImageRiskLevelStatisticResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeImageRiskLevelStatisticResponse
     */
    public function describeImageRiskLevelStatisticWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeImageRiskLevelStatistic',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeImageRiskLevelStatisticResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the number of images on which security alerts are generated. Security alerts are generated for risks such as vulnerabilities, baselines risks, and malicious samples.
     *
     * @returns DescribeImageRiskLevelStatisticResponse
     *
     * @return DescribeImageRiskLevelStatisticResponse
     */
    public function describeImageRiskLevelStatistic()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageRiskLevelStatisticWithOptions($runtime);
    }

    /**
     * Queries the details of the quota for container image scan.
     *
     * @param request - DescribeImageScanAuthCountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeImageScanAuthCountResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeImageScanAuthCountResponse
     */
    public function describeImageScanAuthCountWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeImageScanAuthCount',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeImageScanAuthCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of the quota for container image scan.
     *
     * @returns DescribeImageScanAuthCountResponse
     *
     * @return DescribeImageScanAuthCountResponse
     */
    public function describeImageScanAuthCount()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageScanAuthCountWithOptions($runtime);
    }

    /**
     * Queries the number of security events detected on an image.
     *
     * @param request - DescribeImageSecurityScanCountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeImageSecurityScanCountResponse
     *
     * @param DescribeImageSecurityScanCountRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DescribeImageSecurityScanCountResponse
     */
    public function describeImageSecurityScanCountWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->dealed) {
            @$query['Dealed'] = $request->dealed;
        }

        if (null !== $request->imageDigest) {
            @$query['ImageDigest'] = $request->imageDigest;
        }

        if (null !== $request->imageTag) {
            @$query['ImageTag'] = $request->imageTag;
        }

        if (null !== $request->imageUuid) {
            @$query['ImageUuid'] = $request->imageUuid;
        }

        if (null !== $request->repoId) {
            @$query['RepoId'] = $request->repoId;
        }

        if (null !== $request->repoInstanceId) {
            @$query['RepoInstanceId'] = $request->repoInstanceId;
        }

        if (null !== $request->repoRegionId) {
            @$query['RepoRegionId'] = $request->repoRegionId;
        }

        if (null !== $request->scanRange) {
            @$query['ScanRange'] = $request->scanRange;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeImageSecurityScanCount',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeImageSecurityScanCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the number of security events detected on an image.
     *
     * @param request - DescribeImageSecurityScanCountRequest
     *
     * @returns DescribeImageSecurityScanCountResponse
     *
     * @param DescribeImageSecurityScanCountRequest $request
     *
     * @return DescribeImageSecurityScanCountResponse
     */
    public function describeImageSecurityScanCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageSecurityScanCountWithOptions($request, $runtime);
    }

    /**
     * Queries the sensitive files in an image.
     *
     * @param tmpReq - DescribeImageSensitiveFileByKeyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeImageSensitiveFileByKeyResponse
     *
     * @param DescribeImageSensitiveFileByKeyRequest $tmpReq
     * @param RuntimeOptions                         $runtime
     *
     * @return DescribeImageSensitiveFileByKeyResponse
     */
    public function describeImageSensitiveFileByKeyWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new DescribeImageSensitiveFileByKeyShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->scanRange) {
            $request->scanRangeShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->scanRange, 'ScanRange', 'json');
        }

        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->imageUuid) {
            @$query['ImageUuid'] = $request->imageUuid;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->scanRangeShrink) {
            @$query['ScanRange'] = $request->scanRangeShrink;
        }

        if (null !== $request->sensitiveFileKey) {
            @$query['SensitiveFileKey'] = $request->sensitiveFileKey;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeImageSensitiveFileByKey',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeImageSensitiveFileByKeyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the sensitive files in an image.
     *
     * @param request - DescribeImageSensitiveFileByKeyRequest
     *
     * @returns DescribeImageSensitiveFileByKeyResponse
     *
     * @param DescribeImageSensitiveFileByKeyRequest $request
     *
     * @return DescribeImageSensitiveFileByKeyResponse
     */
    public function describeImageSensitiveFileByKey($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageSensitiveFileByKeyWithOptions($request, $runtime);
    }

    /**
     * Queries information about sensitive files.
     *
     * @param tmpReq - DescribeImageSensitiveFileListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeImageSensitiveFileListResponse
     *
     * @param DescribeImageSensitiveFileListRequest $tmpReq
     * @param RuntimeOptions                        $runtime
     *
     * @return DescribeImageSensitiveFileListResponse
     */
    public function describeImageSensitiveFileListWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new DescribeImageSensitiveFileListShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->scanRange) {
            $request->scanRangeShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->scanRange, 'ScanRange', 'json');
        }

        $query = [];
        if (null !== $request->criteria) {
            @$query['Criteria'] = $request->criteria;
        }

        if (null !== $request->criteriaType) {
            @$query['CriteriaType'] = $request->criteriaType;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->imageUuid) {
            @$query['ImageUuid'] = $request->imageUuid;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->riskLevel) {
            @$query['RiskLevel'] = $request->riskLevel;
        }

        if (null !== $request->scanRangeShrink) {
            @$query['ScanRange'] = $request->scanRangeShrink;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeImageSensitiveFileList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeImageSensitiveFileListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries information about sensitive files.
     *
     * @param request - DescribeImageSensitiveFileListRequest
     *
     * @returns DescribeImageSensitiveFileListResponse
     *
     * @param DescribeImageSensitiveFileListRequest $request
     *
     * @return DescribeImageSensitiveFileListResponse
     */
    public function describeImageSensitiveFileList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageSensitiveFileListWithOptions($request, $runtime);
    }

    /**
     * Queries the risk statistics on container images.
     *
     * @remarks
     * Security Center can scan for security risks and collect statistics only for **Container Registry Enterprise Edition instances**.
     * >  Security Center cannot scan for security risks or collect statistics for **default** Container Registry instances.
     *
     * @param request - DescribeImageStatisticsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeImageStatisticsResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeImageStatisticsResponse
     */
    public function describeImageStatisticsWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeImageStatistics',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeImageStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the risk statistics on container images.
     *
     * @remarks
     * Security Center can scan for security risks and collect statistics only for **Container Registry Enterprise Edition instances**.
     * >  Security Center cannot scan for security risks or collect statistics for **default** Container Registry instances.
     *
     * @returns DescribeImageStatisticsResponse
     *
     * @return DescribeImageStatisticsResponse
     */
    public function describeImageStatistics()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageStatisticsWithOptions($runtime);
    }

    /**
     * Queries the details of vulnerabilities that are detected by using container image scan and the affected images.
     *
     * @remarks
     * To query the information about the recently detected image vulnerabilities, call the [PublicCreateImageScanTask](https://help.aliyun.com/document_detail/411723.html) operation. Wait 1 to 5 minutes until the call is successful and call the DescribeImageVulList operation.
     *
     * @param request - DescribeImageVulListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeImageVulListResponse
     *
     * @param DescribeImageVulListRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DescribeImageVulListResponse
     */
    public function describeImageVulListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aliasName) {
            @$query['AliasName'] = $request->aliasName;
        }

        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->clusterName) {
            @$query['ClusterName'] = $request->clusterName;
        }

        if (null !== $request->containerId) {
            @$query['ContainerId'] = $request->containerId;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->dealed) {
            @$query['Dealed'] = $request->dealed;
        }

        if (null !== $request->digest) {
            @$query['Digest'] = $request->digest;
        }

        if (null !== $request->image) {
            @$query['Image'] = $request->image;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->namespace) {
            @$query['Namespace'] = $request->namespace;
        }

        if (null !== $request->necessity) {
            @$query['Necessity'] = $request->necessity;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->pod) {
            @$query['Pod'] = $request->pod;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->repoId) {
            @$query['RepoId'] = $request->repoId;
        }

        if (null !== $request->repoId) {
            @$query['RepoId'] = $request->repoId;
        }

        if (null !== $request->repoInstanceId) {
            @$query['RepoInstanceId'] = $request->repoInstanceId;
        }

        if (null !== $request->repoName) {
            @$query['RepoName'] = $request->repoName;
        }

        if (null !== $request->repoName) {
            @$query['RepoName'] = $request->repoName;
        }

        if (null !== $request->repoNamespace) {
            @$query['RepoNamespace'] = $request->repoNamespace;
        }

        if (null !== $request->repoRegionId) {
            @$query['RepoRegionId'] = $request->repoRegionId;
        }

        if (null !== $request->ruleTag) {
            @$query['RuleTag'] = $request->ruleTag;
        }

        if (null !== $request->scanRange) {
            @$query['ScanRange'] = $request->scanRange;
        }

        if (null !== $request->statusList) {
            @$query['StatusList'] = $request->statusList;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeImageVulList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeImageVulListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of vulnerabilities that are detected by using container image scan and the affected images.
     *
     * @remarks
     * To query the information about the recently detected image vulnerabilities, call the [PublicCreateImageScanTask](https://help.aliyun.com/document_detail/411723.html) operation. Wait 1 to 5 minutes until the call is successful and call the DescribeImageVulList operation.
     *
     * @param request - DescribeImageVulListRequest
     *
     * @returns DescribeImageVulListResponse
     *
     * @param DescribeImageVulListRequest $request
     *
     * @return DescribeImageVulListResponse
     */
    public function describeImageVulList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageVulListWithOptions($request, $runtime);
    }

    /**
     * Queries the whitelist of image vulnerabilities.
     *
     * @param request - DescribeImageVulWhiteListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeImageVulWhiteListResponse
     *
     * @param DescribeImageVulWhiteListRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeImageVulWhiteListResponse
     */
    public function describeImageVulWhiteListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aliasName) {
            @$query['AliasName'] = $request->aliasName;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeImageVulWhiteList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeImageVulWhiteListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the whitelist of image vulnerabilities.
     *
     * @param request - DescribeImageVulWhiteListRequest
     *
     * @returns DescribeImageVulWhiteListResponse
     *
     * @param DescribeImageVulWhiteListRequest $request
     *
     * @return DescribeImageVulWhiteListResponse
     */
    public function describeImageVulWhiteList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageVulWhiteListWithOptions($request, $runtime);
    }

    /**
     * Queries the verification codes that are used to manually install the Security Center agent.
     *
     * @param request - DescribeInstallCaptchaRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeInstallCaptchaResponse
     *
     * @param DescribeInstallCaptchaRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DescribeInstallCaptchaResponse
     */
    public function describeInstallCaptchaWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->deadline) {
            @$query['Deadline'] = $request->deadline;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeInstallCaptcha',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeInstallCaptchaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the verification codes that are used to manually install the Security Center agent.
     *
     * @param request - DescribeInstallCaptchaRequest
     *
     * @returns DescribeInstallCaptchaResponse
     *
     * @param DescribeInstallCaptchaRequest $request
     *
     * @return DescribeInstallCaptchaResponse
     */
    public function describeInstallCaptcha($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeInstallCaptchaWithOptions($request, $runtime);
    }

    /**
     * Queries the installation verification code that is used to run the installation command of the Security Center agent.
     *
     * @param request - DescribeInstallCodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeInstallCodeResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeInstallCodeResponse
     */
    public function describeInstallCodeWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeInstallCode',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeInstallCodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the installation verification code that is used to run the installation command of the Security Center agent.
     *
     * @returns DescribeInstallCodeResponse
     *
     * @return DescribeInstallCodeResponse
     */
    public function describeInstallCode()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeInstallCodeWithOptions($runtime);
    }

    /**
     * Queries the commands that are used to manually install the Security Center Agent.
     *
     * @remarks
     * You can call this operation to query the commands that are used to manually install the Security Center agent on the server. The return result contains the installation verification code and the server information. If you want to manually install the Security Center agent on your server, you can call this operation to query installation commands.
     * ### QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @param request - DescribeInstallCodesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeInstallCodesResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeInstallCodesResponse
     */
    public function describeInstallCodesWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeInstallCodes',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeInstallCodesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the commands that are used to manually install the Security Center Agent.
     *
     * @remarks
     * You can call this operation to query the commands that are used to manually install the Security Center agent on the server. The return result contains the installation verification code and the server information. If you want to manually install the Security Center agent on your server, you can call this operation to query installation commands.
     * ### QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *
     * @returns DescribeInstallCodesResponse
     *
     * @return DescribeInstallCodesResponse
     */
    public function describeInstallCodes()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeInstallCodesWithOptions($runtime);
    }

    /**
     * Queries the information about servers to which a defense rule against brute-force attacks is applied.
     *
     * @param request - DescribeInstanceAntiBruteForceRulesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeInstanceAntiBruteForceRulesResponse
     *
     * @param DescribeInstanceAntiBruteForceRulesRequest $request
     * @param RuntimeOptions                             $runtime
     *
     * @return DescribeInstanceAntiBruteForceRulesResponse
     */
    public function describeInstanceAntiBruteForceRulesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->uuidList) {
            @$query['UuidList'] = $request->uuidList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeInstanceAntiBruteForceRules',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeInstanceAntiBruteForceRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about servers to which a defense rule against brute-force attacks is applied.
     *
     * @param request - DescribeInstanceAntiBruteForceRulesRequest
     *
     * @returns DescribeInstanceAntiBruteForceRulesResponse
     *
     * @param DescribeInstanceAntiBruteForceRulesRequest $request
     *
     * @return DescribeInstanceAntiBruteForceRulesResponse
     */
    public function describeInstanceAntiBruteForceRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeInstanceAntiBruteForceRulesWithOptions($request, $runtime);
    }

    /**
     * Queries the status of the instance that you restart.
     *
     * @param request - DescribeInstanceRebootStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeInstanceRebootStatusResponse
     *
     * @param DescribeInstanceRebootStatusRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribeInstanceRebootStatusResponse
     */
    public function describeInstanceRebootStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeInstanceRebootStatus',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeInstanceRebootStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the status of the instance that you restart.
     *
     * @param request - DescribeInstanceRebootStatusRequest
     *
     * @returns DescribeInstanceRebootStatusResponse
     *
     * @param DescribeInstanceRebootStatusRequest $request
     *
     * @return DescribeInstanceRebootStatusResponse
     */
    public function describeInstanceRebootStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeInstanceRebootStatusWithOptions($request, $runtime);
    }

    /**
     * Queries the statistics of assets that are protected by Security Center.
     *
     * @param request - DescribeInstanceStatisticsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeInstanceStatisticsResponse
     *
     * @param DescribeInstanceStatisticsRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeInstanceStatisticsResponse
     */
    public function describeInstanceStatisticsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeInstanceStatistics',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeInstanceStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics of assets that are protected by Security Center.
     *
     * @param request - DescribeInstanceStatisticsRequest
     *
     * @returns DescribeInstanceStatisticsResponse
     *
     * @param DescribeInstanceStatisticsRequest $request
     *
     * @return DescribeInstanceStatisticsResponse
     */
    public function describeInstanceStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeInstanceStatisticsWithOptions($request, $runtime);
    }

    /**
     * Queries the statistics of vulnerabilities that are detected on a cluster.
     *
     * @param request - DescribeInstanceVulStatisticsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeInstanceVulStatisticsResponse
     *
     * @param DescribeInstanceVulStatisticsRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DescribeInstanceVulStatisticsResponse
     */
    public function describeInstanceVulStatisticsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->types) {
            @$query['Types'] = $request->types;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeInstanceVulStatistics',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeInstanceVulStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics of vulnerabilities that are detected on a cluster.
     *
     * @param request - DescribeInstanceVulStatisticsRequest
     *
     * @returns DescribeInstanceVulStatisticsResponse
     *
     * @param DescribeInstanceVulStatisticsRequest $request
     *
     * @return DescribeInstanceVulStatisticsResponse
     */
    public function describeInstanceVulStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeInstanceVulStatisticsWithOptions($request, $runtime);
    }

    /**
     * Queries the progress of the last virus scan task.
     *
     * @param request - DescribeLatestScanTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLatestScanTaskResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeLatestScanTaskResponse
     */
    public function describeLatestScanTaskWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeLatestScanTask',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLatestScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the progress of the last virus scan task.
     *
     * @returns DescribeLatestScanTaskResponse
     *
     * @return DescribeLatestScanTaskResponse
     */
    public function describeLatestScanTask()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLatestScanTaskWithOptions($runtime);
    }

    /**
     * Queries the configurations of the log analysis feature provided by Security Center.
     *
     * @param request - DescribeLogMetaRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLogMetaResponse
     *
     * @param DescribeLogMetaRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return DescribeLogMetaResponse
     */
    public function describeLogMetaWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLogMeta',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLogMetaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configurations of the log analysis feature provided by Security Center.
     *
     * @param request - DescribeLogMetaRequest
     *
     * @returns DescribeLogMetaResponse
     *
     * @param DescribeLogMetaRequest $request
     *
     * @return DescribeLogMetaResponse
     */
    public function describeLogMeta($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLogMetaWithOptions($request, $runtime);
    }

    /**
     * Queries the status information about the log analysis feature.
     *
     * @param request - DescribeLogShipperStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLogShipperStatusResponse
     *
     * @param DescribeLogShipperStatusRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeLogShipperStatusResponse
     */
    public function describeLogShipperStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLogShipperStatus',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLogShipperStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the status information about the log analysis feature.
     *
     * @param request - DescribeLogShipperStatusRequest
     *
     * @returns DescribeLogShipperStatusResponse
     *
     * @param DescribeLogShipperStatusRequest $request
     *
     * @return DescribeLogShipperStatusResponse
     */
    public function describeLogShipperStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLogShipperStatusWithOptions($request, $runtime);
    }

    /**
     * Queries the information about the configurations that are used to detect unusual logons to your servers.
     *
     * @param request - DescribeLoginBaseConfigsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLoginBaseConfigsResponse
     *
     * @param DescribeLoginBaseConfigsRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeLoginBaseConfigsResponse
     */
    public function describeLoginBaseConfigsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->target) {
            @$query['Target'] = $request->target;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLoginBaseConfigs',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLoginBaseConfigsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about the configurations that are used to detect unusual logons to your servers.
     *
     * @param request - DescribeLoginBaseConfigsRequest
     *
     * @returns DescribeLoginBaseConfigsResponse
     *
     * @param DescribeLoginBaseConfigsRequest $request
     *
     * @return DescribeLoginBaseConfigsResponse
     */
    public function describeLoginBaseConfigs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLoginBaseConfigsWithOptions($request, $runtime);
    }

    /**
     * Queries the alerting status for unapproved logon IP addresses, unapproved logon time ranges, or unapproved logon accounts.
     *
     * @param request - DescribeLoginSwitchConfigsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLoginSwitchConfigsResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeLoginSwitchConfigsResponse
     */
    public function describeLoginSwitchConfigsWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeLoginSwitchConfigs',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLoginSwitchConfigsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the alerting status for unapproved logon IP addresses, unapproved logon time ranges, or unapproved logon accounts.
     *
     * @returns DescribeLoginSwitchConfigsResponse
     *
     * @return DescribeLoginSwitchConfigsResponse
     */
    public function describeLoginSwitchConfigs()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLoginSwitchConfigsWithOptions($runtime);
    }

    /**
     * Queries the purchased log storage capacity.
     *
     * @param request - DescribeLogstoreStorageRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLogstoreStorageResponse
     *
     * @param DescribeLogstoreStorageRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeLogstoreStorageResponse
     */
    public function describeLogstoreStorageWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLogstoreStorage',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLogstoreStorageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the purchased log storage capacity.
     *
     * @param request - DescribeLogstoreStorageRequest
     *
     * @returns DescribeLogstoreStorageResponse
     *
     * @param DescribeLogstoreStorageRequest $request
     *
     * @return DescribeLogstoreStorageResponse
     */
    public function describeLogstoreStorage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLogstoreStorageWithOptions($request, $runtime);
    }

    /**
     * Queries whether a server can be restarted after the vulnerabilities on the server are fixed. The fixes take effect only after the server is restarted.
     *
     * @param request - DescribeMachineCanRebootRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeMachineCanRebootResponse
     *
     * @param DescribeMachineCanRebootRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeMachineCanRebootResponse
     */
    public function describeMachineCanRebootWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeMachineCanReboot',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeMachineCanRebootResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries whether a server can be restarted after the vulnerabilities on the server are fixed. The fixes take effect only after the server is restarted.
     *
     * @param request - DescribeMachineCanRebootRequest
     *
     * @returns DescribeMachineCanRebootResponse
     *
     * @param DescribeMachineCanRebootRequest $request
     *
     * @return DescribeMachineCanRebootResponse
     */
    public function describeMachineCanReboot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeMachineCanRebootWithOptions($request, $runtime);
    }

    /**
     * Queries a list of malicious image sample types.
     *
     * @param request - DescribeMatchedMaliciousNamesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeMatchedMaliciousNamesResponse
     *
     * @param DescribeMatchedMaliciousNamesRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DescribeMatchedMaliciousNamesResponse
     */
    public function describeMatchedMaliciousNamesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->levels) {
            @$query['Levels'] = $request->levels;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeMatchedMaliciousNames',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeMatchedMaliciousNamesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of malicious image sample types.
     *
     * @param request - DescribeMatchedMaliciousNamesRequest
     *
     * @returns DescribeMatchedMaliciousNamesResponse
     *
     * @param DescribeMatchedMaliciousNamesRequest $request
     *
     * @return DescribeMatchedMaliciousNamesResponse
     */
    public function describeMatchedMaliciousNames($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeMatchedMaliciousNamesWithOptions($request, $runtime);
    }

    /**
     * Queries the configurations of the asset fingerprint module.
     *
     * @param request - DescribeModuleConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeModuleConfigResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeModuleConfigResponse
     */
    public function describeModuleConfigWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeModuleConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeModuleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configurations of the asset fingerprint module.
     *
     * @returns DescribeModuleConfigResponse
     *
     * @return DescribeModuleConfigResponse
     */
    public function describeModuleConfig()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeModuleConfigWithOptions($runtime);
    }

    /**
     * Queries the list of accounts that are added to the multi-account management feature as members.
     *
     * @param request - DescribeMonitorAccountsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeMonitorAccountsResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeMonitorAccountsResponse
     */
    public function describeMonitorAccountsWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeMonitorAccounts',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeMonitorAccountsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the list of accounts that are added to the multi-account management feature as members.
     *
     * @returns DescribeMonitorAccountsResponse
     *
     * @return DescribeMonitorAccountsResponse
     */
    public function describeMonitorAccounts()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeMonitorAccountsWithOptions($runtime);
    }

    /**
     * Queries whether slow queries need to be optimized.
     *
     * @param request - DescribeNeedAsyncQueryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeNeedAsyncQueryResponse
     *
     * @param DescribeNeedAsyncQueryRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DescribeNeedAsyncQueryResponse
     */
    public function describeNeedAsyncQueryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeNeedAsyncQuery',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeNeedAsyncQueryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries whether slow queries need to be optimized.
     *
     * @param request - DescribeNeedAsyncQueryRequest
     *
     * @returns DescribeNeedAsyncQueryResponse
     *
     * @param DescribeNeedAsyncQueryRequest $request
     *
     * @return DescribeNeedAsyncQueryResponse
     */
    public function describeNeedAsyncQuery($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeNeedAsyncQueryWithOptions($request, $runtime);
    }

    /**
     * Queries notification settings.
     *
     * @param request - DescribeNoticeConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeNoticeConfigResponse
     *
     * @param DescribeNoticeConfigRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DescribeNoticeConfigResponse
     */
    public function describeNoticeConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeNoticeConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeNoticeConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries notification settings.
     *
     * @param request - DescribeNoticeConfigRequest
     *
     * @returns DescribeNoticeConfigResponse
     *
     * @param DescribeNoticeConfigRequest $request
     *
     * @return DescribeNoticeConfigResponse
     */
    public function describeNoticeConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeNoticeConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the information about an alert type.
     *
     * @param request - DescribeNsasSuspEventTypeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeNsasSuspEventTypeResponse
     *
     * @param DescribeNsasSuspEventTypeRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeNsasSuspEventTypeResponse
     */
    public function describeNsasSuspEventTypeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->containerFieldName) {
            @$query['ContainerFieldName'] = $request->containerFieldName;
        }

        if (null !== $request->containerFieldValue) {
            @$query['ContainerFieldValue'] = $request->containerFieldValue;
        }

        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->multiAccountActionType) {
            @$query['MultiAccountActionType'] = $request->multiAccountActionType;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->supportOperateCodeList) {
            @$query['SupportOperateCodeList'] = $request->supportOperateCodeList;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeNsasSuspEventType',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeNsasSuspEventTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about an alert type.
     *
     * @param request - DescribeNsasSuspEventTypeRequest
     *
     * @returns DescribeNsasSuspEventTypeResponse
     *
     * @param DescribeNsasSuspEventTypeRequest $request
     *
     * @return DescribeNsasSuspEventTypeResponse
     */
    public function describeNsasSuspEventType($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeNsasSuspEventTypeWithOptions($request, $runtime);
    }

    /**
     * Queries the information about the servers whose Security Center agent status is Offline.
     *
     * @param request - DescribeOfflineMachinesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeOfflineMachinesResponse
     *
     * @param DescribeOfflineMachinesRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeOfflineMachinesResponse
     */
    public function describeOfflineMachinesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->os) {
            @$query['Os'] = $request->os;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionIdStr) {
            @$query['RegionIdStr'] = $request->regionIdStr;
        }

        if (null !== $request->regionNo) {
            @$query['RegionNo'] = $request->regionNo;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->vendor) {
            @$query['Vendor'] = $request->vendor;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeOfflineMachines',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeOfflineMachinesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about the servers whose Security Center agent status is Offline.
     *
     * @param request - DescribeOfflineMachinesRequest
     *
     * @returns DescribeOfflineMachinesResponse
     *
     * @param DescribeOfflineMachinesRequest $request
     *
     * @return DescribeOfflineMachinesResponse
     */
    public function describeOfflineMachines($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeOfflineMachinesWithOptions($request, $runtime);
    }

    /**
     * Queries agent tasks.
     *
     * @param request - DescribeOnceTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeOnceTaskResponse
     *
     * @param DescribeOnceTaskRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DescribeOnceTaskResponse
     */
    public function describeOnceTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->endTimeQuery) {
            @$query['EndTimeQuery'] = $request->endTimeQuery;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->rootTaskId) {
            @$query['RootTaskId'] = $request->rootTaskId;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        if (null !== $request->startTimeQuery) {
            @$query['StartTimeQuery'] = $request->startTimeQuery;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        if (null !== $request->taskType) {
            @$query['TaskType'] = $request->taskType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeOnceTask',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeOnceTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries agent tasks.
     *
     * @param request - DescribeOnceTaskRequest
     *
     * @returns DescribeOnceTaskResponse
     *
     * @param DescribeOnceTaskRequest $request
     *
     * @return DescribeOnceTaskResponse
     */
    public function describeOnceTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeOnceTaskWithOptions($request, $runtime);
    }

    /**
     * Queries the sub-task information of one-time scan task. A sub-task can be an image scan task or an image asset synchronization task.
     *
     * @param request - DescribeOnceTaskLeafRecordPageRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeOnceTaskLeafRecordPageResponse
     *
     * @param DescribeOnceTaskLeafRecordPageRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DescribeOnceTaskLeafRecordPageResponse
     */
    public function describeOnceTaskLeafRecordPageWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->relateInfo) {
            @$query['RelateInfo'] = $request->relateInfo;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->statusList) {
            @$query['StatusList'] = $request->statusList;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        if (null !== $request->taskType) {
            @$query['TaskType'] = $request->taskType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeOnceTaskLeafRecordPage',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeOnceTaskLeafRecordPageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the sub-task information of one-time scan task. A sub-task can be an image scan task or an image asset synchronization task.
     *
     * @param request - DescribeOnceTaskLeafRecordPageRequest
     *
     * @returns DescribeOnceTaskLeafRecordPageResponse
     *
     * @param DescribeOnceTaskLeafRecordPageRequest $request
     *
     * @return DescribeOnceTaskLeafRecordPageResponse
     */
    public function describeOnceTaskLeafRecordPage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeOnceTaskLeafRecordPageWithOptions($request, $runtime);
    }

    /**
     * Queries statistics on the client plug-in installation status.
     *
     * @param request - DescribePluginSummaryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribePluginSummaryResponse
     *
     * @param DescribePluginSummaryRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DescribePluginSummaryResponse
     */
    public function describePluginSummaryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pluginName) {
            @$query['PluginName'] = $request->pluginName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribePluginSummary',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribePluginSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries statistics on the client plug-in installation status.
     *
     * @param request - DescribePluginSummaryRequest
     *
     * @returns DescribePluginSummaryResponse
     *
     * @param DescribePluginSummaryRequest $request
     *
     * @return DescribePluginSummaryResponse
     */
    public function describePluginSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePluginSummaryWithOptions($request, $runtime);
    }

    /**
     * Queries the statistics of asset fingerprints. The assets include processes, ports, software, accounts, middleware, websites, web services, scheduled tasks, startup items, and databases.
     *
     * @param request - DescribePropertyCountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribePropertyCountResponse
     *
     * @param DescribePropertyCountRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DescribePropertyCountResponse
     */
    public function describePropertyCountWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        if (null !== $request->uuidList) {
            @$query['UuidList'] = $request->uuidList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribePropertyCount',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribePropertyCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics of asset fingerprints. The assets include processes, ports, software, accounts, middleware, websites, web services, scheduled tasks, startup items, and databases.
     *
     * @param request - DescribePropertyCountRequest
     *
     * @returns DescribePropertyCountResponse
     *
     * @param DescribePropertyCountRequest $request
     *
     * @return DescribePropertyCountResponse
     */
    public function describePropertyCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyCountWithOptions($request, $runtime);
    }

    /**
     * Queries the details of scheduled tasks on the Host page.
     *
     * @param request - DescribePropertyCronDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribePropertyCronDetailResponse
     *
     * @param DescribePropertyCronDetailRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribePropertyCronDetailResponse
     */
    public function describePropertyCronDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->extend) {
            @$query['Extend'] = $request->extend;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        if (null !== $request->user) {
            @$query['User'] = $request->user;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribePropertyCronDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribePropertyCronDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of scheduled tasks on the Host page.
     *
     * @param request - DescribePropertyCronDetailRequest
     *
     * @returns DescribePropertyCronDetailResponse
     *
     * @param DescribePropertyCronDetailRequest $request
     *
     * @return DescribePropertyCronDetailResponse
     */
    public function describePropertyCronDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyCronDetailWithOptions($request, $runtime);
    }

    /**
     * Queries the scheduled tasks of your assets.
     *
     * @param request - DescribePropertyCronItemRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribePropertyCronItemResponse
     *
     * @param DescribePropertyCronItemRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribePropertyCronItemResponse
     */
    public function describePropertyCronItemWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->forceFlush) {
            @$query['ForceFlush'] = $request->forceFlush;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribePropertyCronItem',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribePropertyCronItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the scheduled tasks of your assets.
     *
     * @param request - DescribePropertyCronItemRequest
     *
     * @returns DescribePropertyCronItemResponse
     *
     * @param DescribePropertyCronItemRequest $request
     *
     * @return DescribePropertyCronItemResponse
     */
    public function describePropertyCronItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyCronItemWithOptions($request, $runtime);
    }

    /**
     * Queries the fingerprints of ports on a specified server.
     *
     * @param request - DescribePropertyPortDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribePropertyPortDetailResponse
     *
     * @param DescribePropertyPortDetailRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribePropertyPortDetailResponse
     */
    public function describePropertyPortDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bindIp) {
            @$query['BindIp'] = $request->bindIp;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->extend) {
            @$query['Extend'] = $request->extend;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->port) {
            @$query['Port'] = $request->port;
        }

        if (null !== $request->procName) {
            @$query['ProcName'] = $request->procName;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribePropertyPortDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribePropertyPortDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the fingerprints of ports on a specified server.
     *
     * @param request - DescribePropertyPortDetailRequest
     *
     * @returns DescribePropertyPortDetailResponse
     *
     * @param DescribePropertyPortDetailRequest $request
     *
     * @return DescribePropertyPortDetailResponse
     */
    public function describePropertyPortDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyPortDetailWithOptions($request, $runtime);
    }

    /**
     * Queries information about all ports.
     *
     * @param request - DescribePropertyPortItemRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribePropertyPortItemResponse
     *
     * @param DescribePropertyPortItemRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribePropertyPortItemResponse
     */
    public function describePropertyPortItemWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->forceFlush) {
            @$query['ForceFlush'] = $request->forceFlush;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->port) {
            @$query['Port'] = $request->port;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribePropertyPortItem',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribePropertyPortItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries information about all ports.
     *
     * @param request - DescribePropertyPortItemRequest
     *
     * @returns DescribePropertyPortItemResponse
     *
     * @param DescribePropertyPortItemRequest $request
     *
     * @return DescribePropertyPortItemResponse
     */
    public function describePropertyPortItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyPortItemWithOptions($request, $runtime);
    }

    /**
     * Queries the fingerprints of processes on a specified server.
     *
     * @param request - DescribePropertyProcDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribePropertyProcDetailResponse
     *
     * @param DescribePropertyProcDetailRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribePropertyProcDetailResponse
     */
    public function describePropertyProcDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->cmdline) {
            @$query['Cmdline'] = $request->cmdline;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->extend) {
            @$query['Extend'] = $request->extend;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->procTimeEnd) {
            @$query['ProcTimeEnd'] = $request->procTimeEnd;
        }

        if (null !== $request->procTimeStart) {
            @$query['ProcTimeStart'] = $request->procTimeStart;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        if (null !== $request->user) {
            @$query['User'] = $request->user;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribePropertyProcDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribePropertyProcDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the fingerprints of processes on a specified server.
     *
     * @param request - DescribePropertyProcDetailRequest
     *
     * @returns DescribePropertyProcDetailResponse
     *
     * @param DescribePropertyProcDetailRequest $request
     *
     * @return DescribePropertyProcDetailResponse
     */
    public function describePropertyProcDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyProcDetailWithOptions($request, $runtime);
    }

    /**
     * Queries information about all processes.
     *
     * @param request - DescribePropertyProcItemRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribePropertyProcItemResponse
     *
     * @param DescribePropertyProcItemRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribePropertyProcItemResponse
     */
    public function describePropertyProcItemWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->forceFlush) {
            @$query['ForceFlush'] = $request->forceFlush;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribePropertyProcItem',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribePropertyProcItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries information about all processes.
     *
     * @param request - DescribePropertyProcItemRequest
     *
     * @returns DescribePropertyProcItemResponse
     *
     * @param DescribePropertyProcItemRequest $request
     *
     * @return DescribePropertyProcItemResponse
     */
    public function describePropertyProcItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyProcItemWithOptions($request, $runtime);
    }

    /**
     * Queries middleware fingerprints.
     *
     * @param request - DescribePropertyScaDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribePropertyScaDetailResponse
     *
     * @param DescribePropertyScaDetailRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribePropertyScaDetailResponse
     */
    public function describePropertyScaDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->biz) {
            @$query['Biz'] = $request->biz;
        }

        if (null !== $request->bizType) {
            @$query['BizType'] = $request->bizType;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->pid) {
            @$query['Pid'] = $request->pid;
        }

        if (null !== $request->port) {
            @$query['Port'] = $request->port;
        }

        if (null !== $request->processStartedEnd) {
            @$query['ProcessStartedEnd'] = $request->processStartedEnd;
        }

        if (null !== $request->processStartedStart) {
            @$query['ProcessStartedStart'] = $request->processStartedStart;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->scaName) {
            @$query['ScaName'] = $request->scaName;
        }

        if (null !== $request->scaNamePattern) {
            @$query['ScaNamePattern'] = $request->scaNamePattern;
        }

        if (null !== $request->scaVersion) {
            @$query['ScaVersion'] = $request->scaVersion;
        }

        if (null !== $request->searchInfo) {
            @$query['SearchInfo'] = $request->searchInfo;
        }

        if (null !== $request->searchInfoSub) {
            @$query['SearchInfoSub'] = $request->searchInfoSub;
        }

        if (null !== $request->searchItem) {
            @$query['SearchItem'] = $request->searchItem;
        }

        if (null !== $request->searchItemSub) {
            @$query['SearchItemSub'] = $request->searchItemSub;
        }

        if (null !== $request->user) {
            @$query['User'] = $request->user;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribePropertyScaDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribePropertyScaDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries middleware fingerprints.
     *
     * @param request - DescribePropertyScaDetailRequest
     *
     * @returns DescribePropertyScaDetailResponse
     *
     * @param DescribePropertyScaDetailRequest $request
     *
     * @return DescribePropertyScaDetailResponse
     */
    public function describePropertyScaDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyScaDetailWithOptions($request, $runtime);
    }

    /**
     * Queries middleware fingerprints.
     *
     * @param request - DescribePropertyScaItemRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribePropertyScaItemResponse
     *
     * @param DescribePropertyScaItemRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribePropertyScaItemResponse
     */
    public function describePropertyScaItemWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->biz) {
            @$query['Biz'] = $request->biz;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->forceFlush) {
            @$query['ForceFlush'] = $request->forceFlush;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->searchInfo) {
            @$query['SearchInfo'] = $request->searchInfo;
        }

        if (null !== $request->searchItem) {
            @$query['SearchItem'] = $request->searchItem;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribePropertyScaItem',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribePropertyScaItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries middleware fingerprints.
     *
     * @param request - DescribePropertyScaItemRequest
     *
     * @returns DescribePropertyScaItemResponse
     *
     * @param DescribePropertyScaItemRequest $request
     *
     * @return DescribePropertyScaItemResponse
     */
    public function describePropertyScaItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyScaItemWithOptions($request, $runtime);
    }

    /**
     * Queries the Java processes that are collected by the asset fingerprints feature of Security Center in your assets.
     *
     * @param request - DescribePropertyScaProcessDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribePropertyScaProcessDetailResponse
     *
     * @param DescribePropertyScaProcessDetailRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return DescribePropertyScaProcessDetailResponse
     */
    public function describePropertyScaProcessDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bizType) {
            @$query['BizType'] = $request->bizType;
        }

        if (null !== $request->cmdline) {
            @$query['Cmdline'] = $request->cmdline;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->pid) {
            @$query['Pid'] = $request->pid;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribePropertyScaProcessDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribePropertyScaProcessDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the Java processes that are collected by the asset fingerprints feature of Security Center in your assets.
     *
     * @param request - DescribePropertyScaProcessDetailRequest
     *
     * @returns DescribePropertyScaProcessDetailResponse
     *
     * @param DescribePropertyScaProcessDetailRequest $request
     *
     * @return DescribePropertyScaProcessDetailResponse
     */
    public function describePropertyScaProcessDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyScaProcessDetailWithOptions($request, $runtime);
    }

    /**
     * Queries the configurations of scheduled tasks of asset fingerprint collection.
     *
     * @param request - DescribePropertyScheduleConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribePropertyScheduleConfigResponse
     *
     * @param DescribePropertyScheduleConfigRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DescribePropertyScheduleConfigResponse
     */
    public function describePropertyScheduleConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribePropertyScheduleConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribePropertyScheduleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configurations of scheduled tasks of asset fingerprint collection.
     *
     * @param request - DescribePropertyScheduleConfigRequest
     *
     * @returns DescribePropertyScheduleConfigResponse
     *
     * @param DescribePropertyScheduleConfigRequest $request
     *
     * @return DescribePropertyScheduleConfigResponse
     */
    public function describePropertyScheduleConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyScheduleConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the details of a software asset.
     *
     * @param request - DescribePropertySoftwareDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribePropertySoftwareDetailResponse
     *
     * @param DescribePropertySoftwareDetailRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DescribePropertySoftwareDetailResponse
     */
    public function describePropertySoftwareDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->extend) {
            @$query['Extend'] = $request->extend;
        }

        if (null !== $request->installTimeEnd) {
            @$query['InstallTimeEnd'] = $request->installTimeEnd;
        }

        if (null !== $request->installTimeStart) {
            @$query['InstallTimeStart'] = $request->installTimeStart;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->path) {
            @$query['Path'] = $request->path;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->softwareVersion) {
            @$query['SoftwareVersion'] = $request->softwareVersion;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribePropertySoftwareDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribePropertySoftwareDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of a software asset.
     *
     * @param request - DescribePropertySoftwareDetailRequest
     *
     * @returns DescribePropertySoftwareDetailResponse
     *
     * @param DescribePropertySoftwareDetailRequest $request
     *
     * @return DescribePropertySoftwareDetailResponse
     */
    public function describePropertySoftwareDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertySoftwareDetailWithOptions($request, $runtime);
    }

    /**
     * Queries information about all software assets.
     *
     * @param request - DescribePropertySoftwareItemRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribePropertySoftwareItemResponse
     *
     * @param DescribePropertySoftwareItemRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribePropertySoftwareItemResponse
     */
    public function describePropertySoftwareItemWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->forceFlush) {
            @$query['ForceFlush'] = $request->forceFlush;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribePropertySoftwareItem',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribePropertySoftwareItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries information about all software assets.
     *
     * @param request - DescribePropertySoftwareItemRequest
     *
     * @returns DescribePropertySoftwareItemResponse
     *
     * @param DescribePropertySoftwareItemRequest $request
     *
     * @return DescribePropertySoftwareItemResponse
     */
    public function describePropertySoftwareItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertySoftwareItemWithOptions($request, $runtime);
    }

    /**
     * Queries middleware types.
     *
     * @param request - DescribePropertyTypeScaItemRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribePropertyTypeScaItemResponse
     *
     * @param DescribePropertyTypeScaItemRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribePropertyTypeScaItemResponse
     */
    public function describePropertyTypeScaItemWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribePropertyTypeScaItem',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribePropertyTypeScaItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries middleware types.
     *
     * @param request - DescribePropertyTypeScaItemRequest
     *
     * @returns DescribePropertyTypeScaItemResponse
     *
     * @param DescribePropertyTypeScaItemRequest $request
     *
     * @return DescribePropertyTypeScaItemResponse
     */
    public function describePropertyTypeScaItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyTypeScaItemWithOptions($request, $runtime);
    }

    /**
     * Uses the asset fingerprints feature to obtain the statistics on top five most frequently detected ports, processes, software, accounts, or middleware.
     *
     * @remarks
     * Only users who purchase the Enterprise or Ultimate edition of Security Center can call this operation.
     *
     * @param request - DescribePropertyUsageTopRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribePropertyUsageTopResponse
     *
     * @param DescribePropertyUsageTopRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribePropertyUsageTopResponse
     */
    public function describePropertyUsageTopWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribePropertyUsageTop',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribePropertyUsageTopResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Uses the asset fingerprints feature to obtain the statistics on top five most frequently detected ports, processes, software, accounts, or middleware.
     *
     * @remarks
     * Only users who purchase the Enterprise or Ultimate edition of Security Center can call this operation.
     *
     * @param request - DescribePropertyUsageTopRequest
     *
     * @returns DescribePropertyUsageTopResponse
     *
     * @param DescribePropertyUsageTopRequest $request
     *
     * @return DescribePropertyUsageTopResponse
     */
    public function describePropertyUsageTop($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyUsageTopWithOptions($request, $runtime);
    }

    /**
     * Queries the asset fingerprints for an account to which a server belongs.
     *
     * @param request - DescribePropertyUserDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribePropertyUserDetailResponse
     *
     * @param DescribePropertyUserDetailRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribePropertyUserDetailResponse
     */
    public function describePropertyUserDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->extend) {
            @$query['Extend'] = $request->extend;
        }

        if (null !== $request->isRoot) {
            @$query['IsRoot'] = $request->isRoot;
        }

        if (null !== $request->lastLoginTimeEnd) {
            @$query['LastLoginTimeEnd'] = $request->lastLoginTimeEnd;
        }

        if (null !== $request->lastLoginTimeStart) {
            @$query['LastLoginTimeStart'] = $request->lastLoginTimeStart;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->user) {
            @$query['User'] = $request->user;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribePropertyUserDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribePropertyUserDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the asset fingerprints for an account to which a server belongs.
     *
     * @param request - DescribePropertyUserDetailRequest
     *
     * @returns DescribePropertyUserDetailResponse
     *
     * @param DescribePropertyUserDetailRequest $request
     *
     * @return DescribePropertyUserDetailResponse
     */
    public function describePropertyUserDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyUserDetailWithOptions($request, $runtime);
    }

    /**
     * Queries information about an account.
     *
     * @param request - DescribePropertyUserItemRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribePropertyUserItemResponse
     *
     * @param DescribePropertyUserItemRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribePropertyUserItemResponse
     */
    public function describePropertyUserItemWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->forceFlush) {
            @$query['ForceFlush'] = $request->forceFlush;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->user) {
            @$query['User'] = $request->user;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribePropertyUserItem',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribePropertyUserItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries information about an account.
     *
     * @param request - DescribePropertyUserItemRequest
     *
     * @returns DescribePropertyUserItemResponse
     *
     * @param DescribePropertyUserItemRequest $request
     *
     * @return DescribePropertyUserItemResponse
     */
    public function describePropertyUserItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyUserItemWithOptions($request, $runtime);
    }

    /**
     * Queries the download information about a quarantined file.
     *
     * @param request - DescribeQuaraFileDownloadInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeQuaraFileDownloadInfoResponse
     *
     * @param DescribeQuaraFileDownloadInfoRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DescribeQuaraFileDownloadInfoResponse
     */
    public function describeQuaraFileDownloadInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        if (null !== $request->quaraFileId) {
            @$query['QuaraFileId'] = $request->quaraFileId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeQuaraFileDownloadInfo',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeQuaraFileDownloadInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the download information about a quarantined file.
     *
     * @param request - DescribeQuaraFileDownloadInfoRequest
     *
     * @returns DescribeQuaraFileDownloadInfoResponse
     *
     * @param DescribeQuaraFileDownloadInfoRequest $request
     *
     * @return DescribeQuaraFileDownloadInfoResponse
     */
    public function describeQuaraFileDownloadInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeQuaraFileDownloadInfoWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a report export task.
     *
     * @param request - DescribeReportExportRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeReportExportResponse
     *
     * @param DescribeReportExportRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DescribeReportExportResponse
     */
    public function describeReportExportWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->exportId) {
            @$query['ExportId'] = $request->exportId;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeReportExport',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeReportExportResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a report export task.
     *
     * @param request - DescribeReportExportRequest
     *
     * @returns DescribeReportExportResponse
     *
     * @param DescribeReportExportRequest $request
     *
     * @return DescribeReportExportResponse
     */
    public function describeReportExport($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeReportExportWithOptions($request, $runtime);
    }

    /**
     * Queries the status of a report recipient by using the security report feature of the System Configuration module in the Security Center console.
     *
     * @param request - DescribeReportRecipientStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeReportRecipientStatusResponse
     *
     * @param DescribeReportRecipientStatusRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DescribeReportRecipientStatusResponse
     */
    public function describeReportRecipientStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->recipients) {
            @$query['Recipients'] = $request->recipients;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeReportRecipientStatus',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeReportRecipientStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the status of a report recipient by using the security report feature of the System Configuration module in the Security Center console.
     *
     * @param request - DescribeReportRecipientStatusRequest
     *
     * @returns DescribeReportRecipientStatusResponse
     *
     * @param DescribeReportRecipientStatusRequest $request
     *
     * @return DescribeReportRecipientStatusResponse
     */
    public function describeReportRecipientStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeReportRecipientStatusWithOptions($request, $runtime);
    }

    /**
     * Queries the details about restoration tasks.
     *
     * @remarks
     * If the data on your servers is encrypted by ransomware, you can create a restoration task to restore the data on your servers by using backup data in Security Center.
     * >  After you enable an anti-ransomware policy, the data on your servers is backed up based on the policy. For more information about anti-ransomware policies, see [Manage protection policies](https://help.aliyun.com/document_detail/164781.html).
     *
     * @param request - DescribeRestoreJobsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRestoreJobsResponse
     *
     * @param DescribeRestoreJobsRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DescribeRestoreJobsResponse
     */
    public function describeRestoreJobsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->machineRemark) {
            @$query['MachineRemark'] = $request->machineRemark;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRestoreJobs',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRestoreJobsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details about restoration tasks.
     *
     * @remarks
     * If the data on your servers is encrypted by ransomware, you can create a restoration task to restore the data on your servers by using backup data in Security Center.
     * >  After you enable an anti-ransomware policy, the data on your servers is backed up based on the policy. For more information about anti-ransomware policies, see [Manage protection policies](https://help.aliyun.com/document_detail/164781.html).
     *
     * @param request - DescribeRestoreJobsRequest
     *
     * @returns DescribeRestoreJobsResponse
     *
     * @param DescribeRestoreJobsRequest $request
     *
     * @return DescribeRestoreJobsResponse
     */
    public function describeRestoreJobs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRestoreJobsWithOptions($request, $runtime);
    }

    /**
     * Queries restoration tasks.
     *
     * @param request - DescribeRestorePlansRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRestorePlansResponse
     *
     * @param DescribeRestorePlansRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DescribeRestorePlansResponse
     */
    public function describeRestorePlansWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->instanceName) {
            @$query['InstanceName'] = $request->instanceName;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRestorePlans',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRestorePlansResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries restoration tasks.
     *
     * @param request - DescribeRestorePlansRequest
     *
     * @returns DescribeRestorePlansResponse
     *
     * @param DescribeRestorePlansRequest $request
     *
     * @return DescribeRestorePlansResponse
     */
    public function describeRestorePlans($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRestorePlansWithOptions($request, $runtime);
    }

    /**
     * Queries the assets that are affected by the risk item detected in configuration assessment based on a specified check item.
     *
     * @remarks
     * ListCheckInstanceResult
     *
     * @deprecated OpenAPI DescribeRiskCheckItemResult is deprecated
     *
     * @param request - DescribeRiskCheckItemResultRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRiskCheckItemResultResponse
     *
     * @param DescribeRiskCheckItemResultRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeRiskCheckItemResultResponse
     */
    public function describeRiskCheckItemResultWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->itemId) {
            @$query['ItemId'] = $request->itemId;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRiskCheckItemResult',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRiskCheckItemResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Queries the assets that are affected by the risk item detected in configuration assessment based on a specified check item.
     *
     * @remarks
     * ListCheckInstanceResult
     *
     * @deprecated OpenAPI DescribeRiskCheckItemResult is deprecated
     *
     * @param request - DescribeRiskCheckItemResultRequest
     *
     * @returns DescribeRiskCheckItemResultResponse
     *
     * @param DescribeRiskCheckItemResultRequest $request
     *
     * @return DescribeRiskCheckItemResultResponse
     */
    public function describeRiskCheckItemResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRiskCheckItemResultWithOptions($request, $runtime);
    }

    /**
     * Queries the check results of cloud service configurations by check item type or name.
     *
     * @remarks
     * This operation is phased out. You can use the [ListCheckResult](~~ListCheckResult~~) operation.
     *
     * @deprecated OpenAPI DescribeRiskCheckResult is deprecated
     *
     * @param request - DescribeRiskCheckResultRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRiskCheckResultResponse
     *
     * @param DescribeRiskCheckResultRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeRiskCheckResultResponse
     */
    public function describeRiskCheckResultWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->assetType) {
            @$query['AssetType'] = $request->assetType;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        if (null !== $request->itemIds) {
            @$query['ItemIds'] = $request->itemIds;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->queryFlag) {
            @$query['QueryFlag'] = $request->queryFlag;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->riskLevel) {
            @$query['RiskLevel'] = $request->riskLevel;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRiskCheckResult',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRiskCheckResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Queries the check results of cloud service configurations by check item type or name.
     *
     * @remarks
     * This operation is phased out. You can use the [ListCheckResult](~~ListCheckResult~~) operation.
     *
     * @deprecated OpenAPI DescribeRiskCheckResult is deprecated
     *
     * @param request - DescribeRiskCheckResultRequest
     *
     * @returns DescribeRiskCheckResultResponse
     *
     * @param DescribeRiskCheckResultRequest $request
     *
     * @return DescribeRiskCheckResultResponse
     */
    public function describeRiskCheckResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRiskCheckResultWithOptions($request, $runtime);
    }

    /**
     * Queries the summary information about the check results of cloud service configurations. The information includes the number of risk items, the risk rate, the number of affected assets, the check time, and the statistics for each type of check item.
     *
     * @remarks
     * This operation is phased out. You can use the GetCheckSummary operation.
     *
     * @deprecated OpenAPI DescribeRiskCheckSummary is deprecated
     *
     * @param request - DescribeRiskCheckSummaryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRiskCheckSummaryResponse
     *
     * @param DescribeRiskCheckSummaryRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeRiskCheckSummaryResponse
     */
    public function describeRiskCheckSummaryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRiskCheckSummary',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRiskCheckSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Queries the summary information about the check results of cloud service configurations. The information includes the number of risk items, the risk rate, the number of affected assets, the check time, and the statistics for each type of check item.
     *
     * @remarks
     * This operation is phased out. You can use the GetCheckSummary operation.
     *
     * @deprecated OpenAPI DescribeRiskCheckSummary is deprecated
     *
     * @param request - DescribeRiskCheckSummaryRequest
     *
     * @returns DescribeRiskCheckSummaryResponse
     *
     * @param DescribeRiskCheckSummaryRequest $request
     *
     * @return DescribeRiskCheckSummaryResponse
     */
    public function describeRiskCheckSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRiskCheckSummaryWithOptions($request, $runtime);
    }

    /**
     * Queries the types of check items in configuration assessment.
     *
     * @remarks
     * This operation is phased out. You can use the ListCheckStandard operation instead.
     *
     * @deprecated OpenAPI DescribeRiskItemType is deprecated
     *
     * @param request - DescribeRiskItemTypeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRiskItemTypeResponse
     *
     * @param DescribeRiskItemTypeRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DescribeRiskItemTypeResponse
     */
    public function describeRiskItemTypeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRiskItemType',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRiskItemTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Queries the types of check items in configuration assessment.
     *
     * @remarks
     * This operation is phased out. You can use the ListCheckStandard operation instead.
     *
     * @deprecated OpenAPI DescribeRiskItemType is deprecated
     *
     * @param request - DescribeRiskItemTypeRequest
     *
     * @returns DescribeRiskItemTypeResponse
     *
     * @param DescribeRiskItemTypeRequest $request
     *
     * @return DescribeRiskItemTypeResponse
     */
    public function describeRiskItemType($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRiskItemTypeWithOptions($request, $runtime);
    }

    /**
     * Queries the number of risk items detected in the configuration assessment of one or more cloud services by using the instance IDs of the cloud services.
     *
     * @remarks
     * This operation is phased out. You can use the ListCheckResult operation. When you call the ListCheckResult operation, set the Statuses parameter to NOT_PASS.
     *
     * @deprecated OpenAPI DescribeRiskListCheckResult is deprecated
     *
     * @param request - DescribeRiskListCheckResultRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRiskListCheckResultResponse
     *
     * @param DescribeRiskListCheckResultRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeRiskListCheckResultResponse
     */
    public function describeRiskListCheckResultWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->instanceIds) {
            @$query['InstanceIds'] = $request->instanceIds;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRiskListCheckResult',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRiskListCheckResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Queries the number of risk items detected in the configuration assessment of one or more cloud services by using the instance IDs of the cloud services.
     *
     * @remarks
     * This operation is phased out. You can use the ListCheckResult operation. When you call the ListCheckResult operation, set the Statuses parameter to NOT_PASS.
     *
     * @deprecated OpenAPI DescribeRiskListCheckResult is deprecated
     *
     * @param request - DescribeRiskListCheckResultRequest
     *
     * @returns DescribeRiskListCheckResultResponse
     *
     * @param DescribeRiskListCheckResultRequest $request
     *
     * @return DescribeRiskListCheckResultResponse
     */
    public function describeRiskListCheckResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRiskListCheckResultWithOptions($request, $runtime);
    }

    /**
     * Queries baseline types.
     *
     * @param request - DescribeRiskTypeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRiskTypeResponse
     *
     * @param DescribeRiskTypeRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DescribeRiskTypeResponse
     */
    public function describeRiskTypeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRiskType',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRiskTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries baseline types.
     *
     * @param request - DescribeRiskTypeRequest
     *
     * @returns DescribeRiskTypeResponse
     *
     * @param DescribeRiskTypeRequest $request
     *
     * @return DescribeRiskTypeResponse
     */
    public function describeRiskType($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRiskTypeWithOptions($request, $runtime);
    }

    /**
     * Queries the information about baselines based on baseline IDs or names.
     *
     * @param request - DescribeRisksRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRisksResponse
     *
     * @param DescribeRisksRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return DescribeRisksResponse
     */
    public function describeRisksWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->limit) {
            @$query['Limit'] = $request->limit;
        }

        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        if (null !== $request->riskId) {
            @$query['RiskId'] = $request->riskId;
        }

        if (null !== $request->riskName) {
            @$query['RiskName'] = $request->riskName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRisks',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRisksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about baselines based on baseline IDs or names.
     *
     * @param request - DescribeRisksRequest
     *
     * @returns DescribeRisksResponse
     *
     * @param DescribeRisksRequest $request
     *
     * @return DescribeRisksResponse
     */
    public function describeRisks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRisksWithOptions($request, $runtime);
    }

    /**
     * Queries the servers on which you want to install Cloud Assistant or the CloudMonitor agent.
     *
     * @param request - DescribeSasPmAgentListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSasPmAgentListResponse
     *
     * @param DescribeSasPmAgentListRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DescribeSasPmAgentListResponse
     */
    public function describeSasPmAgentListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSasPmAgentList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSasPmAgentListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the servers on which you want to install Cloud Assistant or the CloudMonitor agent.
     *
     * @param request - DescribeSasPmAgentListRequest
     *
     * @returns DescribeSasPmAgentListResponse
     *
     * @param DescribeSasPmAgentListRequest $request
     *
     * @return DescribeSasPmAgentListResponse
     */
    public function describeSasPmAgentList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSasPmAgentListWithOptions($request, $runtime);
    }

    /**
     * Queries the progress of a virus scan task.
     *
     * @param request - DescribeScanTaskProgressRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeScanTaskProgressResponse
     *
     * @param DescribeScanTaskProgressRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeScanTaskProgressResponse
     */
    public function describeScanTaskProgressWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeScanTaskProgress',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeScanTaskProgressResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the progress of a virus scan task.
     *
     * @param request - DescribeScanTaskProgressRequest
     *
     * @returns DescribeScanTaskProgressResponse
     *
     * @param DescribeScanTaskProgressRequest $request
     *
     * @return DescribeScanTaskProgressResponse
     */
    public function describeScanTaskProgress($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeScanTaskProgressWithOptions($request, $runtime);
    }

    /**
     * Queries the statistics of virus detection tasks.
     *
     * @param request - DescribeScanTaskStatisticsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeScanTaskStatisticsResponse
     *
     * @param DescribeScanTaskStatisticsRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeScanTaskStatisticsResponse
     */
    public function describeScanTaskStatisticsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->levels) {
            @$query['Levels'] = $request->levels;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeScanTaskStatistics',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeScanTaskStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics of virus detection tasks.
     *
     * @param request - DescribeScanTaskStatisticsRequest
     *
     * @returns DescribeScanTaskStatisticsResponse
     *
     * @param DescribeScanTaskStatisticsRequest $request
     *
     * @return DescribeScanTaskStatisticsResponse
     */
    public function describeScanTaskStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeScanTaskStatisticsWithOptions($request, $runtime);
    }

    /**
     * Queries the trends of the scores on the security dashboard.
     *
     * @param request - DescribeScreenScoreThreadRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeScreenScoreThreadResponse
     *
     * @param DescribeScreenScoreThreadRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeScreenScoreThreadResponse
     */
    public function describeScreenScoreThreadWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeScreenScoreThread',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeScreenScoreThreadResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the trends of the scores on the security dashboard.
     *
     * @param request - DescribeScreenScoreThreadRequest
     *
     * @returns DescribeScreenScoreThreadResponse
     *
     * @param DescribeScreenScoreThreadRequest $request
     *
     * @return DescribeScreenScoreThreadResponse
     */
    public function describeScreenScoreThread($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeScreenScoreThreadWithOptions($request, $runtime);
    }

    /**
     * Queries the filter conditions that are used to search for assets.
     *
     * @param request - DescribeSearchConditionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSearchConditionResponse
     *
     * @param DescribeSearchConditionRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeSearchConditionResponse
     */
    public function describeSearchConditionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSearchCondition',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSearchConditionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the filter conditions that are used to search for assets.
     *
     * @param request - DescribeSearchConditionRequest
     *
     * @returns DescribeSearchConditionResponse
     *
     * @param DescribeSearchConditionRequest $request
     *
     * @return DescribeSearchConditionResponse
     */
    public function describeSearchCondition($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSearchConditionWithOptions($request, $runtime);
    }

    /**
     * Queries suggestions on how to handle the risks that affect the security score.
     *
     * @param request - DescribeSecureSuggestionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSecureSuggestionResponse
     *
     * @param DescribeSecureSuggestionRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeSecureSuggestionResponse
     */
    public function describeSecureSuggestionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->calType) {
            @$query['CalType'] = $request->calType;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSecureSuggestion',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSecureSuggestionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries suggestions on how to handle the risks that affect the security score.
     *
     * @param request - DescribeSecureSuggestionRequest
     *
     * @returns DescribeSecureSuggestionResponse
     *
     * @param DescribeSecureSuggestionRequest $request
     *
     * @return DescribeSecureSuggestionResponse
     */
    public function describeSecureSuggestion($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSecureSuggestionWithOptions($request, $runtime);
    }

    /**
     * Queries the day of a week when custom check tasks are performed and the time range during which the custom check tasks are performed.
     *
     * @remarks
     * This operation is phased out. You can use the GetCheckConfig operation.
     *
     * @deprecated OpenAPI DescribeSecurityCheckScheduleConfig is deprecated
     *
     * @param request - DescribeSecurityCheckScheduleConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSecurityCheckScheduleConfigResponse
     *
     * @param DescribeSecurityCheckScheduleConfigRequest $request
     * @param RuntimeOptions                             $runtime
     *
     * @return DescribeSecurityCheckScheduleConfigResponse
     */
    public function describeSecurityCheckScheduleConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSecurityCheckScheduleConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSecurityCheckScheduleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Queries the day of a week when custom check tasks are performed and the time range during which the custom check tasks are performed.
     *
     * @remarks
     * This operation is phased out. You can use the GetCheckConfig operation.
     *
     * @deprecated OpenAPI DescribeSecurityCheckScheduleConfig is deprecated
     *
     * @param request - DescribeSecurityCheckScheduleConfigRequest
     *
     * @returns DescribeSecurityCheckScheduleConfigResponse
     *
     * @param DescribeSecurityCheckScheduleConfigRequest $request
     *
     * @return DescribeSecurityCheckScheduleConfigResponse
     */
    public function describeSecurityCheckScheduleConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSecurityCheckScheduleConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the list of whitelist rules.
     *
     * @param request - DescribeSecurityEventMarkMissListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSecurityEventMarkMissListResponse
     *
     * @param DescribeSecurityEventMarkMissListRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return DescribeSecurityEventMarkMissListResponse
     */
    public function describeSecurityEventMarkMissListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->eventName) {
            @$query['EventName'] = $request->eventName;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSecurityEventMarkMissList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSecurityEventMarkMissListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the list of whitelist rules.
     *
     * @param request - DescribeSecurityEventMarkMissListRequest
     *
     * @returns DescribeSecurityEventMarkMissListResponse
     *
     * @param DescribeSecurityEventMarkMissListRequest $request
     *
     * @return DescribeSecurityEventMarkMissListResponse
     */
    public function describeSecurityEventMarkMissList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSecurityEventMarkMissListWithOptions($request, $runtime);
    }

    /**
     * Queries the alert events that are triggered by the same IP address rule or of the same alert type as a specific alert event if you want to handle the specific alert event in batch operation mode.
     *
     * @param request - DescribeSecurityEventOperationStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSecurityEventOperationStatusResponse
     *
     * @param DescribeSecurityEventOperationStatusRequest $request
     * @param RuntimeOptions                              $runtime
     *
     * @return DescribeSecurityEventOperationStatusResponse
     */
    public function describeSecurityEventOperationStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->securityEventIds) {
            @$query['SecurityEventIds'] = $request->securityEventIds;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSecurityEventOperationStatus',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSecurityEventOperationStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the alert events that are triggered by the same IP address rule or of the same alert type as a specific alert event if you want to handle the specific alert event in batch operation mode.
     *
     * @param request - DescribeSecurityEventOperationStatusRequest
     *
     * @returns DescribeSecurityEventOperationStatusResponse
     *
     * @param DescribeSecurityEventOperationStatusRequest $request
     *
     * @return DescribeSecurityEventOperationStatusResponse
     */
    public function describeSecurityEventOperationStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSecurityEventOperationStatusWithOptions($request, $runtime);
    }

    /**
     * Queries the operations that you can perform to handle an alert.
     *
     * @param request - DescribeSecurityEventOperationsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSecurityEventOperationsResponse
     *
     * @param DescribeSecurityEventOperationsRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return DescribeSecurityEventOperationsResponse
     */
    public function describeSecurityEventOperationsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->securityEventId) {
            @$query['SecurityEventId'] = $request->securityEventId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSecurityEventOperations',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSecurityEventOperationsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the operations that you can perform to handle an alert.
     *
     * @param request - DescribeSecurityEventOperationsRequest
     *
     * @returns DescribeSecurityEventOperationsResponse
     *
     * @param DescribeSecurityEventOperationsRequest $request
     *
     * @return DescribeSecurityEventOperationsResponse
     */
    public function describeSecurityEventOperations($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSecurityEventOperationsWithOptions($request, $runtime);
    }

    /**
     * Queries the statistics of each security check item and the daily statistics in the trend chart based on each security check item.
     *
     * @param request - DescribeSecurityStatInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSecurityStatInfoResponse
     *
     * @param DescribeSecurityStatInfoRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeSecurityStatInfoResponse
     */
    public function describeSecurityStatInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSecurityStatInfo',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSecurityStatInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics of each security check item and the daily statistics in the trend chart based on each security check item.
     *
     * @param request - DescribeSecurityStatInfoRequest
     *
     * @returns DescribeSecurityStatInfoResponse
     *
     * @param DescribeSecurityStatInfoRequest $request
     *
     * @return DescribeSecurityStatInfoResponse
     */
    public function describeSecurityStatInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSecurityStatInfoWithOptions($request, $runtime);
    }

    /**
     * Checks whether a service-linked role is created for Security Center.
     *
     * @param request - DescribeServiceLinkedRoleStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeServiceLinkedRoleStatusResponse
     *
     * @param DescribeServiceLinkedRoleStatusRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return DescribeServiceLinkedRoleStatusResponse
     */
    public function describeServiceLinkedRoleStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->serviceLinkedRole) {
            @$query['ServiceLinkedRole'] = $request->serviceLinkedRole;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeServiceLinkedRoleStatus',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeServiceLinkedRoleStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Checks whether a service-linked role is created for Security Center.
     *
     * @param request - DescribeServiceLinkedRoleStatusRequest
     *
     * @returns DescribeServiceLinkedRoleStatusResponse
     *
     * @param DescribeServiceLinkedRoleStatusRequest $request
     *
     * @return DescribeServiceLinkedRoleStatusResponse
     */
    public function describeServiceLinkedRoleStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeServiceLinkedRoleStatusWithOptions($request, $runtime);
    }

    /**
     * Queries the scenarios in which alerts triggered by the same rule or rules of the same type are handled.
     *
     * @param request - DescribeSimilarEventScenariosRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSimilarEventScenariosResponse
     *
     * @param DescribeSimilarEventScenariosRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DescribeSimilarEventScenariosResponse
     */
    public function describeSimilarEventScenariosWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->securityEventId) {
            @$query['SecurityEventId'] = $request->securityEventId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSimilarEventScenarios',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSimilarEventScenariosResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the scenarios in which alerts triggered by the same rule or rules of the same type are handled.
     *
     * @param request - DescribeSimilarEventScenariosRequest
     *
     * @returns DescribeSimilarEventScenariosResponse
     *
     * @param DescribeSimilarEventScenariosRequest $request
     *
     * @return DescribeSimilarEventScenariosResponse
     */
    public function describeSimilarEventScenarios($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSimilarEventScenariosWithOptions($request, $runtime);
    }

    /**
     * Queries alert events that are triggered by the same rule or of the same alert type.
     *
     * @param request - DescribeSimilarSecurityEventsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSimilarSecurityEventsResponse
     *
     * @param DescribeSimilarSecurityEventsRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DescribeSimilarSecurityEventsResponse
     */
    public function describeSimilarSecurityEventsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSimilarSecurityEvents',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSimilarSecurityEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries alert events that are triggered by the same rule or of the same alert type.
     *
     * @param request - DescribeSimilarSecurityEventsRequest
     *
     * @returns DescribeSimilarSecurityEventsResponse
     *
     * @param DescribeSimilarSecurityEventsRequest $request
     *
     * @return DescribeSimilarSecurityEventsResponse
     */
    public function describeSimilarSecurityEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSimilarSecurityEventsWithOptions($request, $runtime);
    }

    /**
     * Queries the backup snapshots that are created for anti-ransomware.
     *
     * @param request - DescribeSnapshotsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSnapshotsResponse
     *
     * @param DescribeSnapshotsRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return DescribeSnapshotsResponse
     */
    public function describeSnapshotsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->apiVersion) {
            @$query['ApiVersion'] = $request->apiVersion;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->isAliYunEcs) {
            @$query['IsAliYunEcs'] = $request->isAliYunEcs;
        }

        if (null !== $request->machineRegion) {
            @$query['MachineRegion'] = $request->machineRegion;
        }

        if (null !== $request->machineRemark) {
            @$query['MachineRemark'] = $request->machineRemark;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->statusList) {
            @$query['StatusList'] = $request->statusList;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSnapshots',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSnapshotsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the backup snapshots that are created for anti-ransomware.
     *
     * @param request - DescribeSnapshotsRequest
     *
     * @returns DescribeSnapshotsResponse
     *
     * @param DescribeSnapshotsRequest $request
     *
     * @return DescribeSnapshotsResponse
     */
    public function describeSnapshots($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSnapshotsWithOptions($request, $runtime);
    }

    /**
     * Query the execution details of a remediation task playbook.
     *
     * @remarks
     * This API is only supported by the Enterprise and Flagship editions of Cloud Security Center, other versions do not support it.
     *
     * @param request - DescribeSoarPlaybookTaskDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSoarPlaybookTaskDetailResponse
     *
     * @param DescribeSoarPlaybookTaskDetailRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DescribeSoarPlaybookTaskDetailResponse
     */
    public function describeSoarPlaybookTaskDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->playbookId) {
            @$query['PlaybookId'] = $request->playbookId;
        }

        if (null !== $request->recordId) {
            @$query['RecordId'] = $request->recordId;
        }

        if (null !== $request->requestUuid) {
            @$query['RequestUuid'] = $request->requestUuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSoarPlaybookTaskDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSoarPlaybookTaskDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Query the execution details of a remediation task playbook.
     *
     * @remarks
     * This API is only supported by the Enterprise and Flagship editions of Cloud Security Center, other versions do not support it.
     *
     * @param request - DescribeSoarPlaybookTaskDetailRequest
     *
     * @returns DescribeSoarPlaybookTaskDetailResponse
     *
     * @param DescribeSoarPlaybookTaskDetailRequest $request
     *
     * @return DescribeSoarPlaybookTaskDetailResponse
     */
    public function describeSoarPlaybookTaskDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSoarPlaybookTaskDetailWithOptions($request, $runtime);
    }

    /**
     * Queries the policy templates on the Playbook page.
     *
     * @remarks
     * Only the Enterprise and Ultimate editions of Security Center support this API operation.
     *
     * @param request - DescribeSoarStrategiesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSoarStrategiesResponse
     *
     * @param DescribeSoarStrategiesRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DescribeSoarStrategiesResponse
     */
    public function describeSoarStrategiesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSoarStrategies',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSoarStrategiesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the policy templates on the Playbook page.
     *
     * @remarks
     * Only the Enterprise and Ultimate editions of Security Center support this API operation.
     *
     * @param request - DescribeSoarStrategiesRequest
     *
     * @returns DescribeSoarStrategiesResponse
     *
     * @param DescribeSoarStrategiesRequest $request
     *
     * @return DescribeSoarStrategiesResponse
     */
    public function describeSoarStrategies($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSoarStrategiesWithOptions($request, $runtime);
    }

    /**
     * Queries the parameters of a policy on the Playbook page.
     *
     * @remarks
     * Only the Enterprise and Ultimate editions of Security Center support this API operation.
     *
     * @param request - DescribeSoarStrategyParamRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSoarStrategyParamResponse
     *
     * @param DescribeSoarStrategyParamRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeSoarStrategyParamResponse
     */
    public function describeSoarStrategyParamWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->strategyId) {
            @$query['StrategyId'] = $request->strategyId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSoarStrategyParam',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSoarStrategyParamResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the parameters of a policy on the Playbook page.
     *
     * @remarks
     * Only the Enterprise and Ultimate editions of Security Center support this API operation.
     *
     * @param request - DescribeSoarStrategyParamRequest
     *
     * @returns DescribeSoarStrategyParamResponse
     *
     * @param DescribeSoarStrategyParamRequest $request
     *
     * @return DescribeSoarStrategyParamResponse
     */
    public function describeSoarStrategyParam($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSoarStrategyParamWithOptions($request, $runtime);
    }

    /**
     * Queries the details of a policy task on the Playbook page, including the execution status of the task and the process information of the task.
     *
     * @remarks
     * Only the Enterprise and Ultimate editions of Security Center support this API operation.
     *
     * @param request - DescribeSoarStrategyTaskDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSoarStrategyTaskDetailResponse
     *
     * @param DescribeSoarStrategyTaskDetailRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DescribeSoarStrategyTaskDetailResponse
     */
    public function describeSoarStrategyTaskDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->strategyTaskId) {
            @$query['StrategyTaskId'] = $request->strategyTaskId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSoarStrategyTaskDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSoarStrategyTaskDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of a policy task on the Playbook page, including the execution status of the task and the process information of the task.
     *
     * @remarks
     * Only the Enterprise and Ultimate editions of Security Center support this API operation.
     *
     * @param request - DescribeSoarStrategyTaskDetailRequest
     *
     * @returns DescribeSoarStrategyTaskDetailResponse
     *
     * @param DescribeSoarStrategyTaskDetailRequest $request
     *
     * @return DescribeSoarStrategyTaskDetailResponse
     */
    public function describeSoarStrategyTaskDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSoarStrategyTaskDetailWithOptions($request, $runtime);
    }

    /**
     * Get the input parameters for a specific task.
     *
     * @remarks
     * Only the Enterprise and Flagship editions of Cloud Security Center support this API call, other versions do not support it.
     *
     * @param request - DescribeSoarStrategyTaskParamsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSoarStrategyTaskParamsResponse
     *
     * @param DescribeSoarStrategyTaskParamsRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DescribeSoarStrategyTaskParamsResponse
     */
    public function describeSoarStrategyTaskParamsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSoarStrategyTaskParams',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSoarStrategyTaskParamsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Get the input parameters for a specific task.
     *
     * @remarks
     * Only the Enterprise and Flagship editions of Cloud Security Center support this API call, other versions do not support it.
     *
     * @param request - DescribeSoarStrategyTaskParamsRequest
     *
     * @returns DescribeSoarStrategyTaskParamsResponse
     *
     * @param DescribeSoarStrategyTaskParamsRequest $request
     *
     * @return DescribeSoarStrategyTaskParamsResponse
     */
    public function describeSoarStrategyTaskParams($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSoarStrategyTaskParamsWithOptions($request, $runtime);
    }

    /**
     * Get the list of task execution results.
     *
     * @remarks
     * This API is only supported by the Enterprise and Flagship editions of Cloud Security Center, other versions do not support it.
     *
     * @param request - DescribeSoarStrategyTaskResultRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSoarStrategyTaskResultResponse
     *
     * @param DescribeSoarStrategyTaskResultRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DescribeSoarStrategyTaskResultResponse
     */
    public function describeSoarStrategyTaskResultWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSoarStrategyTaskResult',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSoarStrategyTaskResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Get the list of task execution results.
     *
     * @remarks
     * This API is only supported by the Enterprise and Flagship editions of Cloud Security Center, other versions do not support it.
     *
     * @param request - DescribeSoarStrategyTaskResultRequest
     *
     * @returns DescribeSoarStrategyTaskResultResponse
     *
     * @param DescribeSoarStrategyTaskResultRequest $request
     *
     * @return DescribeSoarStrategyTaskResultResponse
     */
    public function describeSoarStrategyTaskResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSoarStrategyTaskResultWithOptions($request, $runtime);
    }

    /**
     * Queries a list of policy tasks on the Playbook page.
     *
     * @remarks
     * Only the Enterprise and Ultimate editions of Security Center support this API operation.
     *
     * @param request - DescribeSoarStrategyTasksRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSoarStrategyTasksResponse
     *
     * @param DescribeSoarStrategyTasksRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeSoarStrategyTasksResponse
     */
    public function describeSoarStrategyTasksWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSoarStrategyTasks',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSoarStrategyTasksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of policy tasks on the Playbook page.
     *
     * @remarks
     * Only the Enterprise and Ultimate editions of Security Center support this API operation.
     *
     * @param request - DescribeSoarStrategyTasksRequest
     *
     * @returns DescribeSoarStrategyTasksResponse
     *
     * @param DescribeSoarStrategyTasksRequest $request
     *
     * @return DescribeSoarStrategyTasksResponse
     */
    public function describeSoarStrategyTasks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSoarStrategyTasksWithOptions($request, $runtime);
    }

    /**
     * Queries a list of policies created on the Playbook page of Security Center.
     *
     * @remarks
     * Only the Enterprise and Ultimate editions of Security Center support this API operation.
     *
     * @param request - DescribeSoarSubscribedStrategyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSoarSubscribedStrategyResponse
     *
     * @param DescribeSoarSubscribedStrategyRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DescribeSoarSubscribedStrategyResponse
     */
    public function describeSoarSubscribedStrategyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSoarSubscribedStrategy',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSoarSubscribedStrategyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of policies created on the Playbook page of Security Center.
     *
     * @remarks
     * Only the Enterprise and Ultimate editions of Security Center support this API operation.
     *
     * @param request - DescribeSoarSubscribedStrategyRequest
     *
     * @returns DescribeSoarSubscribedStrategyResponse
     *
     * @param DescribeSoarSubscribedStrategyRequest $request
     *
     * @return DescribeSoarSubscribedStrategyResponse
     */
    public function describeSoarSubscribedStrategy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSoarSubscribedStrategyWithOptions($request, $runtime);
    }

    /**
     * Queries the details about baseline check policies.
     *
     * @param request - DescribeStrategyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeStrategyResponse
     *
     * @param DescribeStrategyRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DescribeStrategyResponse
     */
    public function describeStrategyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->customType) {
            @$query['CustomType'] = $request->customType;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->strategyIds) {
            @$query['StrategyIds'] = $request->strategyIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeStrategy',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeStrategyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details about baseline check policies.
     *
     * @param request - DescribeStrategyRequest
     *
     * @returns DescribeStrategyResponse
     *
     * @param DescribeStrategyRequest $request
     *
     * @return DescribeStrategyResponse
     */
    public function describeStrategy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeStrategyWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a baseline check policy.
     *
     * @param request - DescribeStrategyDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeStrategyDetailResponse
     *
     * @param DescribeStrategyDetailRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DescribeStrategyDetailResponse
     */
    public function describeStrategyDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeStrategyDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeStrategyDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a baseline check policy.
     *
     * @param request - DescribeStrategyDetailRequest
     *
     * @returns DescribeStrategyDetailResponse
     *
     * @param DescribeStrategyDetailRequest $request
     *
     * @return DescribeStrategyDetailResponse
     */
    public function describeStrategyDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeStrategyDetailWithOptions($request, $runtime);
    }

    /**
     * Queries the results of the last baseline check by using a specified baseline check policy.
     *
     * @param request - DescribeStrategyExecDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeStrategyExecDetailResponse
     *
     * @param DescribeStrategyExecDetailRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeStrategyExecDetailResponse
     */
    public function describeStrategyExecDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->strategyId) {
            @$query['StrategyId'] = $request->strategyId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeStrategyExecDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeStrategyExecDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the results of the last baseline check by using a specified baseline check policy.
     *
     * @param request - DescribeStrategyExecDetailRequest
     *
     * @returns DescribeStrategyExecDetailResponse
     *
     * @param DescribeStrategyExecDetailRequest $request
     *
     * @return DescribeStrategyExecDetailResponse
     */
    public function describeStrategyExecDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeStrategyExecDetailWithOptions($request, $runtime);
    }

    /**
     * Queries the information about the assets to which a baseline check policy is applied.
     *
     * @param request - DescribeStrategyTargetRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeStrategyTargetResponse
     *
     * @param DescribeStrategyTargetRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DescribeStrategyTargetResponse
     */
    public function describeStrategyTargetWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->config) {
            @$query['Config'] = $request->config;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeStrategyTarget',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeStrategyTargetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about the assets to which a baseline check policy is applied.
     *
     * @param request - DescribeStrategyTargetRequest
     *
     * @returns DescribeStrategyTargetResponse
     *
     * @param DescribeStrategyTargetRequest $request
     *
     * @return DescribeStrategyTargetResponse
     */
    public function describeStrategyTarget($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeStrategyTargetWithOptions($request, $runtime);
    }

    /**
     * Strict mode supports alarm queries.
     *
     * @param request - DescribeStrictEventNameRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeStrictEventNameResponse
     *
     * @param DescribeStrictEventNameRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeStrictEventNameResponse
     */
    public function describeStrictEventNameWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeStrictEventName',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeStrictEventNameResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Strict mode supports alarm queries.
     *
     * @param request - DescribeStrictEventNameRequest
     *
     * @returns DescribeStrictEventNameResponse
     *
     * @param DescribeStrictEventNameRequest $request
     *
     * @return DescribeStrictEventNameResponse
     */
    public function describeStrictEventName($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeStrictEventNameWithOptions($request, $runtime);
    }

    /**
     * Queries the security information about your assets. The information includes the security score and the numbers of protected and unprotected assets.
     *
     * @param request - DescribeSummaryInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSummaryInfoResponse
     *
     * @param DescribeSummaryInfoRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DescribeSummaryInfoResponse
     */
    public function describeSummaryInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSummaryInfo',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSummaryInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the security information about your assets. The information includes the security score and the numbers of protected and unprotected assets.
     *
     * @param request - DescribeSummaryInfoRequest
     *
     * @returns DescribeSummaryInfoResponse
     *
     * @param DescribeSummaryInfoRequest $request
     *
     * @return DescribeSummaryInfoResponse
     */
    public function describeSummaryInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSummaryInfoWithOptions($request, $runtime);
    }

    /**
     * Queries the time when a system vulnerability was last detected.
     *
     * @param request - DescribeSupervisonInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSupervisonInfoResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeSupervisonInfoResponse
     */
    public function describeSupervisonInfoWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeSupervisonInfo',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSupervisonInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the time when a system vulnerability was last detected.
     *
     * @returns DescribeSupervisonInfoResponse
     *
     * @return DescribeSupervisonInfoResponse
     */
    public function describeSupervisonInfo()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSupervisonInfoWithOptions($runtime);
    }

    /**
     * Queries the regions in which the anti-ransomware feature is supported.
     *
     * @param request - DescribeSupportRegionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSupportRegionResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeSupportRegionResponse
     */
    public function describeSupportRegionWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeSupportRegion',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSupportRegionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the regions in which the anti-ransomware feature is supported.
     *
     * @returns DescribeSupportRegionResponse
     *
     * @return DescribeSupportRegionResponse
     */
    public function describeSupportRegion()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSupportRegionWithOptions($runtime);
    }

    /**
     * Queries the details of an exception. An alert event consists of an alert and exceptions. Each alert event is associated with multiple exceptions.
     *
     * @param request - DescribeSuspEventDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSuspEventDetailResponse
     *
     * @param DescribeSuspEventDetailRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeSuspEventDetailResponse
     */
    public function describeSuspEventDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->suspiciousEventId) {
            @$query['SuspiciousEventId'] = $request->suspiciousEventId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSuspEventDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSuspEventDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of an exception. An alert event consists of an alert and exceptions. Each alert event is associated with multiple exceptions.
     *
     * @param request - DescribeSuspEventDetailRequest
     *
     * @returns DescribeSuspEventDetailResponse
     *
     * @param DescribeSuspEventDetailRequest $request
     *
     * @return DescribeSuspEventDetailResponse
     */
    public function describeSuspEventDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSuspEventDetailWithOptions($request, $runtime);
    }

    /**
     * Queries the information about an export task of exceptions.
     *
     * @param request - DescribeSuspEventExportInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSuspEventExportInfoResponse
     *
     * @param DescribeSuspEventExportInfoRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeSuspEventExportInfoResponse
     */
    public function describeSuspEventExportInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->exportId) {
            @$query['ExportId'] = $request->exportId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSuspEventExportInfo',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSuspEventExportInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about an export task of exceptions.
     *
     * @param request - DescribeSuspEventExportInfoRequest
     *
     * @returns DescribeSuspEventExportInfoResponse
     *
     * @param DescribeSuspEventExportInfoRequest $request
     *
     * @return DescribeSuspEventExportInfoResponse
     */
    public function describeSuspEventExportInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSuspEventExportInfoWithOptions($request, $runtime);
    }

    /**
     * Queries quarantined files by page.
     *
     * @param request - DescribeSuspEventQuaraFilesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSuspEventQuaraFilesResponse
     *
     * @param DescribeSuspEventQuaraFilesRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeSuspEventQuaraFilesResponse
     */
    public function describeSuspEventQuaraFilesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        if (null !== $request->groupingId) {
            @$query['GroupingId'] = $request->groupingId;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->quaraTag) {
            @$query['QuaraTag'] = $request->quaraTag;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSuspEventQuaraFiles',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSuspEventQuaraFilesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries quarantined files by page.
     *
     * @param request - DescribeSuspEventQuaraFilesRequest
     *
     * @returns DescribeSuspEventQuaraFilesResponse
     *
     * @param DescribeSuspEventQuaraFilesRequest $request
     *
     * @return DescribeSuspEventQuaraFilesResponse
     */
    public function describeSuspEventQuaraFiles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSuspEventQuaraFilesWithOptions($request, $runtime);
    }

    /**
     * Queries the user settings for exceptions.
     *
     * @param request - DescribeSuspEventUserSettingRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSuspEventUserSettingResponse
     *
     * @param DescribeSuspEventUserSettingRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribeSuspEventUserSettingResponse
     */
    public function describeSuspEventUserSettingWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSuspEventUserSetting',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSuspEventUserSettingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the user settings for exceptions.
     *
     * @param request - DescribeSuspEventUserSettingRequest
     *
     * @returns DescribeSuspEventUserSettingResponse
     *
     * @param DescribeSuspEventUserSettingRequest $request
     *
     * @return DescribeSuspEventUserSettingResponse
     */
    public function describeSuspEventUserSetting($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSuspEventUserSettingWithOptions($request, $runtime);
    }

    /**
     * Queries a list of alert events that are generated without aggregation.
     *
     * @param tmpReq - DescribeSuspEventsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSuspEventsResponse
     *
     * @param DescribeSuspEventsRequest $tmpReq
     * @param RuntimeOptions            $runtime
     *
     * @return DescribeSuspEventsResponse
     */
    public function describeSuspEventsWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new DescribeSuspEventsShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->sourceAliUids) {
            $request->sourceAliUidsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->sourceAliUids, 'SourceAliUids', 'simple');
        }

        $query = [];
        if (null !== $request->alarmUniqueInfo) {
            @$query['AlarmUniqueInfo'] = $request->alarmUniqueInfo;
        }

        if (null !== $request->assetsTypeList) {
            @$query['AssetsTypeList'] = $request->assetsTypeList;
        }

        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->containerFieldName) {
            @$query['ContainerFieldName'] = $request->containerFieldName;
        }

        if (null !== $request->containerFieldValue) {
            @$query['ContainerFieldValue'] = $request->containerFieldValue;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->dealed) {
            @$query['Dealed'] = $request->dealed;
        }

        if (null !== $request->eventNames) {
            @$query['EventNames'] = $request->eventNames;
        }

        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->levels) {
            @$query['Levels'] = $request->levels;
        }

        if (null !== $request->multiAccountActionType) {
            @$query['MultiAccountActionType'] = $request->multiAccountActionType;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->operateErrorCodeList) {
            @$query['OperateErrorCodeList'] = $request->operateErrorCodeList;
        }

        if (null !== $request->operateTimeEnd) {
            @$query['OperateTimeEnd'] = $request->operateTimeEnd;
        }

        if (null !== $request->operateTimeStart) {
            @$query['OperateTimeStart'] = $request->operateTimeStart;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->parentEventTypes) {
            @$query['ParentEventTypes'] = $request->parentEventTypes;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        if (null !== $request->sortColumn) {
            @$query['SortColumn'] = $request->sortColumn;
        }

        if (null !== $request->sortType) {
            @$query['SortType'] = $request->sortType;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        if (null !== $request->sourceAliUidsShrink) {
            @$query['SourceAliUids'] = $request->sourceAliUidsShrink;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->strictMode) {
            @$query['StrictMode'] = $request->strictMode;
        }

        if (null !== $request->supportOperateCodeList) {
            @$query['SupportOperateCodeList'] = $request->supportOperateCodeList;
        }

        if (null !== $request->targetType) {
            @$query['TargetType'] = $request->targetType;
        }

        if (null !== $request->timeEnd) {
            @$query['TimeEnd'] = $request->timeEnd;
        }

        if (null !== $request->timeStart) {
            @$query['TimeStart'] = $request->timeStart;
        }

        if (null !== $request->uniqueInfo) {
            @$query['UniqueInfo'] = $request->uniqueInfo;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        $body = [];
        if (null !== $request->tacticId) {
            @$body['TacticId'] = $request->tacticId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'DescribeSuspEvents',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSuspEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of alert events that are generated without aggregation.
     *
     * @param request - DescribeSuspEventsRequest
     *
     * @returns DescribeSuspEventsResponse
     *
     * @param DescribeSuspEventsRequest $request
     *
     * @return DescribeSuspEventsResponse
     */
    public function describeSuspEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSuspEventsWithOptions($request, $runtime);
    }

    /**
     * Queries the configuration of a specified feature.
     *
     * @param request - DescribeSuspiciousOverallConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSuspiciousOverallConfigResponse
     *
     * @param DescribeSuspiciousOverallConfigRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return DescribeSuspiciousOverallConfigResponse
     */
    public function describeSuspiciousOverallConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSuspiciousOverallConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSuspiciousOverallConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configuration of a specified feature.
     *
     * @param request - DescribeSuspiciousOverallConfigRequest
     *
     * @returns DescribeSuspiciousOverallConfigResponse
     *
     * @param DescribeSuspiciousOverallConfigRequest $request
     *
     * @return DescribeSuspiciousOverallConfigResponse
     */
    public function describeSuspiciousOverallConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSuspiciousOverallConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the UUIDs of servers on which proactive defense of a specified type takes effect.
     *
     * @param request - DescribeSuspiciousUUIDConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSuspiciousUUIDConfigResponse
     *
     * @param DescribeSuspiciousUUIDConfigRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribeSuspiciousUUIDConfigResponse
     */
    public function describeSuspiciousUUIDConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSuspiciousUUIDConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSuspiciousUUIDConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the UUIDs of servers on which proactive defense of a specified type takes effect.
     *
     * @param request - DescribeSuspiciousUUIDConfigRequest
     *
     * @returns DescribeSuspiciousUUIDConfigResponse
     *
     * @param DescribeSuspiciousUUIDConfigRequest $request
     *
     * @return DescribeSuspiciousUUIDConfigResponse
     */
    public function describeSuspiciousUUIDConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSuspiciousUUIDConfigWithOptions($request, $runtime);
    }

    /**
     * Queries a list of IDC scan tasks.
     *
     * @param request - DescribeSyncAssetTaskListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSyncAssetTaskListResponse
     *
     * @param DescribeSyncAssetTaskListRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeSyncAssetTaskListResponse
     */
    public function describeSyncAssetTaskListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->taskName) {
            @$query['TaskName'] = $request->taskName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSyncAssetTaskList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSyncAssetTaskListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of IDC scan tasks.
     *
     * @param request - DescribeSyncAssetTaskListRequest
     *
     * @returns DescribeSyncAssetTaskListResponse
     *
     * @param DescribeSyncAssetTaskListRequest $request
     *
     * @return DescribeSyncAssetTaskListResponse
     */
    public function describeSyncAssetTaskList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSyncAssetTaskListWithOptions($request, $runtime);
    }

    /**
     * Queries the details of an IDC scan task.
     *
     * @param request - DescribeSyncAssetTaskLogDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSyncAssetTaskLogDetailResponse
     *
     * @param DescribeSyncAssetTaskLogDetailRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DescribeSyncAssetTaskLogDetailResponse
     */
    public function describeSyncAssetTaskLogDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->rootTaskId) {
            @$query['RootTaskId'] = $request->rootTaskId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->taskName) {
            @$query['TaskName'] = $request->taskName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSyncAssetTaskLogDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSyncAssetTaskLogDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of an IDC scan task.
     *
     * @param request - DescribeSyncAssetTaskLogDetailRequest
     *
     * @returns DescribeSyncAssetTaskLogDetailResponse
     *
     * @param DescribeSyncAssetTaskLogDetailRequest $request
     *
     * @return DescribeSyncAssetTaskLogDetailResponse
     */
    public function describeSyncAssetTaskLogDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSyncAssetTaskLogDetailWithOptions($request, $runtime);
    }

    /**
     * Queries the servers on which vulnerability scan is enabled.
     *
     * @param request - DescribeTargetRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeTargetResponse
     *
     * @param DescribeTargetRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return DescribeTargetResponse
     */
    public function describeTargetWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->config) {
            @$query['Config'] = $request->config;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeTarget',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeTargetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the servers on which vulnerability scan is enabled.
     *
     * @param request - DescribeTargetRequest
     *
     * @returns DescribeTargetResponse
     *
     * @param DescribeTargetRequest $request
     *
     * @return DescribeTargetResponse
     */
    public function describeTarget($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeTargetWithOptions($request, $runtime);
    }

    /**
     * Queries the error logs on a task that failed to fix image vulnerabilities.
     *
     * @param request - DescribeTaskErrorLogRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeTaskErrorLogResponse
     *
     * @param DescribeTaskErrorLogRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DescribeTaskErrorLogResponse
     */
    public function describeTaskErrorLogWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->buildTaskId) {
            @$query['BuildTaskId'] = $request->buildTaskId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeTaskErrorLog',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeTaskErrorLogResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the error logs on a task that failed to fix image vulnerabilities.
     *
     * @param request - DescribeTaskErrorLogRequest
     *
     * @returns DescribeTaskErrorLogResponse
     *
     * @param DescribeTaskErrorLogRequest $request
     *
     * @return DescribeTaskErrorLogResponse
     */
    public function describeTaskErrorLog($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeTaskErrorLogWithOptions($request, $runtime);
    }

    /**
     * Queries event statistics.
     *
     * @param request - DescribeTotalStatisticsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeTotalStatisticsResponse
     *
     * @param DescribeTotalStatisticsRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeTotalStatisticsResponse
     */
    public function describeTotalStatisticsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeTotalStatistics',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeTotalStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries event statistics.
     *
     * @param request - DescribeTotalStatisticsRequest
     *
     * @returns DescribeTotalStatisticsResponse
     *
     * @param DescribeTotalStatisticsRequest $request
     *
     * @return DescribeTotalStatisticsResponse
     */
    public function describeTotalStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeTotalStatisticsWithOptions($request, $runtime);
    }

    /**
     * Queries the trace information about alerts.
     *
     * @param request - DescribeTraceInfoDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeTraceInfoDetailResponse
     *
     * @param DescribeTraceInfoDetailRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeTraceInfoDetailResponse
     */
    public function describeTraceInfoDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        if (null !== $request->incidentTime) {
            @$query['IncidentTime'] = $request->incidentTime;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        if (null !== $request->vertexId) {
            @$query['VertexId'] = $request->vertexId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeTraceInfoDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeTraceInfoDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the trace information about alerts.
     *
     * @param request - DescribeTraceInfoDetailRequest
     *
     * @returns DescribeTraceInfoDetailResponse
     *
     * @param DescribeTraceInfoDetailRequest $request
     *
     * @return DescribeTraceInfoDetailResponse
     */
    public function describeTraceInfoDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeTraceInfoDetailWithOptions($request, $runtime);
    }

    /**
     * Queries the details about a trace node.
     *
     * @param request - DescribeTraceInfoNodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeTraceInfoNodeResponse
     *
     * @param DescribeTraceInfoNodeRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DescribeTraceInfoNodeResponse
     */
    public function describeTraceInfoNodeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->eventName) {
            @$query['EventName'] = $request->eventName;
        }

        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        if (null !== $request->incidentTime) {
            @$query['IncidentTime'] = $request->incidentTime;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        if (null !== $request->vertexId) {
            @$query['VertexId'] = $request->vertexId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeTraceInfoNode',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeTraceInfoNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details about a trace node.
     *
     * @param request - DescribeTraceInfoNodeRequest
     *
     * @returns DescribeTraceInfoNodeResponse
     *
     * @param DescribeTraceInfoNodeRequest $request
     *
     * @return DescribeTraceInfoNodeResponse
     */
    public function describeTraceInfoNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeTraceInfoNodeWithOptions($request, $runtime);
    }

    /**
     * Queries the information about databases for which anti-ransomware policies are created.
     *
     * @param request - DescribeUniBackupDatabaseRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeUniBackupDatabaseResponse
     *
     * @param DescribeUniBackupDatabaseRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeUniBackupDatabaseResponse
     */
    public function describeUniBackupDatabaseWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->databaseType) {
            @$query['DatabaseType'] = $request->databaseType;
        }

        if (null !== $request->instanceName) {
            @$query['InstanceName'] = $request->instanceName;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->queryType) {
            @$query['QueryType'] = $request->queryType;
        }

        if (null !== $request->uniRegionId) {
            @$query['UniRegionId'] = $request->uniRegionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeUniBackupDatabase',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeUniBackupDatabaseResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about databases for which anti-ransomware policies are created.
     *
     * @param request - DescribeUniBackupDatabaseRequest
     *
     * @returns DescribeUniBackupDatabaseResponse
     *
     * @param DescribeUniBackupDatabaseRequest $request
     *
     * @return DescribeUniBackupDatabaseResponse
     */
    public function describeUniBackupDatabase($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUniBackupDatabaseWithOptions($request, $runtime);
    }

    /**
     * Queries the anti-ransomware policies that are created for databases.
     *
     * @param request - DescribeUniBackupPoliciesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeUniBackupPoliciesResponse
     *
     * @param DescribeUniBackupPoliciesRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeUniBackupPoliciesResponse
     */
    public function describeUniBackupPoliciesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->policyName) {
            @$query['PolicyName'] = $request->policyName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeUniBackupPolicies',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeUniBackupPoliciesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the anti-ransomware policies that are created for databases.
     *
     * @param request - DescribeUniBackupPoliciesRequest
     *
     * @returns DescribeUniBackupPoliciesResponse
     *
     * @param DescribeUniBackupPoliciesRequest $request
     *
     * @return DescribeUniBackupPoliciesResponse
     */
    public function describeUniBackupPolicies($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUniBackupPoliciesWithOptions($request, $runtime);
    }

    /**
     * Queries the details of an anti-ransomware policy for databases.
     *
     * @param request - DescribeUniBackupPolicyDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeUniBackupPolicyDetailResponse
     *
     * @param DescribeUniBackupPolicyDetailRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DescribeUniBackupPolicyDetailResponse
     */
    public function describeUniBackupPolicyDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->policyId) {
            @$query['PolicyId'] = $request->policyId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeUniBackupPolicyDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeUniBackupPolicyDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of an anti-ransomware policy for databases.
     *
     * @param request - DescribeUniBackupPolicyDetailRequest
     *
     * @returns DescribeUniBackupPolicyDetailResponse
     *
     * @param DescribeUniBackupPolicyDetailRequest $request
     *
     * @return DescribeUniBackupPolicyDetailResponse
     */
    public function describeUniBackupPolicyDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUniBackupPolicyDetailWithOptions($request, $runtime);
    }

    /**
     * Queries the statistics on backups based on anti-ransomware policies.
     *
     * @param request - DescribeUniBackupStatisticsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeUniBackupStatisticsResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeUniBackupStatisticsResponse
     */
    public function describeUniBackupStatisticsWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeUniBackupStatistics',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeUniBackupStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics on backups based on anti-ransomware policies.
     *
     * @returns DescribeUniBackupStatisticsResponse
     *
     * @return DescribeUniBackupStatisticsResponse
     */
    public function describeUniBackupStatistics()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUniBackupStatisticsWithOptions($runtime);
    }

    /**
     * Queries the backup snapshots from which the data of a database can be restored.
     *
     * @param request - DescribeUniRecoverableListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeUniRecoverableListResponse
     *
     * @param DescribeUniRecoverableListRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeUniRecoverableListResponse
     */
    public function describeUniRecoverableListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->database) {
            @$query['Database'] = $request->database;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->policyId) {
            @$query['PolicyId'] = $request->policyId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeUniRecoverableList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeUniRecoverableListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the backup snapshots from which the data of a database can be restored.
     *
     * @param request - DescribeUniRecoverableListRequest
     *
     * @returns DescribeUniRecoverableListResponse
     *
     * @param DescribeUniRecoverableListRequest $request
     *
     * @return DescribeUniRecoverableListResponse
     */
    public function describeUniRecoverableList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUniRecoverableListWithOptions($request, $runtime);
    }

    /**
     * Queries the region that is supported by anti-ransomware for databases.
     *
     * @param request - DescribeUniSupportRegionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeUniSupportRegionResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeUniSupportRegionResponse
     */
    public function describeUniSupportRegionWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeUniSupportRegion',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeUniSupportRegionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the region that is supported by anti-ransomware for databases.
     *
     * @returns DescribeUniSupportRegionResponse
     *
     * @return DescribeUniSupportRegionResponse
     */
    public function describeUniSupportRegion()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUniSupportRegionWithOptions($runtime);
    }

    /**
     * Queries the information about the servers to which an anti-ransomware policy is applied.
     *
     * @param request - DescribeUserBackupMachinesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeUserBackupMachinesResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeUserBackupMachinesResponse
     */
    public function describeUserBackupMachinesWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeUserBackupMachines',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeUserBackupMachinesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about the servers to which an anti-ransomware policy is applied.
     *
     * @returns DescribeUserBackupMachinesResponse
     *
     * @return DescribeUserBackupMachinesResponse
     */
    public function describeUserBackupMachines()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUserBackupMachinesWithOptions($runtime);
    }

    /**
     * The source IP address of the request.
     *
     * @param request - DescribeUserBaselineAuthorizationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeUserBaselineAuthorizationResponse
     *
     * @param DescribeUserBaselineAuthorizationRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return DescribeUserBaselineAuthorizationResponse
     */
    public function describeUserBaselineAuthorizationWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeUserBaselineAuthorization',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeUserBaselineAuthorizationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * The source IP address of the request.
     *
     * @param request - DescribeUserBaselineAuthorizationRequest
     *
     * @returns DescribeUserBaselineAuthorizationResponse
     *
     * @param DescribeUserBaselineAuthorizationRequest $request
     *
     * @return DescribeUserBaselineAuthorizationResponse
     */
    public function describeUserBaselineAuthorization($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUserBaselineAuthorizationWithOptions($request, $runtime);
    }

    /**
     * Queries the settings of a custom baseline check policy.
     *
     * @param request - DescribeUserSettingRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeUserSettingResponse
     *
     * @param DescribeUserSettingRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DescribeUserSettingResponse
     */
    public function describeUserSettingWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeUserSetting',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeUserSettingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the settings of a custom baseline check policy.
     *
     * @param request - DescribeUserSettingRequest
     *
     * @returns DescribeUserSettingResponse
     *
     * @param DescribeUserSettingRequest $request
     *
     * @return DescribeUserSettingResponse
     */
    public function describeUserSetting($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUserSettingWithOptions($request, $runtime);
    }

    /**
     * Queries a list of assets that support fixing based on vulnerability names.
     *
     * @param request - DescribeUuidsByVulNamesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeUuidsByVulNamesResponse
     *
     * @param DescribeUuidsByVulNamesRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeUuidsByVulNamesResponse
     */
    public function describeUuidsByVulNamesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dealed) {
            @$query['Dealed'] = $request->dealed;
        }

        if (null !== $request->fieldName) {
            @$query['FieldName'] = $request->fieldName;
        }

        if (null !== $request->fieldValue) {
            @$query['FieldValue'] = $request->fieldValue;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->level) {
            @$query['Level'] = $request->level;
        }

        if (null !== $request->necessity) {
            @$query['Necessity'] = $request->necessity;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->searchTags) {
            @$query['SearchTags'] = $request->searchTags;
        }

        if (null !== $request->statusList) {
            @$query['StatusList'] = $request->statusList;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->targetType) {
            @$query['TargetType'] = $request->targetType;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        if (null !== $request->vpcInstanceIds) {
            @$query['VpcInstanceIds'] = $request->vpcInstanceIds;
        }

        if (null !== $request->vulNames) {
            @$query['VulNames'] = $request->vulNames;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeUuidsByVulNames',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeUuidsByVulNamesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of assets that support fixing based on vulnerability names.
     *
     * @param request - DescribeUuidsByVulNamesRequest
     *
     * @returns DescribeUuidsByVulNamesResponse
     *
     * @param DescribeUuidsByVulNamesRequest $request
     *
     * @return DescribeUuidsByVulNamesResponse
     */
    public function describeUuidsByVulNames($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUuidsByVulNamesWithOptions($request, $runtime);
    }

    /**
     * Queries the service providers whose assets can be added to Security Center.
     *
     * @param request - DescribeVendorListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVendorListResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeVendorListResponse
     */
    public function describeVendorListWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeVendorList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVendorListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the service providers whose assets can be added to Security Center.
     *
     * @returns DescribeVendorListResponse
     *
     * @return DescribeVendorListResponse
     */
    public function describeVendorList()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVendorListWithOptions($runtime);
    }

    /**
     * Queries the details about the edition of purchased Security Center.
     *
     * @param request - DescribeVersionConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVersionConfigResponse
     *
     * @param DescribeVersionConfigRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DescribeVersionConfigResponse
     */
    public function describeVersionConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVersionConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVersionConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details about the edition of purchased Security Center.
     *
     * @param request - DescribeVersionConfigRequest
     *
     * @returns DescribeVersionConfigResponse
     *
     * @param DescribeVersionConfigRequest $request
     *
     * @return DescribeVersionConfigResponse
     */
    public function describeVersionConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVersionConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the QR code address of a DingTalk group.
     *
     * @param request - DescribeVolDingdingMessageRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVolDingdingMessageResponse
     *
     * @param DescribeVolDingdingMessageRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeVolDingdingMessageResponse
     */
    public function describeVolDingdingMessageWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVolDingdingMessage',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVolDingdingMessageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the QR code address of a DingTalk group.
     *
     * @param request - DescribeVolDingdingMessageRequest
     *
     * @returns DescribeVolDingdingMessageResponse
     *
     * @param DescribeVolDingdingMessageRequest $request
     *
     * @return DescribeVolDingdingMessageResponse
     */
    public function describeVolDingdingMessage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVolDingdingMessageWithOptions($request, $runtime);
    }

    /**
     * Queries the search conditions that can be used to query honeypots.
     *
     * @param request - DescribeVpcHoneyPotCriteriaRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVpcHoneyPotCriteriaResponse
     *
     * @param DescribeVpcHoneyPotCriteriaRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeVpcHoneyPotCriteriaResponse
     */
    public function describeVpcHoneyPotCriteriaWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVpcHoneyPotCriteria',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVpcHoneyPotCriteriaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the search conditions that can be used to query honeypots.
     *
     * @param request - DescribeVpcHoneyPotCriteriaRequest
     *
     * @returns DescribeVpcHoneyPotCriteriaResponse
     *
     * @param DescribeVpcHoneyPotCriteriaRequest $request
     *
     * @return DescribeVpcHoneyPotCriteriaResponse
     */
    public function describeVpcHoneyPotCriteria($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpcHoneyPotCriteriaWithOptions($request, $runtime);
    }

    /**
     * Queries virtual private clouds (VPCs) on which honeypots are deployed.
     *
     * @remarks
     * If you specify only the Action request parameter in your request, Security Center returns the list of all VPCs regardless of whether a honeypot is deployed on a VPC.
     *
     * @param request - DescribeVpcHoneyPotListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVpcHoneyPotListResponse
     *
     * @param DescribeVpcHoneyPotListRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeVpcHoneyPotListResponse
     */
    public function describeVpcHoneyPotListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->honeyPotExistence) {
            @$query['HoneyPotExistence'] = $request->honeyPotExistence;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        if (null !== $request->vpcName) {
            @$query['VpcName'] = $request->vpcName;
        }

        if (null !== $request->vpcRegionId) {
            @$query['VpcRegionId'] = $request->vpcRegionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVpcHoneyPotList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVpcHoneyPotListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries virtual private clouds (VPCs) on which honeypots are deployed.
     *
     * @remarks
     * If you specify only the Action request parameter in your request, Security Center returns the list of all VPCs regardless of whether a honeypot is deployed on a VPC.
     *
     * @param request - DescribeVpcHoneyPotListRequest
     *
     * @returns DescribeVpcHoneyPotListResponse
     *
     * @param DescribeVpcHoneyPotListRequest $request
     *
     * @return DescribeVpcHoneyPotListResponse
     */
    public function describeVpcHoneyPotList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpcHoneyPotListWithOptions($request, $runtime);
    }

    /**
     * Queries the information about virtual private clouds (VPCs).
     *
     * @param request - DescribeVpcListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVpcListResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeVpcListResponse
     */
    public function describeVpcListWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeVpcList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVpcListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about virtual private clouds (VPCs).
     *
     * @returns DescribeVpcListResponse
     *
     * @return DescribeVpcListResponse
     */
    public function describeVpcList()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpcListWithOptions($runtime);
    }

    /**
     * Queries the status information about vulnerability scan tasks on a server.
     *
     * @param request - DescribeVulCheckTaskStatusDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVulCheckTaskStatusDetailResponse
     *
     * @param DescribeVulCheckTaskStatusDetailRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return DescribeVulCheckTaskStatusDetailResponse
     */
    public function describeVulCheckTaskStatusDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->taskIds) {
            @$query['TaskIds'] = $request->taskIds;
        }

        if (null !== $request->types) {
            @$query['Types'] = $request->types;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVulCheckTaskStatusDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVulCheckTaskStatusDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the status information about vulnerability scan tasks on a server.
     *
     * @param request - DescribeVulCheckTaskStatusDetailRequest
     *
     * @returns DescribeVulCheckTaskStatusDetailResponse
     *
     * @param DescribeVulCheckTaskStatusDetailRequest $request
     *
     * @return DescribeVulCheckTaskStatusDetailResponse
     */
    public function describeVulCheckTaskStatusDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulCheckTaskStatusDetailWithOptions($request, $runtime);
    }

    /**
     * Queries the configurations of vulnerability management.
     *
     * @param request - DescribeVulConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVulConfigResponse
     *
     * @param DescribeVulConfigRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return DescribeVulConfigResponse
     */
    public function describeVulConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVulConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVulConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configurations of vulnerability management.
     *
     * @param request - DescribeVulConfigRequest
     *
     * @returns DescribeVulConfigResponse
     *
     * @param DescribeVulConfigRequest $request
     *
     * @return DescribeVulConfigResponse
     */
    public function describeVulConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the vulnerability defense statistics in Security Center.
     *
     * @param request - DescribeVulDefendCountStatisticsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVulDefendCountStatisticsResponse
     *
     * @param DescribeVulDefendCountStatisticsRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return DescribeVulDefendCountStatisticsResponse
     */
    public function describeVulDefendCountStatisticsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->vulType) {
            @$query['VulType'] = $request->vulType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVulDefendCountStatistics',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVulDefendCountStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the vulnerability defense statistics in Security Center.
     *
     * @param request - DescribeVulDefendCountStatisticsRequest
     *
     * @returns DescribeVulDefendCountStatisticsResponse
     *
     * @param DescribeVulDefendCountStatisticsRequest $request
     *
     * @return DescribeVulDefendCountStatisticsResponse
     */
    public function describeVulDefendCountStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulDefendCountStatisticsWithOptions($request, $runtime);
    }

    /**
     * Queries the details about a vulnerability.
     *
     * @param request - DescribeVulDetailsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVulDetailsResponse
     *
     * @param DescribeVulDetailsRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return DescribeVulDetailsResponse
     */
    public function describeVulDetailsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aliasName) {
            @$query['AliasName'] = $request->aliasName;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVulDetails',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVulDetailsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details about a vulnerability.
     *
     * @param request - DescribeVulDetailsRequest
     *
     * @returns DescribeVulDetailsResponse
     *
     * @param DescribeVulDetailsRequest $request
     *
     * @return DescribeVulDetailsResponse
     */
    public function describeVulDetails($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulDetailsWithOptions($request, $runtime);
    }

    /**
     * Queries the progress of a task that exports vulnerabilities.
     *
     * @remarks
     * If the value of ExportStatus is success, the URL at which you can download the exported Excel file is returned.
     *
     * @param request - DescribeVulExportInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVulExportInfoResponse
     *
     * @param DescribeVulExportInfoRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DescribeVulExportInfoResponse
     */
    public function describeVulExportInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->exportId) {
            @$query['ExportId'] = $request->exportId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVulExportInfo',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVulExportInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the progress of a task that exports vulnerabilities.
     *
     * @remarks
     * If the value of ExportStatus is success, the URL at which you can download the exported Excel file is returned.
     *
     * @param request - DescribeVulExportInfoRequest
     *
     * @returns DescribeVulExportInfoResponse
     *
     * @param DescribeVulExportInfoRequest $request
     *
     * @return DescribeVulExportInfoResponse
     */
    public function describeVulExportInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulExportInfoWithOptions($request, $runtime);
    }

    /**
     * Queries the statistics of vulnerability fixes.
     *
     * @param request - DescribeVulFixStatisticsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVulFixStatisticsResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeVulFixStatisticsResponse
     */
    public function describeVulFixStatisticsWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeVulFixStatistics',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVulFixStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics of vulnerability fixes.
     *
     * @returns DescribeVulFixStatisticsResponse
     *
     * @return DescribeVulFixStatisticsResponse
     */
    public function describeVulFixStatistics()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulFixStatisticsWithOptions($runtime);
    }

    /**
     * Queries vulnerabilities by type.
     *
     * @param request - DescribeVulListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVulListResponse
     *
     * @param DescribeVulListRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return DescribeVulListResponse
     */
    public function describeVulListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aliasName) {
            @$query['AliasName'] = $request->aliasName;
        }

        if (null !== $request->attachTypes) {
            @$query['AttachTypes'] = $request->attachTypes;
        }

        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->dealed) {
            @$query['Dealed'] = $request->dealed;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        if (null !== $request->ids) {
            @$query['Ids'] = $request->ids;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->necessity) {
            @$query['Necessity'] = $request->necessity;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->raspDefend) {
            @$query['RaspDefend'] = $request->raspDefend;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        if (null !== $request->statusList) {
            @$query['StatusList'] = $request->statusList;
        }

        if (null !== $request->targetType) {
            @$query['TargetType'] = $request->targetType;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        if (null !== $request->useNextToken) {
            @$query['UseNextToken'] = $request->useNextToken;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        if (null !== $request->vpcInstanceIds) {
            @$query['VpcInstanceIds'] = $request->vpcInstanceIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVulList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVulListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries vulnerabilities by type.
     *
     * @param request - DescribeVulListRequest
     *
     * @returns DescribeVulListResponse
     *
     * @param DescribeVulListRequest $request
     *
     * @return DescribeVulListResponse
     */
    public function describeVulList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulListWithOptions($request, $runtime);
    }

    /**
     * Queries the vulnerabilities that can be detected.
     *
     * @param request - DescribeVulListPageRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVulListPageResponse
     *
     * @param DescribeVulListPageRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DescribeVulListPageResponse
     */
    public function describeVulListPageWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->cveId) {
            @$query['CveId'] = $request->cveId;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->raspDefend) {
            @$query['RaspDefend'] = $request->raspDefend;
        }

        if (null !== $request->vulNameLike) {
            @$query['VulNameLike'] = $request->vulNameLike;
        }

        if (null !== $request->vulType) {
            @$query['VulType'] = $request->vulType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVulListPage',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVulListPageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the vulnerabilities that can be detected.
     *
     * @param request - DescribeVulListPageRequest
     *
     * @returns DescribeVulListPageResponse
     *
     * @param DescribeVulListPageRequest $request
     *
     * @return DescribeVulListPageResponse
     */
    public function describeVulListPage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulListPageWithOptions($request, $runtime);
    }

    /**
     * Queries the statistics of vulnerabilities in Security Center.
     *
     * @param request - DescribeVulMetaCountStatisticsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVulMetaCountStatisticsResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeVulMetaCountStatisticsResponse
     */
    public function describeVulMetaCountStatisticsWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeVulMetaCountStatistics',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVulMetaCountStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics of vulnerabilities in Security Center.
     *
     * @returns DescribeVulMetaCountStatisticsResponse
     *
     * @return DescribeVulMetaCountStatisticsResponse
     */
    public function describeVulMetaCountStatistics()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulMetaCountStatisticsWithOptions($runtime);
    }

    /**
     * Queries the statistics of vulnerabilities.
     *
     * @param request - DescribeVulNumStatisticsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVulNumStatisticsResponse
     *
     * @param DescribeVulNumStatisticsRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeVulNumStatisticsResponse
     */
    public function describeVulNumStatisticsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVulNumStatistics',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVulNumStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics of vulnerabilities.
     *
     * @param request - DescribeVulNumStatisticsRequest
     *
     * @returns DescribeVulNumStatisticsResponse
     *
     * @param DescribeVulNumStatisticsRequest $request
     *
     * @return DescribeVulNumStatisticsResponse
     */
    public function describeVulNumStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulNumStatisticsWithOptions($request, $runtime);
    }

    /**
     * Queries the configurations of the vulnerability scan feature for a server.
     *
     * @param request - DescribeVulTargetConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVulTargetConfigResponse
     *
     * @param DescribeVulTargetConfigRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeVulTargetConfigResponse
     */
    public function describeVulTargetConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVulTargetConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVulTargetConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configurations of the vulnerability scan feature for a server.
     *
     * @param request - DescribeVulTargetConfigRequest
     *
     * @returns DescribeVulTargetConfigResponse
     *
     * @param DescribeVulTargetConfigRequest $request
     *
     * @return DescribeVulTargetConfigResponse
     */
    public function describeVulTargetConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulTargetConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the configurations of the vulnerability scan feature.
     *
     * @param request - DescribeVulTargetStatisticsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVulTargetStatisticsResponse
     *
     * @param DescribeVulTargetStatisticsRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeVulTargetStatisticsResponse
     */
    public function describeVulTargetStatisticsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVulTargetStatistics',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVulTargetStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configurations of the vulnerability scan feature.
     *
     * @param request - DescribeVulTargetStatisticsRequest
     *
     * @returns DescribeVulTargetStatisticsResponse
     *
     * @param DescribeVulTargetStatisticsRequest $request
     *
     * @return DescribeVulTargetStatisticsResponse
     */
    public function describeVulTargetStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulTargetStatisticsWithOptions($request, $runtime);
    }

    /**
     * Queries the whitelist of vulnerabilities by page.
     *
     * @param request - DescribeVulWhitelistRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVulWhitelistResponse
     *
     * @param DescribeVulWhitelistRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DescribeVulWhitelistResponse
     */
    public function describeVulWhitelistWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVulWhitelist',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVulWhitelistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the whitelist of vulnerabilities by page.
     *
     * @param request - DescribeVulWhitelistRequest
     *
     * @returns DescribeVulWhitelistResponse
     *
     * @param DescribeVulWhitelistRequest $request
     *
     * @return DescribeVulWhitelistResponse
     */
    public function describeVulWhitelist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulWhitelistWithOptions($request, $runtime);
    }

    /**
     * Queries the progress of a export task for a baseline check result.
     *
     * @param request - DescribeWarningExportInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeWarningExportInfoResponse
     *
     * @param DescribeWarningExportInfoRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeWarningExportInfoResponse
     */
    public function describeWarningExportInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->exportId) {
            @$query['ExportId'] = $request->exportId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeWarningExportInfo',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeWarningExportInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the progress of a export task for a baseline check result.
     *
     * @param request - DescribeWarningExportInfoRequest
     *
     * @returns DescribeWarningExportInfoResponse
     *
     * @param DescribeWarningExportInfoRequest $request
     *
     * @return DescribeWarningExportInfoResponse
     */
    public function describeWarningExportInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWarningExportInfoWithOptions($request, $runtime);
    }

    /**
     * Queries information about servers on which a baseline check is performed. The information includes the IDs of the servers, the statistics of a risk item, and the status of the risk item.
     *
     * @param request - DescribeWarningMachinesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeWarningMachinesResponse
     *
     * @param DescribeWarningMachinesRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeWarningMachinesResponse
     */
    public function describeWarningMachinesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->containerFieldName) {
            @$query['ContainerFieldName'] = $request->containerFieldName;
        }

        if (null !== $request->containerFieldValue) {
            @$query['ContainerFieldValue'] = $request->containerFieldValue;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        if (null !== $request->haveRisk) {
            @$query['HaveRisk'] = $request->haveRisk;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->machineName) {
            @$query['MachineName'] = $request->machineName;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->riskId) {
            @$query['RiskId'] = $request->riskId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->strategyId) {
            @$query['StrategyId'] = $request->strategyId;
        }

        if (null !== $request->targetType) {
            @$query['TargetType'] = $request->targetType;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeWarningMachines',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeWarningMachinesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries information about servers on which a baseline check is performed. The information includes the IDs of the servers, the statistics of a risk item, and the status of the risk item.
     *
     * @param request - DescribeWarningMachinesRequest
     *
     * @returns DescribeWarningMachinesResponse
     *
     * @param DescribeWarningMachinesRequest $request
     *
     * @return DescribeWarningMachinesResponse
     */
    public function describeWarningMachines($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWarningMachinesWithOptions($request, $runtime);
    }

    /**
     * Queries the information about the servers that have web tamper proofing enabled.
     *
     * @param request - DescribeWebLockBindListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeWebLockBindListResponse
     *
     * @param DescribeWebLockBindListRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeWebLockBindListResponse
     */
    public function describeWebLockBindListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeWebLockBindList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeWebLockBindListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about the servers that have web tamper proofing enabled.
     *
     * @param request - DescribeWebLockBindListRequest
     *
     * @returns DescribeWebLockBindListResponse
     *
     * @param DescribeWebLockBindListRequest $request
     *
     * @return DescribeWebLockBindListResponse
     */
    public function describeWebLockBindList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebLockBindListWithOptions($request, $runtime);
    }

    /**
     * Queries the configurations of web tamper proofing for a specified server.
     *
     * @param request - DescribeWebLockConfigListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeWebLockConfigListResponse
     *
     * @param DescribeWebLockConfigListRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeWebLockConfigListResponse
     */
    public function describeWebLockConfigListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeWebLockConfigList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeWebLockConfigListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configurations of web tamper proofing for a specified server.
     *
     * @param request - DescribeWebLockConfigListRequest
     *
     * @returns DescribeWebLockConfigListResponse
     *
     * @param DescribeWebLockConfigListRequest $request
     *
     * @return DescribeWebLockConfigListResponse
     */
    public function describeWebLockConfigList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebLockConfigListWithOptions($request, $runtime);
    }

    /**
     * Queries the types of files that are excluded from web tamper proofing.
     *
     * @param request - DescribeWebLockExclusiveFileTypeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeWebLockExclusiveFileTypeResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeWebLockExclusiveFileTypeResponse
     */
    public function describeWebLockExclusiveFileTypeWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeWebLockExclusiveFileType',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeWebLockExclusiveFileTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the types of files that are excluded from web tamper proofing.
     *
     * @returns DescribeWebLockExclusiveFileTypeResponse
     *
     * @return DescribeWebLockExclusiveFileTypeResponse
     */
    public function describeWebLockExclusiveFileType()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebLockExclusiveFileTypeWithOptions($runtime);
    }

    /**
     * Queries the statistics on changes to the files that are protected by web tamper proofing.
     *
     * @param request - DescribeWebLockFileChangeStatisticsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeWebLockFileChangeStatisticsResponse
     *
     * @param DescribeWebLockFileChangeStatisticsRequest $request
     * @param RuntimeOptions                             $runtime
     *
     * @return DescribeWebLockFileChangeStatisticsResponse
     */
    public function describeWebLockFileChangeStatisticsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeWebLockFileChangeStatistics',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeWebLockFileChangeStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics on changes to the files that are protected by web tamper proofing.
     *
     * @param request - DescribeWebLockFileChangeStatisticsRequest
     *
     * @returns DescribeWebLockFileChangeStatisticsResponse
     *
     * @param DescribeWebLockFileChangeStatisticsRequest $request
     *
     * @return DescribeWebLockFileChangeStatisticsResponse
     */
    public function describeWebLockFileChangeStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebLockFileChangeStatisticsWithOptions($request, $runtime);
    }

    /**
     * Queries events on web tamper proofing.
     *
     * @param request - DescribeWebLockFileEventsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeWebLockFileEventsResponse
     *
     * @param DescribeWebLockFileEventsRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeWebLockFileEventsResponse
     */
    public function describeWebLockFileEventsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->dealed) {
            @$query['Dealed'] = $request->dealed;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->processName) {
            @$query['ProcessName'] = $request->processName;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->tsBegin) {
            @$query['TsBegin'] = $request->tsBegin;
        }

        if (null !== $request->tsEnd) {
            @$query['TsEnd'] = $request->tsEnd;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeWebLockFileEvents',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeWebLockFileEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries events on web tamper proofing.
     *
     * @param request - DescribeWebLockFileEventsRequest
     *
     * @returns DescribeWebLockFileEventsResponse
     *
     * @param DescribeWebLockFileEventsRequest $request
     *
     * @return DescribeWebLockFileEventsResponse
     */
    public function describeWebLockFileEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebLockFileEventsWithOptions($request, $runtime);
    }

    /**
     * The number of attempts.
     *
     * @param request - DescribeWebLockFileTypeSummaryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeWebLockFileTypeSummaryResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeWebLockFileTypeSummaryResponse
     */
    public function describeWebLockFileTypeSummaryWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeWebLockFileTypeSummary',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeWebLockFileTypeSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * The number of attempts.
     *
     * @returns DescribeWebLockFileTypeSummaryResponse
     *
     * @return DescribeWebLockFileTypeSummaryResponse
     */
    public function describeWebLockFileTypeSummary()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebLockFileTypeSummaryWithOptions($runtime);
    }

    /**
     * Queries the types of files that can be protected by web tamper proofing.
     *
     * @param request - DescribeWebLockInclusiveFileTypeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeWebLockInclusiveFileTypeResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeWebLockInclusiveFileTypeResponse
     */
    public function describeWebLockInclusiveFileTypeWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeWebLockInclusiveFileType',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeWebLockInclusiveFileTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the types of files that can be protected by web tamper proofing.
     *
     * @returns DescribeWebLockInclusiveFileTypeResponse
     *
     * @return DescribeWebLockInclusiveFileTypeResponse
     */
    public function describeWebLockInclusiveFileType()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebLockInclusiveFileTypeWithOptions($runtime);
    }

    /**
     * Queries the statistics on processes for web tamper proofing.
     *
     * @param request - DescribeWebLockProcessBlockStatisticsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeWebLockProcessBlockStatisticsResponse
     *
     * @param DescribeWebLockProcessBlockStatisticsRequest $request
     * @param RuntimeOptions                               $runtime
     *
     * @return DescribeWebLockProcessBlockStatisticsResponse
     */
    public function describeWebLockProcessBlockStatisticsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeWebLockProcessBlockStatistics',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeWebLockProcessBlockStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics on processes for web tamper proofing.
     *
     * @param request - DescribeWebLockProcessBlockStatisticsRequest
     *
     * @returns DescribeWebLockProcessBlockStatisticsResponse
     *
     * @param DescribeWebLockProcessBlockStatisticsRequest $request
     *
     * @return DescribeWebLockProcessBlockStatisticsResponse
     */
    public function describeWebLockProcessBlockStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebLockProcessBlockStatisticsWithOptions($request, $runtime);
    }

    /**
     * Queries the processes for web tamper proofing.
     *
     * @param request - DescribeWebLockProcessListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeWebLockProcessListResponse
     *
     * @param DescribeWebLockProcessListRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeWebLockProcessListResponse
     */
    public function describeWebLockProcessListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->processName) {
            @$query['ProcessName'] = $request->processName;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeWebLockProcessList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeWebLockProcessListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the processes for web tamper proofing.
     *
     * @param request - DescribeWebLockProcessListRequest
     *
     * @returns DescribeWebLockProcessListResponse
     *
     * @param DescribeWebLockProcessListRequest $request
     *
     * @return DescribeWebLockProcessListResponse
     */
    public function describeWebLockProcessList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebLockProcessListWithOptions($request, $runtime);
    }

    /**
     * Queries the status of web tamper proofing.
     *
     * @param request - DescribeWebLockStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeWebLockStatusResponse
     *
     * @param DescribeWebLockStatusRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DescribeWebLockStatusResponse
     */
    public function describeWebLockStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeWebLockStatus',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeWebLockStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the status of web tamper proofing.
     *
     * @param request - DescribeWebLockStatusRequest
     *
     * @returns DescribeWebLockStatusResponse
     *
     * @param DescribeWebLockStatusRequest $request
     *
     * @return DescribeWebLockStatusResponse
     */
    public function describeWebLockStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebLockStatusWithOptions($request, $runtime);
    }

    /**
     * Queries the number of times that the files protected by web tamper proofing are changed.
     *
     * @param request - DescribeWebLockTotalFileChangeCountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeWebLockTotalFileChangeCountResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DescribeWebLockTotalFileChangeCountResponse
     */
    public function describeWebLockTotalFileChangeCountWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DescribeWebLockTotalFileChangeCount',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeWebLockTotalFileChangeCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the number of times that the files protected by web tamper proofing are changed.
     *
     * @returns DescribeWebLockTotalFileChangeCountResponse
     *
     * @return DescribeWebLockTotalFileChangeCountResponse
     */
    public function describeWebLockTotalFileChangeCount()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebLockTotalFileChangeCountWithOptions($runtime);
    }

    /**
     * Queries the custom web directories that are scanned based on the alerting feature.
     *
     * @param request - DescribeWebPathRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeWebPathResponse
     *
     * @param DescribeWebPathRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return DescribeWebPathResponse
     */
    public function describeWebPathWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeWebPath',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeWebPathResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the custom web directories that are scanned based on the alerting feature.
     *
     * @param request - DescribeWebPathRequest
     *
     * @returns DescribeWebPathResponse
     *
     * @param DescribeWebPathRequest $request
     *
     * @return DescribeWebPathResponse
     */
    public function describeWebPath($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebPathWithOptions($request, $runtime);
    }

    /**
     * Queries the information about servers that can be added or are added to application whitelist policies.
     *
     * @remarks
     * The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
     *
     * @param request - DescribeWhiteListAssetRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeWhiteListAssetResponse
     *
     * @param DescribeWhiteListAssetRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DescribeWhiteListAssetResponse
     */
    public function describeWhiteListAssetWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->lastMaxId) {
            @$query['LastMaxId'] = $request->lastMaxId;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->strategyId) {
            @$query['StrategyId'] = $request->strategyId;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeWhiteListAsset',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeWhiteListAssetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about servers that can be added or are added to application whitelist policies.
     *
     * @remarks
     * The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
     *
     * @param request - DescribeWhiteListAssetRequest
     *
     * @returns DescribeWhiteListAssetResponse
     *
     * @param DescribeWhiteListAssetRequest $request
     *
     * @return DescribeWhiteListAssetResponse
     */
    public function describeWhiteListAsset($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWhiteListAssetWithOptions($request, $runtime);
    }

    /**
     * Queries the available quota for the application whitelist feature.
     *
     * @remarks
     * The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
     *
     * @param request - DescribeWhiteListAuthorizeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeWhiteListAuthorizeResponse
     *
     * @param DescribeWhiteListAuthorizeRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeWhiteListAuthorizeResponse
     */
    public function describeWhiteListAuthorizeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeWhiteListAuthorize',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeWhiteListAuthorizeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the available quota for the application whitelist feature.
     *
     * @remarks
     * The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
     *
     * @param request - DescribeWhiteListAuthorizeRequest
     *
     * @returns DescribeWhiteListAuthorizeResponse
     *
     * @param DescribeWhiteListAuthorizeRequest $request
     *
     * @return DescribeWhiteListAuthorizeResponse
     */
    public function describeWhiteListAuthorize($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWhiteListAuthorizeWithOptions($request, $runtime);
    }

    /**
     * Queries the servers on which an application whitelist policy takes effect.
     *
     * @remarks
     * The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in-use, you can call this operation.
     *
     * @param request - DescribeWhiteListEffectiveAssetsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeWhiteListEffectiveAssetsResponse
     *
     * @param DescribeWhiteListEffectiveAssetsRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return DescribeWhiteListEffectiveAssetsResponse
     */
    public function describeWhiteListEffectiveAssetsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->needStatistics) {
            @$query['NeedStatistics'] = $request->needStatistics;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->strategyId) {
            @$query['StrategyId'] = $request->strategyId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeWhiteListEffectiveAssets',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeWhiteListEffectiveAssetsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the servers on which an application whitelist policy takes effect.
     *
     * @remarks
     * The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in-use, you can call this operation.
     *
     * @param request - DescribeWhiteListEffectiveAssetsRequest
     *
     * @returns DescribeWhiteListEffectiveAssetsResponse
     *
     * @param DescribeWhiteListEffectiveAssetsRequest $request
     *
     * @return DescribeWhiteListEffectiveAssetsResponse
     */
    public function describeWhiteListEffectiveAssets($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWhiteListEffectiveAssetsWithOptions($request, $runtime);
    }

    /**
     * Queries the information about the processes that are detected in an application whitelist policy.
     *
     * @remarks
     * The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
     *
     * @param request - DescribeWhiteListProcessRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeWhiteListProcessResponse
     *
     * @param DescribeWhiteListProcessRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeWhiteListProcessResponse
     */
    public function describeWhiteListProcessWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->desc) {
            @$query['Desc'] = $request->desc;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->orderBy) {
            @$query['OrderBy'] = $request->orderBy;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->processName) {
            @$query['ProcessName'] = $request->processName;
        }

        if (null !== $request->processType) {
            @$query['ProcessType'] = $request->processType;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->strategyId) {
            @$query['StrategyId'] = $request->strategyId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeWhiteListProcess',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeWhiteListProcessResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about the processes that are detected in an application whitelist policy.
     *
     * @remarks
     * The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
     *
     * @param request - DescribeWhiteListProcessRequest
     *
     * @returns DescribeWhiteListProcessResponse
     *
     * @param DescribeWhiteListProcessRequest $request
     *
     * @return DescribeWhiteListProcessResponse
     */
    public function describeWhiteListProcess($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWhiteListProcessWithOptions($request, $runtime);
    }

    /**
     * Queries a list of application whitelist policies.
     *
     * @remarks
     * The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
     *
     * @param request - DescribeWhiteListStrategyListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeWhiteListStrategyListResponse
     *
     * @param DescribeWhiteListStrategyListRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DescribeWhiteListStrategyListResponse
     */
    public function describeWhiteListStrategyListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->strategyIds) {
            @$query['StrategyIds'] = $request->strategyIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeWhiteListStrategyList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeWhiteListStrategyListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of application whitelist policies.
     *
     * @remarks
     * The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
     *
     * @param request - DescribeWhiteListStrategyListRequest
     *
     * @returns DescribeWhiteListStrategyListResponse
     *
     * @param DescribeWhiteListStrategyListRequest $request
     *
     * @return DescribeWhiteListStrategyListResponse
     */
    public function describeWhiteListStrategyList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWhiteListStrategyListWithOptions($request, $runtime);
    }

    /**
     * Queries the statistics of application whitelist policies.
     *
     * @remarks
     * The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
     *
     * @param request - DescribeWhiteListStrategyStatisticsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeWhiteListStrategyStatisticsResponse
     *
     * @param DescribeWhiteListStrategyStatisticsRequest $request
     * @param RuntimeOptions                             $runtime
     *
     * @return DescribeWhiteListStrategyStatisticsResponse
     */
    public function describeWhiteListStrategyStatisticsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->strategyIds) {
            @$query['StrategyIds'] = $request->strategyIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeWhiteListStrategyStatistics',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeWhiteListStrategyStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics of application whitelist policies.
     *
     * @remarks
     * The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
     *
     * @param request - DescribeWhiteListStrategyStatisticsRequest
     *
     * @returns DescribeWhiteListStrategyStatisticsResponse
     *
     * @param DescribeWhiteListStrategyStatisticsRequest $request
     *
     * @return DescribeWhiteListStrategyStatisticsResponse
     */
    public function describeWhiteListStrategyStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWhiteListStrategyStatisticsWithOptions($request, $runtime);
    }

    /**
     * Queries the number of the servers on which an application whitelist policy takes effect.
     *
     * @remarks
     * The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in-use, you can call this operation.
     *
     * @param request - DescribeWhiteListStrategyUuidCountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeWhiteListStrategyUuidCountResponse
     *
     * @param DescribeWhiteListStrategyUuidCountRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return DescribeWhiteListStrategyUuidCountResponse
     */
    public function describeWhiteListStrategyUuidCountWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->strategyId) {
            @$query['StrategyId'] = $request->strategyId;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeWhiteListStrategyUuidCount',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeWhiteListStrategyUuidCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the number of the servers on which an application whitelist policy takes effect.
     *
     * @remarks
     * The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in-use, you can call this operation.
     *
     * @param request - DescribeWhiteListStrategyUuidCountRequest
     *
     * @returns DescribeWhiteListStrategyUuidCountResponse
     *
     * @param DescribeWhiteListStrategyUuidCountRequest $request
     *
     * @return DescribeWhiteListStrategyUuidCountResponse
     */
    public function describeWhiteListStrategyUuidCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWhiteListStrategyUuidCountWithOptions($request, $runtime);
    }

    /**
     * Tests whether DingTalk notification configurations are valid.
     *
     * @param request - DingTalkOnlineTestRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DingTalkOnlineTestResponse
     *
     * @param DingTalkOnlineTestRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return DingTalkOnlineTestResponse
     */
    public function dingTalkOnlineTestWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DingTalkOnlineTest',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DingTalkOnlineTestResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Tests whether DingTalk notification configurations are valid.
     *
     * @param request - DingTalkOnlineTestRequest
     *
     * @returns DingTalkOnlineTestResponse
     *
     * @param DingTalkOnlineTestRequest $request
     *
     * @return DingTalkOnlineTestResponse
     */
    public function dingTalkOnlineTest($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dingTalkOnlineTestWithOptions($request, $runtime);
    }

    /**
     * Disables an IP address blocking policy that is in effect.
     *
     * @param request - DisableBruteForceRecordRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DisableBruteForceRecordResponse
     *
     * @param DisableBruteForceRecordRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DisableBruteForceRecordResponse
     */
    public function disableBruteForceRecordWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->blockIp) {
            @$query['BlockIp'] = $request->blockIp;
        }

        if (null !== $request->bound) {
            @$query['Bound'] = $request->bound;
        }

        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        if (null !== $request->port) {
            @$query['Port'] = $request->port;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DisableBruteForceRecord',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DisableBruteForceRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Disables an IP address blocking policy that is in effect.
     *
     * @param request - DisableBruteForceRecordRequest
     *
     * @returns DisableBruteForceRecordResponse
     *
     * @param DisableBruteForceRecordRequest $request
     *
     * @return DisableBruteForceRecordResponse
     */
    public function disableBruteForceRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->disableBruteForceRecordWithOptions($request, $runtime);
    }

    /**
     * Disables a custom IP address blocking policy for servers.
     *
     * @param request - DisableCustomBlockRecordRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DisableCustomBlockRecordResponse
     *
     * @param DisableCustomBlockRecordRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DisableCustomBlockRecordResponse
     */
    public function disableCustomBlockRecordWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->blockIp) {
            @$query['BlockIp'] = $request->blockIp;
        }

        if (null !== $request->bound) {
            @$query['Bound'] = $request->bound;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DisableCustomBlockRecord',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DisableCustomBlockRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Disables a custom IP address blocking policy for servers.
     *
     * @param request - DisableCustomBlockRecordRequest
     *
     * @returns DisableCustomBlockRecordResponse
     *
     * @param DisableCustomBlockRecordRequest $request
     *
     * @return DisableCustomBlockRecordResponse
     */
    public function disableCustomBlockRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->disableCustomBlockRecordWithOptions($request, $runtime);
    }

    /**
     * Enables an IP address blocking policy for a specified server.
     *
     * @param request - EnableBruteForceRecordRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns EnableBruteForceRecordResponse
     *
     * @param EnableBruteForceRecordRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return EnableBruteForceRecordResponse
     */
    public function enableBruteForceRecordWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->blockIp) {
            @$query['BlockIp'] = $request->blockIp;
        }

        if (null !== $request->bound) {
            @$query['Bound'] = $request->bound;
        }

        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        if (null !== $request->port) {
            @$query['Port'] = $request->port;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'EnableBruteForceRecord',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return EnableBruteForceRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables an IP address blocking policy for a specified server.
     *
     * @param request - EnableBruteForceRecordRequest
     *
     * @returns EnableBruteForceRecordResponse
     *
     * @param EnableBruteForceRecordRequest $request
     *
     * @return EnableBruteForceRecordResponse
     */
    public function enableBruteForceRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->enableBruteForceRecordWithOptions($request, $runtime);
    }

    /**
     * Enables a custom IP address blocking policy.
     *
     * @param request - EnableCustomBlockRecordRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns EnableCustomBlockRecordResponse
     *
     * @param EnableCustomBlockRecordRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return EnableCustomBlockRecordResponse
     */
    public function enableCustomBlockRecordWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->blockIp) {
            @$query['BlockIp'] = $request->blockIp;
        }

        if (null !== $request->bound) {
            @$query['Bound'] = $request->bound;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'EnableCustomBlockRecord',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return EnableCustomBlockRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables a custom IP address blocking policy.
     *
     * @param request - EnableCustomBlockRecordRequest
     *
     * @returns EnableCustomBlockRecordResponse
     *
     * @param EnableCustomBlockRecordRequest $request
     *
     * @return EnableCustomBlockRecordResponse
     */
    public function enableCustomBlockRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->enableCustomBlockRecordWithOptions($request, $runtime);
    }

    /**
     * Enables a custom rule for an instance.
     *
     * @param request - EnableCustomInstanceBlockRecordRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns EnableCustomInstanceBlockRecordResponse
     *
     * @param EnableCustomInstanceBlockRecordRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return EnableCustomInstanceBlockRecordResponse
     */
    public function enableCustomInstanceBlockRecordWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->blockIp) {
            @$query['BlockIp'] = $request->blockIp;
        }

        if (null !== $request->bound) {
            @$query['Bound'] = $request->bound;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'EnableCustomInstanceBlockRecord',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return EnableCustomInstanceBlockRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables a custom rule for an instance.
     *
     * @param request - EnableCustomInstanceBlockRecordRequest
     *
     * @returns EnableCustomInstanceBlockRecordResponse
     *
     * @param EnableCustomInstanceBlockRecordRequest $request
     *
     * @return EnableCustomInstanceBlockRecordResponse
     */
    public function enableCustomInstanceBlockRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->enableCustomInstanceBlockRecordWithOptions($request, $runtime);
    }

    /**
     * Enable the multi-account management feature of Security Center.
     *
     * @remarks
     * You must use the management account of your resource directory or a delegated administrator account of Security Center to call this operation.
     *
     * @param request - EnableServiceAccessResourceDirectoryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns EnableServiceAccessResourceDirectoryResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return EnableServiceAccessResourceDirectoryResponse
     */
    public function enableServiceAccessResourceDirectoryWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'EnableServiceAccessResourceDirectory',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return EnableServiceAccessResourceDirectoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enable the multi-account management feature of Security Center.
     *
     * @remarks
     * You must use the management account of your resource directory or a delegated administrator account of Security Center to call this operation.
     *
     * @returns EnableServiceAccessResourceDirectoryResponse
     *
     * @return EnableServiceAccessResourceDirectoryResponse
     */
    public function enableServiceAccessResourceDirectory()
    {
        $runtime = new RuntimeOptions([]);

        return $this->enableServiceAccessResourceDirectoryWithOptions($runtime);
    }

    /**
     * Performs a baseline check on servers to which a specified baseline check policy is applied.
     *
     * @param request - ExecStrategyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ExecStrategyResponse
     *
     * @param ExecStrategyRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return ExecStrategyResponse
     */
    public function execStrategyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->execAction) {
            @$query['ExecAction'] = $request->execAction;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->strategyId) {
            @$query['StrategyId'] = $request->strategyId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ExecStrategy',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ExecStrategyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Performs a baseline check on servers to which a specified baseline check policy is applied.
     *
     * @param request - ExecStrategyRequest
     *
     * @returns ExecStrategyResponse
     *
     * @param ExecStrategyRequest $request
     *
     * @return ExecStrategyResponse
     */
    public function execStrategy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->execStrategyWithOptions($request, $runtime);
    }

    /**
     * Exports a security report.
     *
     * @param request - ExportCustomizeReportRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ExportCustomizeReportResponse
     *
     * @param ExportCustomizeReportRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return ExportCustomizeReportResponse
     */
    public function exportCustomizeReportWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->exportType) {
            @$query['ExportType'] = $request->exportType;
        }

        if (null !== $request->reportId) {
            @$query['ReportId'] = $request->reportId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ExportCustomizeReport',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ExportCustomizeReportResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Exports a security report.
     *
     * @param request - ExportCustomizeReportRequest
     *
     * @returns ExportCustomizeReportResponse
     *
     * @param ExportCustomizeReportRequest $request
     *
     * @return ExportCustomizeReportResponse
     */
    public function exportCustomizeReport($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->exportCustomizeReportWithOptions($request, $runtime);
    }

    /**
     * Exports the check results on the Host, Cloud Platform Configuration Assessment, Image Security, Attack Awareness, and AK leak detection pages to Excel files.
     *
     * @remarks
     * You can call the operation to export the following check result lists:
     * *   The list of servers on the Host page.
     * *   The lists of image system vulnerabilities, image application vulnerabilities, image baseline check results, and malicious image samples on the Image Security page.
     * *   The list of attack analysis data on the Attack Awareness page.
     * *   The list of check results for AccessKey pair leaks on the AK leak detection page.
     *
     * @param request - ExportRecordRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ExportRecordResponse
     *
     * @param ExportRecordRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return ExportRecordResponse
     */
    public function exportRecordWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->exportFileType) {
            @$query['ExportFileType'] = $request->exportFileType;
        }

        if (null !== $request->exportType) {
            @$query['ExportType'] = $request->exportType;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->params) {
            @$query['Params'] = $request->params;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ExportRecord',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ExportRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Exports the check results on the Host, Cloud Platform Configuration Assessment, Image Security, Attack Awareness, and AK leak detection pages to Excel files.
     *
     * @remarks
     * You can call the operation to export the following check result lists:
     * *   The list of servers on the Host page.
     * *   The lists of image system vulnerabilities, image application vulnerabilities, image baseline check results, and malicious image samples on the Image Security page.
     * *   The list of attack analysis data on the Attack Awareness page.
     * *   The list of check results for AccessKey pair leaks on the AK leak detection page.
     *
     * @param request - ExportRecordRequest
     *
     * @returns ExportRecordResponse
     *
     * @param ExportRecordRequest $request
     *
     * @return ExportRecordResponse
     */
    public function exportRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->exportRecordWithOptions($request, $runtime);
    }

    /**
     * Exports the information about exceptions to a file.
     *
     * @param request - ExportSuspEventsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ExportSuspEventsResponse
     *
     * @param ExportSuspEventsRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return ExportSuspEventsResponse
     */
    public function exportSuspEventsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->assetsTypeList) {
            @$query['AssetsTypeList'] = $request->assetsTypeList;
        }

        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->containerFieldName) {
            @$query['ContainerFieldName'] = $request->containerFieldName;
        }

        if (null !== $request->containerFieldValue) {
            @$query['ContainerFieldValue'] = $request->containerFieldValue;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->dealed) {
            @$query['Dealed'] = $request->dealed;
        }

        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->levels) {
            @$query['Levels'] = $request->levels;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->operateErrorCodeList) {
            @$query['OperateErrorCodeList'] = $request->operateErrorCodeList;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->parentEventTypes) {
            @$query['ParentEventTypes'] = $request->parentEventTypes;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->targetType) {
            @$query['TargetType'] = $request->targetType;
        }

        if (null !== $request->timeEnd) {
            @$query['TimeEnd'] = $request->timeEnd;
        }

        if (null !== $request->timeStart) {
            @$query['TimeStart'] = $request->timeStart;
        }

        if (null !== $request->uniqueInfo) {
            @$query['UniqueInfo'] = $request->uniqueInfo;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ExportSuspEvents',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ExportSuspEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Exports the information about exceptions to a file.
     *
     * @param request - ExportSuspEventsRequest
     *
     * @returns ExportSuspEventsResponse
     *
     * @param ExportSuspEventsRequest $request
     *
     * @return ExportSuspEventsResponse
     */
    public function exportSuspEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->exportSuspEventsWithOptions($request, $runtime);
    }

    /**
     * Exports vulnerabilities.
     *
     * @remarks
     * You can call the ExportVul operation to export the following types of vulnerabilities: Linux software vulnerabilities, Windows system vulnerabilities, Web-CMS vulnerabilities, application vulnerabilities, and urgent vulnerabilities.
     * You can use this operation together with the DescribeVulExportInfo operation. After you call the ExportVul operation to create a vulnerability export task, you can call the DescribeVulExportInfo operation to query the progress of the task by specifying the ID of the task.
     * ### Limits
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - ExportVulRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ExportVulResponse
     *
     * @param ExportVulRequest $request
     * @param RuntimeOptions   $runtime
     *
     * @return ExportVulResponse
     */
    public function exportVulWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aliasName) {
            @$query['AliasName'] = $request->aliasName;
        }

        if (null !== $request->attachTypes) {
            @$query['AttachTypes'] = $request->attachTypes;
        }

        if (null !== $request->containerName) {
            @$query['ContainerName'] = $request->containerName;
        }

        if (null !== $request->createTsEnd) {
            @$query['CreateTsEnd'] = $request->createTsEnd;
        }

        if (null !== $request->createTsStart) {
            @$query['CreateTsStart'] = $request->createTsStart;
        }

        if (null !== $request->cveId) {
            @$query['CveId'] = $request->cveId;
        }

        if (null !== $request->dealed) {
            @$query['Dealed'] = $request->dealed;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        if (null !== $request->imageName) {
            @$query['ImageName'] = $request->imageName;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->necessity) {
            @$query['Necessity'] = $request->necessity;
        }

        if (null !== $request->path) {
            @$query['Path'] = $request->path;
        }

        if (null !== $request->raspDefend) {
            @$query['RaspDefend'] = $request->raspDefend;
        }

        if (null !== $request->searchTags) {
            @$query['SearchTags'] = $request->searchTags;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        if (null !== $request->vpcInstanceIds) {
            @$query['VpcInstanceIds'] = $request->vpcInstanceIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ExportVul',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ExportVulResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Exports vulnerabilities.
     *
     * @remarks
     * You can call the ExportVul operation to export the following types of vulnerabilities: Linux software vulnerabilities, Windows system vulnerabilities, Web-CMS vulnerabilities, application vulnerabilities, and urgent vulnerabilities.
     * You can use this operation together with the DescribeVulExportInfo operation. After you call the ExportVul operation to create a vulnerability export task, you can call the DescribeVulExportInfo operation to query the progress of the task by specifying the ID of the task.
     * ### Limits
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - ExportVulRequest
     *
     * @returns ExportVulResponse
     *
     * @param ExportVulRequest $request
     *
     * @return ExportVulResponse
     */
    public function exportVul($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->exportVulWithOptions($request, $runtime);
    }

    /**
     * Exports baseline check results.
     *
     * @deprecated openAPI ExportWarning is deprecated, please use Sas::2018-12-03::ExportRecord instead
     *
     * @param request - ExportWarningRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ExportWarningResponse
     *
     * @param ExportWarningRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return ExportWarningResponse
     */
    public function exportWarningWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dealed) {
            @$query['Dealed'] = $request->dealed;
        }

        if (null !== $request->exportType) {
            @$query['ExportType'] = $request->exportType;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        if (null !== $request->isCleartextPwd) {
            @$query['IsCleartextPwd'] = $request->isCleartextPwd;
        }

        if (null !== $request->isSummaryExport) {
            @$query['IsSummaryExport'] = $request->isSummaryExport;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->riskIds) {
            @$query['RiskIds'] = $request->riskIds;
        }

        if (null !== $request->riskLevels) {
            @$query['RiskLevels'] = $request->riskLevels;
        }

        if (null !== $request->riskName) {
            @$query['RiskName'] = $request->riskName;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->statusList) {
            @$query['StatusList'] = $request->statusList;
        }

        if (null !== $request->strategyId) {
            @$query['StrategyId'] = $request->strategyId;
        }

        if (null !== $request->subTypeNames) {
            @$query['SubTypeNames'] = $request->subTypeNames;
        }

        if (null !== $request->typeName) {
            @$query['TypeName'] = $request->typeName;
        }

        if (null !== $request->typeNames) {
            @$query['TypeNames'] = $request->typeNames;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ExportWarning',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ExportWarningResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Exports baseline check results.
     *
     * @deprecated openAPI ExportWarning is deprecated, please use Sas::2018-12-03::ExportRecord instead
     *
     * @param request - ExportWarningRequest
     *
     * @returns ExportWarningResponse
     *
     * @param ExportWarningRequest $request
     *
     * @return ExportWarningResponse
     */
    public function exportWarning($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->exportWarningWithOptions($request, $runtime);
    }

    /**
     * .
     *
     * @param tmpReq - FindContainerNetworkConnectRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns FindContainerNetworkConnectResponse
     *
     * @param FindContainerNetworkConnectRequest $tmpReq
     * @param RuntimeOptions                     $runtime
     *
     * @return FindContainerNetworkConnectResponse
     */
    public function findContainerNetworkConnectWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new FindContainerNetworkConnectShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->dstNode) {
            $request->dstNodeShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->dstNode, 'DstNode', 'json');
        }

        if (null !== $tmpReq->srcNode) {
            $request->srcNodeShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->srcNode, 'SrcNode', 'json');
        }

        $query = [];
        if (null !== $request->criteriaType) {
            @$query['CriteriaType'] = $request->criteriaType;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->dstNodeShrink) {
            @$query['DstNode'] = $request->dstNodeShrink;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->srcNodeShrink) {
            @$query['SrcNode'] = $request->srcNodeShrink;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'FindContainerNetworkConnect',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return FindContainerNetworkConnectResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * .
     *
     * @param request - FindContainerNetworkConnectRequest
     *
     * @returns FindContainerNetworkConnectResponse
     *
     * @param FindContainerNetworkConnectRequest $request
     *
     * @return FindContainerNetworkConnectResponse
     */
    public function findContainerNetworkConnect($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->findContainerNetworkConnectWithOptions($request, $runtime);
    }

    /**
     * Completes guidance tasks for beginners to earn rewards.
     *
     * @param request - FinishGuidTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns FinishGuidTaskResponse
     *
     * @param FinishGuidTaskRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return FinishGuidTaskResponse
     */
    public function finishGuidTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->taskTypeName) {
            @$query['TaskTypeName'] = $request->taskTypeName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'FinishGuidTask',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return FinishGuidTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Completes guidance tasks for beginners to earn rewards.
     *
     * @param request - FinishGuidTaskRequest
     *
     * @returns FinishGuidTaskResponse
     *
     * @param FinishGuidTaskRequest $request
     *
     * @return FinishGuidTaskResponse
     */
    public function finishGuidTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->finishGuidTaskWithOptions($request, $runtime);
    }

    /**
     * Fixes a baseline risk item.
     *
     * @param request - FixCheckWarningsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns FixCheckWarningsResponse
     *
     * @param FixCheckWarningsRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return FixCheckWarningsResponse
     */
    public function fixCheckWarningsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->checkParams) {
            @$query['CheckParams'] = $request->checkParams;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->retentionDays) {
            @$query['RetentionDays'] = $request->retentionDays;
        }

        if (null !== $request->riskId) {
            @$query['RiskId'] = $request->riskId;
        }

        if (null !== $request->snapshotName) {
            @$query['SnapshotName'] = $request->snapshotName;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'FixCheckWarnings',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return FixCheckWarningsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Fixes a baseline risk item.
     *
     * @param request - FixCheckWarningsRequest
     *
     * @returns FixCheckWarningsResponse
     *
     * @param FixCheckWarningsRequest $request
     *
     * @return FixCheckWarningsResponse
     */
    public function fixCheckWarnings($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->fixCheckWarningsWithOptions($request, $runtime);
    }

    /**
     * Generate K8s cluster scan access configuration.
     *
     * @param request - GenerateClusterScannerWebhookYamlRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GenerateClusterScannerWebhookYamlResponse
     *
     * @param GenerateClusterScannerWebhookYamlRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return GenerateClusterScannerWebhookYamlResponse
     */
    public function generateClusterScannerWebhookYamlWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->webhookOpen) {
            @$query['WebhookOpen'] = $request->webhookOpen;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GenerateClusterScannerWebhookYaml',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GenerateClusterScannerWebhookYamlResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Generate K8s cluster scan access configuration.
     *
     * @param request - GenerateClusterScannerWebhookYamlRequest
     *
     * @returns GenerateClusterScannerWebhookYamlResponse
     *
     * @param GenerateClusterScannerWebhookYamlRequest $request
     *
     * @return GenerateClusterScannerWebhookYamlResponse
     */
    public function generateClusterScannerWebhookYaml($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->generateClusterScannerWebhookYamlWithOptions($request, $runtime);
    }

    /**
     * Generates a custom dictionary of weak passwords for the baseline check feature.
     *
     * @param request - GenerateDynamicDictRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GenerateDynamicDictResponse
     *
     * @param GenerateDynamicDictRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return GenerateDynamicDictResponse
     */
    public function generateDynamicDictWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->argKeywords) {
            @$query['ArgKeywords'] = $request->argKeywords;
        }

        if (null !== $request->domains) {
            @$query['Domains'] = $request->domains;
        }

        if (null !== $request->names) {
            @$query['Names'] = $request->names;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GenerateDynamicDict',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GenerateDynamicDictResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Generates a custom dictionary of weak passwords for the baseline check feature.
     *
     * @param request - GenerateDynamicDictRequest
     *
     * @returns GenerateDynamicDictResponse
     *
     * @param GenerateDynamicDictRequest $request
     *
     * @return GenerateDynamicDictResponse
     */
    public function generateDynamicDict($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->generateDynamicDictWithOptions($request, $runtime);
    }

    /**
     * Generates a command that is used to add a self-managed Kubernetes cluster.
     *
     * @param request - GenerateK8sAccessInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GenerateK8sAccessInfoResponse
     *
     * @param GenerateK8sAccessInfoRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return GenerateK8sAccessInfoResponse
     */
    public function generateK8sAccessInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aliyunYundunGatewayApiName) {
            @$query['AliyunYundunGatewayApiName'] = $request->aliyunYundunGatewayApiName;
        }

        if (null !== $request->aliyunYundunGatewayPopName) {
            @$query['AliyunYundunGatewayPopName'] = $request->aliyunYundunGatewayPopName;
        }

        if (null !== $request->aliyunYundunGatewayProjectName) {
            @$query['AliyunYundunGatewayProjectName'] = $request->aliyunYundunGatewayProjectName;
        }

        if (null !== $request->auditLogStore) {
            @$query['AuditLogStore'] = $request->auditLogStore;
        }

        if (null !== $request->auditProject) {
            @$query['AuditProject'] = $request->auditProject;
        }

        if (null !== $request->auditRegionId) {
            @$query['AuditRegionId'] = $request->auditRegionId;
        }

        if (null !== $request->clusterName) {
            @$query['ClusterName'] = $request->clusterName;
        }

        if (null !== $request->cpuArch) {
            @$query['CpuArch'] = $request->cpuArch;
        }

        if (null !== $request->expireDate) {
            @$query['ExpireDate'] = $request->expireDate;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        if (null !== $request->vendor) {
            @$query['Vendor'] = $request->vendor;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GenerateK8sAccessInfo',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GenerateK8sAccessInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Generates a command that is used to add a self-managed Kubernetes cluster.
     *
     * @param request - GenerateK8sAccessInfoRequest
     *
     * @returns GenerateK8sAccessInfoResponse
     *
     * @param GenerateK8sAccessInfoRequest $request
     *
     * @return GenerateK8sAccessInfoResponse
     */
    public function generateK8sAccessInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->generateK8sAccessInfoWithOptions($request, $runtime);
    }

    /**
     * Creates a one-time scan task.
     *
     * @param request - GenerateOnceTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GenerateOnceTaskResponse
     *
     * @param GenerateOnceTaskRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return GenerateOnceTaskResponse
     */
    public function generateOnceTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->param) {
            @$query['Param'] = $request->param;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        if (null !== $request->taskName) {
            @$query['TaskName'] = $request->taskName;
        }

        if (null !== $request->taskType) {
            @$query['TaskType'] = $request->taskType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GenerateOnceTask',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GenerateOnceTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a one-time scan task.
     *
     * @param request - GenerateOnceTaskRequest
     *
     * @returns GenerateOnceTaskResponse
     *
     * @param GenerateOnceTaskRequest $request
     *
     * @return GenerateOnceTaskResponse
     */
    public function generateOnceTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->generateOnceTaskWithOptions($request, $runtime);
    }

    /**
     * Obtains account tags.
     *
     * @param request - GetAccountLabelRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetAccountLabelResponse
     *
     * @param GetAccountLabelRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return GetAccountLabelResponse
     */
    public function getAccountLabelWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->labelList) {
            @$query['LabelList'] = $request->labelList;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetAccountLabel',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetAccountLabelResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Obtains account tags.
     *
     * @param request - GetAccountLabelRequest
     *
     * @returns GetAccountLabelResponse
     *
     * @param GetAccountLabelRequest $request
     *
     * @return GetAccountLabelResponse
     */
    public function getAccountLabel($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAccountLabelWithOptions($request, $runtime);
    }

    /**
     * Queries the details of a defense rule against container escapes.
     *
     * @remarks
     * Only the Ultimate edition of Security Center supports this operation.
     *
     * @param request - GetAegisContainerPluginRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetAegisContainerPluginRuleResponse
     *
     * @param GetAegisContainerPluginRuleRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return GetAegisContainerPluginRuleResponse
     */
    public function getAegisContainerPluginRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->ruleType) {
            @$query['RuleType'] = $request->ruleType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetAegisContainerPluginRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetAegisContainerPluginRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of a defense rule against container escapes.
     *
     * @remarks
     * Only the Ultimate edition of Security Center supports this operation.
     *
     * @param request - GetAegisContainerPluginRuleRequest
     *
     * @returns GetAegisContainerPluginRuleResponse
     *
     * @param GetAegisContainerPluginRuleRequest $request
     *
     * @return GetAegisContainerPluginRuleResponse
     */
    public function getAegisContainerPluginRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAegisContainerPluginRuleWithOptions($request, $runtime);
    }

    /**
     * Queries search conditions that can be used to search for container file protection rules.
     *
     * @param request - GetAegisContainerPluginRuleCriteriaRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetAegisContainerPluginRuleCriteriaResponse
     *
     * @param GetAegisContainerPluginRuleCriteriaRequest $request
     * @param RuntimeOptions                             $runtime
     *
     * @return GetAegisContainerPluginRuleCriteriaResponse
     */
    public function getAegisContainerPluginRuleCriteriaWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->value) {
            @$query['Value'] = $request->value;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetAegisContainerPluginRuleCriteria',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetAegisContainerPluginRuleCriteriaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries search conditions that can be used to search for container file protection rules.
     *
     * @param request - GetAegisContainerPluginRuleCriteriaRequest
     *
     * @returns GetAegisContainerPluginRuleCriteriaResponse
     *
     * @param GetAegisContainerPluginRuleCriteriaRequest $request
     *
     * @return GetAegisContainerPluginRuleCriteriaResponse
     */
    public function getAegisContainerPluginRuleCriteria($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAegisContainerPluginRuleCriteriaWithOptions($request, $runtime);
    }

    /**
     * Queries the number of agentless detection tasks.
     *
     * @param request - GetAgentlessTaskCountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetAgentlessTaskCountResponse
     *
     * @param GetAgentlessTaskCountRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return GetAgentlessTaskCountResponse
     */
    public function getAgentlessTaskCountWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->target) {
            @$query['Target'] = $request->target;
        }

        if (null !== $request->targetType) {
            @$query['TargetType'] = $request->targetType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetAgentlessTaskCount',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetAgentlessTaskCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the number of agentless detection tasks.
     *
     * @param request - GetAgentlessTaskCountRequest
     *
     * @returns GetAgentlessTaskCountResponse
     *
     * @param GetAgentlessTaskCountRequest $request
     *
     * @return GetAgentlessTaskCountResponse
     */
    public function getAgentlessTaskCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAgentlessTaskCountWithOptions($request, $runtime);
    }

    /**
     * Query the estimated volume for agentless detection.
     *
     * @param request - GetAgentlessTaskUsedSizeEstimateRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetAgentlessTaskUsedSizeEstimateResponse
     *
     * @param GetAgentlessTaskUsedSizeEstimateRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return GetAgentlessTaskUsedSizeEstimateResponse
     */
    public function getAgentlessTaskUsedSizeEstimateWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->assetSelectionType) {
            @$query['AssetSelectionType'] = $request->assetSelectionType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetAgentlessTaskUsedSizeEstimate',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetAgentlessTaskUsedSizeEstimateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Query the estimated volume for agentless detection.
     *
     * @param request - GetAgentlessTaskUsedSizeEstimateRequest
     *
     * @returns GetAgentlessTaskUsedSizeEstimateResponse
     *
     * @param GetAgentlessTaskUsedSizeEstimateRequest $request
     *
     * @return GetAgentlessTaskUsedSizeEstimateResponse
     */
    public function getAgentlessTaskUsedSizeEstimate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAgentlessTaskUsedSizeEstimateWithOptions($request, $runtime);
    }

    /**
     * Queries the number of servers on which alerts are generated.
     *
     * @param request - GetAlarmMachineCountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetAlarmMachineCountResponse
     *
     * @param GetAlarmMachineCountRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return GetAlarmMachineCountResponse
     */
    public function getAlarmMachineCountWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetAlarmMachineCount',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetAlarmMachineCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the number of servers on which alerts are generated.
     *
     * @param request - GetAlarmMachineCountRequest
     *
     * @returns GetAlarmMachineCountResponse
     *
     * @param GetAlarmMachineCountRequest $request
     *
     * @return GetAlarmMachineCountResponse
     */
    public function getAlarmMachineCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAlarmMachineCountWithOptions($request, $runtime);
    }

    /**
     * Queries the network topology between containerized applications.
     *
     * @param request - GetAppNetworkRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetAppNetworkResponse
     *
     * @param GetAppNetworkRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return GetAppNetworkResponse
     */
    public function getAppNetworkWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetAppNetwork',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetAppNetworkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the network topology between containerized applications.
     *
     * @param request - GetAppNetworkRequest
     *
     * @returns GetAppNetworkResponse
     *
     * @param GetAppNetworkRequest $request
     *
     * @return GetAppNetworkResponse
     */
    public function getAppNetwork($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAppNetworkWithOptions($request, $runtime);
    }

    /**
     * Queries the details of a server and the extended information about the server by using the UUID of the server.
     *
     * @param request - GetAssetDetailByUuidRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetAssetDetailByUuidResponse
     *
     * @param GetAssetDetailByUuidRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return GetAssetDetailByUuidResponse
     */
    public function getAssetDetailByUuidWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetAssetDetailByUuid',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetAssetDetailByUuidResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of a server and the extended information about the server by using the UUID of the server.
     *
     * @param request - GetAssetDetailByUuidRequest
     *
     * @returns GetAssetDetailByUuidResponse
     *
     * @param GetAssetDetailByUuidRequest $request
     *
     * @return GetAssetDetailByUuidResponse
     */
    public function getAssetDetailByUuid($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAssetDetailByUuidWithOptions($request, $runtime);
    }

    /**
     * Queries asset selection configurations.
     *
     * @param request - GetAssetSelectionConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetAssetSelectionConfigResponse
     *
     * @param GetAssetSelectionConfigRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return GetAssetSelectionConfigResponse
     */
    public function getAssetSelectionConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->businessType) {
            @$query['BusinessType'] = $request->businessType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetAssetSelectionConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetAssetSelectionConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries asset selection configurations.
     *
     * @param request - GetAssetSelectionConfigRequest
     *
     * @returns GetAssetSelectionConfigResponse
     *
     * @param GetAssetSelectionConfigRequest $request
     *
     * @return GetAssetSelectionConfigResponse
     */
    public function getAssetSelectionConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAssetSelectionConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the details about the asset fingerprints of the startup item, kernel module, or website type.
     *
     * @param request - GetAssetsPropertyDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetAssetsPropertyDetailResponse
     *
     * @param GetAssetsPropertyDetailRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return GetAssetsPropertyDetailResponse
     */
    public function getAssetsPropertyDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->biz) {
            @$query['Biz'] = $request->biz;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->itemName) {
            @$query['ItemName'] = $request->itemName;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->searchCriteriaList) {
            @$query['SearchCriteriaList'] = $request->searchCriteriaList;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetAssetsPropertyDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetAssetsPropertyDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details about the asset fingerprints of the startup item, kernel module, or website type.
     *
     * @param request - GetAssetsPropertyDetailRequest
     *
     * @returns GetAssetsPropertyDetailResponse
     *
     * @param GetAssetsPropertyDetailRequest $request
     *
     * @return GetAssetsPropertyDetailResponse
     */
    public function getAssetsPropertyDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAssetsPropertyDetailWithOptions($request, $runtime);
    }

    /**
     * Queries the aggregation information about the asset fingerprints of the startup item, kernel module, or website type.
     *
     * @param request - GetAssetsPropertyItemRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetAssetsPropertyItemResponse
     *
     * @param GetAssetsPropertyItemRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return GetAssetsPropertyItemResponse
     */
    public function getAssetsPropertyItemWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->biz) {
            @$query['Biz'] = $request->biz;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->forceFlush) {
            @$query['ForceFlush'] = $request->forceFlush;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->searchInfo) {
            @$query['SearchInfo'] = $request->searchInfo;
        }

        if (null !== $request->searchItem) {
            @$query['SearchItem'] = $request->searchItem;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetAssetsPropertyItem',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetAssetsPropertyItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the aggregation information about the asset fingerprints of the startup item, kernel module, or website type.
     *
     * @param request - GetAssetsPropertyItemRequest
     *
     * @returns GetAssetsPropertyItemResponse
     *
     * @param GetAssetsPropertyItemRequest $request
     *
     * @return GetAssetsPropertyItemResponse
     */
    public function getAssetsPropertyItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAssetsPropertyItemWithOptions($request, $runtime);
    }

    /**
     * Query Attack Path Event Details.
     *
     * @param request - GetAttackPathEventDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetAttackPathEventDetailResponse
     *
     * @param GetAttackPathEventDetailRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return GetAttackPathEventDetailResponse
     */
    public function getAttackPathEventDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->eventId) {
            @$query['EventId'] = $request->eventId;
        }

        if (null !== $request->eventSource) {
            @$query['EventSource'] = $request->eventSource;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetAttackPathEventDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetAttackPathEventDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Query Attack Path Event Details.
     *
     * @param request - GetAttackPathEventDetailRequest
     *
     * @returns GetAttackPathEventDetailResponse
     *
     * @param GetAttackPathEventDetailRequest $request
     *
     * @return GetAttackPathEventDetailResponse
     */
    public function getAttackPathEventDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAttackPathEventDetailWithOptions($request, $runtime);
    }

    /**
     * Query Attack Path Event Statistics.
     *
     * @param request - GetAttackPathEventStatisticsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetAttackPathEventStatisticsResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return GetAttackPathEventStatisticsResponse
     */
    public function getAttackPathEventStatisticsWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'GetAttackPathEventStatistics',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetAttackPathEventStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Query Attack Path Event Statistics.
     *
     * @returns GetAttackPathEventStatisticsResponse
     *
     * @return GetAttackPathEventStatisticsResponse
     */
    public function getAttackPathEventStatistics()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAttackPathEventStatisticsWithOptions($runtime);
    }

    /**
     * Query Attack Path Sensitive Assets.
     *
     * @param request - GetAttackPathSensitiveAssetConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetAttackPathSensitiveAssetConfigResponse
     *
     * @param GetAttackPathSensitiveAssetConfigRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return GetAttackPathSensitiveAssetConfigResponse
     */
    public function getAttackPathSensitiveAssetConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->attackPathSensitiveAssetConfigId) {
            @$query['AttackPathSensitiveAssetConfigId'] = $request->attackPathSensitiveAssetConfigId;
        }

        if (null !== $request->configType) {
            @$query['ConfigType'] = $request->configType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetAttackPathSensitiveAssetConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetAttackPathSensitiveAssetConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Query Attack Path Sensitive Assets.
     *
     * @param request - GetAttackPathSensitiveAssetConfigRequest
     *
     * @returns GetAttackPathSensitiveAssetConfigResponse
     *
     * @param GetAttackPathSensitiveAssetConfigRequest $request
     *
     * @return GetAttackPathSensitiveAssetConfigResponse
     */
    public function getAttackPathSensitiveAssetConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAttackPathSensitiveAssetConfigWithOptions($request, $runtime);
    }

    /**
     * Query Attack Path Whitelist Details.
     *
     * @param request - GetAttackPathWhitelistRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetAttackPathWhitelistResponse
     *
     * @param GetAttackPathWhitelistRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return GetAttackPathWhitelistResponse
     */
    public function getAttackPathWhitelistWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->attackPathWhitelistId) {
            @$query['AttackPathWhitelistId'] = $request->attackPathWhitelistId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetAttackPathWhitelist',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetAttackPathWhitelistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Query Attack Path Whitelist Details.
     *
     * @param request - GetAttackPathWhitelistRequest
     *
     * @returns GetAttackPathWhitelistResponse
     *
     * @param GetAttackPathWhitelistRequest $request
     *
     * @return GetAttackPathWhitelistResponse
     */
    public function getAttackPathWhitelist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAttackPathWhitelistWithOptions($request, $runtime);
    }

    /**
     * Queries a list of attack types on the Attack Analysis page.
     *
     * @param request - GetAttackTypeListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetAttackTypeListResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return GetAttackTypeListResponse
     */
    public function getAttackTypeListWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'GetAttackTypeList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetAttackTypeListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of attack types on the Attack Analysis page.
     *
     * @returns GetAttackTypeListResponse
     *
     * @return GetAttackTypeListResponse
     */
    public function getAttackTypeList()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAttackTypeListWithOptions($runtime);
    }

    /**
     * Queries the statistics of asset protection quota.
     *
     * @param request - GetAuthSummaryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetAuthSummaryResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return GetAuthSummaryResponse
     */
    public function getAuthSummaryWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'GetAuthSummary',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetAuthSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics of asset protection quota.
     *
     * @returns GetAuthSummaryResponse
     *
     * @return GetAuthSummaryResponse
     */
    public function getAuthSummary()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAuthSummaryWithOptions($runtime);
    }

    /**
     * Queries the statistics about the numbers of assets protected by each edition of Security Center.
     *
     * @param request - GetAuthVersionStatisticRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetAuthVersionStatisticResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return GetAuthVersionStatisticResponse
     */
    public function getAuthVersionStatisticWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'GetAuthVersionStatistic',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetAuthVersionStatisticResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics about the numbers of assets protected by each edition of Security Center.
     *
     * @returns GetAuthVersionStatisticResponse
     *
     * @return GetAuthVersionStatisticResponse
     */
    public function getAuthVersionStatistic()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAuthVersionStatisticWithOptions($runtime);
    }

    /**
     * Checks whether the managed anti-ransomware feature can automatically configure an anti-ransomware policy for servers.
     *
     * @param request - GetBackupAutoConfigStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetBackupAutoConfigStatusResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return GetBackupAutoConfigStatusResponse
     */
    public function getBackupAutoConfigStatusWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'GetBackupAutoConfigStatus',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetBackupAutoConfigStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Checks whether the managed anti-ransomware feature can automatically configure an anti-ransomware policy for servers.
     *
     * @returns GetBackupAutoConfigStatusResponse
     *
     * @return GetBackupAutoConfigStatusResponse
     */
    public function getBackupAutoConfigStatus()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getBackupAutoConfigStatusWithOptions($runtime);
    }

    /**
     * Queries the anti-ransomware capacity that is used.
     *
     * @param request - GetBackupStorageCountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetBackupStorageCountResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return GetBackupStorageCountResponse
     */
    public function getBackupStorageCountWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'GetBackupStorageCount',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetBackupStorageCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the anti-ransomware capacity that is used.
     *
     * @returns GetBackupStorageCountResponse
     *
     * @return GetBackupStorageCountResponse
     */
    public function getBackupStorageCount()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getBackupStorageCountWithOptions($runtime);
    }

    /**
     * Queries configurations for scanning image build command risks.
     *
     * @param request - GetBuildRiskDefineRuleConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetBuildRiskDefineRuleConfigResponse
     *
     * @param GetBuildRiskDefineRuleConfigRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return GetBuildRiskDefineRuleConfigResponse
     */
    public function getBuildRiskDefineRuleConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetBuildRiskDefineRuleConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetBuildRiskDefineRuleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries configurations for scanning image build command risks.
     *
     * @param request - GetBuildRiskDefineRuleConfigRequest
     *
     * @returns GetBuildRiskDefineRuleConfigResponse
     *
     * @param GetBuildRiskDefineRuleConfigRequest $request
     *
     * @return GetBuildRiskDefineRuleConfigResponse
     */
    public function getBuildRiskDefineRuleConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getBuildRiskDefineRuleConfigWithOptions($request, $runtime);
    }

    /**
     * Checks whether the current user is qualified for the trial use of Security Center.
     *
     * @param request - GetCanTrySasRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetCanTrySasResponse
     *
     * @param GetCanTrySasRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return GetCanTrySasResponse
     */
    public function getCanTrySasWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->fromEcs) {
            @$body['FromEcs'] = $request->fromEcs;
        }

        if (null !== $request->lang) {
            @$body['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetCanTrySas',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetCanTrySasResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Checks whether the current user is qualified for the trial use of Security Center.
     *
     * @param request - GetCanTrySasRequest
     *
     * @returns GetCanTrySasResponse
     *
     * @param GetCanTrySasRequest $request
     *
     * @return GetCanTrySasResponse
     */
    public function getCanTrySas($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCanTrySasWithOptions($request, $runtime);
    }

    /**
     * Queries the information about an automatic configuration check on cloud services.
     *
     * @param request - GetCheckConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetCheckConfigResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return GetCheckConfigResponse
     */
    public function getCheckConfigWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'GetCheckConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetCheckConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about an automatic configuration check on cloud services.
     *
     * @returns GetCheckConfigResponse
     *
     * @return GetCheckConfigResponse
     */
    public function getCheckConfig()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCheckConfigWithOptions($runtime);
    }

    /**
     * Queries statistics on the number of risk items in cloud security posture management (CSPM) for cloud services.
     *
     * @param request - GetCheckCountStatisticRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetCheckCountStatisticResponse
     *
     * @param GetCheckCountStatisticRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return GetCheckCountStatisticResponse
     */
    public function getCheckCountStatisticWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->statisticType) {
            @$query['StatisticType'] = $request->statisticType;
        }

        if (null !== $request->taskSources) {
            @$query['TaskSources'] = $request->taskSources;
        }

        if (null !== $request->vendors) {
            @$query['Vendors'] = $request->vendors;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetCheckCountStatistic',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetCheckCountStatisticResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries statistics on the number of risk items in cloud security posture management (CSPM) for cloud services.
     *
     * @param request - GetCheckCountStatisticRequest
     *
     * @returns GetCheckCountStatisticResponse
     *
     * @param GetCheckCountStatisticRequest $request
     *
     * @return GetCheckCountStatisticResponse
     */
    public function getCheckCountStatistic($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCheckCountStatisticWithOptions($request, $runtime);
    }

    /**
     * Queries the details about a check item that is used for configuration assessment.
     *
     * @param request - GetCheckDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetCheckDetailResponse
     *
     * @param GetCheckDetailRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return GetCheckDetailResponse
     */
    public function getCheckDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->checkId) {
            @$query['CheckId'] = $request->checkId;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetCheckDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetCheckDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details about a check item that is used for configuration assessment.
     *
     * @param request - GetCheckDetailRequest
     *
     * @returns GetCheckDetailResponse
     *
     * @param GetCheckDetailRequest $request
     *
     * @return GetCheckDetailResponse
     */
    public function getCheckDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCheckDetailWithOptions($request, $runtime);
    }

    /**
     * Queries the progress of a configuration check task on cloud services.
     *
     * @param request - GetCheckProcessRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetCheckProcessResponse
     *
     * @param GetCheckProcessRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return GetCheckProcessResponse
     */
    public function getCheckProcessWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetCheckProcess',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetCheckProcessResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the progress of a configuration check task on cloud services.
     *
     * @param request - GetCheckProcessRequest
     *
     * @returns GetCheckProcessResponse
     *
     * @param GetCheckProcessRequest $request
     *
     * @return GetCheckProcessResponse
     */
    public function getCheckProcess($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCheckProcessWithOptions($request, $runtime);
    }

    /**
     * Queries the statistics on risk scenarios and check items that are used in the risk scenarios, including the statistics on low-risk, medium-risk, and high-risk items by baseline type.
     *
     * @param request - GetCheckRiskStatisticsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetCheckRiskStatisticsResponse
     *
     * @param GetCheckRiskStatisticsRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return GetCheckRiskStatisticsResponse
     */
    public function getCheckRiskStatisticsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetCheckRiskStatistics',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetCheckRiskStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics on risk scenarios and check items that are used in the risk scenarios, including the statistics on low-risk, medium-risk, and high-risk items by baseline type.
     *
     * @param request - GetCheckRiskStatisticsRequest
     *
     * @returns GetCheckRiskStatisticsResponse
     *
     * @param GetCheckRiskStatisticsRequest $request
     *
     * @return GetCheckRiskStatisticsResponse
     */
    public function getCheckRiskStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCheckRiskStatisticsWithOptions($request, $runtime);
    }

    /**
     * Queries the sales information about the configuration assessment feature, including the purchased quota and the consumed quota.
     *
     * @param request - GetCheckSaleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetCheckSaleResponse
     *
     * @param GetCheckSaleRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return GetCheckSaleResponse
     */
    public function getCheckSaleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetCheckSale',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetCheckSaleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the sales information about the configuration assessment feature, including the purchased quota and the consumed quota.
     *
     * @param request - GetCheckSaleRequest
     *
     * @returns GetCheckSaleResponse
     *
     * @param GetCheckSaleRequest $request
     *
     * @return GetCheckSaleResponse
     */
    public function getCheckSale($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCheckSaleWithOptions($request, $runtime);
    }

    /**
     * Obtains the structure information about check items provided by the configuration assessment feature.
     *
     * @remarks
     * You must purchase the configuration assessment feature before you can use the feature.
     *
     * @param request - GetCheckStructureRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetCheckStructureResponse
     *
     * @param GetCheckStructureRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return GetCheckStructureResponse
     */
    public function getCheckStructureWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->taskSources) {
            @$query['TaskSources'] = $request->taskSources;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetCheckStructure',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetCheckStructureResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Obtains the structure information about check items provided by the configuration assessment feature.
     *
     * @remarks
     * You must purchase the configuration assessment feature before you can use the feature.
     *
     * @param request - GetCheckStructureRequest
     *
     * @returns GetCheckStructureResponse
     *
     * @param GetCheckStructureRequest $request
     *
     * @return GetCheckStructureResponse
     */
    public function getCheckStructure($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCheckStructureWithOptions($request, $runtime);
    }

    /**
     * Queries the summary information about the configuration checks on cloud services.
     *
     * @param request - GetCheckSummaryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetCheckSummaryResponse
     *
     * @param GetCheckSummaryRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return GetCheckSummaryResponse
     */
    public function getCheckSummaryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->isItemStatistic) {
            @$query['IsItemStatistic'] = $request->isItemStatistic;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        if (null !== $request->taskSources) {
            @$query['TaskSources'] = $request->taskSources;
        }

        if (null !== $request->vendors) {
            @$query['Vendors'] = $request->vendors;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetCheckSummary',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetCheckSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the summary information about the configuration checks on cloud services.
     *
     * @param request - GetCheckSummaryRequest
     *
     * @returns GetCheckSummaryResponse
     *
     * @param GetCheckSummaryRequest $request
     *
     * @return GetCheckSummaryResponse
     */
    public function getCheckSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCheckSummaryWithOptions($request, $runtime);
    }

    /**
     * Get time trend statistics data.
     *
     * @param request - GetCheckTimeDimensionStatisticRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetCheckTimeDimensionStatisticResponse
     *
     * @param GetCheckTimeDimensionStatisticRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return GetCheckTimeDimensionStatisticResponse
     */
    public function getCheckTimeDimensionStatisticWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->endTimeStamp) {
            @$query['EndTimeStamp'] = $request->endTimeStamp;
        }

        if (null !== $request->startTimeStamp) {
            @$query['StartTimeStamp'] = $request->startTimeStamp;
        }

        if (null !== $request->statisticType) {
            @$query['StatisticType'] = $request->statisticType;
        }

        if (null !== $request->vendors) {
            @$query['Vendors'] = $request->vendors;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetCheckTimeDimensionStatistic',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetCheckTimeDimensionStatisticResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Get time trend statistics data.
     *
     * @param request - GetCheckTimeDimensionStatisticRequest
     *
     * @returns GetCheckTimeDimensionStatisticResponse
     *
     * @param GetCheckTimeDimensionStatisticRequest $request
     *
     * @return GetCheckTimeDimensionStatisticResponse
     */
    public function getCheckTimeDimensionStatistic($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCheckTimeDimensionStatisticWithOptions($request, $runtime);
    }

    /**
     * Queries the installation rate and online rate of the agent.
     *
     * @param request - GetClientRatioStatisticRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetClientRatioStatisticResponse
     *
     * @param GetClientRatioStatisticRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return GetClientRatioStatisticResponse
     */
    public function getClientRatioStatisticWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        if (null !== $request->statisticTypes) {
            @$query['StatisticTypes'] = $request->statisticTypes;
        }

        if (null !== $request->timeEnd) {
            @$query['TimeEnd'] = $request->timeEnd;
        }

        if (null !== $request->timeStart) {
            @$query['TimeStart'] = $request->timeStart;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetClientRatioStatistic',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetClientRatioStatisticResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the installation rate and online rate of the agent.
     *
     * @param request - GetClientRatioStatisticRequest
     *
     * @returns GetClientRatioStatisticResponse
     *
     * @param GetClientRatioStatisticRequest $request
     *
     * @return GetClientRatioStatisticResponse
     */
    public function getClientRatioStatistic($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getClientRatioStatisticWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a custom defense rule.
     *
     * @param request - GetClientUserDefineRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetClientUserDefineRuleResponse
     *
     * @param GetClientUserDefineRuleRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return GetClientUserDefineRuleResponse
     */
    public function getClientUserDefineRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetClientUserDefineRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetClientUserDefineRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a custom defense rule.
     *
     * @param request - GetClientUserDefineRuleRequest
     *
     * @returns GetClientUserDefineRuleResponse
     *
     * @param GetClientUserDefineRuleRequest $request
     *
     * @return GetClientUserDefineRuleResponse
     */
    public function getClientUserDefineRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getClientUserDefineRuleWithOptions($request, $runtime);
    }

    /**
     * Queries the filter conditions that are used to search for cloud assets.
     *
     * @param request - GetCloudAssetCriteriaRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetCloudAssetCriteriaResponse
     *
     * @param GetCloudAssetCriteriaRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return GetCloudAssetCriteriaResponse
     */
    public function getCloudAssetCriteriaWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->cloudAssetTypes) {
            @$query['CloudAssetTypes'] = $request->cloudAssetTypes;
        }

        if (null !== $request->value) {
            @$query['Value'] = $request->value;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetCloudAssetCriteria',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetCloudAssetCriteriaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the filter conditions that are used to search for cloud assets.
     *
     * @param request - GetCloudAssetCriteriaRequest
     *
     * @returns GetCloudAssetCriteriaResponse
     *
     * @param GetCloudAssetCriteriaRequest $request
     *
     * @return GetCloudAssetCriteriaResponse
     */
    public function getCloudAssetCriteria($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCloudAssetCriteriaWithOptions($request, $runtime);
    }

    /**
     * Obtains the details of cloud assets.
     *
     * @param request - GetCloudAssetDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetCloudAssetDetailResponse
     *
     * @param GetCloudAssetDetailRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return GetCloudAssetDetailResponse
     */
    public function getCloudAssetDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->assetSubType) {
            @$query['AssetSubType'] = $request->assetSubType;
        }

        if (null !== $request->assetType) {
            @$query['AssetType'] = $request->assetType;
        }

        if (null !== $request->cloudAssetInstances) {
            @$query['CloudAssetInstances'] = $request->cloudAssetInstances;
        }

        if (null !== $request->vendor) {
            @$query['Vendor'] = $request->vendor;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetCloudAssetDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetCloudAssetDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Obtains the details of cloud assets.
     *
     * @param request - GetCloudAssetDetailRequest
     *
     * @returns GetCloudAssetDetailResponse
     *
     * @param GetCloudAssetDetailRequest $request
     *
     * @return GetCloudAssetDetailResponse
     */
    public function getCloudAssetDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCloudAssetDetailWithOptions($request, $runtime);
    }

    /**
     * 
     *
     * @param request - GetCloudAssetSummaryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetCloudAssetSummaryResponse
     *
     * @param GetCloudAssetSummaryRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return GetCloudAssetSummaryResponse
     */
    public function getCloudAssetSummaryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->cloudAssetTypes) {
            @$query['CloudAssetTypes'] = $request->cloudAssetTypes;
        }

        if (null !== $request->vendors) {
            @$query['Vendors'] = $request->vendors;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetCloudAssetSummary',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetCloudAssetSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 
     *
     * @param request - GetCloudAssetSummaryRequest
     *
     * @returns GetCloudAssetSummaryResponse
     *
     * @param GetCloudAssetSummaryRequest $request
     *
     * @return GetCloudAssetSummaryResponse
     */
    public function getCloudAssetSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCloudAssetSummaryWithOptions($request, $runtime);
    }

    /**
     * Queries the statistics on baseline risk items of container clusters.
     *
     * @param request - GetClusterCheckItemWarningStatisticsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetClusterCheckItemWarningStatisticsResponse
     *
     * @param GetClusterCheckItemWarningStatisticsRequest $request
     * @param RuntimeOptions                              $runtime
     *
     * @return GetClusterCheckItemWarningStatisticsResponse
     */
    public function getClusterCheckItemWarningStatisticsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetClusterCheckItemWarningStatistics',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetClusterCheckItemWarningStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics on baseline risk items of container clusters.
     *
     * @param request - GetClusterCheckItemWarningStatisticsRequest
     *
     * @returns GetClusterCheckItemWarningStatisticsResponse
     *
     * @param GetClusterCheckItemWarningStatisticsRequest $request
     *
     * @return GetClusterCheckItemWarningStatisticsResponse
     */
    public function getClusterCheckItemWarningStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getClusterCheckItemWarningStatisticsWithOptions($request, $runtime);
    }

    /**
     * Queries the overall information about cluster defense rules that are configured for the container firewall feature.
     *
     * @param request - GetClusterRuleSummaryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetClusterRuleSummaryResponse
     *
     * @param GetClusterRuleSummaryRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return GetClusterRuleSummaryResponse
     */
    public function getClusterRuleSummaryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetClusterRuleSummary',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetClusterRuleSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the overall information about cluster defense rules that are configured for the container firewall feature.
     *
     * @param request - GetClusterRuleSummaryRequest
     *
     * @returns GetClusterRuleSummaryResponse
     *
     * @param GetClusterRuleSummaryRequest $request
     *
     * @return GetClusterRuleSummaryResponse
     */
    public function getClusterRuleSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getClusterRuleSummaryWithOptions($request, $runtime);
    }

    /**
     * Query K8s cluster scan access configuration.
     *
     * @param request - GetClusterScannerYamlRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetClusterScannerYamlResponse
     *
     * @param GetClusterScannerYamlRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return GetClusterScannerYamlResponse
     */
    public function getClusterScannerYamlWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetClusterScannerYaml',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetClusterScannerYamlResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Query K8s cluster scan access configuration.
     *
     * @param request - GetClusterScannerYamlRequest
     *
     * @returns GetClusterScannerYamlResponse
     *
     * @param GetClusterScannerYamlRequest $request
     *
     * @return GetClusterScannerYamlResponse
     */
    public function getClusterScannerYaml($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getClusterScannerYamlWithOptions($request, $runtime);
    }

    /**
     * Queries the number of policies in each cluster.
     *
     * @param request - GetClusterStrategyCountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetClusterStrategyCountResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return GetClusterStrategyCountResponse
     */
    public function getClusterStrategyCountWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'GetClusterStrategyCount',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetClusterStrategyCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the number of policies in each cluster.
     *
     * @returns GetClusterStrategyCountResponse
     *
     * @return GetClusterStrategyCountResponse
     */
    public function getClusterStrategyCount()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getClusterStrategyCountWithOptions($runtime);
    }

    /**
     * Queries the statistics on alert events that are generated for containers.
     *
     * @param request - GetClusterSuspEventStatisticsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetClusterSuspEventStatisticsResponse
     *
     * @param GetClusterSuspEventStatisticsRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return GetClusterSuspEventStatisticsResponse
     */
    public function getClusterSuspEventStatisticsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetClusterSuspEventStatistics',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetClusterSuspEventStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics on alert events that are generated for containers.
     *
     * @param request - GetClusterSuspEventStatisticsRequest
     *
     * @returns GetClusterSuspEventStatisticsResponse
     *
     * @param GetClusterSuspEventStatisticsRequest $request
     *
     * @return GetClusterSuspEventStatisticsResponse
     */
    public function getClusterSuspEventStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getClusterSuspEventStatisticsWithOptions($request, $runtime);
    }

    /**
     * Queries the configuration of a common switch.
     *
     * @param request - GetCommonSwitchConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetCommonSwitchConfigResponse
     *
     * @param GetCommonSwitchConfigRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return GetCommonSwitchConfigResponse
     */
    public function getCommonSwitchConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetCommonSwitchConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetCommonSwitchConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configuration of a common switch.
     *
     * @param request - GetCommonSwitchConfigRequest
     *
     * @returns GetCommonSwitchConfigResponse
     *
     * @param GetCommonSwitchConfigRequest $request
     *
     * @return GetCommonSwitchConfigResponse
     */
    public function getCommonSwitchConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCommonSwitchConfigWithOptions($request, $runtime);
    }

    /**
     * Query whether the core function\\"s gray switch is hit.
     *
     * @param request - GetConsoleFuncGrayStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetConsoleFuncGrayStatusResponse
     *
     * @param GetConsoleFuncGrayStatusRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return GetConsoleFuncGrayStatusResponse
     */
    public function getConsoleFuncGrayStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->condition) {
            @$query['Condition'] = $request->condition;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetConsoleFuncGrayStatus',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetConsoleFuncGrayStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Query whether the core function\\"s gray switch is hit.
     *
     * @param request - GetConsoleFuncGrayStatusRequest
     *
     * @returns GetConsoleFuncGrayStatusResponse
     *
     * @param GetConsoleFuncGrayStatusRequest $request
     *
     * @return GetConsoleFuncGrayStatusResponse
     */
    public function getConsoleFuncGrayStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getConsoleFuncGrayStatusWithOptions($request, $runtime);
    }

    /**
     * Queries the details of a rule for non-image program defense.
     *
     * @param request - GetContainerDefenseRuleDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetContainerDefenseRuleDetailResponse
     *
     * @param GetContainerDefenseRuleDetailRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return GetContainerDefenseRuleDetailResponse
     */
    public function getContainerDefenseRuleDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->ruleId) {
            @$query['RuleId'] = $request->ruleId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetContainerDefenseRuleDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetContainerDefenseRuleDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of a rule for non-image program defense.
     *
     * @param request - GetContainerDefenseRuleDetailRequest
     *
     * @returns GetContainerDefenseRuleDetailResponse
     *
     * @param GetContainerDefenseRuleDetailRequest $request
     *
     * @return GetContainerDefenseRuleDetailResponse
     */
    public function getContainerDefenseRuleDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getContainerDefenseRuleDetailWithOptions($request, $runtime);
    }

    /**
     * Queries the publish details of the Security Center agent.
     *
     * @param request - GetCurrentVersionPublishRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetCurrentVersionPublishResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return GetCurrentVersionPublishResponse
     */
    public function getCurrentVersionPublishWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'GetCurrentVersionPublish',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetCurrentVersionPublishResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the publish details of the Security Center agent.
     *
     * @returns GetCurrentVersionPublishResponse
     *
     * @return GetCurrentVersionPublishResponse
     */
    public function getCurrentVersionPublish()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCurrentVersionPublishWithOptions($runtime);
    }

    /**
     * Queries the security operations trends of the vulnerabilities, alerts, and baseline risks.
     *
     * @param request - GetDataTrendRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetDataTrendResponse
     *
     * @param GetDataTrendRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return GetDataTrendResponse
     */
    public function getDataTrendWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bizTypes) {
            @$query['BizTypes'] = $request->bizTypes;
        }

        if (null !== $request->endTimestamp) {
            @$query['EndTimestamp'] = $request->endTimestamp;
        }

        if (null !== $request->interval) {
            @$query['Interval'] = $request->interval;
        }

        if (null !== $request->startTimestamp) {
            @$query['StartTimestamp'] = $request->startTimestamp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetDataTrend',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetDataTrendResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the security operations trends of the vulnerabilities, alerts, and baseline risks.
     *
     * @param request - GetDataTrendRequest
     *
     * @returns GetDataTrendResponse
     *
     * @param GetDataTrendRequest $request
     *
     * @return GetDataTrendResponse
     */
    public function getDataTrend($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDataTrendWithOptions($request, $runtime);
    }

    /**
     * Queries the numbers of handled alerts of the precision defense type and the web tamper proofing type.
     *
     * @param request - GetDefenceCountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetDefenceCountResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return GetDefenceCountResponse
     */
    public function getDefenceCountWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'GetDefenceCount',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetDefenceCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the numbers of handled alerts of the precision defense type and the web tamper proofing type.
     *
     * @returns GetDefenceCountResponse
     *
     * @return GetDefenceCountResponse
     */
    public function getDefenceCount()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDefenceCountWithOptions($runtime);
    }

    /**
     * Queries the ranking of images in each dimension.
     *
     * @param request - GetDockerhubImageRiskRankInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetDockerhubImageRiskRankInfoResponse
     *
     * @param GetDockerhubImageRiskRankInfoRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return GetDockerhubImageRiskRankInfoResponse
     */
    public function getDockerhubImageRiskRankInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->types) {
            @$query['Types'] = $request->types;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetDockerhubImageRiskRankInfo',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetDockerhubImageRiskRankInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the ranking of images in each dimension.
     *
     * @param request - GetDockerhubImageRiskRankInfoRequest
     *
     * @returns GetDockerhubImageRiskRankInfoResponse
     *
     * @param GetDockerhubImageRiskRankInfoRequest $request
     *
     * @return GetDockerhubImageRiskRankInfoResponse
     */
    public function getDockerhubImageRiskRankInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDockerhubImageRiskRankInfoWithOptions($request, $runtime);
    }

    /**
     * Queries the risk statistics of Docker Hub images.
     *
     * @param request - GetDockerhubImageRiskStatisticRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetDockerhubImageRiskStatisticResponse
     *
     * @param GetDockerhubImageRiskStatisticRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return GetDockerhubImageRiskStatisticResponse
     */
    public function getDockerhubImageRiskStatisticWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->types) {
            @$query['Types'] = $request->types;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetDockerhubImageRiskStatistic',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetDockerhubImageRiskStatisticResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the risk statistics of Docker Hub images.
     *
     * @param request - GetDockerhubImageRiskStatisticRequest
     *
     * @returns GetDockerhubImageRiskStatisticResponse
     *
     * @param GetDockerhubImageRiskStatisticRequest $request
     *
     * @return GetDockerhubImageRiskStatisticResponse
     */
    public function getDockerhubImageRiskStatistic($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDockerhubImageRiskStatisticWithOptions($request, $runtime);
    }

    /**
     * Obtains the usage information of the malicious file detection SDK.
     *
     * @param request - GetFileDetectApiInvokeInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetFileDetectApiInvokeInfoResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return GetFileDetectApiInvokeInfoResponse
     */
    public function getFileDetectApiInvokeInfoWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'GetFileDetectApiInvokeInfo',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetFileDetectApiInvokeInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Obtains the usage information of the malicious file detection SDK.
     *
     * @returns GetFileDetectApiInvokeInfoResponse
     *
     * @return GetFileDetectApiInvokeInfoResponse
     */
    public function getFileDetectApiInvokeInfo()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFileDetectApiInvokeInfoWithOptions($runtime);
    }

    /**
     * Queries the cloud sandbox check results of malicious files.
     *
     * @param request - GetFileDetectReportRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetFileDetectReportResponse
     *
     * @param GetFileDetectReportRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return GetFileDetectReportResponse
     */
    public function getFileDetectReportWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->eventId) {
            @$query['EventId'] = $request->eventId;
        }

        if (null !== $request->field) {
            @$query['Field'] = $request->field;
        }

        if (null !== $request->fileHash) {
            @$query['FileHash'] = $request->fileHash;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceType) {
            @$query['SourceType'] = $request->sourceType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetFileDetectReport',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetFileDetectReportResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the cloud sandbox check results of malicious files.
     *
     * @param request - GetFileDetectReportRequest
     *
     * @returns GetFileDetectReportResponse
     *
     * @param GetFileDetectReportRequest $request
     *
     * @return GetFileDetectReportResponse
     */
    public function getFileDetectReport($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFileDetectReportWithOptions($request, $runtime);
    }

    /**
     * Obtains file detection results.
     *
     * @remarks
     * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
     *
     * @param request - GetFileDetectResultRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetFileDetectResultResponse
     *
     * @param GetFileDetectResultRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return GetFileDetectResultResponse
     */
    public function getFileDetectResultWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hashKeyList) {
            @$query['HashKeyList'] = $request->hashKeyList;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetFileDetectResult',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetFileDetectResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Obtains file detection results.
     *
     * @remarks
     * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
     *
     * @param request - GetFileDetectResultRequest
     *
     * @returns GetFileDetectResultResponse
     *
     * @param GetFileDetectResultRequest $request
     *
     * @return GetFileDetectResultResponse
     */
    public function getFileDetectResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFileDetectResultWithOptions($request, $runtime);
    }

    /**
     * Queries information about the core file monitoring feature, including the number of effective rules and the installation status of the Security Center agent on servers.
     *
     * @param request - GetFileProtectDashboardRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetFileProtectDashboardResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return GetFileProtectDashboardResponse
     */
    public function getFileProtectDashboardWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'GetFileProtectDashboard',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetFileProtectDashboardResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries information about the core file monitoring feature, including the number of effective rules and the installation status of the Security Center agent on servers.
     *
     * @returns GetFileProtectDashboardResponse
     *
     * @return GetFileProtectDashboardResponse
     */
    public function getFileProtectDashboard()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFileProtectDashboardWithOptions($runtime);
    }

    /**
     * Queries information about core file monitoring events.
     *
     * @param request - GetFileProtectEventRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetFileProtectEventResponse
     *
     * @param GetFileProtectEventRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return GetFileProtectEventResponse
     */
    public function getFileProtectEventWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetFileProtectEvent',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetFileProtectEventResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries information about core file monitoring events.
     *
     * @param request - GetFileProtectEventRequest
     *
     * @returns GetFileProtectEventResponse
     *
     * @param GetFileProtectEventRequest $request
     *
     * @return GetFileProtectEventResponse
     */
    public function getFileProtectEvent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFileProtectEventWithOptions($request, $runtime);
    }

    /**
     * Queries the total number of core file monitoring events by filter condition.
     *
     * @param request - GetFileProtectEventCountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetFileProtectEventCountResponse
     *
     * @param GetFileProtectEventCountRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return GetFileProtectEventCountResponse
     */
    public function getFileProtectEventCountWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetFileProtectEventCount',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetFileProtectEventCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the total number of core file monitoring events by filter condition.
     *
     * @param request - GetFileProtectEventCountRequest
     *
     * @returns GetFileProtectEventCountResponse
     *
     * @param GetFileProtectEventCountRequest $request
     *
     * @return GetFileProtectEventCountResponse
     */
    public function getFileProtectEventCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFileProtectEventCountWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a core file monitoring rule based on the ID of the rule.
     *
     * @param request - GetFileProtectRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetFileProtectRuleResponse
     *
     * @param GetFileProtectRuleRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return GetFileProtectRuleResponse
     */
    public function getFileProtectRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetFileProtectRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetFileProtectRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a core file monitoring rule based on the ID of the rule.
     *
     * @param request - GetFileProtectRuleRequest
     *
     * @returns GetFileProtectRuleResponse
     *
     * @param GetFileProtectRuleRequest $request
     *
     * @return GetFileProtectRuleResponse
     */
    public function getFileProtectRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFileProtectRuleWithOptions($request, $runtime);
    }

    /**
     * Queries the queries per second (QPS) limit on the files uploaded from the client.
     *
     * @param request - GetFileUploadLimitRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetFileUploadLimitResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return GetFileUploadLimitResponse
     */
    public function getFileUploadLimitWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'GetFileUploadLimit',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetFileUploadLimitResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the queries per second (QPS) limit on the files uploaded from the client.
     *
     * @returns GetFileUploadLimitResponse
     *
     * @return GetFileUploadLimitResponse
     */
    public function getFileUploadLimit()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFileUploadLimitWithOptions($runtime);
    }

    /**
     * Get Trial Status.
     *
     * @param request - GetFunctionTrialStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetFunctionTrialStatusResponse
     *
     * @param GetFunctionTrialStatusRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return GetFunctionTrialStatusResponse
     */
    public function getFunctionTrialStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->functionName) {
            @$query['FunctionName'] = $request->functionName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetFunctionTrialStatus',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetFunctionTrialStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Get Trial Status.
     *
     * @param request - GetFunctionTrialStatusRequest
     *
     * @returns GetFunctionTrialStatusResponse
     *
     * @param GetFunctionTrialStatusRequest $request
     *
     * @return GetFunctionTrialStatusResponse
     */
    public function getFunctionTrialStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFunctionTrialStatusWithOptions($request, $runtime);
    }

    /**
     * Obtains the URL that is used to upload a file to a honeypot.
     *
     * @param request - GetHoneyPotUploadPolicyInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetHoneyPotUploadPolicyInfoResponse
     *
     * @param GetHoneyPotUploadPolicyInfoRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return GetHoneyPotUploadPolicyInfoResponse
     */
    public function getHoneyPotUploadPolicyInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetHoneyPotUploadPolicyInfo',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetHoneyPotUploadPolicyInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Obtains the URL that is used to upload a file to a honeypot.
     *
     * @param request - GetHoneyPotUploadPolicyInfoRequest
     *
     * @returns GetHoneyPotUploadPolicyInfoResponse
     *
     * @param GetHoneyPotUploadPolicyInfoRequest $request
     *
     * @return GetHoneyPotUploadPolicyInfoResponse
     */
    public function getHoneyPotUploadPolicyInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getHoneyPotUploadPolicyInfoWithOptions($request, $runtime);
    }

    /**
     * .
     *
     * @param request - GetHoneypotAttackStatisticsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetHoneypotAttackStatisticsResponse
     *
     * @param GetHoneypotAttackStatisticsRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return GetHoneypotAttackStatisticsResponse
     */
    public function getHoneypotAttackStatisticsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->endTimeStamp) {
            @$query['EndTimeStamp'] = $request->endTimeStamp;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->riskLevelList) {
            @$query['RiskLevelList'] = $request->riskLevelList;
        }

        if (null !== $request->srcIp) {
            @$query['SrcIp'] = $request->srcIp;
        }

        if (null !== $request->startTimeStamp) {
            @$query['StartTimeStamp'] = $request->startTimeStamp;
        }

        if (null !== $request->statisticsType) {
            @$query['StatisticsType'] = $request->statisticsType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetHoneypotAttackStatistics',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetHoneypotAttackStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * .
     *
     * @param request - GetHoneypotAttackStatisticsRequest
     *
     * @returns GetHoneypotAttackStatisticsResponse
     *
     * @param GetHoneypotAttackStatisticsRequest $request
     *
     * @return GetHoneypotAttackStatisticsResponse
     */
    public function getHoneypotAttackStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getHoneypotAttackStatisticsWithOptions($request, $runtime);
    }

    /**
     * Obtain attack trend statistics for a single attack source.
     *
     * @param request - GetHoneypotEventTrendRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetHoneypotEventTrendResponse
     *
     * @param GetHoneypotEventTrendRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return GetHoneypotEventTrendResponse
     */
    public function getHoneypotEventTrendWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->endTimeStamp) {
            @$query['EndTimeStamp'] = $request->endTimeStamp;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->riskLevelList) {
            @$query['RiskLevelList'] = $request->riskLevelList;
        }

        if (null !== $request->srcIp) {
            @$query['SrcIp'] = $request->srcIp;
        }

        if (null !== $request->startTimeStamp) {
            @$query['StartTimeStamp'] = $request->startTimeStamp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetHoneypotEventTrend',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetHoneypotEventTrendResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Obtain attack trend statistics for a single attack source.
     *
     * @param request - GetHoneypotEventTrendRequest
     *
     * @returns GetHoneypotEventTrendResponse
     *
     * @param GetHoneypotEventTrendRequest $request
     *
     * @return GetHoneypotEventTrendResponse
     */
    public function getHoneypotEventTrend($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getHoneypotEventTrendWithOptions($request, $runtime);
    }

    /**
     * Queries the details of a specified management node.
     *
     * @param request - GetHoneypotNodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetHoneypotNodeResponse
     *
     * @param GetHoneypotNodeRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return GetHoneypotNodeResponse
     */
    public function getHoneypotNodeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->nodeId) {
            @$query['NodeId'] = $request->nodeId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetHoneypotNode',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetHoneypotNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of a specified management node.
     *
     * @param request - GetHoneypotNodeRequest
     *
     * @returns GetHoneypotNodeResponse
     *
     * @param GetHoneypotNodeRequest $request
     *
     * @return GetHoneypotNodeResponse
     */
    public function getHoneypotNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getHoneypotNodeWithOptions($request, $runtime);
    }

    /**
     * Queries the monitoring data of management nodes to which the cloud honeypot belongs.
     *
     * @param request - GetHoneypotNodeMetricListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetHoneypotNodeMetricListResponse
     *
     * @param GetHoneypotNodeMetricListRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return GetHoneypotNodeMetricListResponse
     */
    public function getHoneypotNodeMetricListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->express) {
            @$query['Express'] = $request->express;
        }

        if (null !== $request->length) {
            @$query['Length'] = $request->length;
        }

        if (null !== $request->metricName) {
            @$query['MetricName'] = $request->metricName;
        }

        if (null !== $request->namespace) {
            @$query['Namespace'] = $request->namespace;
        }

        if (null !== $request->nodeId) {
            @$query['NodeId'] = $request->nodeId;
        }

        if (null !== $request->period) {
            @$query['Period'] = $request->period;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetHoneypotNodeMetricList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetHoneypotNodeMetricListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the monitoring data of management nodes to which the cloud honeypot belongs.
     *
     * @param request - GetHoneypotNodeMetricListRequest
     *
     * @returns GetHoneypotNodeMetricListResponse
     *
     * @param GetHoneypotNodeMetricListRequest $request
     *
     * @return GetHoneypotNodeMetricListResponse
     */
    public function getHoneypotNodeMetricList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getHoneypotNodeMetricListWithOptions($request, $runtime);
    }

    /**
     * Queries the configurations of a specified honeypot template.
     *
     * @param request - GetHoneypotPresetRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetHoneypotPresetResponse
     *
     * @param GetHoneypotPresetRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return GetHoneypotPresetResponse
     */
    public function getHoneypotPresetWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->honeypotPresetId) {
            @$query['HoneypotPresetId'] = $request->honeypotPresetId;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetHoneypotPreset',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetHoneypotPresetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configurations of a specified honeypot template.
     *
     * @param request - GetHoneypotPresetRequest
     *
     * @returns GetHoneypotPresetResponse
     *
     * @param GetHoneypotPresetRequest $request
     *
     * @return GetHoneypotPresetResponse
     */
    public function getHoneypotPreset($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getHoneypotPresetWithOptions($request, $runtime);
    }

    /**
     * Queries the details about a specified probe.
     *
     * @param request - GetHoneypotProbeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetHoneypotProbeResponse
     *
     * @param GetHoneypotProbeRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return GetHoneypotProbeResponse
     */
    public function getHoneypotProbeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->probeId) {
            @$query['ProbeId'] = $request->probeId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetHoneypotProbe',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetHoneypotProbeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details about a specified probe.
     *
     * @param request - GetHoneypotProbeRequest
     *
     * @returns GetHoneypotProbeResponse
     *
     * @param GetHoneypotProbeRequest $request
     *
     * @return GetHoneypotProbeResponse
     */
    public function getHoneypotProbe($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getHoneypotProbeWithOptions($request, $runtime);
    }

    /**
     * Get statistics on honey pot usage.
     *
     * @param request - GetHoneypotStatisticsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetHoneypotStatisticsResponse
     *
     * @param GetHoneypotStatisticsRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return GetHoneypotStatisticsResponse
     */
    public function getHoneypotStatisticsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetHoneypotStatistics',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetHoneypotStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Get statistics on honey pot usage.
     *
     * @param request - GetHoneypotStatisticsRequest
     *
     * @returns GetHoneypotStatisticsResponse
     *
     * @param GetHoneypotStatisticsRequest $request
     *
     * @return GetHoneypotStatisticsResponse
     */
    public function getHoneypotStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getHoneypotStatisticsWithOptions($request, $runtime);
    }

    /**
     * Queries alert handling rules.
     *
     * @param request - GetImageEventOperationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetImageEventOperationResponse
     *
     * @param GetImageEventOperationRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return GetImageEventOperationResponse
     */
    public function getImageEventOperationWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetImageEventOperation',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetImageEventOperationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries alert handling rules.
     *
     * @param request - GetImageEventOperationRequest
     *
     * @returns GetImageEventOperationResponse
     *
     * @param GetImageEventOperationRequest $request
     *
     * @return GetImageEventOperationResponse
     */
    public function getImageEventOperation($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getImageEventOperationWithOptions($request, $runtime);
    }

    /**
     * Queries the number of image scans that are performed within the last several days.
     *
     * @param request - GetImageScanNumInPeriodRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetImageScanNumInPeriodResponse
     *
     * @param GetImageScanNumInPeriodRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return GetImageScanNumInPeriodResponse
     */
    public function getImageScanNumInPeriodWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->pastDay) {
            @$query['PastDay'] = $request->pastDay;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetImageScanNumInPeriod',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetImageScanNumInPeriodResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the number of image scans that are performed within the last several days.
     *
     * @param request - GetImageScanNumInPeriodRequest
     *
     * @returns GetImageScanNumInPeriodResponse
     *
     * @param GetImageScanNumInPeriodRequest $request
     *
     * @return GetImageScanNumInPeriodResponse
     */
    public function getImageScanNumInPeriod($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getImageScanNumInPeriodWithOptions($request, $runtime);
    }

    /**
     * Query Asset Installation Code.
     *
     * @param request - GetInstallCodeForUuidRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetInstallCodeForUuidResponse
     *
     * @param GetInstallCodeForUuidRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return GetInstallCodeForUuidResponse
     */
    public function getInstallCodeForUuidWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetInstallCodeForUuid',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetInstallCodeForUuidResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Query Asset Installation Code.
     *
     * @param request - GetInstallCodeForUuidRequest
     *
     * @returns GetInstallCodeForUuidResponse
     *
     * @param GetInstallCodeForUuidRequest $request
     *
     * @return GetInstallCodeForUuidResponse
     */
    public function getInstallCodeForUuid($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInstallCodeForUuidWithOptions($request, $runtime);
    }

    /**
     * Count the number of security events for a single instance.
     *
     * @param request - GetInstanceAlarmStatisticsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetInstanceAlarmStatisticsResponse
     *
     * @param GetInstanceAlarmStatisticsRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return GetInstanceAlarmStatisticsResponse
     */
    public function getInstanceAlarmStatisticsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetInstanceAlarmStatistics',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetInstanceAlarmStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Count the number of security events for a single instance.
     *
     * @param request - GetInstanceAlarmStatisticsRequest
     *
     * @returns GetInstanceAlarmStatisticsResponse
     *
     * @param GetInstanceAlarmStatisticsRequest $request
     *
     * @return GetInstanceAlarmStatisticsResponse
     */
    public function getInstanceAlarmStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInstanceAlarmStatisticsWithOptions($request, $runtime);
    }

    /**
     * Get Instance Authorization Value Range.
     *
     * @param request - GetInstanceAuthRangeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetInstanceAuthRangeResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return GetInstanceAuthRangeResponse
     */
    public function getInstanceAuthRangeWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'GetInstanceAuthRange',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetInstanceAuthRangeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Get Instance Authorization Value Range.
     *
     * @returns GetInstanceAuthRangeResponse
     *
     * @return GetInstanceAuthRangeResponse
     */
    public function getInstanceAuthRange()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInstanceAuthRangeWithOptions($runtime);
    }

    /**
     * Queries the details of a microsegmentation defense rule.
     *
     * @param request - GetInterceptionRuleDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetInterceptionRuleDetailResponse
     *
     * @param GetInterceptionRuleDetailRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return GetInterceptionRuleDetailResponse
     */
    public function getInterceptionRuleDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->ruleId) {
            @$query['RuleId'] = $request->ruleId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetInterceptionRuleDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetInterceptionRuleDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of a microsegmentation defense rule.
     *
     * @param request - GetInterceptionRuleDetailRequest
     *
     * @returns GetInterceptionRuleDetailResponse
     *
     * @param GetInterceptionRuleDetailRequest $request
     *
     * @return GetInterceptionRuleDetailResponse
     */
    public function getInterceptionRuleDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInterceptionRuleDetailWithOptions($request, $runtime);
    }

    /**
     * Queries the statistics of the container firewall feature.
     *
     * @param request - GetInterceptionSummaryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetInterceptionSummaryResponse
     *
     * @param GetInterceptionSummaryRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return GetInterceptionSummaryResponse
     */
    public function getInterceptionSummaryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetInterceptionSummary',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetInterceptionSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics of the container firewall feature.
     *
     * @param request - GetInterceptionSummaryRequest
     *
     * @returns GetInterceptionSummaryResponse
     *
     * @param GetInterceptionSummaryRequest $request
     *
     * @return GetInterceptionSummaryResponse
     */
    public function getInterceptionSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInterceptionSummaryWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a specified network object that is protected by the container firewall feature.
     *
     * @param request - GetInterceptionTargetDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetInterceptionTargetDetailResponse
     *
     * @param GetInterceptionTargetDetailRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return GetInterceptionTargetDetailResponse
     */
    public function getInterceptionTargetDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->targetId) {
            @$query['TargetId'] = $request->targetId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetInterceptionTargetDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetInterceptionTargetDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a specified network object that is protected by the container firewall feature.
     *
     * @param request - GetInterceptionTargetDetailRequest
     *
     * @returns GetInterceptionTargetDetailResponse
     *
     * @param GetInterceptionTargetDetailRequest $request
     *
     * @return GetInterceptionTargetDetailResponse
     */
    public function getInterceptionTargetDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInterceptionTargetDetailWithOptions($request, $runtime);
    }

    /**
     * Queries information about the latest scan task to determine whether the task is complete.
     *
     * @param request - GetLastOnceTaskInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetLastOnceTaskInfoResponse
     *
     * @param GetLastOnceTaskInfoRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return GetLastOnceTaskInfoResponse
     */
    public function getLastOnceTaskInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        if (null !== $request->taskName) {
            @$query['TaskName'] = $request->taskName;
        }

        if (null !== $request->taskType) {
            @$query['TaskType'] = $request->taskType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetLastOnceTaskInfo',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetLastOnceTaskInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries information about the latest scan task to determine whether the task is complete.
     *
     * @param request - GetLastOnceTaskInfoRequest
     *
     * @returns GetLastOnceTaskInfoResponse
     *
     * @param GetLastOnceTaskInfoRequest $request
     *
     * @return GetLastOnceTaskInfoResponse
     */
    public function getLastOnceTaskInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getLastOnceTaskInfoWithOptions($request, $runtime);
    }

    /**
     * Obtains the default region for synchronizing assets outside Alibaba Cloud.
     *
     * @param request - GetLocalDefaultRegionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetLocalDefaultRegionResponse
     *
     * @param GetLocalDefaultRegionRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return GetLocalDefaultRegionResponse
     */
    public function getLocalDefaultRegionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->vendor) {
            @$query['Vendor'] = $request->vendor;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetLocalDefaultRegion',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetLocalDefaultRegionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Obtains the default region for synchronizing assets outside Alibaba Cloud.
     *
     * @param request - GetLocalDefaultRegionRequest
     *
     * @returns GetLocalDefaultRegionResponse
     *
     * @param GetLocalDefaultRegionRequest $request
     *
     * @return GetLocalDefaultRegionResponse
     */
    public function getLocalDefaultRegion($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getLocalDefaultRegionWithOptions($request, $runtime);
    }

    /**
     * Queries the status of a data shipping task of a log.
     *
     * @param request - GetLogMetaRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetLogMetaResponse
     *
     * @param GetLogMetaRequest $request
     * @param RuntimeOptions    $runtime
     *
     * @return GetLogMetaResponse
     */
    public function getLogMetaWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->logStore) {
            @$query['LogStore'] = $request->logStore;
        }

        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetLogMeta',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetLogMetaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the status of a data shipping task of a log.
     *
     * @param request - GetLogMetaRequest
     *
     * @returns GetLogMetaResponse
     *
     * @param GetLogMetaRequest $request
     *
     * @return GetLogMetaResponse
     */
    public function getLogMeta($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getLogMetaWithOptions($request, $runtime);
    }

    /**
     * Queries an alert whitelist rule of sensitive files that are detected by using the agentless detection feature.
     *
     * @param request - GetMaliciousFileWhitelistConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetMaliciousFileWhitelistConfigResponse
     *
     * @param GetMaliciousFileWhitelistConfigRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return GetMaliciousFileWhitelistConfigResponse
     */
    public function getMaliciousFileWhitelistConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->configId) {
            @$query['ConfigId'] = $request->configId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetMaliciousFileWhitelistConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetMaliciousFileWhitelistConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries an alert whitelist rule of sensitive files that are detected by using the agentless detection feature.
     *
     * @param request - GetMaliciousFileWhitelistConfigRequest
     *
     * @returns GetMaliciousFileWhitelistConfigResponse
     *
     * @param GetMaliciousFileWhitelistConfigRequest $request
     *
     * @return GetMaliciousFileWhitelistConfigResponse
     */
    public function getMaliciousFileWhitelistConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMaliciousFileWhitelistConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the configurations of a module.
     *
     * @param request - GetModuleConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetModuleConfigResponse
     *
     * @param GetModuleConfigRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return GetModuleConfigResponse
     */
    public function getModuleConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetModuleConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetModuleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configurations of a module.
     *
     * @param request - GetModuleConfigRequest
     *
     * @returns GetModuleConfigResponse
     *
     * @param GetModuleConfigRequest $request
     *
     * @return GetModuleConfigResponse
     */
    public function getModuleConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getModuleConfigWithOptions($request, $runtime);
    }

    /**
     * Checks whether the purchased Security Center features are enabled and whether related configurations take effect.
     *
     * @param tmpReq - GetModuleConfigStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetModuleConfigStatusResponse
     *
     * @param GetModuleConfigStatusRequest $tmpReq
     * @param RuntimeOptions               $runtime
     *
     * @return GetModuleConfigStatusResponse
     */
    public function getModuleConfigStatusWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new GetModuleConfigStatusShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->moduleNames) {
            $request->moduleNamesShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->moduleNames, 'ModuleNames', 'json');
        }

        $query = [];
        if (null !== $request->moduleNamesShrink) {
            @$query['ModuleNames'] = $request->moduleNamesShrink;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetModuleConfigStatus',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetModuleConfigStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Checks whether the purchased Security Center features are enabled and whether related configurations take effect.
     *
     * @param request - GetModuleConfigStatusRequest
     *
     * @returns GetModuleConfigStatusResponse
     *
     * @param GetModuleConfigStatusRequest $request
     *
     * @return GetModuleConfigStatusResponse
     */
    public function getModuleConfigStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getModuleConfigStatusWithOptions($request, $runtime);
    }

    /**
     * Queries the qualification information about the trial use of Security Center value-added features, including vulnerability fixing and threat analysis and response.
     *
     * @param request - GetModuleTrialAuthInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetModuleTrialAuthInfoResponse
     *
     * @param GetModuleTrialAuthInfoRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return GetModuleTrialAuthInfoResponse
     */
    public function getModuleTrialAuthInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->moduleCode) {
            @$query['ModuleCode'] = $request->moduleCode;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetModuleTrialAuthInfo',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetModuleTrialAuthInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the qualification information about the trial use of Security Center value-added features, including vulnerability fixing and threat analysis and response.
     *
     * @param request - GetModuleTrialAuthInfoRequest
     *
     * @returns GetModuleTrialAuthInfoResponse
     *
     * @param GetModuleTrialAuthInfoRequest $request
     *
     * @return GetModuleTrialAuthInfoResponse
     */
    public function getModuleTrialAuthInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getModuleTrialAuthInfoWithOptions($request, $runtime);
    }

    /**
     * Queries the details of an alert event that is generated for a malicious object.
     *
     * @param request - GetObjectScanEventRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetObjectScanEventResponse
     *
     * @param GetObjectScanEventRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return GetObjectScanEventResponse
     */
    public function getObjectScanEventWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->eventId) {
            @$query['EventId'] = $request->eventId;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetObjectScanEvent',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetObjectScanEventResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of an alert event that is generated for a malicious object.
     *
     * @param request - GetObjectScanEventRequest
     *
     * @returns GetObjectScanEventResponse
     *
     * @param GetObjectScanEventRequest $request
     *
     * @return GetObjectScanEventResponse
     */
    public function getObjectScanEvent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getObjectScanEventWithOptions($request, $runtime);
    }

    /**
     * Queries the execution result of a one-time scan task, such as asset fingerprint collection, vulnerability scan, and image security scan.
     *
     * @param request - GetOnceTaskResultInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetOnceTaskResultInfoResponse
     *
     * @param GetOnceTaskResultInfoRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return GetOnceTaskResultInfoResponse
     */
    public function getOnceTaskResultInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        if (null !== $request->taskName) {
            @$query['TaskName'] = $request->taskName;
        }

        if (null !== $request->taskType) {
            @$query['TaskType'] = $request->taskType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetOnceTaskResultInfo',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetOnceTaskResultInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the execution result of a one-time scan task, such as asset fingerprint collection, vulnerability scan, and image security scan.
     *
     * @param request - GetOnceTaskResultInfoRequest
     *
     * @returns GetOnceTaskResultInfoResponse
     *
     * @param GetOnceTaskResultInfoRequest $request
     *
     * @return GetOnceTaskResultInfoResponse
     */
    public function getOnceTaskResultInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOnceTaskResultInfoWithOptions($request, $runtime);
    }

    /**
     * Queries the baselines that are supported by at-risk image blocking.
     *
     * @param request - GetOpaClusterBaseLineListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetOpaClusterBaseLineListResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return GetOpaClusterBaseLineListResponse
     */
    public function getOpaClusterBaseLineListWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'GetOpaClusterBaseLineList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetOpaClusterBaseLineListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the baselines that are supported by at-risk image blocking.
     *
     * @returns GetOpaClusterBaseLineListResponse
     *
     * @return GetOpaClusterBaseLineListResponse
     */
    public function getOpaClusterBaseLineList()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOpaClusterBaseLineListWithOptions($runtime);
    }

    /**
     * Get cluster image information.
     *
     * @param request - GetOpaClusterImageListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetOpaClusterImageListResponse
     *
     * @param GetOpaClusterImageListRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return GetOpaClusterImageListResponse
     */
    public function getOpaClusterImageListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->imageName) {
            @$query['ImageName'] = $request->imageName;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetOpaClusterImageList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetOpaClusterImageListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Get cluster image information.
     *
     * @param request - GetOpaClusterImageListRequest
     *
     * @returns GetOpaClusterImageListResponse
     *
     * @param GetOpaClusterImageListRequest $request
     *
     * @return GetOpaClusterImageListResponse
     */
    public function getOpaClusterImageList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOpaClusterImageListWithOptions($request, $runtime);
    }

    /**
     * Queries information about the tags that are added to containers based on the feature of proactive defense for containers.
     *
     * @param request - GetOpaClusterLabelListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetOpaClusterLabelListResponse
     *
     * @param GetOpaClusterLabelListRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return GetOpaClusterLabelListResponse
     */
    public function getOpaClusterLabelListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->tagName) {
            @$query['TagName'] = $request->tagName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetOpaClusterLabelList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetOpaClusterLabelListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries information about the tags that are added to containers based on the feature of proactive defense for containers.
     *
     * @param request - GetOpaClusterLabelListRequest
     *
     * @returns GetOpaClusterLabelListResponse
     *
     * @param GetOpaClusterLabelListRequest $request
     *
     * @return GetOpaClusterLabelListResponse
     */
    public function getOpaClusterLabelList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOpaClusterLabelListWithOptions($request, $runtime);
    }

    /**
     * Queries information about the namespaces of clusters for which the rules of the at-risk image blocking type are configured in proactive defense for containers.
     *
     * @param request - GetOpaClusterNamespaceListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetOpaClusterNamespaceListResponse
     *
     * @param GetOpaClusterNamespaceListRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return GetOpaClusterNamespaceListResponse
     */
    public function getOpaClusterNamespaceListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->nameSpaceName) {
            @$query['NameSpaceName'] = $request->nameSpaceName;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetOpaClusterNamespaceList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetOpaClusterNamespaceListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries information about the namespaces of clusters for which the rules of the at-risk image blocking type are configured in proactive defense for containers.
     *
     * @param request - GetOpaClusterNamespaceListRequest
     *
     * @returns GetOpaClusterNamespaceListResponse
     *
     * @param GetOpaClusterNamespaceListRequest $request
     *
     * @return GetOpaClusterNamespaceListResponse
     */
    public function getOpaClusterNamespaceList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOpaClusterNamespaceListWithOptions($request, $runtime);
    }

    /**
     * Queries the installation status of the components that are required for clusters protected by proactive defense for containers.
     *
     * @param request - GetOpaPluginStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetOpaPluginStatusResponse
     *
     * @param GetOpaPluginStatusRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return GetOpaPluginStatusResponse
     */
    public function getOpaPluginStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterIds) {
            @$query['ClusterIds'] = $request->clusterIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetOpaPluginStatus',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetOpaPluginStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the installation status of the components that are required for clusters protected by proactive defense for containers.
     *
     * @param request - GetOpaPluginStatusRequest
     *
     * @returns GetOpaPluginStatusResponse
     *
     * @param GetOpaPluginStatusRequest $request
     *
     * @return GetOpaPluginStatusResponse
     */
    public function getOpaPluginStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOpaPluginStatusWithOptions($request, $runtime);
    }

    /**
     * Queries the details of the rule that is used to block at-risk images.
     *
     * @param request - GetOpaStrategyDetailNewRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetOpaStrategyDetailNewResponse
     *
     * @param GetOpaStrategyDetailNewRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return GetOpaStrategyDetailNewResponse
     */
    public function getOpaStrategyDetailNewWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->strategyId) {
            @$query['StrategyId'] = $request->strategyId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetOpaStrategyDetailNew',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetOpaStrategyDetailNewResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of the rule that is used to block at-risk images.
     *
     * @param request - GetOpaStrategyDetailNewRequest
     *
     * @returns GetOpaStrategyDetailNewResponse
     *
     * @param GetOpaStrategyDetailNewRequest $request
     *
     * @return GetOpaStrategyDetailNewResponse
     */
    public function getOpaStrategyDetailNew($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOpaStrategyDetailNewWithOptions($request, $runtime);
    }

    /**
     * Queries the usage statistics about the templates provided in the feature of proactive defense for containers for rules of the at-risk image blocking type.
     *
     * @param request - GetOpaStrategyTemplateSummaryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetOpaStrategyTemplateSummaryResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return GetOpaStrategyTemplateSummaryResponse
     */
    public function getOpaStrategyTemplateSummaryWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'GetOpaStrategyTemplateSummary',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetOpaStrategyTemplateSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the usage statistics about the templates provided in the feature of proactive defense for containers for rules of the at-risk image blocking type.
     *
     * @returns GetOpaStrategyTemplateSummaryResponse
     *
     * @return GetOpaStrategyTemplateSummaryResponse
     */
    public function getOpaStrategyTemplateSummary()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOpaStrategyTemplateSummaryWithOptions($runtime);
    }

    /**
     * Queries the statistics about an Object Storage Service (OSS) bucket check.
     *
     * @param request - GetOssBucketScanStatisticRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetOssBucketScanStatisticResponse
     *
     * @param GetOssBucketScanStatisticRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return GetOssBucketScanStatisticResponse
     */
    public function getOssBucketScanStatisticWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bucketNameList) {
            @$query['BucketNameList'] = $request->bucketNameList;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetOssBucketScanStatistic',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetOssBucketScanStatisticResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics about an Object Storage Service (OSS) bucket check.
     *
     * @param request - GetOssBucketScanStatisticRequest
     *
     * @returns GetOssBucketScanStatisticResponse
     *
     * @param GetOssBucketScanStatisticRequest $request
     *
     * @return GetOssBucketScanStatisticResponse
     */
    public function getOssBucketScanStatistic($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOssBucketScanStatisticWithOptions($request, $runtime);
    }

    /**
     * Queries the configurations of an Object Storage Service (OSS) bucket check policy.
     *
     * @param request - GetOssScanConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetOssScanConfigResponse
     *
     * @param GetOssScanConfigRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return GetOssScanConfigResponse
     */
    public function getOssScanConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bucketName) {
            @$query['BucketName'] = $request->bucketName;
        }

        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetOssScanConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetOssScanConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configurations of an Object Storage Service (OSS) bucket check policy.
     *
     * @param request - GetOssScanConfigRequest
     *
     * @returns GetOssScanConfigResponse
     *
     * @param GetOssScanConfigRequest $request
     *
     * @return GetOssScanConfigResponse
     */
    public function getOssScanConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOssScanConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the configurations for the collection frequency of asset fingerprints.
     *
     * @param request - GetPropertyScheduleConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetPropertyScheduleConfigResponse
     *
     * @param GetPropertyScheduleConfigRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return GetPropertyScheduleConfigResponse
     */
    public function getPropertyScheduleConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetPropertyScheduleConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetPropertyScheduleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configurations for the collection frequency of asset fingerprints.
     *
     * @param request - GetPropertyScheduleConfigRequest
     *
     * @returns GetPropertyScheduleConfigResponse
     *
     * @param GetPropertyScheduleConfigRequest $request
     *
     * @return GetPropertyScheduleConfigResponse
     */
    public function getPropertyScheduleConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getPropertyScheduleConfigWithOptions($request, $runtime);
    }

    /**
     * Get Publish Time Configuration.
     *
     * @param request - GetPublishCronRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetPublishCronResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return GetPublishCronResponse
     */
    public function getPublishCronWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'GetPublishCron',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetPublishCronResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Get Publish Time Configuration.
     *
     * @returns GetPublishCronResponse
     *
     * @return GetPublishCronResponse
     */
    public function getPublishCron()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getPublishCronWithOptions($runtime);
    }

    /**
     * Queries the organizational structure of a resource directory by using the multi-account management feature.
     *
     * @remarks
     * You can call this operation only by using the management account of a resource directory or a delegated administrator account of Security Center.
     *
     * @param request - GetRdTreeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetRdTreeResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return GetRdTreeResponse
     */
    public function getRdTreeWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'GetRdTree',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetRdTreeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the organizational structure of a resource directory by using the multi-account management feature.
     *
     * @remarks
     * You can call this operation only by using the management account of a resource directory or a delegated administrator account of Security Center.
     *
     * @returns GetRdTreeResponse
     *
     * @return GetRdTreeResponse
     */
    public function getRdTree()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getRdTreeWithOptions($runtime);
    }

    /**
     * Queries the time range of image scans.
     *
     * @param request - GetRegistryScanDayNumRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetRegistryScanDayNumResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return GetRegistryScanDayNumResponse
     */
    public function getRegistryScanDayNumWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'GetRegistryScanDayNum',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetRegistryScanDayNumResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the time range of image scans.
     *
     * @returns GetRegistryScanDayNumResponse
     *
     * @return GetRegistryScanDayNumResponse
     */
    public function getRegistryScanDayNum()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getRegistryScanDayNumWithOptions($runtime);
    }

    /**
     * Queries the numbers of system defense rules and custom defense rules.
     *
     * @param request - GetRulesCountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetRulesCountResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return GetRulesCountResponse
     */
    public function getRulesCountWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'GetRulesCount',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetRulesCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the numbers of system defense rules and custom defense rules.
     *
     * @returns GetRulesCountResponse
     *
     * @return GetRulesCountResponse
     */
    public function getRulesCount()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getRulesCountWithOptions($runtime);
    }

    /**
     * Get Container File Defense Rule Details.
     *
     * @param request - GetSasContainerWebDefenseRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetSasContainerWebDefenseRuleResponse
     *
     * @param GetSasContainerWebDefenseRuleRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return GetSasContainerWebDefenseRuleResponse
     */
    public function getSasContainerWebDefenseRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ruleId) {
            @$query['RuleId'] = $request->ruleId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetSasContainerWebDefenseRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetSasContainerWebDefenseRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Get Container File Defense Rule Details.
     *
     * @param request - GetSasContainerWebDefenseRuleRequest
     *
     * @returns GetSasContainerWebDefenseRuleResponse
     *
     * @param GetSasContainerWebDefenseRuleRequest $request
     *
     * @return GetSasContainerWebDefenseRuleResponse
     */
    public function getSasContainerWebDefenseRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getSasContainerWebDefenseRuleWithOptions($request, $runtime);
    }

    /**
     * Queries the applications that are specified in a rule for container tamper-proofing.
     *
     * @param request - GetSasContainerWebDefenseRuleApplicationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetSasContainerWebDefenseRuleApplicationResponse
     *
     * @param GetSasContainerWebDefenseRuleApplicationRequest $request
     * @param RuntimeOptions                                  $runtime
     *
     * @return GetSasContainerWebDefenseRuleApplicationResponse
     */
    public function getSasContainerWebDefenseRuleApplicationWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ruleId) {
            @$query['RuleId'] = $request->ruleId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetSasContainerWebDefenseRuleApplication',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetSasContainerWebDefenseRuleApplicationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the applications that are specified in a rule for container tamper-proofing.
     *
     * @param request - GetSasContainerWebDefenseRuleApplicationRequest
     *
     * @returns GetSasContainerWebDefenseRuleApplicationResponse
     *
     * @param GetSasContainerWebDefenseRuleApplicationRequest $request
     *
     * @return GetSasContainerWebDefenseRuleApplicationResponse
     */
    public function getSasContainerWebDefenseRuleApplication($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getSasContainerWebDefenseRuleApplicationWithOptions($request, $runtime);
    }

    /**
     * Queries search conditions that can be used to search for container file protection rules.
     *
     * @param request - GetSasContainerWebDefenseRuleCriteriaRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetSasContainerWebDefenseRuleCriteriaResponse
     *
     * @param GetSasContainerWebDefenseRuleCriteriaRequest $request
     * @param RuntimeOptions                               $runtime
     *
     * @return GetSasContainerWebDefenseRuleCriteriaResponse
     */
    public function getSasContainerWebDefenseRuleCriteriaWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->value) {
            @$query['Value'] = $request->value;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetSasContainerWebDefenseRuleCriteria',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetSasContainerWebDefenseRuleCriteriaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries search conditions that can be used to search for container file protection rules.
     *
     * @param request - GetSasContainerWebDefenseRuleCriteriaRequest
     *
     * @returns GetSasContainerWebDefenseRuleCriteriaResponse
     *
     * @param GetSasContainerWebDefenseRuleCriteriaRequest $request
     *
     * @return GetSasContainerWebDefenseRuleCriteriaResponse
     */
    public function getSasContainerWebDefenseRuleCriteria($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getSasContainerWebDefenseRuleCriteriaWithOptions($request, $runtime);
    }

    /**
     * Queries the details of the deduction modules of the security score feature, including custom settings.
     *
     * @param request - GetSecurityScoreRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetSecurityScoreRuleResponse
     *
     * @param GetSecurityScoreRuleRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return GetSecurityScoreRuleResponse
     */
    public function getSecurityScoreRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->calType) {
            @$query['CalType'] = $request->calType;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetSecurityScoreRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetSecurityScoreRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of the deduction modules of the security score feature, including custom settings.
     *
     * @param request - GetSecurityScoreRuleRequest
     *
     * @returns GetSecurityScoreRuleResponse
     *
     * @param GetSecurityScoreRuleRequest $request
     *
     * @return GetSecurityScoreRuleResponse
     */
    public function getSecurityScoreRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getSecurityScoreRuleWithOptions($request, $runtime);
    }

    /**
     * Queries the check rules of sensitive files.
     *
     * @param request - GetSensitiveDefineRuleConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetSensitiveDefineRuleConfigResponse
     *
     * @param GetSensitiveDefineRuleConfigRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return GetSensitiveDefineRuleConfigResponse
     */
    public function getSensitiveDefineRuleConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetSensitiveDefineRuleConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetSensitiveDefineRuleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the check rules of sensitive files.
     *
     * @param request - GetSensitiveDefineRuleConfigRequest
     *
     * @returns GetSensitiveDefineRuleConfigResponse
     *
     * @param GetSensitiveDefineRuleConfigRequest $request
     *
     * @return GetSensitiveDefineRuleConfigResponse
     */
    public function getSensitiveDefineRuleConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getSensitiveDefineRuleConfigWithOptions($request, $runtime);
    }

    /**
     * Get Serverless Application Authorization Details.
     *
     * @param request - GetServerlessAppAuthDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetServerlessAppAuthDetailResponse
     *
     * @param GetServerlessAppAuthDetailRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return GetServerlessAppAuthDetailResponse
     */
    public function getServerlessAppAuthDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->appRegionId) {
            @$query['AppRegionId'] = $request->appRegionId;
        }

        if (null !== $request->machineType) {
            @$query['MachineType'] = $request->machineType;
        }

        if (null !== $request->vendorType) {
            @$query['VendorType'] = $request->vendorType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetServerlessAppAuthDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetServerlessAppAuthDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Get Serverless Application Authorization Details.
     *
     * @param request - GetServerlessAppAuthDetailRequest
     *
     * @returns GetServerlessAppAuthDetailResponse
     *
     * @param GetServerlessAppAuthDetailRequest $request
     *
     * @return GetServerlessAppAuthDetailResponse
     */
    public function getServerlessAppAuthDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getServerlessAppAuthDetailWithOptions($request, $runtime);
    }

    /**
     * Get Serverless Authorization Overview.
     *
     * @param request - GetServerlessAuthSummaryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetServerlessAuthSummaryResponse
     *
     * @param GetServerlessAuthSummaryRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return GetServerlessAuthSummaryResponse
     */
    public function getServerlessAuthSummaryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appRegionId) {
            @$query['AppRegionId'] = $request->appRegionId;
        }

        if (null !== $request->machineType) {
            @$query['MachineType'] = $request->machineType;
        }

        if (null !== $request->vendorType) {
            @$query['VendorType'] = $request->vendorType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetServerlessAuthSummary',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetServerlessAuthSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Get Serverless Authorization Overview.
     *
     * @param request - GetServerlessAuthSummaryRequest
     *
     * @returns GetServerlessAuthSummaryResponse
     *
     * @param GetServerlessAuthSummaryRequest $request
     *
     * @return GetServerlessAuthSummaryResponse
     */
    public function getServerlessAuthSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getServerlessAuthSummaryWithOptions($request, $runtime);
    }

    /**
     * Queries the service trail that was delivered to ActionTrail.
     *
     * @param request - GetServiceTrailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetServiceTrailResponse
     *
     * @param GetServiceTrailRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return GetServiceTrailResponse
     */
    public function getServiceTrailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetServiceTrail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetServiceTrailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the service trail that was delivered to ActionTrail.
     *
     * @param request - GetServiceTrailRequest
     *
     * @returns GetServiceTrailResponse
     *
     * @param GetServiceTrailRequest $request
     *
     * @return GetServiceTrailResponse
     */
    public function getServiceTrail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getServiceTrailWithOptions($request, $runtime);
    }

    /**
     * Queries the usage details of templates provided in the feature of proactive defense for containers for rules.
     *
     * @param request - GetStrategyTemplateDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetStrategyTemplateDetailResponse
     *
     * @param GetStrategyTemplateDetailRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return GetStrategyTemplateDetailResponse
     */
    public function getStrategyTemplateDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->strategyId) {
            @$query['StrategyId'] = $request->strategyId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetStrategyTemplateDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetStrategyTemplateDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the usage details of templates provided in the feature of proactive defense for containers for rules.
     *
     * @param request - GetStrategyTemplateDetailRequest
     *
     * @returns GetStrategyTemplateDetailResponse
     *
     * @param GetStrategyTemplateDetailRequest $request
     *
     * @return GetStrategyTemplateDetailResponse
     */
    public function getStrategyTemplateDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getStrategyTemplateDetailWithOptions($request, $runtime);
    }

    /**
     * Get the list of modules supported by authorization.
     *
     * @param request - GetSupportedModulesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetSupportedModulesResponse
     *
     * @param GetSupportedModulesRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return GetSupportedModulesResponse
     */
    public function getSupportedModulesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetSupportedModules',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetSupportedModulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Get the list of modules supported by authorization.
     *
     * @param request - GetSupportedModulesRequest
     *
     * @returns GetSupportedModulesResponse
     *
     * @param GetSupportedModulesRequest $request
     *
     * @return GetSupportedModulesResponse
     */
    public function getSupportedModules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getSupportedModulesWithOptions($request, $runtime);
    }

    /**
     * Queries the statistics on alerts in one or more asset groups.
     *
     * @param request - GetSuspiciousStatisticsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetSuspiciousStatisticsResponse
     *
     * @param GetSuspiciousStatisticsRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return GetSuspiciousStatisticsResponse
     */
    public function getSuspiciousStatisticsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->groupIdList) {
            @$query['GroupIdList'] = $request->groupIdList;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetSuspiciousStatistics',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetSuspiciousStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics on alerts in one or more asset groups.
     *
     * @param request - GetSuspiciousStatisticsRequest
     *
     * @returns GetSuspiciousStatisticsResponse
     *
     * @param GetSuspiciousStatisticsRequest $request
     *
     * @return GetSuspiciousStatisticsResponse
     */
    public function getSuspiciousStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getSuspiciousStatisticsWithOptions($request, $runtime);
    }

    /**
     * Queries the details of a migration operation. For example, you can query the progress and status of a migration operation after you migrate a server from a region in the Chinese mainland to the Singapore region.
     *
     * @param request - GetSwitchRegionDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetSwitchRegionDetailResponse
     *
     * @param GetSwitchRegionDetailRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return GetSwitchRegionDetailResponse
     */
    public function getSwitchRegionDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetSwitchRegionDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetSwitchRegionDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of a migration operation. For example, you can query the progress and status of a migration operation after you migrate a server from a region in the Chinese mainland to the Singapore region.
     *
     * @param request - GetSwitchRegionDetailRequest
     *
     * @returns GetSwitchRegionDetailResponse
     *
     * @param GetSwitchRegionDetailRequest $request
     *
     * @return GetSwitchRegionDetailResponse
     */
    public function getSwitchRegionDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getSwitchRegionDetailWithOptions($request, $runtime);
    }

    /**
     * Checks whether you can submit a free quick scan task, which includes vulnerability detection in the free category and free check items of Cloud Security Posture Management (CSPM).
     *
     * @param request - GetTenantCheckAvailableRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetTenantCheckAvailableResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return GetTenantCheckAvailableResponse
     */
    public function getTenantCheckAvailableWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'GetTenantCheckAvailable',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetTenantCheckAvailableResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Checks whether you can submit a free quick scan task, which includes vulnerability detection in the free category and free check items of Cloud Security Posture Management (CSPM).
     *
     * @returns GetTenantCheckAvailableResponse
     *
     * @return GetTenantCheckAvailableResponse
     */
    public function getTenantCheckAvailable()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getTenantCheckAvailableWithOptions($runtime);
    }

    /**
     * Queries the language settings of log analysis.
     *
     * @param request - GetUserLangRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetUserLangResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return GetUserLangResponse
     */
    public function getUserLangWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'GetUserLang',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetUserLangResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the language settings of log analysis.
     *
     * @returns GetUserLangResponse
     *
     * @return GetUserLangResponse
     */
    public function getUserLang()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getUserLangWithOptions($runtime);
    }

    /**
     * Queries the configurations of a periodic virus scan task.
     *
     * @param request - GetVirusScanConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetVirusScanConfigResponse
     *
     * @param GetVirusScanConfigRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return GetVirusScanConfigResponse
     */
    public function getVirusScanConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->taskType) {
            @$query['TaskType'] = $request->taskType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetVirusScanConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetVirusScanConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configurations of a periodic virus scan task.
     *
     * @param request - GetVirusScanConfigRequest
     *
     * @returns GetVirusScanConfigResponse
     *
     * @param GetVirusScanConfigRequest $request
     *
     * @return GetVirusScanConfigResponse
     */
    public function getVirusScanConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getVirusScanConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the information about the latest virus scan task.
     *
     * @param request - GetVirusScanLatestTaskStatisticRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetVirusScanLatestTaskStatisticResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return GetVirusScanLatestTaskStatisticResponse
     */
    public function getVirusScanLatestTaskStatisticWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'GetVirusScanLatestTaskStatistic',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetVirusScanLatestTaskStatisticResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about the latest virus scan task.
     *
     * @returns GetVirusScanLatestTaskStatisticResponse
     *
     * @return GetVirusScanLatestTaskStatisticResponse
     */
    public function getVirusScanLatestTaskStatistic()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getVirusScanLatestTaskStatisticWithOptions($runtime);
    }

    /**
     * Queries the statistics on vulnerabilities in asset groups.
     *
     * @param request - GetVulStatisticsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetVulStatisticsResponse
     *
     * @param GetVulStatisticsRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return GetVulStatisticsResponse
     */
    public function getVulStatisticsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->groupIdList) {
            @$query['GroupIdList'] = $request->groupIdList;
        }

        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->typeList) {
            @$query['TypeList'] = $request->typeList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetVulStatistics',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetVulStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics on vulnerabilities in asset groups.
     *
     * @param request - GetVulStatisticsRequest
     *
     * @returns GetVulStatisticsResponse
     *
     * @param GetVulStatisticsRequest $request
     *
     * @return GetVulStatisticsResponse
     */
    public function getVulStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getVulStatisticsWithOptions($request, $runtime);
    }

    /**
     * Queries information about a vulnerability whitelist.
     *
     * @param request - GetVulWhitelistRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetVulWhitelistResponse
     *
     * @param GetVulWhitelistRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return GetVulWhitelistResponse
     */
    public function getVulWhitelistWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->vulWhitelistId) {
            @$query['VulWhitelistId'] = $request->vulWhitelistId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetVulWhitelist',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetVulWhitelistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries information about a vulnerability whitelist.
     *
     * @param request - GetVulWhitelistRequest
     *
     * @returns GetVulWhitelistResponse
     *
     * @param GetVulWhitelistRequest $request
     *
     * @return GetVulWhitelistResponse
     */
    public function getVulWhitelist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getVulWhitelistWithOptions($request, $runtime);
    }

    /**
     * Authorization for Switching Migration.
     *
     * @param request - GrantSwitchAgreementRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GrantSwitchAgreementResponse
     *
     * @param GrantSwitchAgreementRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return GrantSwitchAgreementResponse
     */
    public function grantSwitchAgreementWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->isAgree) {
            @$query['IsAgree'] = $request->isAgree;
        }

        if (null !== $request->isConfirmed) {
            @$query['IsConfirmed'] = $request->isConfirmed;
        }

        if (null !== $request->isImmediate) {
            @$query['IsImmediate'] = $request->isImmediate;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GrantSwitchAgreement',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GrantSwitchAgreementResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Authorization for Switching Migration.
     *
     * @param request - GrantSwitchAgreementRequest
     *
     * @returns GrantSwitchAgreementResponse
     *
     * @param GrantSwitchAgreementRequest $request
     *
     * @return GrantSwitchAgreementResponse
     */
    public function grantSwitchAgreement($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->grantSwitchAgreementWithOptions($request, $runtime);
    }

    /**
     * Handle Malicious Files.
     *
     * @param request - HandleMaliciousFilesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns HandleMaliciousFilesResponse
     *
     * @param HandleMaliciousFilesRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return HandleMaliciousFilesResponse
     */
    public function handleMaliciousFilesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->fileIdList) {
            @$query['FileIdList'] = $request->fileIdList;
        }

        if (null !== $request->operation) {
            @$query['Operation'] = $request->operation;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'HandleMaliciousFiles',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return HandleMaliciousFilesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Handle Malicious Files.
     *
     * @param request - HandleMaliciousFilesRequest
     *
     * @returns HandleMaliciousFilesResponse
     *
     * @param HandleMaliciousFilesRequest $request
     *
     * @return HandleMaliciousFilesResponse
     */
    public function handleMaliciousFiles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->handleMaliciousFilesWithOptions($request, $runtime);
    }

    /**
     * Handles alert events.
     *
     * @param request - HandleSecurityEventsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns HandleSecurityEventsResponse
     *
     * @param HandleSecurityEventsRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return HandleSecurityEventsResponse
     */
    public function handleSecurityEventsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->markBatch) {
            @$query['MarkBatch'] = $request->markBatch;
        }

        if (null !== $request->markMissParam) {
            @$query['MarkMissParam'] = $request->markMissParam;
        }

        if (null !== $request->operationCode) {
            @$query['OperationCode'] = $request->operationCode;
        }

        if (null !== $request->operationParams) {
            @$query['OperationParams'] = $request->operationParams;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        if (null !== $request->securityEventIds) {
            @$query['SecurityEventIds'] = $request->securityEventIds;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'HandleSecurityEvents',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return HandleSecurityEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Handles alert events.
     *
     * @param request - HandleSecurityEventsRequest
     *
     * @returns HandleSecurityEventsResponse
     *
     * @param HandleSecurityEventsRequest $request
     *
     * @return HandleSecurityEventsResponse
     */
    public function handleSecurityEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->handleSecurityEventsWithOptions($request, $runtime);
    }

    /**
     * Batch process malicious alerts.
     *
     * @remarks
     *
     * @param request - HandleSimilarMaliciousFilesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns HandleSimilarMaliciousFilesResponse
     *
     * @param HandleSimilarMaliciousFilesRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return HandleSimilarMaliciousFilesResponse
     */
    public function handleSimilarMaliciousFilesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->eventId) {
            @$query['EventId'] = $request->eventId;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->operation) {
            @$query['Operation'] = $request->operation;
        }

        if (null !== $request->scanRange) {
            @$query['ScanRange'] = $request->scanRange;
        }

        if (null !== $request->scenario) {
            @$query['Scenario'] = $request->scenario;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'HandleSimilarMaliciousFiles',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return HandleSimilarMaliciousFilesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Batch process malicious alerts.
     *
     * @remarks
     *
     * @param request - HandleSimilarMaliciousFilesRequest
     *
     * @returns HandleSimilarMaliciousFilesResponse
     *
     * @param HandleSimilarMaliciousFilesRequest $request
     *
     * @return HandleSimilarMaliciousFilesResponse
     */
    public function handleSimilarMaliciousFiles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->handleSimilarMaliciousFilesWithOptions($request, $runtime);
    }

    /**
     * Handles multiple alert events that are triggered by the same IP address rule or IP address rules of the same type at a time.
     *
     * @param request - HandleSimilarSecurityEventsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns HandleSimilarSecurityEventsResponse
     *
     * @param HandleSimilarSecurityEventsRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return HandleSimilarSecurityEventsResponse
     */
    public function handleSimilarSecurityEventsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->markMissParam) {
            @$query['MarkMissParam'] = $request->markMissParam;
        }

        if (null !== $request->operationCode) {
            @$query['OperationCode'] = $request->operationCode;
        }

        if (null !== $request->operationParams) {
            @$query['OperationParams'] = $request->operationParams;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'HandleSimilarSecurityEvents',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return HandleSimilarSecurityEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Handles multiple alert events that are triggered by the same IP address rule or IP address rules of the same type at a time.
     *
     * @param request - HandleSimilarSecurityEventsRequest
     *
     * @returns HandleSimilarSecurityEventsResponse
     *
     * @param HandleSimilarSecurityEventsRequest $request
     *
     * @return HandleSimilarSecurityEventsResponse
     */
    public function handleSimilarSecurityEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->handleSimilarSecurityEventsWithOptions($request, $runtime);
    }

    /**
     * Adds risk items to the whitelist or removes risk items from the whitelist by specifying servers and risk items.
     *
     * @param request - IgnoreCheckItemsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns IgnoreCheckItemsResponse
     *
     * @param IgnoreCheckItemsRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return IgnoreCheckItemsResponse
     */
    public function ignoreCheckItemsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->checkAndRiskTypeList) {
            @$query['CheckAndRiskTypeList'] = $request->checkAndRiskTypeList;
        }

        if (null !== $request->checkIds) {
            @$query['CheckIds'] = $request->checkIds;
        }

        if (null !== $request->containerItems) {
            @$query['ContainerItems'] = $request->containerItems;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->reason) {
            @$query['Reason'] = $request->reason;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        if (null !== $request->uuidList) {
            @$query['UuidList'] = $request->uuidList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'IgnoreCheckItems',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return IgnoreCheckItemsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds risk items to the whitelist or removes risk items from the whitelist by specifying servers and risk items.
     *
     * @param request - IgnoreCheckItemsRequest
     *
     * @returns IgnoreCheckItemsResponse
     *
     * @param IgnoreCheckItemsRequest $request
     *
     * @return IgnoreCheckItemsResponse
     */
    public function ignoreCheckItems($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->ignoreCheckItemsWithOptions($request, $runtime);
    }

    /**
     * Ignores multiple baseline risk items at a time or cancels the ignore action that is performed on multiple baseline risk items at a time.
     *
     * @deprecated openAPI IgnoreHcCheckWarnings is deprecated, please use Sas::2018-12-03::IgnoreCheckItems instead
     *
     * @param request - IgnoreHcCheckWarningsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns IgnoreHcCheckWarningsResponse
     *
     * @param IgnoreHcCheckWarningsRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return IgnoreHcCheckWarningsResponse
     */
    public function ignoreHcCheckWarningsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->checkIds) {
            @$query['CheckIds'] = $request->checkIds;
        }

        if (null !== $request->checkWarningIds) {
            @$query['CheckWarningIds'] = $request->checkWarningIds;
        }

        if (null !== $request->reason) {
            @$query['Reason'] = $request->reason;
        }

        if (null !== $request->riskId) {
            @$query['RiskId'] = $request->riskId;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'IgnoreHcCheckWarnings',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return IgnoreHcCheckWarningsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Ignores multiple baseline risk items at a time or cancels the ignore action that is performed on multiple baseline risk items at a time.
     *
     * @deprecated openAPI IgnoreHcCheckWarnings is deprecated, please use Sas::2018-12-03::IgnoreCheckItems instead
     *
     * @param request - IgnoreHcCheckWarningsRequest
     *
     * @returns IgnoreHcCheckWarningsResponse
     *
     * @param IgnoreHcCheckWarningsRequest $request
     *
     * @return IgnoreHcCheckWarningsResponse
     */
    public function ignoreHcCheckWarnings($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->ignoreHcCheckWarningsWithOptions($request, $runtime);
    }

    /**
     * Adds the result scanned by an IDC probe to the whitelist or ignores the scan result.
     *
     * @param request - IgnoreIdcProbeScanResultRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns IgnoreIdcProbeScanResultResponse
     *
     * @param IgnoreIdcProbeScanResultRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return IgnoreIdcProbeScanResultResponse
     */
    public function ignoreIdcProbeScanResultWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ignoreAction) {
            @$query['IgnoreAction'] = $request->ignoreAction;
        }

        if (null !== $request->scanResultIds) {
            @$query['ScanResultIds'] = $request->scanResultIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'IgnoreIdcProbeScanResult',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return IgnoreIdcProbeScanResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds the result scanned by an IDC probe to the whitelist or ignores the scan result.
     *
     * @param request - IgnoreIdcProbeScanResultRequest
     *
     * @returns IgnoreIdcProbeScanResultResponse
     *
     * @param IgnoreIdcProbeScanResultRequest $request
     *
     * @return IgnoreIdcProbeScanResultResponse
     */
    public function ignoreIdcProbeScanResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->ignoreIdcProbeScanResultWithOptions($request, $runtime);
    }

    /**
     * Install Aegis client on Lingjun bare metal.
     *
     * @param tmpReq - InstallAegisForLingjunRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns InstallAegisForLingjunResponse
     *
     * @param InstallAegisForLingjunRequest $tmpReq
     * @param RuntimeOptions                $runtime
     *
     * @return InstallAegisForLingjunResponse
     */
    public function installAegisForLingjunWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new InstallAegisForLingjunShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->uuids) {
            $request->uuidsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->uuids, 'Uuids', 'json');
        }

        $query = [];
        if (null !== $request->uuidsShrink) {
            @$query['Uuids'] = $request->uuidsShrink;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'InstallAegisForLingjun',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return InstallAegisForLingjunResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Install Aegis client on Lingjun bare metal.
     *
     * @param request - InstallAegisForLingjunRequest
     *
     * @returns InstallAegisForLingjunResponse
     *
     * @param InstallAegisForLingjunRequest $request
     *
     * @return InstallAegisForLingjunResponse
     */
    public function installAegisForLingjun($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->installAegisForLingjunWithOptions($request, $runtime);
    }

    /**
     * Installs the anti-ransomware agent.
     *
     * @param request - InstallBackupClientRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns InstallBackupClientResponse
     *
     * @param InstallBackupClientRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return InstallBackupClientResponse
     */
    public function installBackupClientWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->policyVersion) {
            @$query['PolicyVersion'] = $request->policyVersion;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        if (null !== $request->uuidList) {
            @$query['UuidList'] = $request->uuidList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'InstallBackupClient',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return InstallBackupClientResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Installs the anti-ransomware agent.
     *
     * @param request - InstallBackupClientRequest
     *
     * @returns InstallBackupClientResponse
     *
     * @param InstallBackupClientRequest $request
     *
     * @return InstallBackupClientResponse
     */
    public function installBackupClient($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->installBackupClientWithOptions($request, $runtime);
    }

    /**
     * Installs the CloudMonitor agent on specified servers.
     *
     * @remarks
     * > Before you call this operation, make sure that the Security Center agent on your servers is online and the servers can access Alibaba Cloud services.
     *
     * @param request - InstallCloudMonitorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns InstallCloudMonitorResponse
     *
     * @param InstallCloudMonitorRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return InstallCloudMonitorResponse
     */
    public function installCloudMonitorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->agentAccessKey) {
            @$query['AgentAccessKey'] = $request->agentAccessKey;
        }

        if (null !== $request->agentSecretKey) {
            @$query['AgentSecretKey'] = $request->agentSecretKey;
        }

        if (null !== $request->argusVersion) {
            @$query['ArgusVersion'] = $request->argusVersion;
        }

        if (null !== $request->instanceIdList) {
            @$query['InstanceIdList'] = $request->instanceIdList;
        }

        if (null !== $request->uuidList) {
            @$query['UuidList'] = $request->uuidList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'InstallCloudMonitor',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return InstallCloudMonitorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Installs the CloudMonitor agent on specified servers.
     *
     * @remarks
     * > Before you call this operation, make sure that the Security Center agent on your servers is online and the servers can access Alibaba Cloud services.
     *
     * @param request - InstallCloudMonitorRequest
     *
     * @returns InstallCloudMonitorResponse
     *
     * @param InstallCloudMonitorRequest $request
     *
     * @return InstallCloudMonitorResponse
     */
    public function installCloudMonitor($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->installCloudMonitorWithOptions($request, $runtime);
    }

    /**
     * Installs the Security Center agent on a proxy server in a hybrid cloud.
     *
     * @param request - InstallHybridProxyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns InstallHybridProxyResponse
     *
     * @param InstallHybridProxyRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return InstallHybridProxyResponse
     */
    public function installHybridProxyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterName) {
            @$query['ClusterName'] = $request->clusterName;
        }

        if (null !== $request->installCode) {
            @$query['InstallCode'] = $request->installCode;
        }

        if (null !== $request->yundunUuids) {
            @$query['YundunUuids'] = $request->yundunUuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'InstallHybridProxy',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return InstallHybridProxyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Installs the Security Center agent on a proxy server in a hybrid cloud.
     *
     * @param request - InstallHybridProxyRequest
     *
     * @returns InstallHybridProxyResponse
     *
     * @param InstallHybridProxyRequest $request
     *
     * @return InstallHybridProxyResponse
     */
    public function installHybridProxy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->installHybridProxyWithOptions($request, $runtime);
    }

    /**
     * Installs the CloudMonitor agent on a server that is not deployed on Alibaba Cloud.
     *
     * @param request - InstallPmAgentRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns InstallPmAgentResponse
     *
     * @param InstallPmAgentRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return InstallPmAgentResponse
     */
    public function installPmAgentWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'InstallPmAgent',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return InstallPmAgentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Installs the CloudMonitor agent on a server that is not deployed on Alibaba Cloud.
     *
     * @param request - InstallPmAgentRequest
     *
     * @returns InstallPmAgentResponse
     *
     * @param InstallPmAgentRequest $request
     *
     * @return InstallPmAgentResponse
     */
    public function installPmAgent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->installPmAgentWithOptions($request, $runtime);
    }

    /**
     * Installs the anti-ransomware agent for databases.
     *
     * @param request - InstallUniBackupAgentRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns InstallUniBackupAgentResponse
     *
     * @param InstallUniBackupAgentRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return InstallUniBackupAgentResponse
     */
    public function installUniBackupAgentWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->policyId) {
            @$query['PolicyId'] = $request->policyId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'InstallUniBackupAgent',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return InstallUniBackupAgentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Installs the anti-ransomware agent for databases.
     *
     * @param request - InstallUniBackupAgentRequest
     *
     * @returns InstallUniBackupAgentResponse
     *
     * @param InstallUniBackupAgentRequest $request
     *
     * @return InstallUniBackupAgentResponse
     */
    public function installUniBackupAgent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->installUniBackupAgentWithOptions($request, $runtime);
    }

    /**
     * Adds processes to the process whitelist of web tamper proofing.
     *
     * @param request - JoinWebLockProcessWhiteListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns JoinWebLockProcessWhiteListResponse
     *
     * @param JoinWebLockProcessWhiteListRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return JoinWebLockProcessWhiteListResponse
     */
    public function joinWebLockProcessWhiteListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->processPaths) {
            @$query['ProcessPaths'] = $request->processPaths;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'JoinWebLockProcessWhiteList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return JoinWebLockProcessWhiteListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds processes to the process whitelist of web tamper proofing.
     *
     * @param request - JoinWebLockProcessWhiteListRequest
     *
     * @returns JoinWebLockProcessWhiteListResponse
     *
     * @param JoinWebLockProcessWhiteListRequest $request
     *
     * @return JoinWebLockProcessWhiteListResponse
     */
    public function joinWebLockProcessWhiteList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->joinWebLockProcessWhiteListWithOptions($request, $runtime);
    }

    /**
     * Queries members in the resource directory that is involved when the multi-account management feature is enabled.
     *
     * @remarks
     * You must use the management account of your resource directory or a delegated administrator account of Security Center to call this operation.
     *
     * @param request - ListAccountsInResourceDirectoryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListAccountsInResourceDirectoryResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return ListAccountsInResourceDirectoryResponse
     */
    public function listAccountsInResourceDirectoryWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'ListAccountsInResourceDirectory',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListAccountsInResourceDirectoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries members in the resource directory that is involved when the multi-account management feature is enabled.
     *
     * @remarks
     * You must use the management account of your resource directory or a delegated administrator account of Security Center to call this operation.
     *
     * @returns ListAccountsInResourceDirectoryResponse
     *
     * @return ListAccountsInResourceDirectoryResponse
     */
    public function listAccountsInResourceDirectory()
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAccountsInResourceDirectoryWithOptions($runtime);
    }

    /**
     * Queries defense rules against container escapes.
     *
     * @param request - ListAegisContainerPluginRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListAegisContainerPluginRuleResponse
     *
     * @param ListAegisContainerPluginRuleRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return ListAegisContainerPluginRuleResponse
     */
    public function listAegisContainerPluginRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->criteria) {
            @$query['Criteria'] = $request->criteria;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->ruleType) {
            @$query['RuleType'] = $request->ruleType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListAegisContainerPluginRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListAegisContainerPluginRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries defense rules against container escapes.
     *
     * @param request - ListAegisContainerPluginRuleRequest
     *
     * @returns ListAegisContainerPluginRuleResponse
     *
     * @param ListAegisContainerPluginRuleRequest $request
     *
     * @return ListAegisContainerPluginRuleResponse
     */
    public function listAegisContainerPluginRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAegisContainerPluginRuleWithOptions($request, $runtime);
    }

    /**
     * Query the Aegis client installation result for Lingjun bare metal.
     *
     * @param tmpReq - ListAegisForLingjunStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListAegisForLingjunStatusResponse
     *
     * @param ListAegisForLingjunStatusRequest $tmpReq
     * @param RuntimeOptions                   $runtime
     *
     * @return ListAegisForLingjunStatusResponse
     */
    public function listAegisForLingjunStatusWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new ListAegisForLingjunStatusShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->uuids) {
            $request->uuidsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->uuids, 'Uuids', 'json');
        }

        $query = [];
        if (null !== $request->uuidsShrink) {
            @$query['Uuids'] = $request->uuidsShrink;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListAegisForLingjunStatus',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListAegisForLingjunStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Query the Aegis client installation result for Lingjun bare metal.
     *
     * @param request - ListAegisForLingjunStatusRequest
     *
     * @returns ListAegisForLingjunStatusResponse
     *
     * @param ListAegisForLingjunStatusRequest $request
     *
     * @return ListAegisForLingjunStatusResponse
     */
    public function listAegisForLingjunStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAegisForLingjunStatusWithOptions($request, $runtime);
    }

    /**
     * Query agentless detection assets.
     *
     * @param request - ListAgentlessAssetRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListAgentlessAssetResponse
     *
     * @param ListAgentlessAssetRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return ListAgentlessAssetResponse
     */
    public function listAgentlessAssetWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->diskType) {
            @$query['DiskType'] = $request->diskType;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->instanceName) {
            @$query['InstanceName'] = $request->instanceName;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->platform) {
            @$query['Platform'] = $request->platform;
        }

        if (null !== $request->scanRegionId) {
            @$query['ScanRegionId'] = $request->scanRegionId;
        }

        if (null !== $request->targetType) {
            @$query['TargetType'] = $request->targetType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListAgentlessAsset',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListAgentlessAssetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Query agentless detection assets.
     *
     * @param request - ListAgentlessAssetRequest
     *
     * @returns ListAgentlessAssetResponse
     *
     * @param ListAgentlessAssetRequest $request
     *
     * @return ListAgentlessAssetResponse
     */
    public function listAgentlessAsset($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAgentlessAssetWithOptions($request, $runtime);
    }

    /**
     * Queries malicious files that are detected by agentless detection tasks.
     *
     * @param request - ListAgentlessMaliciousFilesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListAgentlessMaliciousFilesResponse
     *
     * @param ListAgentlessMaliciousFilesRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return ListAgentlessMaliciousFilesResponse
     */
    public function listAgentlessMaliciousFilesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->dealed) {
            @$query['Dealed'] = $request->dealed;
        }

        if (null !== $request->eventId) {
            @$query['EventId'] = $request->eventId;
        }

        if (null !== $request->fuzzyMaliciousName) {
            @$query['FuzzyMaliciousName'] = $request->fuzzyMaliciousName;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->levels) {
            @$query['Levels'] = $request->levels;
        }

        if (null !== $request->maliciousMd5) {
            @$query['MaliciousMd5'] = $request->maliciousMd5;
        }

        if (null !== $request->maliciousType) {
            @$query['MaliciousType'] = $request->maliciousType;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->scanRange) {
            @$query['ScanRange'] = $request->scanRange;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListAgentlessMaliciousFiles',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListAgentlessMaliciousFilesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries malicious files that are detected by agentless detection tasks.
     *
     * @param request - ListAgentlessMaliciousFilesRequest
     *
     * @returns ListAgentlessMaliciousFilesResponse
     *
     * @param ListAgentlessMaliciousFilesRequest $request
     *
     * @return ListAgentlessMaliciousFilesResponse
     */
    public function listAgentlessMaliciousFiles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAgentlessMaliciousFilesWithOptions($request, $runtime);
    }

    /**
     * Queries the regions that are supported by the agentless detection feature.
     *
     * @param request - ListAgentlessRegionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListAgentlessRegionResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return ListAgentlessRegionResponse
     */
    public function listAgentlessRegionWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'ListAgentlessRegion',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListAgentlessRegionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the regions that are supported by the agentless detection feature.
     *
     * @returns ListAgentlessRegionResponse
     *
     * @return ListAgentlessRegionResponse
     */
    public function listAgentlessRegion()
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAgentlessRegionWithOptions($runtime);
    }

    /**
     * Obtains the risks associated with an agentless detection event.
     *
     * @param request - ListAgentlessRelateMaliciousRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListAgentlessRelateMaliciousResponse
     *
     * @param ListAgentlessRelateMaliciousRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return ListAgentlessRelateMaliciousResponse
     */
    public function listAgentlessRelateMaliciousWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->eventId) {
            @$query['EventId'] = $request->eventId;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->scenario) {
            @$query['Scenario'] = $request->scenario;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListAgentlessRelateMalicious',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListAgentlessRelateMaliciousResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Obtains the risks associated with an agentless detection event.
     *
     * @param request - ListAgentlessRelateMaliciousRequest
     *
     * @returns ListAgentlessRelateMaliciousResponse
     *
     * @param ListAgentlessRelateMaliciousRequest $request
     *
     * @return ListAgentlessRelateMaliciousResponse
     */
    public function listAgentlessRelateMalicious($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAgentlessRelateMaliciousWithOptions($request, $runtime);
    }

    /**
     * Queries at-risk hosts that are detected by the agentless detection feature.
     *
     * @param request - ListAgentlessRiskUuidRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListAgentlessRiskUuidResponse
     *
     * @param ListAgentlessRiskUuidRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return ListAgentlessRiskUuidResponse
     */
    public function listAgentlessRiskUuidWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->instanceName) {
            @$query['InstanceName'] = $request->instanceName;
        }

        if (null !== $request->internetIp) {
            @$query['InternetIp'] = $request->internetIp;
        }

        if (null !== $request->intranetIp) {
            @$query['IntranetIp'] = $request->intranetIp;
        }

        if (null !== $request->machineName) {
            @$query['MachineName'] = $request->machineName;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->risk) {
            @$query['Risk'] = $request->risk;
        }

        if (null !== $request->targetName) {
            @$query['TargetName'] = $request->targetName;
        }

        if (null !== $request->targetType) {
            @$query['TargetType'] = $request->targetType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListAgentlessRiskUuid',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListAgentlessRiskUuidResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries at-risk hosts that are detected by the agentless detection feature.
     *
     * @param request - ListAgentlessRiskUuidRequest
     *
     * @returns ListAgentlessRiskUuidResponse
     *
     * @param ListAgentlessRiskUuidRequest $request
     *
     * @return ListAgentlessRiskUuidResponse
     */
    public function listAgentlessRiskUuid($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAgentlessRiskUuidWithOptions($request, $runtime);
    }

    /**
     * Queries agentless detection tasks.
     *
     * @param request - ListAgentlessTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListAgentlessTaskResponse
     *
     * @param ListAgentlessTaskRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return ListAgentlessTaskResponse
     */
    public function listAgentlessTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->internetIp) {
            @$query['InternetIp'] = $request->internetIp;
        }

        if (null !== $request->intranetIp) {
            @$query['IntranetIp'] = $request->intranetIp;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->machineName) {
            @$query['MachineName'] = $request->machineName;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->rootTask) {
            @$query['RootTask'] = $request->rootTask;
        }

        if (null !== $request->rootTaskId) {
            @$query['RootTaskId'] = $request->rootTaskId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->targetName) {
            @$query['TargetName'] = $request->targetName;
        }

        if (null !== $request->targetType) {
            @$query['TargetType'] = $request->targetType;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListAgentlessTask',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListAgentlessTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries agentless detection tasks.
     *
     * @param request - ListAgentlessTaskRequest
     *
     * @returns ListAgentlessTaskResponse
     *
     * @param ListAgentlessTaskRequest $request
     *
     * @return ListAgentlessTaskResponse
     */
    public function listAgentlessTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAgentlessTaskWithOptions($request, $runtime);
    }

    /**
     * Queries the configurations for cleaning offline hosts whose provider cannot be identified.
     *
     * @param request - ListAssetCleanConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListAssetCleanConfigResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return ListAssetCleanConfigResponse
     */
    public function listAssetCleanConfigWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'ListAssetCleanConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListAssetCleanConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configurations for cleaning offline hosts whose provider cannot be identified.
     *
     * @returns ListAssetCleanConfigResponse
     *
     * @return ListAssetCleanConfigResponse
     */
    public function listAssetCleanConfig()
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAssetCleanConfigWithOptions($runtime);
    }

    /**
     * Queries the custom upgrade information about assets.
     *
     * @param request - ListAssetInfoPublishRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListAssetInfoPublishResponse
     *
     * @param ListAssetInfoPublishRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return ListAssetInfoPublishResponse
     */
    public function listAssetInfoPublishWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->uuidList) {
            @$query['UuidList'] = $request->uuidList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListAssetInfoPublish',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListAssetInfoPublishResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the custom upgrade information about assets.
     *
     * @param request - ListAssetInfoPublishRequest
     *
     * @returns ListAssetInfoPublishResponse
     *
     * @param ListAssetInfoPublishRequest $request
     *
     * @return ListAssetInfoPublishResponse
     */
    public function listAssetInfoPublish($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAssetInfoPublishWithOptions($request, $runtime);
    }

    /**
     * Queries the configurations of asset synchronization.
     *
     * @param request - ListAssetRefreshTaskConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListAssetRefreshTaskConfigResponse
     *
     * @param ListAssetRefreshTaskConfigRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return ListAssetRefreshTaskConfigResponse
     */
    public function listAssetRefreshTaskConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->refreshConfigType) {
            @$query['RefreshConfigType'] = $request->refreshConfigType;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->targetId) {
            @$query['TargetId'] = $request->targetId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListAssetRefreshTaskConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListAssetRefreshTaskConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configurations of asset synchronization.
     *
     * @param request - ListAssetRefreshTaskConfigRequest
     *
     * @returns ListAssetRefreshTaskConfigResponse
     *
     * @param ListAssetRefreshTaskConfigRequest $request
     *
     * @return ListAssetRefreshTaskConfigResponse
     */
    public function listAssetRefreshTaskConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAssetRefreshTaskConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the selected assets.
     *
     * @param request - ListAssetSelectionSelectedTargetRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListAssetSelectionSelectedTargetResponse
     *
     * @param ListAssetSelectionSelectedTargetRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return ListAssetSelectionSelectedTargetResponse
     */
    public function listAssetSelectionSelectedTargetWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->selectionKey) {
            @$query['SelectionKey'] = $request->selectionKey;
        }

        if (null !== $request->targetList) {
            @$query['TargetList'] = $request->targetList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListAssetSelectionSelectedTarget',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListAssetSelectionSelectedTargetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the selected assets.
     *
     * @param request - ListAssetSelectionSelectedTargetRequest
     *
     * @returns ListAssetSelectionSelectedTargetResponse
     *
     * @param ListAssetSelectionSelectedTargetRequest $request
     *
     * @return ListAssetSelectionSelectedTargetResponse
     */
    public function listAssetSelectionSelectedTarget($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAssetSelectionSelectedTargetWithOptions($request, $runtime);
    }

    /**
     * Queries the required asset.
     *
     * @param request - ListAssetSelectionTargetRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListAssetSelectionTargetResponse
     *
     * @param ListAssetSelectionTargetRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return ListAssetSelectionTargetResponse
     */
    public function listAssetSelectionTargetWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->selectionKey) {
            @$query['SelectionKey'] = $request->selectionKey;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListAssetSelectionTarget',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListAssetSelectionTargetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the required asset.
     *
     * @param request - ListAssetSelectionTargetRequest
     *
     * @returns ListAssetSelectionTargetResponse
     *
     * @param ListAssetSelectionTargetRequest $request
     *
     * @return ListAssetSelectionTargetResponse
     */
    public function listAssetSelectionTarget($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAssetSelectionTargetWithOptions($request, $runtime);
    }

    /**
     * Query Attack Path Events.
     *
     * @param request - ListAttackPathEventRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListAttackPathEventResponse
     *
     * @param ListAttackPathEventRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ListAttackPathEventResponse
     */
    public function listAttackPathEventWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->attackPathAssetList) {
            @$query['AttackPathAssetList'] = $request->attackPathAssetList;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->pathNameDesc) {
            @$query['PathNameDesc'] = $request->pathNameDesc;
        }

        if (null !== $request->pathType) {
            @$query['PathType'] = $request->pathType;
        }

        if (null !== $request->riskLevelList) {
            @$query['RiskLevelList'] = $request->riskLevelList;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListAttackPathEvent',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListAttackPathEventResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Query Attack Path Events.
     *
     * @param request - ListAttackPathEventRequest
     *
     * @returns ListAttackPathEventResponse
     *
     * @param ListAttackPathEventRequest $request
     *
     * @return ListAttackPathEventResponse
     */
    public function listAttackPathEvent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAttackPathEventWithOptions($request, $runtime);
    }

    /**
     * Query Attack Path Whitelist List.
     *
     * @param request - ListAttackPathWhitelistRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListAttackPathWhitelistResponse
     *
     * @param ListAttackPathWhitelistRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ListAttackPathWhitelistResponse
     */
    public function listAttackPathWhitelistWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->pathNameDesc) {
            @$query['PathNameDesc'] = $request->pathNameDesc;
        }

        if (null !== $request->pathType) {
            @$query['PathType'] = $request->pathType;
        }

        if (null !== $request->whitelistName) {
            @$query['WhitelistName'] = $request->whitelistName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListAttackPathWhitelist',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListAttackPathWhitelistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Query Attack Path Whitelist List.
     *
     * @param request - ListAttackPathWhitelistRequest
     *
     * @returns ListAttackPathWhitelistResponse
     *
     * @param ListAttackPathWhitelistRequest $request
     *
     * @return ListAttackPathWhitelistResponse
     */
    public function listAttackPathWhitelist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAttackPathWhitelistWithOptions($request, $runtime);
    }

    /**
     * Queries asset auto-tagging rules that are created by using the feature of asset management rules. You can create rules on the System Configuration > Feature Settings > Multi-cloud Configuration Management > Asset Management Rule page in the Security Center console.
     *
     * @param request - ListAutoTagRulesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListAutoTagRulesResponse
     *
     * @param ListAutoTagRulesRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return ListAutoTagRulesResponse
     */
    public function listAutoTagRulesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->ruleName) {
            @$query['RuleName'] = $request->ruleName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListAutoTagRules',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListAutoTagRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries asset auto-tagging rules that are created by using the feature of asset management rules. You can create rules on the System Configuration > Feature Settings > Multi-cloud Configuration Management > Asset Management Rule page in the Security Center console.
     *
     * @param request - ListAutoTagRulesRequest
     *
     * @returns ListAutoTagRulesResponse
     *
     * @param ListAutoTagRulesRequest $request
     *
     * @return ListAutoTagRulesResponse
     */
    public function listAutoTagRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAutoTagRulesWithOptions($request, $runtime);
    }

    /**
     * Query Attack Path List.
     *
     * @param request - ListAvailableAttackPathRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListAvailableAttackPathResponse
     *
     * @param ListAvailableAttackPathRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ListAvailableAttackPathResponse
     */
    public function listAvailableAttackPathWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListAvailableAttackPath',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListAvailableAttackPathResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Query Attack Path List.
     *
     * @param request - ListAvailableAttackPathRequest
     *
     * @returns ListAvailableAttackPathResponse
     *
     * @param ListAvailableAttackPathRequest $request
     *
     * @return ListAvailableAttackPathResponse
     */
    public function listAvailableAttackPath($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAvailableAttackPathWithOptions($request, $runtime);
    }

    /**
     * Queries the information about available honeypot templates.
     *
     * @param request - ListAvailableHoneypotRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListAvailableHoneypotResponse
     *
     * @param ListAvailableHoneypotRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return ListAvailableHoneypotResponse
     */
    public function listAvailableHoneypotWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->nodeId) {
            @$query['NodeId'] = $request->nodeId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListAvailableHoneypot',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListAvailableHoneypotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about available honeypot templates.
     *
     * @param request - ListAvailableHoneypotRequest
     *
     * @returns ListAvailableHoneypotResponse
     *
     * @param ListAvailableHoneypotRequest $request
     *
     * @return ListAvailableHoneypotResponse
     */
    public function listAvailableHoneypot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAvailableHoneypotWithOptions($request, $runtime);
    }

    /**
     * Queries backup records.
     *
     * @param request - ListBackupRecordRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListBackupRecordResponse
     *
     * @param ListBackupRecordRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return ListBackupRecordResponse
     */
    public function listBackupRecordWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->backupEndTime) {
            @$query['BackupEndTime'] = $request->backupEndTime;
        }

        if (null !== $request->backupStartTime) {
            @$query['BackupStartTime'] = $request->backupStartTime;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->machineRemark) {
            @$query['MachineRemark'] = $request->machineRemark;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->statusList) {
            @$query['StatusList'] = $request->statusList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListBackupRecord',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListBackupRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries backup records.
     *
     * @param request - ListBackupRecordRequest
     *
     * @returns ListBackupRecordResponse
     *
     * @param ListBackupRecordRequest $request
     *
     * @return ListBackupRecordResponse
     */
    public function listBackupRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listBackupRecordWithOptions($request, $runtime);
    }

    /**
     * Queries the whitelist rules for a baseline check item.
     *
     * @param tmpReq - ListBaselineCheckWhiteRecordRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListBaselineCheckWhiteRecordResponse
     *
     * @param ListBaselineCheckWhiteRecordRequest $tmpReq
     * @param RuntimeOptions                      $runtime
     *
     * @return ListBaselineCheckWhiteRecordResponse
     */
    public function listBaselineCheckWhiteRecordWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new ListBaselineCheckWhiteRecordShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->checkIds) {
            $request->checkIdsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->checkIds, 'CheckIds', 'json');
        }

        if (null !== $tmpReq->recordIds) {
            $request->recordIdsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->recordIds, 'RecordIds', 'json');
        }

        $query = [];
        if (null !== $request->checkIdsShrink) {
            @$query['CheckIds'] = $request->checkIdsShrink;
        }

        if (null !== $request->checkItemFuzzy) {
            @$query['CheckItemFuzzy'] = $request->checkItemFuzzy;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->recordIdsShrink) {
            @$query['RecordIds'] = $request->recordIdsShrink;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListBaselineCheckWhiteRecord',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListBaselineCheckWhiteRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the whitelist rules for a baseline check item.
     *
     * @param request - ListBaselineCheckWhiteRecordRequest
     *
     * @returns ListBaselineCheckWhiteRecordResponse
     *
     * @param ListBaselineCheckWhiteRecordRequest $request
     *
     * @return ListBaselineCheckWhiteRecordResponse
     */
    public function listBaselineCheckWhiteRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listBaselineCheckWhiteRecordWithOptions($request, $runtime);
    }

    /**
     * Queries the instances that failed a specified check item of configuration assessment.
     *
     * @param request - ListCheckInstanceResultRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListCheckInstanceResultResponse
     *
     * @param ListCheckInstanceResultRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ListCheckInstanceResultResponse
     */
    public function listCheckInstanceResultWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->checkId) {
            @$query['CheckId'] = $request->checkId;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->instanceIdKey) {
            @$query['InstanceIdKey'] = $request->instanceIdKey;
        }

        if (null !== $request->instanceIds) {
            @$query['InstanceIds'] = $request->instanceIds;
        }

        if (null !== $request->instanceNameKey) {
            @$query['InstanceNameKey'] = $request->instanceNameKey;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionIdKey) {
            @$query['RegionIdKey'] = $request->regionIdKey;
        }

        if (null !== $request->sortTypes) {
            @$query['SortTypes'] = $request->sortTypes;
        }

        if (null !== $request->statuses) {
            @$query['Statuses'] = $request->statuses;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListCheckInstanceResult',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListCheckInstanceResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the instances that failed a specified check item of configuration assessment.
     *
     * @param request - ListCheckInstanceResultRequest
     *
     * @returns ListCheckInstanceResultResponse
     *
     * @param ListCheckInstanceResultRequest $request
     *
     * @return ListCheckInstanceResultResponse
     */
    public function listCheckInstanceResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCheckInstanceResultWithOptions($request, $runtime);
    }

    /**
     * Queries the check items that can be customized.
     *
     * @param request - ListCheckItemRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListCheckItemResponse
     *
     * @param ListCheckItemRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return ListCheckItemResponse
     */
    public function listCheckItemWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->taskSources) {
            @$query['TaskSources'] = $request->taskSources;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListCheckItem',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListCheckItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the check items that can be customized.
     *
     * @param request - ListCheckItemRequest
     *
     * @returns ListCheckItemResponse
     *
     * @param ListCheckItemRequest $request
     *
     * @return ListCheckItemResponse
     */
    public function listCheckItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCheckItemWithOptions($request, $runtime);
    }

    /**
     * Query the list of warning machines for a specific baseline check item.
     *
     * @param request - ListCheckItemWarningMachineRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListCheckItemWarningMachineResponse
     *
     * @param ListCheckItemWarningMachineRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return ListCheckItemWarningMachineResponse
     */
    public function listCheckItemWarningMachineWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->checkId) {
            @$query['CheckId'] = $request->checkId;
        }

        if (null !== $request->containerFieldName) {
            @$query['ContainerFieldName'] = $request->containerFieldName;
        }

        if (null !== $request->containerFieldValue) {
            @$query['ContainerFieldValue'] = $request->containerFieldValue;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->riskType) {
            @$query['RiskType'] = $request->riskType;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->uuidList) {
            @$query['UuidList'] = $request->uuidList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListCheckItemWarningMachine',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListCheckItemWarningMachineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Query the list of warning machines for a specific baseline check item.
     *
     * @param request - ListCheckItemWarningMachineRequest
     *
     * @returns ListCheckItemWarningMachineResponse
     *
     * @param ListCheckItemWarningMachineRequest $request
     *
     * @return ListCheckItemWarningMachineResponse
     */
    public function listCheckItemWarningMachine($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCheckItemWarningMachineWithOptions($request, $runtime);
    }

    /**
     * Queries the risk statistics of check items by page.
     *
     * @param request - ListCheckItemWarningSummaryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListCheckItemWarningSummaryResponse
     *
     * @param ListCheckItemWarningSummaryRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return ListCheckItemWarningSummaryResponse
     */
    public function listCheckItemWarningSummaryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->checkItemFuzzy) {
            @$query['CheckItemFuzzy'] = $request->checkItemFuzzy;
        }

        if (null !== $request->checkLevel) {
            @$query['CheckLevel'] = $request->checkLevel;
        }

        if (null !== $request->checkType) {
            @$query['CheckType'] = $request->checkType;
        }

        if (null !== $request->checkWarningStatus) {
            @$query['CheckWarningStatus'] = $request->checkWarningStatus;
        }

        if (null !== $request->checkWarningStatusList) {
            @$query['CheckWarningStatusList'] = $request->checkWarningStatusList;
        }

        if (null !== $request->containerFieldName) {
            @$query['ContainerFieldName'] = $request->containerFieldName;
        }

        if (null !== $request->containerFieldValue) {
            @$query['ContainerFieldValue'] = $request->containerFieldValue;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->riskType) {
            @$query['RiskType'] = $request->riskType;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->uuidList) {
            @$query['UuidList'] = $request->uuidList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListCheckItemWarningSummary',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListCheckItemWarningSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the risk statistics of check items by page.
     *
     * @param request - ListCheckItemWarningSummaryRequest
     *
     * @returns ListCheckItemWarningSummaryResponse
     *
     * @param ListCheckItemWarningSummaryRequest $request
     *
     * @return ListCheckItemWarningSummaryResponse
     */
    public function listCheckItemWarningSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCheckItemWarningSummaryWithOptions($request, $runtime);
    }

    /**
     * List custom check items for situational awareness.
     *
     * @param request - ListCheckItemsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListCheckItemsResponse
     *
     * @param ListCheckItemsRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return ListCheckItemsResponse
     */
    public function listCheckItemsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListCheckItems',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListCheckItemsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * List custom check items for situational awareness.
     *
     * @param request - ListCheckItemsRequest
     *
     * @returns ListCheckItemsResponse
     *
     * @param ListCheckItemsRequest $request
     *
     * @return ListCheckItemsResponse
     */
    public function listCheckItems($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCheckItemsWithOptions($request, $runtime);
    }

    /**
     * List User Policies.
     *
     * @param request - ListCheckPoliciesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListCheckPoliciesResponse
     *
     * @param ListCheckPoliciesRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return ListCheckPoliciesResponse
     */
    public function listCheckPoliciesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListCheckPolicies',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListCheckPoliciesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * List User Policies.
     *
     * @param request - ListCheckPoliciesRequest
     *
     * @returns ListCheckPoliciesResponse
     *
     * @param ListCheckPoliciesRequest $request
     *
     * @return ListCheckPoliciesResponse
     */
    public function listCheckPolicies($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCheckPoliciesWithOptions($request, $runtime);
    }

    /**
     * Queries the details of the risk items that are detected in the configuration checks on cloud services.
     *
     * @param request - ListCheckResultRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListCheckResultResponse
     *
     * @param ListCheckResultRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return ListCheckResultResponse
     */
    public function listCheckResultWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->checkIds) {
            @$query['CheckIds'] = $request->checkIds;
        }

        if (null !== $request->checkKey) {
            @$query['CheckKey'] = $request->checkKey;
        }

        if (null !== $request->checkTypes) {
            @$query['CheckTypes'] = $request->checkTypes;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->customParam) {
            @$query['CustomParam'] = $request->customParam;
        }

        if (null !== $request->instanceIds) {
            @$query['InstanceIds'] = $request->instanceIds;
        }

        if (null !== $request->instanceTypes) {
            @$query['InstanceTypes'] = $request->instanceTypes;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->operationTypes) {
            @$query['OperationTypes'] = $request->operationTypes;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->requirementIds) {
            @$query['RequirementIds'] = $request->requirementIds;
        }

        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        if (null !== $request->riskLevels) {
            @$query['RiskLevels'] = $request->riskLevels;
        }

        if (null !== $request->sortTypes) {
            @$query['SortTypes'] = $request->sortTypes;
        }

        if (null !== $request->standardIds) {
            @$query['StandardIds'] = $request->standardIds;
        }

        if (null !== $request->statuses) {
            @$query['Statuses'] = $request->statuses;
        }

        if (null !== $request->taskSources) {
            @$query['TaskSources'] = $request->taskSources;
        }

        if (null !== $request->types) {
            @$query['Types'] = $request->types;
        }

        if (null !== $request->vendors) {
            @$query['Vendors'] = $request->vendors;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListCheckResult',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListCheckResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of the risk items that are detected in the configuration checks on cloud services.
     *
     * @param request - ListCheckResultRequest
     *
     * @returns ListCheckResultResponse
     *
     * @param ListCheckResultRequest $request
     *
     * @return ListCheckResultResponse
     */
    public function listCheckResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCheckResultWithOptions($request, $runtime);
    }

    /**
     * Display cloud product configuration check rules.
     *
     * @param request - ListCheckRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListCheckRuleResponse
     *
     * @param ListCheckRuleRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return ListCheckRuleResponse
     */
    public function listCheckRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListCheckRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListCheckRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Display cloud product configuration check rules.
     *
     * @param request - ListCheckRuleRequest
     *
     * @returns ListCheckRuleResponse
     *
     * @param ListCheckRuleRequest $request
     *
     * @return ListCheckRuleResponse
     */
    public function listCheckRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCheckRuleWithOptions($request, $runtime);
    }

    /**
     * List all effective machines under the rule.
     *
     * @param request - ListCheckRuleInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListCheckRuleInstanceResponse
     *
     * @param ListCheckRuleInstanceRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return ListCheckRuleInstanceResponse
     */
    public function listCheckRuleInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListCheckRuleInstance',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListCheckRuleInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * List all effective machines under the rule.
     *
     * @param request - ListCheckRuleInstanceRequest
     *
     * @returns ListCheckRuleInstanceResponse
     *
     * @param ListCheckRuleInstanceRequest $request
     *
     * @return ListCheckRuleInstanceResponse
     */
    public function listCheckRuleInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCheckRuleInstanceWithOptions($request, $runtime);
    }

    /**
     * Queries the standards of configuration checks.
     *
     * @param request - ListCheckStandardRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListCheckStandardResponse
     *
     * @param ListCheckStandardRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return ListCheckStandardResponse
     */
    public function listCheckStandardWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceIds) {
            @$query['InstanceIds'] = $request->instanceIds;
        }

        if (null !== $request->instanceSubTypes) {
            @$query['InstanceSubTypes'] = $request->instanceSubTypes;
        }

        if (null !== $request->instanceTypes) {
            @$query['InstanceTypes'] = $request->instanceTypes;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->taskSources) {
            @$query['TaskSources'] = $request->taskSources;
        }

        if (null !== $request->vendors) {
            @$query['Vendors'] = $request->vendors;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListCheckStandard',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListCheckStandardResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the standards of configuration checks.
     *
     * @param request - ListCheckStandardRequest
     *
     * @returns ListCheckStandardResponse
     *
     * @param ListCheckStandardRequest $request
     *
     * @return ListCheckStandardResponse
     */
    public function listCheckStandard($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCheckStandardWithOptions($request, $runtime);
    }

    /**
     * Queries the types of check items that meet the specified conditions based on the ID of a baseline.
     *
     * @param request - ListCheckTypesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListCheckTypesResponse
     *
     * @param ListCheckTypesRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return ListCheckTypesResponse
     */
    public function listCheckTypesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->riskId) {
            @$query['RiskId'] = $request->riskId;
        }

        if (null !== $request->showChecks) {
            @$query['ShowChecks'] = $request->showChecks;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListCheckTypes',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListCheckTypesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the types of check items that meet the specified conditions based on the ID of a baseline.
     *
     * @param request - ListCheckTypesRequest
     *
     * @returns ListCheckTypesResponse
     *
     * @param ListCheckTypesRequest $request
     *
     * @return ListCheckTypesResponse
     */
    public function listCheckTypes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCheckTypesWithOptions($request, $runtime);
    }

    /**
     * Queries the alert settings of assets. By default, the balanced mode is enabled. A detected list of assets can be returned only in strict mode.
     *
     * @param request - ListClientAlertModeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListClientAlertModeResponse
     *
     * @param ListClientAlertModeRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ListClientAlertModeResponse
     */
    public function listClientAlertModeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListClientAlertMode',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListClientAlertModeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the alert settings of assets. By default, the balanced mode is enabled. A detected list of assets can be returned only in strict mode.
     *
     * @param request - ListClientAlertModeRequest
     *
     * @returns ListClientAlertModeResponse
     *
     * @param ListClientAlertModeRequest $request
     *
     * @return ListClientAlertModeResponse
     */
    public function listClientAlertMode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listClientAlertModeWithOptions($request, $runtime);
    }

    /**
     * Queries the supported types of custom defense rules.
     *
     * @param request - ListClientUserDefineRuleTypesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListClientUserDefineRuleTypesResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return ListClientUserDefineRuleTypesResponse
     */
    public function listClientUserDefineRuleTypesWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'ListClientUserDefineRuleTypes',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListClientUserDefineRuleTypesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the supported types of custom defense rules.
     *
     * @returns ListClientUserDefineRuleTypesResponse
     *
     * @return ListClientUserDefineRuleTypesResponse
     */
    public function listClientUserDefineRuleTypes()
    {
        $runtime = new RuntimeOptions([]);

        return $this->listClientUserDefineRuleTypesWithOptions($runtime);
    }

    /**
     * Queries custom defense rules.
     *
     * @param request - ListClientUserDefineRulesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListClientUserDefineRulesResponse
     *
     * @param ListClientUserDefineRulesRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return ListClientUserDefineRulesResponse
     */
    public function listClientUserDefineRulesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListClientUserDefineRules',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListClientUserDefineRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries custom defense rules.
     *
     * @param request - ListClientUserDefineRulesRequest
     *
     * @returns ListClientUserDefineRulesResponse
     *
     * @param ListClientUserDefineRulesRequest $request
     *
     * @return ListClientUserDefineRulesResponse
     */
    public function listClientUserDefineRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listClientUserDefineRulesWithOptions($request, $runtime);
    }

    /**
     * Queries cloud service assets.
     *
     * @param request - ListCloudAssetInstancesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListCloudAssetInstancesResponse
     *
     * @param ListCloudAssetInstancesRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ListCloudAssetInstancesResponse
     */
    public function listCloudAssetInstancesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->cloudAssetTypes) {
            @$query['CloudAssetTypes'] = $request->cloudAssetTypes;
        }

        if (null !== $request->criteria) {
            @$query['Criteria'] = $request->criteria;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->logicalExp) {
            @$query['LogicalExp'] = $request->logicalExp;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListCloudAssetInstances',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListCloudAssetInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries cloud service assets.
     *
     * @param request - ListCloudAssetInstancesRequest
     *
     * @returns ListCloudAssetInstancesResponse
     *
     * @param ListCloudAssetInstancesRequest $request
     *
     * @return ListCloudAssetInstancesResponse
     */
    public function listCloudAssetInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCloudAssetInstancesWithOptions($request, $runtime);
    }

    /**
     * Get the list of cloud product configuration rule operators.
     *
     * @remarks
     * Get the list of cloud asset data operators.
     *
     * @param request - ListCloudAssetMatchOperatorsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListCloudAssetMatchOperatorsResponse
     *
     * @param ListCloudAssetMatchOperatorsRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return ListCloudAssetMatchOperatorsResponse
     */
    public function listCloudAssetMatchOperatorsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListCloudAssetMatchOperators',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListCloudAssetMatchOperatorsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Get the list of cloud product configuration rule operators.
     *
     * @remarks
     * Get the list of cloud asset data operators.
     *
     * @param request - ListCloudAssetMatchOperatorsRequest
     *
     * @returns ListCloudAssetMatchOperatorsResponse
     *
     * @param ListCloudAssetMatchOperatorsRequest $request
     *
     * @return ListCloudAssetMatchOperatorsResponse
     */
    public function listCloudAssetMatchOperators($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCloudAssetMatchOperatorsWithOptions($request, $runtime);
    }

    /**
     * .
     *
     * @param request - ListCloudAssetSchemasRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListCloudAssetSchemasResponse
     *
     * @param ListCloudAssetSchemasRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return ListCloudAssetSchemasResponse
     */
    public function listCloudAssetSchemasWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->associatedDataOnly) {
            @$query['AssociatedDataOnly'] = $request->associatedDataOnly;
        }

        if (null !== $request->cloudAssetTypes) {
            @$query['CloudAssetTypes'] = $request->cloudAssetTypes;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->dataNames) {
            @$query['DataNames'] = $request->dataNames;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListCloudAssetSchemas',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListCloudAssetSchemasResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * .
     *
     * @param request - ListCloudAssetSchemasRequest
     *
     * @returns ListCloudAssetSchemasResponse
     *
     * @param ListCloudAssetSchemasRequest $request
     *
     * @return ListCloudAssetSchemasResponse
     */
    public function listCloudAssetSchemas($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCloudAssetSchemasWithOptions($request, $runtime);
    }

    /**
     * Queries the synchronization region configurations of other clouds on a site.
     *
     * @param request - ListCloudVendorRegionsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListCloudVendorRegionsResponse
     *
     * @param ListCloudVendorRegionsRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return ListCloudVendorRegionsResponse
     */
    public function listCloudVendorRegionsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->vendor) {
            @$query['Vendor'] = $request->vendor;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListCloudVendorRegions',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListCloudVendorRegionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the synchronization region configurations of other clouds on a site.
     *
     * @param request - ListCloudVendorRegionsRequest
     *
     * @returns ListCloudVendorRegionsResponse
     *
     * @param ListCloudVendorRegionsRequest $request
     *
     * @return ListCloudVendorRegionsResponse
     */
    public function listCloudVendorRegions($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCloudVendorRegionsWithOptions($request, $runtime);
    }

    /**
     * Queries the protection status of the container firewall.
     *
     * @param request - ListClusterCnnfStatusDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListClusterCnnfStatusDetailResponse
     *
     * @param ListClusterCnnfStatusDetailRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return ListClusterCnnfStatusDetailResponse
     */
    public function listClusterCnnfStatusDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterIds) {
            @$query['ClusterIds'] = $request->clusterIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListClusterCnnfStatusDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListClusterCnnfStatusDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the protection status of the container firewall.
     *
     * @param request - ListClusterCnnfStatusDetailRequest
     *
     * @returns ListClusterCnnfStatusDetailResponse
     *
     * @param ListClusterCnnfStatusDetailRequest $request
     *
     * @return ListClusterCnnfStatusDetailResponse
     */
    public function listClusterCnnfStatusDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listClusterCnnfStatusDetailWithOptions($request, $runtime);
    }

    /**
     * Queries the defense rules that are created for a cluster.
     *
     * @param request - ListClusterInterceptionConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListClusterInterceptionConfigResponse
     *
     * @param ListClusterInterceptionConfigRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return ListClusterInterceptionConfigResponse
     */
    public function listClusterInterceptionConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterCNNFStatus) {
            @$query['ClusterCNNFStatus'] = $request->clusterCNNFStatus;
        }

        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->clusterName) {
            @$query['ClusterName'] = $request->clusterName;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListClusterInterceptionConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListClusterInterceptionConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the defense rules that are created for a cluster.
     *
     * @param request - ListClusterInterceptionConfigRequest
     *
     * @returns ListClusterInterceptionConfigResponse
     *
     * @param ListClusterInterceptionConfigRequest $request
     *
     * @return ListClusterInterceptionConfigResponse
     */
    public function listClusterInterceptionConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listClusterInterceptionConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the status of plug-ins on clusters.
     *
     * @param request - ListClusterPluginInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListClusterPluginInfoResponse
     *
     * @param ListClusterPluginInfoRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return ListClusterPluginInfoResponse
     */
    public function listClusterPluginInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterIds) {
            @$query['ClusterIds'] = $request->clusterIds;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pluginName) {
            @$query['PluginName'] = $request->pluginName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListClusterPluginInfo',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListClusterPluginInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the status of plug-ins on clusters.
     *
     * @param request - ListClusterPluginInfoRequest
     *
     * @returns ListClusterPluginInfoResponse
     *
     * @param ListClusterPluginInfoRequest $request
     *
     * @return ListClusterPluginInfoResponse
     */
    public function listClusterPluginInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listClusterPluginInfoWithOptions($request, $runtime);
    }

    /**
     * Queries the detection results of the files extracted from a package.
     *
     * @remarks
     * You can call this operation to query the detection results of files only if the files are pushed to the cloud for detection and in the form of packages. You can repeatedly query the detection results of files within 5 hours because the results are retained for 5 hours. For more information about how to push a file to the cloud for detection, see the CreateFileDetect operation. For more information about how to query file detection results, see the GetFileDetectResult operation.
     * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only hexadecimal MD5 hash values of complete file content are supported. You must calculate the required MD5 hash value before you call this operation.
     * To calculate the hexadecimal MD5 hash value for a file, you can perform the following steps:
     * 1\\. Use the MD5 algorithm to encrypt data and generate a 128-bit hash value. You can use a tool such as MessageDigest for Java and the hashlib module for Python.
     * 2\\. Convert the hash value to a hexadecimal string. You can use a tool such as Codec for Java and the hex() function for Python.
     *
     * @param request - ListCompressFileDetectResultRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListCompressFileDetectResultResponse
     *
     * @param ListCompressFileDetectResultRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return ListCompressFileDetectResultResponse
     */
    public function listCompressFileDetectResultWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->hashKey) {
            @$query['HashKey'] = $request->hashKey;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListCompressFileDetectResult',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListCompressFileDetectResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the detection results of the files extracted from a package.
     *
     * @remarks
     * You can call this operation to query the detection results of files only if the files are pushed to the cloud for detection and in the form of packages. You can repeatedly query the detection results of files within 5 hours because the results are retained for 5 hours. For more information about how to push a file to the cloud for detection, see the CreateFileDetect operation. For more information about how to query file detection results, see the GetFileDetectResult operation.
     * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only hexadecimal MD5 hash values of complete file content are supported. You must calculate the required MD5 hash value before you call this operation.
     * To calculate the hexadecimal MD5 hash value for a file, you can perform the following steps:
     * 1\\. Use the MD5 algorithm to encrypt data and generate a 128-bit hash value. You can use a tool such as MessageDigest for Java and the hashlib module for Python.
     * 2\\. Convert the hash value to a hexadecimal string. You can use a tool such as Codec for Java and the hex() function for Python.
     *
     * @param request - ListCompressFileDetectResultRequest
     *
     * @returns ListCompressFileDetectResultResponse
     *
     * @param ListCompressFileDetectResultRequest $request
     *
     * @return ListCompressFileDetectResultResponse
     */
    public function listCompressFileDetectResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCompressFileDetectResultWithOptions($request, $runtime);
    }

    /**
     * Queries a list of rules for non-image program defense.
     *
     * @param request - ListContainerDefenseRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListContainerDefenseRuleResponse
     *
     * @param ListContainerDefenseRuleRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return ListContainerDefenseRuleResponse
     */
    public function listContainerDefenseRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->conditions) {
            @$query['Conditions'] = $request->conditions;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->isDefaultRule) {
            @$query['IsDefaultRule'] = $request->isDefaultRule;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->ruleType) {
            @$query['RuleType'] = $request->ruleType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListContainerDefenseRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListContainerDefenseRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of rules for non-image program defense.
     *
     * @param request - ListContainerDefenseRuleRequest
     *
     * @returns ListContainerDefenseRuleResponse
     *
     * @param ListContainerDefenseRuleRequest $request
     *
     * @return ListContainerDefenseRuleResponse
     */
    public function listContainerDefenseRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listContainerDefenseRuleWithOptions($request, $runtime);
    }

    /**
     * Queries a list of clusters that are included in a rule for non-image program defense.
     *
     * @param request - ListContainerDefenseRuleClustersRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListContainerDefenseRuleClustersResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return ListContainerDefenseRuleClustersResponse
     */
    public function listContainerDefenseRuleClustersWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'ListContainerDefenseRuleClusters',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListContainerDefenseRuleClustersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of clusters that are included in a rule for non-image program defense.
     *
     * @returns ListContainerDefenseRuleClustersResponse
     *
     * @return ListContainerDefenseRuleClustersResponse
     */
    public function listContainerDefenseRuleClusters()
    {
        $runtime = new RuntimeOptions([]);

        return $this->listContainerDefenseRuleClustersWithOptions($runtime);
    }

    /**
     * Queries the IDs and names of rules configured for proactive defense for containers.
     *
     * @param request - ListCriteriaStrategyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListCriteriaStrategyResponse
     *
     * @param ListCriteriaStrategyRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return ListCriteriaStrategyResponse
     */
    public function listCriteriaStrategyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->imageName) {
            @$query['ImageName'] = $request->imageName;
        }

        if (null !== $request->label) {
            @$query['Label'] = $request->label;
        }

        if (null !== $request->namespace) {
            @$query['Namespace'] = $request->namespace;
        }

        if (null !== $request->strategyName) {
            @$query['StrategyName'] = $request->strategyName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListCriteriaStrategy',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListCriteriaStrategyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the IDs and names of rules configured for proactive defense for containers.
     *
     * @param request - ListCriteriaStrategyRequest
     *
     * @returns ListCriteriaStrategyResponse
     *
     * @param ListCriteriaStrategyRequest $request
     *
     * @return ListCriteriaStrategyResponse
     */
    public function listCriteriaStrategy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCriteriaStrategyWithOptions($request, $runtime);
    }

    /**
     * Queries the risk overview of official Docker Hub images.
     *
     * @param request - ListDockerhubImageRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListDockerhubImageResponse
     *
     * @param ListDockerhubImageRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return ListDockerhubImageResponse
     */
    public function listDockerhubImageWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->query) {
            @$query['Query'] = $request->query;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListDockerhubImage',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListDockerhubImageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the risk overview of official Docker Hub images.
     *
     * @param request - ListDockerhubImageRequest
     *
     * @returns ListDockerhubImageResponse
     *
     * @param ListDockerhubImageRequest $request
     *
     * @return ListDockerhubImageResponse
     */
    public function listDockerhubImage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDockerhubImageWithOptions($request, $runtime);
    }

    /**
     * Queries core file monitoring rules that meet the specified filter condition.
     *
     * @param request - ListFileProtectEventRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListFileProtectEventResponse
     *
     * @param ListFileProtectEventRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return ListFileProtectEventResponse
     */
    public function listFileProtectEventWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->alertLevels) {
            @$query['AlertLevels'] = $request->alertLevels;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->instanceName) {
            @$query['InstanceName'] = $request->instanceName;
        }

        if (null !== $request->internetIp) {
            @$query['InternetIp'] = $request->internetIp;
        }

        if (null !== $request->intranetIp) {
            @$query['IntranetIp'] = $request->intranetIp;
        }

        if (null !== $request->operation) {
            @$query['Operation'] = $request->operation;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->ruleName) {
            @$query['RuleName'] = $request->ruleName;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListFileProtectEvent',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListFileProtectEventResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries core file monitoring rules that meet the specified filter condition.
     *
     * @param request - ListFileProtectEventRequest
     *
     * @returns ListFileProtectEventResponse
     *
     * @param ListFileProtectEventRequest $request
     *
     * @return ListFileProtectEventResponse
     */
    public function listFileProtectEvent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listFileProtectEventWithOptions($request, $runtime);
    }

    /**
     * Queries information about the Security Center agent installed on servers on which core file monitoring rules take effect. The information includes the installation status of the Security Center agent and whether the core file monitoring feature is supported.
     *
     * @param request - ListFileProtectPluginStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListFileProtectPluginStatusResponse
     *
     * @param ListFileProtectPluginStatusRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return ListFileProtectPluginStatusResponse
     */
    public function listFileProtectPluginStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->switchId) {
            @$query['SwitchId'] = $request->switchId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListFileProtectPluginStatus',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListFileProtectPluginStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries information about the Security Center agent installed on servers on which core file monitoring rules take effect. The information includes the installation status of the Security Center agent and whether the core file monitoring feature is supported.
     *
     * @param request - ListFileProtectPluginStatusRequest
     *
     * @returns ListFileProtectPluginStatusResponse
     *
     * @param ListFileProtectPluginStatusRequest $request
     *
     * @return ListFileProtectPluginStatusResponse
     */
    public function listFileProtectPluginStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listFileProtectPluginStatusWithOptions($request, $runtime);
    }

    /**
     * Queries core file monitoring rules.
     *
     * @param request - ListFileProtectRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListFileProtectRuleResponse
     *
     * @param ListFileProtectRuleRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ListFileProtectRuleResponse
     */
    public function listFileProtectRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->alertLevel) {
            @$query['AlertLevel'] = $request->alertLevel;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->platform) {
            @$query['Platform'] = $request->platform;
        }

        if (null !== $request->ruleAction) {
            @$query['RuleAction'] = $request->ruleAction;
        }

        if (null !== $request->ruleName) {
            @$query['RuleName'] = $request->ruleName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListFileProtectRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListFileProtectRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries core file monitoring rules.
     *
     * @param request - ListFileProtectRuleRequest
     *
     * @returns ListFileProtectRuleResponse
     *
     * @param ListFileProtectRuleRequest $request
     *
     * @return ListFileProtectRuleResponse
     */
    public function listFileProtectRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listFileProtectRuleWithOptions($request, $runtime);
    }

    /**
     * Queries the server groups.
     *
     * @param request - ListGroupsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListGroupsResponse
     *
     * @param ListGroupsRequest $request
     * @param RuntimeOptions    $runtime
     *
     * @return ListGroupsResponse
     */
    public function listGroupsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->useNextToken) {
            @$query['UseNextToken'] = $request->useNextToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListGroups',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListGroupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the server groups.
     *
     * @param request - ListGroupsRequest
     *
     * @returns ListGroupsResponse
     *
     * @param ListGroupsRequest $request
     *
     * @return ListGroupsResponse
     */
    public function listGroups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listGroupsWithOptions($request, $runtime);
    }

    /**
     * Queries the information about honeypots.
     *
     * @param request - ListHoneypotRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListHoneypotResponse
     *
     * @param ListHoneypotRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return ListHoneypotResponse
     */
    public function listHoneypotWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->honeypotIds) {
            @$query['HoneypotIds'] = $request->honeypotIds;
        }

        if (null !== $request->honeypotName) {
            @$query['HoneypotName'] = $request->honeypotName;
        }

        if (null !== $request->nodeId) {
            @$query['NodeId'] = $request->nodeId;
        }

        if (null !== $request->nodeName) {
            @$query['NodeName'] = $request->nodeName;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListHoneypot',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListHoneypotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about honeypots.
     *
     * @param request - ListHoneypotRequest
     *
     * @returns ListHoneypotResponse
     *
     * @param ListHoneypotRequest $request
     *
     * @return ListHoneypotResponse
     */
    public function listHoneypot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHoneypotWithOptions($request, $runtime);
    }

    /**
     * Queries the information about alert events that are generated.
     *
     * @param request - ListHoneypotAlarmEventsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListHoneypotAlarmEventsResponse
     *
     * @param ListHoneypotAlarmEventsRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ListHoneypotAlarmEventsResponse
     */
    public function listHoneypotAlarmEventsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListHoneypotAlarmEvents',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListHoneypotAlarmEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about alert events that are generated.
     *
     * @param request - ListHoneypotAlarmEventsRequest
     *
     * @returns ListHoneypotAlarmEventsResponse
     *
     * @param ListHoneypotAlarmEventsRequest $request
     *
     * @return ListHoneypotAlarmEventsResponse
     */
    public function listHoneypotAlarmEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHoneypotAlarmEventsWithOptions($request, $runtime);
    }

    /**
     * Queries the attacker profile based on the source IP address of the attack.
     *
     * @param request - ListHoneypotAttackerPortraitRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListHoneypotAttackerPortraitResponse
     *
     * @param ListHoneypotAttackerPortraitRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return ListHoneypotAttackerPortraitResponse
     */
    public function listHoneypotAttackerPortraitWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->endTimeStamp) {
            @$query['EndTimeStamp'] = $request->endTimeStamp;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->srcIp) {
            @$query['SrcIp'] = $request->srcIp;
        }

        if (null !== $request->startTimeStamp) {
            @$query['StartTimeStamp'] = $request->startTimeStamp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListHoneypotAttackerPortrait',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListHoneypotAttackerPortraitResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the attacker profile based on the source IP address of the attack.
     *
     * @param request - ListHoneypotAttackerPortraitRequest
     *
     * @returns ListHoneypotAttackerPortraitResponse
     *
     * @param ListHoneypotAttackerPortraitRequest $request
     *
     * @return ListHoneypotAttackerPortraitResponse
     */
    public function listHoneypotAttackerPortrait($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHoneypotAttackerPortraitWithOptions($request, $runtime);
    }

    /**
     * Queries the attack source IP addresses that are used to attack a honeypot.
     *
     * @param request - ListHoneypotAttackerSourceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListHoneypotAttackerSourceResponse
     *
     * @param ListHoneypotAttackerSourceRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return ListHoneypotAttackerSourceResponse
     */
    public function listHoneypotAttackerSourceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->endTimeStamp) {
            @$query['EndTimeStamp'] = $request->endTimeStamp;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->riskLevelList) {
            @$query['RiskLevelList'] = $request->riskLevelList;
        }

        if (null !== $request->srcIp) {
            @$query['SrcIp'] = $request->srcIp;
        }

        if (null !== $request->startTimeStamp) {
            @$query['StartTimeStamp'] = $request->startTimeStamp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListHoneypotAttackerSource',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListHoneypotAttackerSourceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the attack source IP addresses that are used to attack a honeypot.
     *
     * @param request - ListHoneypotAttackerSourceRequest
     *
     * @returns ListHoneypotAttackerSourceResponse
     *
     * @param ListHoneypotAttackerSourceRequest $request
     *
     * @return ListHoneypotAttackerSourceResponse
     */
    public function listHoneypotAttackerSource($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHoneypotAttackerSourceWithOptions($request, $runtime);
    }

    /**
     * Queries the details of an intrusion event in a honeypot.
     *
     * @param request - ListHoneypotEventFlowsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListHoneypotEventFlowsResponse
     *
     * @param ListHoneypotEventFlowsRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return ListHoneypotEventFlowsResponse
     */
    public function listHoneypotEventFlowsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->dealed) {
            @$query['Dealed'] = $request->dealed;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->requestId) {
            @$query['RequestId'] = $request->requestId;
        }

        if (null !== $request->securityEventId) {
            @$query['SecurityEventId'] = $request->securityEventId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListHoneypotEventFlows',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListHoneypotEventFlowsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of an intrusion event in a honeypot.
     *
     * @param request - ListHoneypotEventFlowsRequest
     *
     * @returns ListHoneypotEventFlowsResponse
     *
     * @param ListHoneypotEventFlowsRequest $request
     *
     * @return ListHoneypotEventFlowsResponse
     */
    public function listHoneypotEventFlows($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHoneypotEventFlowsWithOptions($request, $runtime);
    }

    /**
     * Queries the intrusion events detected by honeypots.
     *
     * @param request - ListHoneypotEventsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListHoneypotEventsResponse
     *
     * @param ListHoneypotEventsRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return ListHoneypotEventsResponse
     */
    public function listHoneypotEventsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListHoneypotEvents',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListHoneypotEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the intrusion events detected by honeypots.
     *
     * @param request - ListHoneypotEventsRequest
     *
     * @returns ListHoneypotEventsResponse
     *
     * @param ListHoneypotEventsRequest $request
     *
     * @return ListHoneypotEventsResponse
     */
    public function listHoneypotEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHoneypotEventsWithOptions($request, $runtime);
    }

    /**
     * Queries the information about management nodes.
     *
     * @param request - ListHoneypotNodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListHoneypotNodeResponse
     *
     * @param ListHoneypotNodeRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return ListHoneypotNodeResponse
     */
    public function listHoneypotNodeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->nodeId) {
            @$query['NodeId'] = $request->nodeId;
        }

        if (null !== $request->nodeName) {
            @$query['NodeName'] = $request->nodeName;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListHoneypotNode',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListHoneypotNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about management nodes.
     *
     * @param request - ListHoneypotNodeRequest
     *
     * @returns ListHoneypotNodeResponse
     *
     * @param ListHoneypotNodeRequest $request
     *
     * @return ListHoneypotNodeResponse
     */
    public function listHoneypotNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHoneypotNodeWithOptions($request, $runtime);
    }

    /**
     * Queries honeypot templates.
     *
     * @param request - ListHoneypotPresetRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListHoneypotPresetResponse
     *
     * @param ListHoneypotPresetRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return ListHoneypotPresetResponse
     */
    public function listHoneypotPresetWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->honeypotImageName) {
            @$query['HoneypotImageName'] = $request->honeypotImageName;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->nodeId) {
            @$query['NodeId'] = $request->nodeId;
        }

        if (null !== $request->nodeName) {
            @$query['NodeName'] = $request->nodeName;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->presetName) {
            @$query['PresetName'] = $request->presetName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListHoneypotPreset',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListHoneypotPresetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries honeypot templates.
     *
     * @param request - ListHoneypotPresetRequest
     *
     * @returns ListHoneypotPresetResponse
     *
     * @param ListHoneypotPresetRequest $request
     *
     * @return ListHoneypotPresetResponse
     */
    public function listHoneypotPreset($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHoneypotPresetWithOptions($request, $runtime);
    }

    /**
     * Queries probes.
     *
     * @param request - ListHoneypotProbeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListHoneypotProbeResponse
     *
     * @param ListHoneypotProbeRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return ListHoneypotProbeResponse
     */
    public function listHoneypotProbeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->displayName) {
            @$query['DisplayName'] = $request->displayName;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->probeStatus) {
            @$query['ProbeStatus'] = $request->probeStatus;
        }

        if (null !== $request->probeType) {
            @$query['ProbeType'] = $request->probeType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListHoneypotProbe',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListHoneypotProbeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries probes.
     *
     * @param request - ListHoneypotProbeRequest
     *
     * @returns ListHoneypotProbeResponse
     *
     * @param ListHoneypotProbeRequest $request
     *
     * @return ListHoneypotProbeResponse
     */
    public function listHoneypotProbe($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHoneypotProbeWithOptions($request, $runtime);
    }

    /**
     * Query installed probes.
     *
     * @param request - ListHoneypotProbeUuidRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListHoneypotProbeUuidResponse
     *
     * @param ListHoneypotProbeUuidRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return ListHoneypotProbeUuidResponse
     */
    public function listHoneypotProbeUuidWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->controlNodeId) {
            @$query['ControlNodeId'] = $request->controlNodeId;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->probeType) {
            @$query['ProbeType'] = $request->probeType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListHoneypotProbeUuid',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListHoneypotProbeUuidResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Query installed probes.
     *
     * @param request - ListHoneypotProbeUuidRequest
     *
     * @returns ListHoneypotProbeUuidResponse
     *
     * @param ListHoneypotProbeUuidRequest $request
     *
     * @return ListHoneypotProbeUuidResponse
     */
    public function listHoneypotProbeUuid($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHoneypotProbeUuidWithOptions($request, $runtime);
    }

    /**
     * Queries the types of risky image build commands.
     *
     * @param request - ListImageBuildRiskItemRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListImageBuildRiskItemResponse
     *
     * @param ListImageBuildRiskItemRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return ListImageBuildRiskItemResponse
     */
    public function listImageBuildRiskItemWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListImageBuildRiskItem',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListImageBuildRiskItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the types of risky image build commands.
     *
     * @param request - ListImageBuildRiskItemRequest
     *
     * @returns ListImageBuildRiskItemResponse
     *
     * @param ListImageBuildRiskItemRequest $request
     *
     * @return ListImageBuildRiskItemResponse
     */
    public function listImageBuildRiskItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listImageBuildRiskItemWithOptions($request, $runtime);
    }

    /**
     * Queries the additional configuration information about an image repository.
     *
     * @param request - ListImageRegistryExtraRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListImageRegistryExtraResponse
     *
     * @param ListImageRegistryExtraRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return ListImageRegistryExtraResponse
     */
    public function listImageRegistryExtraWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->registryId) {
            @$query['RegistryId'] = $request->registryId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListImageRegistryExtra',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListImageRegistryExtraResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the additional configuration information about an image repository.
     *
     * @param request - ListImageRegistryExtraRequest
     *
     * @returns ListImageRegistryExtraResponse
     *
     * @param ListImageRegistryExtraRequest $request
     *
     * @return ListImageRegistryExtraResponse
     */
    public function listImageRegistryExtra($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listImageRegistryExtraWithOptions($request, $runtime);
    }

    /**
     * The region ID of the image.
     *
     * @param request - ListImageRegistryRegionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListImageRegistryRegionResponse
     *
     * @param ListImageRegistryRegionRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ListImageRegistryRegionResponse
     */
    public function listImageRegistryRegionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListImageRegistryRegion',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListImageRegistryRegionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * The region ID of the image.
     *
     * @param request - ListImageRegistryRegionRequest
     *
     * @returns ListImageRegistryRegionResponse
     *
     * @param ListImageRegistryRegionRequest $request
     *
     * @return ListImageRegistryRegionResponse
     */
    public function listImageRegistryRegion($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listImageRegistryRegionWithOptions($request, $runtime);
    }

    /**
     * Queries security information about a container image.
     *
     * @param request - ListImageRiskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListImageRiskResponse
     *
     * @param ListImageRiskRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return ListImageRiskResponse
     */
    public function listImageRiskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->imageName) {
            @$query['ImageName'] = $request->imageName;
        }

        if (null !== $request->namespace) {
            @$query['Namespace'] = $request->namespace;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListImageRisk',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListImageRiskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries security information about a container image.
     *
     * @param request - ListImageRiskRequest
     *
     * @returns ListImageRiskResponse
     *
     * @param ListImageRiskRequest $request
     *
     * @return ListImageRiskResponse
     */
    public function listImageRisk($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listImageRiskWithOptions($request, $runtime);
    }

    /**
     * Queries the asset types and asset subtypes for configuration assessment.
     *
     * @param request - ListInstanceCatalogRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListInstanceCatalogResponse
     *
     * @param ListInstanceCatalogRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ListInstanceCatalogResponse
     */
    public function listInstanceCatalogWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->onlyCustom) {
            @$query['OnlyCustom'] = $request->onlyCustom;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->requirementIds) {
            @$query['RequirementIds'] = $request->requirementIds;
        }

        if (null !== $request->standardIds) {
            @$query['StandardIds'] = $request->standardIds;
        }

        if (null !== $request->taskSources) {
            @$query['TaskSources'] = $request->taskSources;
        }

        if (null !== $request->types) {
            @$query['Types'] = $request->types;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListInstanceCatalog',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListInstanceCatalogResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the asset types and asset subtypes for configuration assessment.
     *
     * @param request - ListInstanceCatalogRequest
     *
     * @returns ListInstanceCatalogResponse
     *
     * @param ListInstanceCatalogRequest $request
     *
     * @return ListInstanceCatalogResponse
     */
    public function listInstanceCatalog($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listInstanceCatalogWithOptions($request, $runtime);
    }

    /**
     * Queries the risk levels of instances.
     *
     * @param request - ListInstanceRiskLevelsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListInstanceRiskLevelsResponse
     *
     * @param ListInstanceRiskLevelsRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return ListInstanceRiskLevelsResponse
     */
    public function listInstanceRiskLevelsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceList) {
            @$query['InstanceList'] = $request->instanceList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListInstanceRiskLevels',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListInstanceRiskLevelsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the risk levels of instances.
     *
     * @param request - ListInstanceRiskLevelsRequest
     *
     * @returns ListInstanceRiskLevelsResponse
     *
     * @param ListInstanceRiskLevelsRequest $request
     *
     * @return ListInstanceRiskLevelsResponse
     */
    public function listInstanceRiskLevels($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listInstanceRiskLevelsWithOptions($request, $runtime);
    }

    /**
     * Queries the statistics about risks in instances.
     *
     * @param request - ListInstanceRiskNumRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListInstanceRiskNumResponse
     *
     * @param ListInstanceRiskNumRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ListInstanceRiskNumResponse
     */
    public function listInstanceRiskNumWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceList) {
            @$query['InstanceList'] = $request->instanceList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListInstanceRiskNum',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListInstanceRiskNumResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics about risks in instances.
     *
     * @param request - ListInstanceRiskNumRequest
     *
     * @returns ListInstanceRiskNumResponse
     *
     * @param ListInstanceRiskNumRequest $request
     *
     * @return ListInstanceRiskNumResponse
     */
    public function listInstanceRiskNum($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listInstanceRiskNumWithOptions($request, $runtime);
    }

    /**
     * Queries the alerts generated by defense rules.
     *
     * @param request - ListInterceptionHistoryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListInterceptionHistoryResponse
     *
     * @param ListInterceptionHistoryRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ListInterceptionHistoryResponse
     */
    public function listInterceptionHistoryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->historyName) {
            @$query['HistoryName'] = $request->historyName;
        }

        if (null !== $request->interceptionTypes) {
            @$query['InterceptionTypes'] = $request->interceptionTypes;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListInterceptionHistory',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListInterceptionHistoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the alerts generated by defense rules.
     *
     * @param request - ListInterceptionHistoryRequest
     *
     * @returns ListInterceptionHistoryResponse
     *
     * @param ListInterceptionHistoryRequest $request
     *
     * @return ListInterceptionHistoryResponse
     */
    public function listInterceptionHistory($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listInterceptionHistoryWithOptions($request, $runtime);
    }

    /**
     * Queries defense rules that are configured for the container firewall feature.
     *
     * @param request - ListInterceptionRulePageRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListInterceptionRulePageResponse
     *
     * @param ListInterceptionRulePageRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return ListInterceptionRulePageResponse
     */
    public function listInterceptionRulePageWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->criteria) {
            @$query['Criteria'] = $request->criteria;
        }

        if (null !== $request->criteriaType) {
            @$query['CriteriaType'] = $request->criteriaType;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListInterceptionRulePage',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListInterceptionRulePageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries defense rules that are configured for the container firewall feature.
     *
     * @param request - ListInterceptionRulePageRequest
     *
     * @returns ListInterceptionRulePageResponse
     *
     * @param ListInterceptionRulePageRequest $request
     *
     * @return ListInterceptionRulePageResponse
     */
    public function listInterceptionRulePage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listInterceptionRulePageWithOptions($request, $runtime);
    }

    /**
     * Queries the network objects that are protected by the container firewall feature.
     *
     * @param request - ListInterceptionTargetPageRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListInterceptionTargetPageResponse
     *
     * @param ListInterceptionTargetPageRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return ListInterceptionTargetPageResponse
     */
    public function listInterceptionTargetPageWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->imageList) {
            @$query['ImageList'] = $request->imageList;
        }

        if (null !== $request->namespace) {
            @$query['Namespace'] = $request->namespace;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->tagList) {
            @$query['TagList'] = $request->tagList;
        }

        if (null !== $request->targetName) {
            @$query['TargetName'] = $request->targetName;
        }

        if (null !== $request->targetType) {
            @$query['TargetType'] = $request->targetType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListInterceptionTargetPage',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListInterceptionTargetPageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the network objects that are protected by the container firewall feature.
     *
     * @param request - ListInterceptionTargetPageRequest
     *
     * @returns ListInterceptionTargetPageResponse
     *
     * @param ListInterceptionTargetPageRequest $request
     *
     * @return ListInterceptionTargetPageResponse
     */
    public function listInterceptionTargetPage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listInterceptionTargetPageWithOptions($request, $runtime);
    }

    /**
     * Queries the information about Kubernetes clusters that are added to Security Center.
     *
     * @remarks
     * You can use this operation to query the access information about Kubernetes clusters.
     *
     * @param request - ListK8sAccessInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListK8sAccessInfoResponse
     *
     * @param ListK8sAccessInfoRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return ListK8sAccessInfoResponse
     */
    public function listK8sAccessInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aliyunYundunGatewayApiName) {
            @$query['AliyunYundunGatewayApiName'] = $request->aliyunYundunGatewayApiName;
        }

        if (null !== $request->aliyunYundunGatewayPopName) {
            @$query['AliyunYundunGatewayPopName'] = $request->aliyunYundunGatewayPopName;
        }

        if (null !== $request->aliyunYundunGatewayProjectName) {
            @$query['AliyunYundunGatewayProjectName'] = $request->aliyunYundunGatewayProjectName;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListK8sAccessInfo',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListK8sAccessInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about Kubernetes clusters that are added to Security Center.
     *
     * @remarks
     * You can use this operation to query the access information about Kubernetes clusters.
     *
     * @param request - ListK8sAccessInfoRequest
     *
     * @returns ListK8sAccessInfoResponse
     *
     * @param ListK8sAccessInfoRequest $request
     *
     * @return ListK8sAccessInfoResponse
     */
    public function listK8sAccessInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listK8sAccessInfoWithOptions($request, $runtime);
    }

    /**
     * Queries the regions supported by the log delivery feature that uses the pay-as-you-go billing method.
     *
     * @param request - ListLogShipperRegionsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListLogShipperRegionsResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return ListLogShipperRegionsResponse
     */
    public function listLogShipperRegionsWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'ListLogShipperRegions',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListLogShipperRegionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the regions supported by the log delivery feature that uses the pay-as-you-go billing method.
     *
     * @returns ListLogShipperRegionsResponse
     *
     * @return ListLogShipperRegionsResponse
     */
    public function listLogShipperRegions()
    {
        $runtime = new RuntimeOptions([]);

        return $this->listLogShipperRegionsWithOptions($runtime);
    }

    /**
     * Queries Serverless App Engine (SAE) applications.
     *
     * @param request - ListMachineAppsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListMachineAppsResponse
     *
     * @param ListMachineAppsRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return ListMachineAppsResponse
     */
    public function listMachineAppsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->appRegionId) {
            @$query['AppRegionId'] = $request->appRegionId;
        }

        if (null !== $request->authVersion) {
            @$query['AuthVersion'] = $request->authVersion;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->resourceDirectoryUid) {
            @$query['ResourceDirectoryUid'] = $request->resourceDirectoryUid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListMachineApps',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListMachineAppsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries Serverless App Engine (SAE) applications.
     *
     * @param request - ListMachineAppsRequest
     *
     * @returns ListMachineAppsResponse
     *
     * @param ListMachineAppsRequest $request
     *
     * @return ListMachineAppsResponse
     */
    public function listMachineApps($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listMachineAppsWithOptions($request, $runtime);
    }

    /**
     * Queries the alert whitelist rules of sensitive files that are detected by using the agentless detection feature.
     *
     * @param request - ListMaliciousFileWhitelistConfigsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListMaliciousFileWhitelistConfigsResponse
     *
     * @param ListMaliciousFileWhitelistConfigsRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return ListMaliciousFileWhitelistConfigsResponse
     */
    public function listMaliciousFileWhitelistConfigsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->eventName) {
            @$query['EventName'] = $request->eventName;
        }

        if (null !== $request->idList) {
            @$query['IdList'] = $request->idList;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListMaliciousFileWhitelistConfigs',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListMaliciousFileWhitelistConfigsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the alert whitelist rules of sensitive files that are detected by using the agentless detection feature.
     *
     * @param request - ListMaliciousFileWhitelistConfigsRequest
     *
     * @returns ListMaliciousFileWhitelistConfigsResponse
     *
     * @param ListMaliciousFileWhitelistConfigsRequest $request
     *
     * @return ListMaliciousFileWhitelistConfigsResponse
     */
    public function listMaliciousFileWhitelistConfigs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listMaliciousFileWhitelistConfigsWithOptions($request, $runtime);
    }

    /**
     * Query Multi-Account Authorization Allocation List.
     *
     * @remarks
     * You can search for assets by conditions such as the instance ID, instance name, VPC ID, region, and public IP address of the asset. You can also search for assets that meet multiple search conditions by setting the logical relationship between different search conditions.
     *
     * @param request - ListMultiUserInstancesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListMultiUserInstancesResponse
     *
     * @param ListMultiUserInstancesRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return ListMultiUserInstancesResponse
     */
    public function listMultiUserInstancesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListMultiUserInstances',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListMultiUserInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Query Multi-Account Authorization Allocation List.
     *
     * @remarks
     * You can search for assets by conditions such as the instance ID, instance name, VPC ID, region, and public IP address of the asset. You can also search for assets that meet multiple search conditions by setting the logical relationship between different search conditions.
     *
     * @param request - ListMultiUserInstancesRequest
     *
     * @returns ListMultiUserInstancesResponse
     *
     * @param ListMultiUserInstancesRequest $request
     *
     * @return ListMultiUserInstancesResponse
     */
    public function listMultiUserInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listMultiUserInstancesWithOptions($request, $runtime);
    }

    /**
     * Queries alerts that are generated for malicious files.
     *
     * @param request - ListObjectScanEventRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListObjectScanEventResponse
     *
     * @param ListObjectScanEventRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ListObjectScanEventResponse
     */
    public function listObjectScanEventWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->batchType) {
            @$query['BatchType'] = $request->batchType;
        }

        if (null !== $request->bucketName) {
            @$query['BucketName'] = $request->bucketName;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->eventId) {
            @$query['EventId'] = $request->eventId;
        }

        if (null !== $request->eventName) {
            @$query['EventName'] = $request->eventName;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->md5) {
            @$query['Md5'] = $request->md5;
        }

        if (null !== $request->ossKey) {
            @$query['OssKey'] = $request->ossKey;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->parentEventId) {
            @$query['ParentEventId'] = $request->parentEventId;
        }

        if (null !== $request->riskLevel) {
            @$query['RiskLevel'] = $request->riskLevel;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->timeEnd) {
            @$query['TimeEnd'] = $request->timeEnd;
        }

        if (null !== $request->timeStart) {
            @$query['TimeStart'] = $request->timeStart;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListObjectScanEvent',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListObjectScanEventResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries alerts that are generated for malicious files.
     *
     * @param request - ListObjectScanEventRequest
     *
     * @returns ListObjectScanEventResponse
     *
     * @param ListObjectScanEventRequest $request
     *
     * @return ListObjectScanEventResponse
     */
    public function listObjectScanEvent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listObjectScanEventWithOptions($request, $runtime);
    }

    /**
     * Queries at-risk image blocking rules.
     *
     * @param request - ListOpaClusterStrategyNewRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListOpaClusterStrategyNewResponse
     *
     * @param ListOpaClusterStrategyNewRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return ListOpaClusterStrategyNewResponse
     */
    public function listOpaClusterStrategyNewWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->imageName) {
            @$query['ImageName'] = $request->imageName;
        }

        if (null !== $request->label) {
            @$query['Label'] = $request->label;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->strategyName) {
            @$query['StrategyName'] = $request->strategyName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListOpaClusterStrategyNew',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListOpaClusterStrategyNewResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries at-risk image blocking rules.
     *
     * @param request - ListOpaClusterStrategyNewRequest
     *
     * @returns ListOpaClusterStrategyNewResponse
     *
     * @param ListOpaClusterStrategyNewRequest $request
     *
     * @return ListOpaClusterStrategyNewResponse
     */
    public function listOpaClusterStrategyNew($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listOpaClusterStrategyNewWithOptions($request, $runtime);
    }

    /**
     * Query the list of instance results under the operation check item.
     *
     * @remarks
     * This interface is only available to users who have purchased the cloud platform configuration check authorization or enabled the pay-as-you-go service for cloud platform configuration checks.
     *
     * @param request - ListOperationCheckRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListOperationCheckResponse
     *
     * @param ListOperationCheckRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return ListOperationCheckResponse
     */
    public function listOperationCheckWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListOperationCheck',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListOperationCheckResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Query the list of instance results under the operation check item.
     *
     * @remarks
     * This interface is only available to users who have purchased the cloud platform configuration check authorization or enabled the pay-as-you-go service for cloud platform configuration checks.
     *
     * @param request - ListOperationCheckRequest
     *
     * @returns ListOperationCheckResponse
     *
     * @param ListOperationCheckRequest $request
     *
     * @return ListOperationCheckResponse
     */
    public function listOperationCheck($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listOperationCheckWithOptions($request, $runtime);
    }

    /**
     * Queries a list of operation tasks.
     *
     * @remarks
     * You can query only operation tasks.
     *
     * @param request - ListOperationProcessRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListOperationProcessResponse
     *
     * @param ListOperationProcessRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return ListOperationProcessResponse
     */
    public function listOperationProcessWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->statusCodes) {
            @$query['StatusCodes'] = $request->statusCodes;
        }

        if (null !== $request->taskIds) {
            @$query['TaskIds'] = $request->taskIds;
        }

        if (null !== $request->taskSources) {
            @$query['TaskSources'] = $request->taskSources;
        }

        if (null !== $request->taskTypes) {
            @$query['TaskTypes'] = $request->taskTypes;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListOperationProcess',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListOperationProcessResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of operation tasks.
     *
     * @remarks
     * You can query only operation tasks.
     *
     * @param request - ListOperationProcessRequest
     *
     * @returns ListOperationProcessResponse
     *
     * @param ListOperationProcessRequest $request
     *
     * @return ListOperationProcessResponse
     */
    public function listOperationProcess($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listOperationProcessWithOptions($request, $runtime);
    }

    /**
     * Query operation task sub-task list.
     *
     * @remarks
     * You can query only operation subtasks.
     *
     * @param request - ListOperationProcessDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListOperationProcessDetailResponse
     *
     * @param ListOperationProcessDetailRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return ListOperationProcessDetailResponse
     */
    public function listOperationProcessDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->statusCodes) {
            @$query['StatusCodes'] = $request->statusCodes;
        }

        if (null !== $request->taskIds) {
            @$query['TaskIds'] = $request->taskIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListOperationProcessDetail',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListOperationProcessDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Query operation task sub-task list.
     *
     * @remarks
     * You can query only operation subtasks.
     *
     * @param request - ListOperationProcessDetailRequest
     *
     * @returns ListOperationProcessDetailResponse
     *
     * @param ListOperationProcessDetailRequest $request
     *
     * @return ListOperationProcessDetailResponse
     */
    public function listOperationProcessDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listOperationProcessDetailWithOptions($request, $runtime);
    }

    /**
     * Display the list of cloud product configuration check, repair, and rollback tasks.
     *
     * @param request - ListOperationTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListOperationTaskResponse
     *
     * @param ListOperationTaskRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return ListOperationTaskResponse
     */
    public function listOperationTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListOperationTask',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListOperationTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Display the list of cloud product configuration check, repair, and rollback tasks.
     *
     * @param request - ListOperationTaskRequest
     *
     * @returns ListOperationTaskResponse
     *
     * @param ListOperationTaskRequest $request
     *
     * @return ListOperationTaskResponse
     */
    public function listOperationTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listOperationTaskWithOptions($request, $runtime);
    }

    /**
     * Queries Object Storage Service (OSS) buckets.
     *
     * @param request - ListOssBucketRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListOssBucketResponse
     *
     * @param ListOssBucketRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return ListOssBucketResponse
     */
    public function listOssBucketWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bucketName) {
            @$query['BucketName'] = $request->bucketName;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListOssBucket',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListOssBucketResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries Object Storage Service (OSS) buckets.
     *
     * @param request - ListOssBucketRequest
     *
     * @returns ListOssBucketResponse
     *
     * @param ListOssBucketRequest $request
     *
     * @return ListOssBucketResponse
     */
    public function listOssBucket($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listOssBucketWithOptions($request, $runtime);
    }

    /**
     * Queries the risk information of an Object Storage Service (OSS) bucket.
     *
     * @param request - ListOssBucketScanInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListOssBucketScanInfoResponse
     *
     * @param ListOssBucketScanInfoRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return ListOssBucketScanInfoResponse
     */
    public function listOssBucketScanInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bucketName) {
            @$query['BucketName'] = $request->bucketName;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->fuzzBucketName) {
            @$query['FuzzBucketName'] = $request->fuzzBucketName;
        }

        if (null !== $request->hasRisk) {
            @$query['HasRisk'] = $request->hasRisk;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListOssBucketScanInfo',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListOssBucketScanInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the risk information of an Object Storage Service (OSS) bucket.
     *
     * @param request - ListOssBucketScanInfoRequest
     *
     * @returns ListOssBucketScanInfoResponse
     *
     * @param ListOssBucketScanInfoRequest $request
     *
     * @return ListOssBucketScanInfoResponse
     */
    public function listOssBucketScanInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listOssBucketScanInfoWithOptions($request, $runtime);
    }

    /**
     * Queries the configuration of an Object Storage Service (OSS) file detection policy.
     *
     * @param request - ListOssScanConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListOssScanConfigResponse
     *
     * @param ListOssScanConfigRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return ListOssScanConfigResponse
     */
    public function listOssScanConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListOssScanConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListOssScanConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configuration of an Object Storage Service (OSS) file detection policy.
     *
     * @param request - ListOssScanConfigRequest
     *
     * @returns ListOssScanConfigResponse
     *
     * @param ListOssScanConfigRequest $request
     *
     * @return ListOssScanConfigResponse
     */
    public function listOssScanConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listOssScanConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the information about plug-ins on a server.
     *
     * @param tmpReq - ListPluginForUuidRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListPluginForUuidResponse
     *
     * @param ListPluginForUuidRequest $tmpReq
     * @param RuntimeOptions           $runtime
     *
     * @return ListPluginForUuidResponse
     */
    public function listPluginForUuidWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new ListPluginForUuidShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->types) {
            $request->typesShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->types, 'Types', 'simple');
        }

        $query = [];
        if (null !== $request->typesShrink) {
            @$query['Types'] = $request->typesShrink;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListPluginForUuid',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListPluginForUuidResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about plug-ins on a server.
     *
     * @param request - ListPluginForUuidRequest
     *
     * @returns ListPluginForUuidResponse
     *
     * @param ListPluginForUuidRequest $request
     *
     * @return ListPluginForUuidResponse
     */
    public function listPluginForUuid($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listPluginForUuidWithOptions($request, $runtime);
    }

    /**
     * Queries the security risks of a pod.
     *
     * @param request - ListPodRiskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListPodRiskResponse
     *
     * @param ListPodRiskRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return ListPodRiskResponse
     */
    public function listPodRiskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->namespace) {
            @$query['Namespace'] = $request->namespace;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->podName) {
            @$query['PodName'] = $request->podName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListPodRisk',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListPodRiskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the security risks of a pod.
     *
     * @param request - ListPodRiskRequest
     *
     * @returns ListPodRiskResponse
     *
     * @param ListPodRiskRequest $request
     *
     * @return ListPodRiskResponse
     */
    public function listPodRisk($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listPodRiskWithOptions($request, $runtime);
    }

    /**
     * Queries the information about the self-managed Kubernetes clusters that are added to Security Center.
     *
     * @param request - ListPrivateK8sRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListPrivateK8sResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return ListPrivateK8sResponse
     */
    public function listPrivateK8sWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'ListPrivateK8s',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListPrivateK8sResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about the self-managed Kubernetes clusters that are added to Security Center.
     *
     * @returns ListPrivateK8sResponse
     *
     * @return ListPrivateK8sResponse
     */
    public function listPrivateK8s()
    {
        $runtime = new RuntimeOptions([]);

        return $this->listPrivateK8sWithOptions($runtime);
    }

    /**
     * Queries image repositories.
     *
     * @param request - ListPrivateRegistryListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListPrivateRegistryListResponse
     *
     * @param ListPrivateRegistryListRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ListPrivateRegistryListResponse
     */
    public function listPrivateRegistryListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->registryType) {
            @$query['RegistryType'] = $request->registryType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListPrivateRegistryList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListPrivateRegistryListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries image repositories.
     *
     * @param request - ListPrivateRegistryListRequest
     *
     * @returns ListPrivateRegistryListResponse
     *
     * @param ListPrivateRegistryListRequest $request
     *
     * @return ListPrivateRegistryListResponse
     */
    public function listPrivateRegistryList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listPrivateRegistryListWithOptions($request, $runtime);
    }

    /**
     * Queries the number of image repositories of each type.
     *
     * @param request - ListPrivateRegistryTypeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListPrivateRegistryTypeResponse
     *
     * @param ListPrivateRegistryTypeRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ListPrivateRegistryTypeResponse
     */
    public function listPrivateRegistryTypeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListPrivateRegistryType',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListPrivateRegistryTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the number of image repositories of each type.
     *
     * @param request - ListPrivateRegistryTypeRequest
     *
     * @returns ListPrivateRegistryTypeResponse
     *
     * @param ListPrivateRegistryTypeRequest $request
     *
     * @return ListPrivateRegistryTypeResponse
     */
    public function listPrivateRegistryType($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listPrivateRegistryTypeWithOptions($request, $runtime);
    }

    /**
     * Query the details of a release batch for upgrade.
     *
     * @param request - ListPublishBatchRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListPublishBatchResponse
     *
     * @param ListPublishBatchRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return ListPublishBatchResponse
     */
    public function listPublishBatchWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->batchName) {
            @$query['BatchName'] = $request->batchName;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->upgradeVersion) {
            @$query['UpgradeVersion'] = $request->upgradeVersion;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListPublishBatch',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListPublishBatchResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Query the details of a release batch for upgrade.
     *
     * @param request - ListPublishBatchRequest
     *
     * @returns ListPublishBatchResponse
     *
     * @param ListPublishBatchRequest $request
     *
     * @return ListPublishBatchResponse
     */
    public function listPublishBatch($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listPublishBatchWithOptions($request, $runtime);
    }

    /**
     * Queries the automatic management policies of members that are added to Security Center for multi-account management. The members in the automatic control management directory are automatically added to the member list of Security Center.
     *
     * @remarks
     * You must use the management account of your resource directory or a delegated administrator account of Security Center to call this operation.
     *
     * @param request - ListRdDefaultSyncListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListRdDefaultSyncListResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return ListRdDefaultSyncListResponse
     */
    public function listRdDefaultSyncListWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'ListRdDefaultSyncList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListRdDefaultSyncListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the automatic management policies of members that are added to Security Center for multi-account management. The members in the automatic control management directory are automatically added to the member list of Security Center.
     *
     * @remarks
     * You must use the management account of your resource directory or a delegated administrator account of Security Center to call this operation.
     *
     * @returns ListRdDefaultSyncListResponse
     *
     * @return ListRdDefaultSyncListResponse
     */
    public function listRdDefaultSyncList()
    {
        $runtime = new RuntimeOptions([]);

        return $this->listRdDefaultSyncListWithOptions($runtime);
    }

    /**
     * Queries the network objects based on which a specified cluster is protected.
     *
     * @param request - ListRuleTargetAllRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListRuleTargetAllResponse
     *
     * @param ListRuleTargetAllRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return ListRuleTargetAllResponse
     */
    public function listRuleTargetAllWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListRuleTargetAll',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListRuleTargetAllResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the network objects based on which a specified cluster is protected.
     *
     * @param request - ListRuleTargetAllRequest
     *
     * @returns ListRuleTargetAllResponse
     *
     * @param ListRuleTargetAllRequest $request
     *
     * @return ListRuleTargetAllResponse
     */
    public function listRuleTargetAll($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listRuleTargetAllWithOptions($request, $runtime);
    }

    /**
     * Queries rules for container tamper-proofing.
     *
     * @param request - ListSasContainerWebDefenseRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListSasContainerWebDefenseRuleResponse
     *
     * @param ListSasContainerWebDefenseRuleRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return ListSasContainerWebDefenseRuleResponse
     */
    public function listSasContainerWebDefenseRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->criteria) {
            @$query['Criteria'] = $request->criteria;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->logicalExp) {
            @$query['LogicalExp'] = $request->logicalExp;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListSasContainerWebDefenseRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListSasContainerWebDefenseRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries rules for container tamper-proofing.
     *
     * @param request - ListSasContainerWebDefenseRuleRequest
     *
     * @returns ListSasContainerWebDefenseRuleResponse
     *
     * @param ListSasContainerWebDefenseRuleRequest $request
     *
     * @return ListSasContainerWebDefenseRuleResponse
     */
    public function listSasContainerWebDefenseRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listSasContainerWebDefenseRuleWithOptions($request, $runtime);
    }

    /**
     * Query the list of supported cloud products for attacks.
     *
     * @param request - ListSupportAttackPathAssetRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListSupportAttackPathAssetResponse
     *
     * @param ListSupportAttackPathAssetRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return ListSupportAttackPathAssetResponse
     */
    public function listSupportAttackPathAssetWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->nodeType) {
            @$query['NodeType'] = $request->nodeType;
        }

        if (null !== $request->pathName) {
            @$query['PathName'] = $request->pathName;
        }

        if (null !== $request->pathType) {
            @$query['PathType'] = $request->pathType;
        }

        if (null !== $request->supportType) {
            @$query['SupportType'] = $request->supportType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListSupportAttackPathAsset',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListSupportAttackPathAssetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Query the list of supported cloud products for attacks.
     *
     * @param request - ListSupportAttackPathAssetRequest
     *
     * @returns ListSupportAttackPathAssetResponse
     *
     * @param ListSupportAttackPathAssetRequest $request
     *
     * @return ListSupportAttackPathAssetResponse
     */
    public function listSupportAttackPathAsset($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listSupportAttackPathAssetWithOptions($request, $runtime);
    }

    /**
     * Queries supported file suffixes.
     *
     * @param request - ListSupportObjectSuffixRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListSupportObjectSuffixResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return ListSupportObjectSuffixResponse
     */
    public function listSupportObjectSuffixWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'ListSupportObjectSuffix',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListSupportObjectSuffixResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries supported file suffixes.
     *
     * @returns ListSupportObjectSuffixResponse
     *
     * @return ListSupportObjectSuffixResponse
     */
    public function listSupportObjectSuffix()
    {
        $runtime = new RuntimeOptions([]);

        return $this->listSupportObjectSuffixWithOptions($runtime);
    }

    /**
     * Queries the details about the aggregation types of system defense rules.
     *
     * @param request - ListSystemAggregationRulesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListSystemAggregationRulesResponse
     *
     * @param ListSystemAggregationRulesRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return ListSystemAggregationRulesResponse
     */
    public function listSystemAggregationRulesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListSystemAggregationRules',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListSystemAggregationRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details about the aggregation types of system defense rules.
     *
     * @param request - ListSystemAggregationRulesRequest
     *
     * @returns ListSystemAggregationRulesResponse
     *
     * @param ListSystemAggregationRulesRequest $request
     *
     * @return ListSystemAggregationRulesResponse
     */
    public function listSystemAggregationRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listSystemAggregationRulesWithOptions($request, $runtime);
    }

    /**
     * Queries the types of system rules.
     *
     * @param request - ListSystemClientRuleTypesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListSystemClientRuleTypesResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return ListSystemClientRuleTypesResponse
     */
    public function listSystemClientRuleTypesWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'ListSystemClientRuleTypes',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListSystemClientRuleTypesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the types of system rules.
     *
     * @returns ListSystemClientRuleTypesResponse
     *
     * @return ListSystemClientRuleTypesResponse
     */
    public function listSystemClientRuleTypes()
    {
        $runtime = new RuntimeOptions([]);

        return $this->listSystemClientRuleTypesWithOptions($runtime);
    }

    /**
     * Queries system defense rules.
     *
     * @param request - ListSystemClientRulesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListSystemClientRulesResponse
     *
     * @param ListSystemClientRulesRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return ListSystemClientRulesResponse
     */
    public function listSystemClientRulesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aggregationIds) {
            @$query['AggregationIds'] = $request->aggregationIds;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->isContainer) {
            @$query['IsContainer'] = $request->isContainer;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->ruleName) {
            @$query['RuleName'] = $request->ruleName;
        }

        if (null !== $request->ruleTypes) {
            @$query['RuleTypes'] = $request->ruleTypes;
        }

        if (null !== $request->systemType) {
            @$query['SystemType'] = $request->systemType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListSystemClientRules',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListSystemClientRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries system defense rules.
     *
     * @param request - ListSystemClientRulesRequest
     *
     * @returns ListSystemClientRulesResponse
     *
     * @param ListSystemClientRulesRequest $request
     *
     * @return ListSystemClientRulesResponse
     */
    public function listSystemClientRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listSystemClientRulesWithOptions($request, $runtime);
    }

    /**
     * Queries the aggregation types of system defense rules.
     *
     * @param request - ListSystemRuleAggregationTypesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListSystemRuleAggregationTypesResponse
     *
     * @param ListSystemRuleAggregationTypesRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return ListSystemRuleAggregationTypesResponse
     */
    public function listSystemRuleAggregationTypesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListSystemRuleAggregationTypes',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListSystemRuleAggregationTypesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the aggregation types of system defense rules.
     *
     * @param request - ListSystemRuleAggregationTypesRequest
     *
     * @returns ListSystemRuleAggregationTypesResponse
     *
     * @param ListSystemRuleAggregationTypesRequest $request
     *
     * @return ListSystemRuleAggregationTypesResponse
     */
    public function listSystemRuleAggregationTypes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listSystemRuleAggregationTypesWithOptions($request, $runtime);
    }

    /**
     * Query Targets by Batch.
     *
     * @param request - ListTargetByBatchRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListTargetByBatchResponse
     *
     * @param ListTargetByBatchRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return ListTargetByBatchResponse
     */
    public function listTargetByBatchWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->batchId) {
            @$query['BatchId'] = $request->batchId;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->operationBase) {
            @$query['OperationBase'] = $request->operationBase;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListTargetByBatch',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListTargetByBatchResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Query Targets by Batch.
     *
     * @param request - ListTargetByBatchRequest
     *
     * @returns ListTargetByBatchResponse
     *
     * @param ListTargetByBatchRequest $request
     *
     * @return ListTargetByBatchResponse
     */
    public function listTargetByBatch($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listTargetByBatchWithOptions($request, $runtime);
    }

    /**
     * Queries tasks that are not complete by task type.
     *
     * @param request - ListUnfinishedOnceTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListUnfinishedOnceTaskResponse
     *
     * @param ListUnfinishedOnceTaskRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return ListUnfinishedOnceTaskResponse
     */
    public function listUnfinishedOnceTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->target) {
            @$query['Target'] = $request->target;
        }

        if (null !== $request->taskType) {
            @$query['TaskType'] = $request->taskType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListUnfinishedOnceTask',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListUnfinishedOnceTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries tasks that are not complete by task type.
     *
     * @param request - ListUnfinishedOnceTaskRequest
     *
     * @returns ListUnfinishedOnceTaskResponse
     *
     * @param ListUnfinishedOnceTaskRequest $request
     *
     * @return ListUnfinishedOnceTaskResponse
     */
    public function listUnfinishedOnceTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listUnfinishedOnceTaskWithOptions($request, $runtime);
    }

    /**
     * List Database Backup Records.
     *
     * @param request - ListUniBackupRecordRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListUniBackupRecordResponse
     *
     * @param ListUniBackupRecordRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ListUniBackupRecordResponse
     */
    public function listUniBackupRecordWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->backupRegionId) {
            @$query['BackupRegionId'] = $request->backupRegionId;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->machineRemark) {
            @$query['MachineRemark'] = $request->machineRemark;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->state) {
            @$query['State'] = $request->state;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListUniBackupRecord',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListUniBackupRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * List Database Backup Records.
     *
     * @param request - ListUniBackupRecordRequest
     *
     * @returns ListUniBackupRecordResponse
     *
     * @param ListUniBackupRecordRequest $request
     *
     * @return ListUniBackupRecordResponse
     */
    public function listUniBackupRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listUniBackupRecordWithOptions($request, $runtime);
    }

    /**
     * Queries the information about the servers whose Security Center agent is not installed.
     *
     * @param request - ListUninstallAegisMachinesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListUninstallAegisMachinesResponse
     *
     * @param ListUninstallAegisMachinesRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return ListUninstallAegisMachinesResponse
     */
    public function listUninstallAegisMachinesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->os) {
            @$query['Os'] = $request->os;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionIdStr) {
            @$query['RegionIdStr'] = $request->regionIdStr;
        }

        if (null !== $request->regionNo) {
            @$query['RegionNo'] = $request->regionNo;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->vendor) {
            @$query['Vendor'] = $request->vendor;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListUninstallAegisMachines',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListUninstallAegisMachinesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about the servers whose Security Center agent is not installed.
     *
     * @param request - ListUninstallAegisMachinesRequest
     *
     * @returns ListUninstallAegisMachinesResponse
     *
     * @param ListUninstallAegisMachinesRequest $request
     *
     * @return ListUninstallAegisMachinesResponse
     */
    public function listUninstallAegisMachines($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listUninstallAegisMachinesWithOptions($request, $runtime);
    }

    /**
     * Get VPC Data.
     *
     * @param request - ListUserVpcRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListUserVpcResponse
     *
     * @param ListUserVpcRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return ListUserVpcResponse
     */
    public function listUserVpcWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->k8sRegionId) {
            @$query['K8sRegionId'] = $request->k8sRegionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListUserVpc',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListUserVpcResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Get VPC Data.
     *
     * @param request - ListUserVpcRequest
     *
     * @returns ListUserVpcResponse
     *
     * @param ListUserVpcRequest $request
     *
     * @return ListUserVpcResponse
     */
    public function listUserVpc($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listUserVpcWithOptions($request, $runtime);
    }

    /**
     * Queries the UUIDs of Serverless App Engine (SAE) instances based on an application ID.
     *
     * @param request - ListUuidsByAppIdRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListUuidsByAppIdResponse
     *
     * @param ListUuidsByAppIdRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return ListUuidsByAppIdResponse
     */
    public function listUuidsByAppIdWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appId) {
            @$query['AppId'] = $request->appId;
        }

        if (null !== $request->appRegionId) {
            @$query['AppRegionId'] = $request->appRegionId;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->resourceDirectoryUid) {
            @$query['ResourceDirectoryUid'] = $request->resourceDirectoryUid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListUuidsByAppId',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListUuidsByAppIdResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the UUIDs of Serverless App Engine (SAE) instances based on an application ID.
     *
     * @param request - ListUuidsByAppIdRequest
     *
     * @returns ListUuidsByAppIdResponse
     *
     * @param ListUuidsByAppIdRequest $request
     *
     * @return ListUuidsByAppIdResponse
     */
    public function listUuidsByAppId($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listUuidsByAppIdWithOptions($request, $runtime);
    }

    /**
     * Queries protected assets by using the paths to specific web directories.
     *
     * @param request - ListUuidsByWebPathRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListUuidsByWebPathResponse
     *
     * @param ListUuidsByWebPathRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return ListUuidsByWebPathResponse
     */
    public function listUuidsByWebPathWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        if (null !== $request->webPath) {
            @$query['WebPath'] = $request->webPath;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListUuidsByWebPath',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListUuidsByWebPathResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries protected assets by using the paths to specific web directories.
     *
     * @param request - ListUuidsByWebPathRequest
     *
     * @returns ListUuidsByWebPathResponse
     *
     * @param ListUuidsByWebPathRequest $request
     *
     * @return ListUuidsByWebPathResponse
     */
    public function listUuidsByWebPath($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listUuidsByWebPathWithOptions($request, $runtime);
    }

    /**
     * Queries servers on which virus detection and removal tasks are performed.
     *
     * @param request - ListVirusScanMachineRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListVirusScanMachineResponse
     *
     * @param ListVirusScanMachineRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return ListVirusScanMachineResponse
     */
    public function listVirusScanMachineWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListVirusScanMachine',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListVirusScanMachineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries servers on which virus detection and removal tasks are performed.
     *
     * @param request - ListVirusScanMachineRequest
     *
     * @returns ListVirusScanMachineResponse
     *
     * @param ListVirusScanMachineRequest $request
     *
     * @return ListVirusScanMachineResponse
     */
    public function listVirusScanMachine($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listVirusScanMachineWithOptions($request, $runtime);
    }

    /**
     * Queries the alert events that are generated for viruses detected on a server.
     *
     * @param request - ListVirusScanMachineEventRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListVirusScanMachineEventResponse
     *
     * @param ListVirusScanMachineEventRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return ListVirusScanMachineEventResponse
     */
    public function listVirusScanMachineEventWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->operateTaskId) {
            @$query['OperateTaskId'] = $request->operateTaskId;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListVirusScanMachineEvent',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListVirusScanMachineEventResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the alert events that are generated for viruses detected on a server.
     *
     * @param request - ListVirusScanMachineEventRequest
     *
     * @returns ListVirusScanMachineEventResponse
     *
     * @param ListVirusScanMachineEventRequest $request
     *
     * @return ListVirusScanMachineEventResponse
     */
    public function listVirusScanMachineEvent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listVirusScanMachineEventWithOptions($request, $runtime);
    }

    /**
     * Queries virus scan tasks based on conditions such as the task type, task status, and server information.
     *
     * @param request - ListVirusScanTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListVirusScanTaskResponse
     *
     * @param ListVirusScanTaskRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return ListVirusScanTaskResponse
     */
    public function listVirusScanTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->internetIp) {
            @$query['InternetIp'] = $request->internetIp;
        }

        if (null !== $request->intranetIp) {
            @$query['IntranetIp'] = $request->intranetIp;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->machineName) {
            @$query['MachineName'] = $request->machineName;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->rootTask) {
            @$query['RootTask'] = $request->rootTask;
        }

        if (null !== $request->rootTaskId) {
            @$query['RootTaskId'] = $request->rootTaskId;
        }

        if (null !== $request->scanType) {
            @$query['ScanType'] = $request->scanType;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->statusList) {
            @$query['StatusList'] = $request->statusList;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListVirusScanTask',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListVirusScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries virus scan tasks based on conditions such as the task type, task status, and server information.
     *
     * @param request - ListVirusScanTaskRequest
     *
     * @returns ListVirusScanTaskResponse
     *
     * @param ListVirusScanTaskRequest $request
     *
     * @return ListVirusScanTaskResponse
     */
    public function listVirusScanTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listVirusScanTaskWithOptions($request, $runtime);
    }

    /**
     * Queries the existing configurations of vulnerabilities that can be automatically fixed.
     *
     * @param request - ListVulAutoRepairConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListVulAutoRepairConfigResponse
     *
     * @param ListVulAutoRepairConfigRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ListVulAutoRepairConfigResponse
     */
    public function listVulAutoRepairConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aliasName) {
            @$query['AliasName'] = $request->aliasName;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListVulAutoRepairConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListVulAutoRepairConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the existing configurations of vulnerabilities that can be automatically fixed.
     *
     * @param request - ListVulAutoRepairConfigRequest
     *
     * @returns ListVulAutoRepairConfigResponse
     *
     * @param ListVulAutoRepairConfigRequest $request
     *
     * @return ListVulAutoRepairConfigResponse
     */
    public function listVulAutoRepairConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listVulAutoRepairConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the global configurations of vulnerability detection.
     *
     * @param request - ListVulGlobalConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListVulGlobalConfigResponse
     *
     * @param ListVulGlobalConfigRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ListVulGlobalConfigResponse
     */
    public function listVulGlobalConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->configKey) {
            @$query['ConfigKey'] = $request->configKey;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListVulGlobalConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListVulGlobalConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the global configurations of vulnerability detection.
     *
     * @param request - ListVulGlobalConfigRequest
     *
     * @returns ListVulGlobalConfigResponse
     *
     * @param ListVulGlobalConfigRequest $request
     *
     * @return ListVulGlobalConfigResponse
     */
    public function listVulGlobalConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listVulGlobalConfigWithOptions($request, $runtime);
    }

    /**
     * Marks members for multi-account management. You can call this operation to mark selected members as followed. In the Security Center console, the drop-down list above the left-side navigation pane displays the followed members.
     *
     * @param request - MarkMonitorAccountsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns MarkMonitorAccountsResponse
     *
     * @param MarkMonitorAccountsRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return MarkMonitorAccountsResponse
     */
    public function markMonitorAccountsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accountIds) {
            @$query['AccountIds'] = $request->accountIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'MarkMonitorAccounts',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return MarkMonitorAccountsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Marks members for multi-account management. You can call this operation to mark selected members as followed. In the Security Center console, the drop-down list above the left-side navigation pane displays the followed members.
     *
     * @param request - MarkMonitorAccountsRequest
     *
     * @returns MarkMonitorAccountsResponse
     *
     * @param MarkMonitorAccountsRequest $request
     *
     * @return MarkMonitorAccountsResponse
     */
    public function markMonitorAccounts($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->markMonitorAccountsWithOptions($request, $runtime);
    }

    /**
     * Handles AccessKey pair leaks.
     *
     * @param request - ModifyAccessKeyLeakDealRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyAccessKeyLeakDealResponse
     *
     * @param ModifyAccessKeyLeakDealRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ModifyAccessKeyLeakDealResponse
     */
    public function modifyAccessKeyLeakDealWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        if (null !== $request->idList) {
            @$query['IdList'] = $request->idList;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyAccessKeyLeakDeal',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyAccessKeyLeakDealResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Handles AccessKey pair leaks.
     *
     * @param request - ModifyAccessKeyLeakDealRequest
     *
     * @returns ModifyAccessKeyLeakDealResponse
     *
     * @param ModifyAccessKeyLeakDealRequest $request
     *
     * @return ModifyAccessKeyLeakDealResponse
     */
    public function modifyAccessKeyLeakDeal($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyAccessKeyLeakDealWithOptions($request, $runtime);
    }

    /**
     * Modifies a defense rule against brute-force attacks.
     *
     * @param tmpReq - ModifyAntiBruteForceRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyAntiBruteForceRuleResponse
     *
     * @param ModifyAntiBruteForceRuleRequest $tmpReq
     * @param RuntimeOptions                  $runtime
     *
     * @return ModifyAntiBruteForceRuleResponse
     */
    public function modifyAntiBruteForceRuleWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new ModifyAntiBruteForceRuleShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->protocolType) {
            $request->protocolTypeShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->protocolType, 'ProtocolType', 'json');
        }

        $query = [];
        if (null !== $request->defaultRule) {
            @$query['DefaultRule'] = $request->defaultRule;
        }

        if (null !== $request->failCount) {
            @$query['FailCount'] = $request->failCount;
        }

        if (null !== $request->forbiddenTime) {
            @$query['ForbiddenTime'] = $request->forbiddenTime;
        }

        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->protocolTypeShrink) {
            @$query['ProtocolType'] = $request->protocolTypeShrink;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->span) {
            @$query['Span'] = $request->span;
        }

        if (null !== $request->uuidList) {
            @$query['UuidList'] = $request->uuidList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyAntiBruteForceRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyAntiBruteForceRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies a defense rule against brute-force attacks.
     *
     * @param request - ModifyAntiBruteForceRuleRequest
     *
     * @returns ModifyAntiBruteForceRuleResponse
     *
     * @param ModifyAntiBruteForceRuleRequest $request
     *
     * @return ModifyAntiBruteForceRuleResponse
     */
    public function modifyAntiBruteForceRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyAntiBruteForceRuleWithOptions($request, $runtime);
    }

    /**
     * Configures a scan cycle for application vulnerabilities.
     *
     * @param request - ModifyAppVulScanCycleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyAppVulScanCycleResponse
     *
     * @param ModifyAppVulScanCycleRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return ModifyAppVulScanCycleResponse
     */
    public function modifyAppVulScanCycleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->cycle) {
            @$query['Cycle'] = $request->cycle;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyAppVulScanCycle',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyAppVulScanCycleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures a scan cycle for application vulnerabilities.
     *
     * @param request - ModifyAppVulScanCycleRequest
     *
     * @returns ModifyAppVulScanCycleResponse
     *
     * @param ModifyAppVulScanCycleRequest $request
     *
     * @return ModifyAppVulScanCycleResponse
     */
    public function modifyAppVulScanCycle($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyAppVulScanCycleWithOptions($request, $runtime);
    }

    /**
     * Modifies the configurations for cleaning offline hosts whose provider cannot be identified.
     *
     * @param request - ModifyAssetCleanConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyAssetCleanConfigResponse
     *
     * @param ModifyAssetCleanConfigRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return ModifyAssetCleanConfigResponse
     */
    public function modifyAssetCleanConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->assetCleanConfigs) {
            @$query['AssetCleanConfigs'] = $request->assetCleanConfigs;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyAssetCleanConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyAssetCleanConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configurations for cleaning offline hosts whose provider cannot be identified.
     *
     * @param request - ModifyAssetCleanConfigRequest
     *
     * @returns ModifyAssetCleanConfigResponse
     *
     * @param ModifyAssetCleanConfigRequest $request
     *
     * @return ModifyAssetCleanConfigResponse
     */
    public function modifyAssetCleanConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyAssetCleanConfigWithOptions($request, $runtime);
    }

    /**
     * Changes the server group to which specified servers belong.
     *
     * @remarks
     * You can call the ModifyAssetGroup operation to change the server group to which one or more servers belong. After you create a server group by calling the [CreateOrUpdateAssetGroup](~~CreateOrUpdateAssetGroup~~) operation, you can call the ModifyAssetGroup operation to change the server group to which your servers belong.
     * ### Limits
     * You can call this API operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - ModifyAssetGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyAssetGroupResponse
     *
     * @param ModifyAssetGroupRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return ModifyAssetGroupResponse
     */
    public function modifyAssetGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->groupId) {
            @$query['GroupId'] = $request->groupId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyAssetGroup',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyAssetGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the server group to which specified servers belong.
     *
     * @remarks
     * You can call the ModifyAssetGroup operation to change the server group to which one or more servers belong. After you create a server group by calling the [CreateOrUpdateAssetGroup](~~CreateOrUpdateAssetGroup~~) operation, you can call the ModifyAssetGroup operation to change the server group to which your servers belong.
     * ### Limits
     * You can call this API operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - ModifyAssetGroupRequest
     *
     * @returns ModifyAssetGroupResponse
     *
     * @param ModifyAssetGroupRequest $request
     *
     * @return ModifyAssetGroupResponse
     */
    public function modifyAssetGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyAssetGroupWithOptions($request, $runtime);
    }

    /**
     * Modifies the importance of an asset.
     *
     * @param request - ModifyAssetImportantRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyAssetImportantResponse
     *
     * @param ModifyAssetImportantRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return ModifyAssetImportantResponse
     */
    public function modifyAssetImportantWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->importantCode) {
            @$query['ImportantCode'] = $request->importantCode;
        }

        if (null !== $request->uuidList) {
            @$query['UuidList'] = $request->uuidList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyAssetImportant',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyAssetImportantResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the importance of an asset.
     *
     * @param request - ModifyAssetImportantRequest
     *
     * @returns ModifyAssetImportantResponse
     *
     * @param ModifyAssetImportantRequest $request
     *
     * @return ModifyAssetImportantResponse
     */
    public function modifyAssetImportant($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyAssetImportantWithOptions($request, $runtime);
    }

    /**
     * Modifies the information about a witness that is created by using the container signature feature.
     *
     * @param request - ModifyAttestorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyAttestorResponse
     *
     * @param ModifyAttestorRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return ModifyAttestorResponse
     */
    public function modifyAttestorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->keyId) {
            @$query['KeyId'] = $request->keyId;
        }

        if (null !== $request->keyRegionId) {
            @$query['KeyRegionId'] = $request->keyRegionId;
        }

        if (null !== $request->keyVersionId) {
            @$query['KeyVersionId'] = $request->keyVersionId;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyAttestor',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyAttestorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the information about a witness that is created by using the container signature feature.
     *
     * @param request - ModifyAttestorRequest
     *
     * @returns ModifyAttestorResponse
     *
     * @param ModifyAttestorRequest $request
     *
     * @return ModifyAttestorResponse
     */
    public function modifyAttestor($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyAttestorWithOptions($request, $runtime);
    }

    /**
     * Specifies the number of days after which a detected vulnerability is automatically deleted.
     *
     * @param request - ModifyAutoDelConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyAutoDelConfigResponse
     *
     * @param ModifyAutoDelConfigRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ModifyAutoDelConfigResponse
     */
    public function modifyAutoDelConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->days) {
            @$query['Days'] = $request->days;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyAutoDelConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyAutoDelConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Specifies the number of days after which a detected vulnerability is automatically deleted.
     *
     * @param request - ModifyAutoDelConfigRequest
     *
     * @returns ModifyAutoDelConfigResponse
     *
     * @param ModifyAutoDelConfigRequest $request
     *
     * @return ModifyAutoDelConfigResponse
     */
    public function modifyAutoDelConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyAutoDelConfigWithOptions($request, $runtime);
    }

    /**
     * Modifies an anti-ransomware policy.
     *
     * @param tmpReq - ModifyBackupPolicyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyBackupPolicyResponse
     *
     * @param ModifyBackupPolicyRequest $tmpReq
     * @param RuntimeOptions            $runtime
     *
     * @return ModifyBackupPolicyResponse
     */
    public function modifyBackupPolicyWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new ModifyBackupPolicyShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->policy) {
            $request->policyShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->policy, 'Policy', 'json');
        }

        $query = [];
        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->policyShrink) {
            @$query['Policy'] = $request->policyShrink;
        }

        if (null !== $request->policyRegionId) {
            @$query['PolicyRegionId'] = $request->policyRegionId;
        }

        if (null !== $request->policyVersion) {
            @$query['PolicyVersion'] = $request->policyVersion;
        }

        if (null !== $request->uuidList) {
            @$query['UuidList'] = $request->uuidList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyBackupPolicy',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyBackupPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies an anti-ransomware policy.
     *
     * @param request - ModifyBackupPolicyRequest
     *
     * @returns ModifyBackupPolicyResponse
     *
     * @param ModifyBackupPolicyRequest $request
     *
     * @return ModifyBackupPolicyResponse
     */
    public function modifyBackupPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyBackupPolicyWithOptions($request, $runtime);
    }

    /**
     * Enables or disables an anti-ransomware policy.
     *
     * @param request - ModifyBackupPolicyStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyBackupPolicyStatusResponse
     *
     * @param ModifyBackupPolicyStatusRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return ModifyBackupPolicyStatusResponse
     */
    public function modifyBackupPolicyStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        if (null !== $request->policyVersion) {
            @$query['PolicyVersion'] = $request->policyVersion;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyBackupPolicyStatus',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyBackupPolicyStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables or disables an anti-ransomware policy.
     *
     * @param request - ModifyBackupPolicyStatusRequest
     *
     * @returns ModifyBackupPolicyStatusResponse
     *
     * @param ModifyBackupPolicyStatusRequest $request
     *
     * @return ModifyBackupPolicyStatusResponse
     */
    public function modifyBackupPolicyStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyBackupPolicyStatusWithOptions($request, $runtime);
    }

    /**
     * Modify Container Image Signature Security Policy.
     *
     * @param request - ModifyBinarySecurityPolicyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyBinarySecurityPolicyResponse
     *
     * @param ModifyBinarySecurityPolicyRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return ModifyBinarySecurityPolicyResponse
     */
    public function modifyBinarySecurityPolicyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusters) {
            @$query['Clusters'] = $request->clusters;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->policy) {
            @$query['Policy'] = $request->policy;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyBinarySecurityPolicy',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyBinarySecurityPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modify Container Image Signature Security Policy.
     *
     * @param request - ModifyBinarySecurityPolicyRequest
     *
     * @returns ModifyBinarySecurityPolicyResponse
     *
     * @param ModifyBinarySecurityPolicyRequest $request
     *
     * @return ModifyBinarySecurityPolicyResponse
     */
    public function modifyBinarySecurityPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyBinarySecurityPolicyWithOptions($request, $runtime);
    }

    /**
     * Modify the rule settings for cloud product configuration checks.
     *
     * @param request - ModifyCheckRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyCheckRuleResponse
     *
     * @param ModifyCheckRuleRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return ModifyCheckRuleResponse
     */
    public function modifyCheckRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->addInstanceList) {
            @$query['AddInstanceList'] = $request->addInstanceList;
        }

        if (null !== $request->deleteInstanceList) {
            @$query['DeleteInstanceList'] = $request->deleteInstanceList;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->ruleId) {
            @$query['RuleId'] = $request->ruleId;
        }

        if (null !== $request->ruleType) {
            @$query['RuleType'] = $request->ruleType;
        }

        if (null !== $request->scopeType) {
            @$query['ScopeType'] = $request->scopeType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyCheckRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyCheckRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modify the rule settings for cloud product configuration checks.
     *
     * @param request - ModifyCheckRuleRequest
     *
     * @returns ModifyCheckRuleResponse
     *
     * @param ModifyCheckRuleRequest $request
     *
     * @return ModifyCheckRuleResponse
     */
    public function modifyCheckRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyCheckRuleWithOptions($request, $runtime);
    }

    /**
     * Deletes all logs that occupy your log storage.
     *
     * @remarks
     * Deleted logs cannot be restored. Before you call this operation to delete all logs and free up log storage, we recommend that you export and save your logs to your computer.
     *
     * @param request - ModifyClearLogstoreStorageRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyClearLogstoreStorageResponse
     *
     * @param ModifyClearLogstoreStorageRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return ModifyClearLogstoreStorageResponse
     */
    public function modifyClearLogstoreStorageWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->userLogStore) {
            @$query['UserLogStore'] = $request->userLogStore;
        }

        if (null !== $request->userProject) {
            @$query['UserProject'] = $request->userProject;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyClearLogstoreStorage',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyClearLogstoreStorageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes all logs that occupy your log storage.
     *
     * @remarks
     * Deleted logs cannot be restored. Before you call this operation to delete all logs and free up log storage, we recommend that you export and save your logs to your computer.
     *
     * @param request - ModifyClearLogstoreStorageRequest
     *
     * @returns ModifyClearLogstoreStorageResponse
     *
     * @param ModifyClearLogstoreStorageRequest $request
     *
     * @return ModifyClearLogstoreStorageResponse
     */
    public function modifyClearLogstoreStorage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyClearLogstoreStorageWithOptions($request, $runtime);
    }

    /**
     * Modifies the resource configurations of the Security Center agent.
     *
     * @param request - ModifyClientConfSetupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyClientConfSetupResponse
     *
     * @param ModifyClientConfSetupRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return ModifyClientConfSetupResponse
     */
    public function modifyClientConfSetupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->strategyConfig) {
            @$query['StrategyConfig'] = $request->strategyConfig;
        }

        if (null !== $request->strategyTag) {
            @$query['StrategyTag'] = $request->strategyTag;
        }

        if (null !== $request->strategyTagValue) {
            @$query['StrategyTagValue'] = $request->strategyTagValue;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyClientConfSetup',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyClientConfSetupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the resource configurations of the Security Center agent.
     *
     * @param request - ModifyClientConfSetupRequest
     *
     * @returns ModifyClientConfSetupResponse
     *
     * @param ModifyClientConfSetupRequest $request
     *
     * @return ModifyClientConfSetupResponse
     */
    public function modifyClientConfSetup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyClientConfSetupWithOptions($request, $runtime);
    }

    /**
     * Modifies an agent configuration policy.
     *
     * @param request - ModifyClientConfStrategyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyClientConfStrategyResponse
     *
     * @param ModifyClientConfStrategyRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return ModifyClientConfStrategyResponse
     */
    public function modifyClientConfStrategyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->tagExt) {
            @$query['TagExt'] = $request->tagExt;
        }

        if (null !== $request->tagValue) {
            @$query['TagValue'] = $request->tagValue;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyClientConfStrategy',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyClientConfStrategyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies an agent configuration policy.
     *
     * @param request - ModifyClientConfStrategyRequest
     *
     * @returns ModifyClientConfStrategyResponse
     *
     * @param ModifyClientConfStrategyRequest $request
     *
     * @return ModifyClientConfStrategyResponse
     */
    public function modifyClientConfStrategy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyClientConfStrategyWithOptions($request, $runtime);
    }

    /**
     * Modifies a custom defense rule.
     *
     * @param request - ModifyClientUserDefineRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyClientUserDefineRuleResponse
     *
     * @param ModifyClientUserDefineRuleRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return ModifyClientUserDefineRuleResponse
     */
    public function modifyClientUserDefineRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->actionType) {
            @$query['ActionType'] = $request->actionType;
        }

        if (null !== $request->cmdline) {
            @$query['Cmdline'] = $request->cmdline;
        }

        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->filePath) {
            @$query['FilePath'] = $request->filePath;
        }

        if (null !== $request->IP) {
            @$query['IP'] = $request->IP;
        }

        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        if (null !== $request->md5List) {
            @$query['Md5List'] = $request->md5List;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->newFilePath) {
            @$query['NewFilePath'] = $request->newFilePath;
        }

        if (null !== $request->parentCmdline) {
            @$query['ParentCmdline'] = $request->parentCmdline;
        }

        if (null !== $request->parentProcPath) {
            @$query['ParentProcPath'] = $request->parentProcPath;
        }

        if (null !== $request->platform) {
            @$query['Platform'] = $request->platform;
        }

        if (null !== $request->port) {
            @$query['Port'] = $request->port;
        }

        if (null !== $request->portStr) {
            @$query['PortStr'] = $request->portStr;
        }

        if (null !== $request->procPath) {
            @$query['ProcPath'] = $request->procPath;
        }

        if (null !== $request->registryContent) {
            @$query['RegistryContent'] = $request->registryContent;
        }

        if (null !== $request->registryKey) {
            @$query['RegistryKey'] = $request->registryKey;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyClientUserDefineRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyClientUserDefineRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies a custom defense rule.
     *
     * @param request - ModifyClientUserDefineRuleRequest
     *
     * @returns ModifyClientUserDefineRuleResponse
     *
     * @param ModifyClientUserDefineRuleRequest $request
     *
     * @return ModifyClientUserDefineRuleResponse
     */
    public function modifyClientUserDefineRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyClientUserDefineRuleWithOptions($request, $runtime);
    }

    /**
     * Modifies the configuration of the AccessKey pair for a third-party account.
     *
     * @param request - ModifyCloudVendorAccountAKRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyCloudVendorAccountAKResponse
     *
     * @param ModifyCloudVendorAccountAKRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return ModifyCloudVendorAccountAKResponse
     */
    public function modifyCloudVendorAccountAKWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->authIds) {
            @$query['AuthIds'] = $request->authIds;
        }

        if (null !== $request->authModules) {
            @$query['AuthModules'] = $request->authModules;
        }

        if (null !== $request->ctdrCloudUserId) {
            @$query['CtdrCloudUserId'] = $request->ctdrCloudUserId;
        }

        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->extendInfo) {
            @$query['ExtendInfo'] = $request->extendInfo;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->regions) {
            @$query['Regions'] = $request->regions;
        }

        if (null !== $request->secretId) {
            @$query['SecretId'] = $request->secretId;
        }

        if (null !== $request->secretKey) {
            @$query['SecretKey'] = $request->secretKey;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->subscriptionIds) {
            @$query['SubscriptionIds'] = $request->subscriptionIds;
        }

        if (null !== $request->tenantId) {
            @$query['TenantId'] = $request->tenantId;
        }

        if (null !== $request->vendorAuthAlias) {
            @$query['VendorAuthAlias'] = $request->vendorAuthAlias;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyCloudVendorAccountAK',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyCloudVendorAccountAKResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configuration of the AccessKey pair for a third-party account.
     *
     * @param request - ModifyCloudVendorAccountAKRequest
     *
     * @returns ModifyCloudVendorAccountAKResponse
     *
     * @param ModifyCloudVendorAccountAKRequest $request
     *
     * @return ModifyCloudVendorAccountAKResponse
     */
    public function modifyCloudVendorAccountAK($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyCloudVendorAccountAKWithOptions($request, $runtime);
    }

    /**
     * Modify the Trail configuration information for the AK.
     *
     * @param request - ModifyCloudVendorTrialConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyCloudVendorTrialConfigResponse
     *
     * @param ModifyCloudVendorTrialConfigRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return ModifyCloudVendorTrialConfigResponse
     */
    public function modifyCloudVendorTrialConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->authId) {
            @$query['AuthId'] = $request->authId;
        }

        if (null !== $request->authInfo) {
            @$query['AuthInfo'] = $request->authInfo;
        }

        if (null !== $request->deleteTrail) {
            @$query['DeleteTrail'] = $request->deleteTrail;
        }

        if (null !== $request->vendor) {
            @$query['Vendor'] = $request->vendor;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyCloudVendorTrialConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyCloudVendorTrialConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modify the Trail configuration information for the AK.
     *
     * @param request - ModifyCloudVendorTrialConfigRequest
     *
     * @returns ModifyCloudVendorTrialConfigResponse
     *
     * @param ModifyCloudVendorTrialConfigRequest $request
     *
     * @return ModifyCloudVendorTrialConfigResponse
     */
    public function modifyCloudVendorTrialConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyCloudVendorTrialConfigWithOptions($request, $runtime);
    }

    /**
     * Fixes the blocking status of clusters whose status is Normal to be confirmed.
     *
     * @param request - ModifyClusterCnnfStatusUserConfirmRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyClusterCnnfStatusUserConfirmResponse
     *
     * @param ModifyClusterCnnfStatusUserConfirmRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return ModifyClusterCnnfStatusUserConfirmResponse
     */
    public function modifyClusterCnnfStatusUserConfirmWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterIds) {
            @$query['ClusterIds'] = $request->clusterIds;
        }

        if (null !== $request->userConfirm) {
            @$query['UserConfirm'] = $request->userConfirm;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyClusterCnnfStatusUserConfirm',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyClusterCnnfStatusUserConfirmResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Fixes the blocking status of clusters whose status is Normal to be confirmed.
     *
     * @param request - ModifyClusterCnnfStatusUserConfirmRequest
     *
     * @returns ModifyClusterCnnfStatusUserConfirmResponse
     *
     * @param ModifyClusterCnnfStatusUserConfirmRequest $request
     *
     * @return ModifyClusterCnnfStatusUserConfirmResponse
     */
    public function modifyClusterCnnfStatusUserConfirm($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyClusterCnnfStatusUserConfirmWithOptions($request, $runtime);
    }

    /**
     * Modifies the priority to fix vulnerabilities.
     *
     * @param request - ModifyConcernNecessityRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyConcernNecessityResponse
     *
     * @param ModifyConcernNecessityRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return ModifyConcernNecessityResponse
     */
    public function modifyConcernNecessityWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->concernNecessity) {
            @$query['ConcernNecessity'] = $request->concernNecessity;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyConcernNecessity',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyConcernNecessityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the priority to fix vulnerabilities.
     *
     * @param request - ModifyConcernNecessityRequest
     *
     * @returns ModifyConcernNecessityResponse
     *
     * @param ModifyConcernNecessityRequest $request
     *
     * @return ModifyConcernNecessityResponse
     */
    public function modifyConcernNecessity($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyConcernNecessityWithOptions($request, $runtime);
    }

    /**
     * Modifies a rule for non-image program defense.
     *
     * @param tmpReq - ModifyContainerDefenseRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyContainerDefenseRuleResponse
     *
     * @param ModifyContainerDefenseRuleRequest $tmpReq
     * @param RuntimeOptions                    $runtime
     *
     * @return ModifyContainerDefenseRuleResponse
     */
    public function modifyContainerDefenseRuleWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new ModifyContainerDefenseRuleShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->whitelist) {
            $request->whitelistShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->whitelist, 'Whitelist', 'json');
        }

        $query = [];
        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->ruleAction) {
            @$query['RuleAction'] = $request->ruleAction;
        }

        if (null !== $request->ruleId) {
            @$query['RuleId'] = $request->ruleId;
        }

        if (null !== $request->ruleName) {
            @$query['RuleName'] = $request->ruleName;
        }

        if (null !== $request->ruleSwitch) {
            @$query['RuleSwitch'] = $request->ruleSwitch;
        }

        if (null !== $request->ruleType) {
            @$query['RuleType'] = $request->ruleType;
        }

        if (null !== $request->scope) {
            @$query['Scope'] = $request->scope;
        }

        if (null !== $request->whitelistShrink) {
            @$query['Whitelist'] = $request->whitelistShrink;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyContainerDefenseRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyContainerDefenseRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies a rule for non-image program defense.
     *
     * @param request - ModifyContainerDefenseRuleRequest
     *
     * @returns ModifyContainerDefenseRuleResponse
     *
     * @param ModifyContainerDefenseRuleRequest $request
     *
     * @return ModifyContainerDefenseRuleResponse
     */
    public function modifyContainerDefenseRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyContainerDefenseRuleWithOptions($request, $runtime);
    }

    /**
     * Changes the status of non-image program defense rules.
     *
     * @param request - ModifyContainerDefenseRuleSwitchRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyContainerDefenseRuleSwitchResponse
     *
     * @param ModifyContainerDefenseRuleSwitchRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return ModifyContainerDefenseRuleSwitchResponse
     */
    public function modifyContainerDefenseRuleSwitchWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ruleIds) {
            @$query['RuleIds'] = $request->ruleIds;
        }

        if (null !== $request->ruleSwitch) {
            @$query['RuleSwitch'] = $request->ruleSwitch;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyContainerDefenseRuleSwitch',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyContainerDefenseRuleSwitchResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the status of non-image program defense rules.
     *
     * @param request - ModifyContainerDefenseRuleSwitchRequest
     *
     * @returns ModifyContainerDefenseRuleSwitchResponse
     *
     * @param ModifyContainerDefenseRuleSwitchRequest $request
     *
     * @return ModifyContainerDefenseRuleSwitchResponse
     */
    public function modifyContainerDefenseRuleSwitch($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyContainerDefenseRuleSwitchWithOptions($request, $runtime);
    }

    /**
     * Modifies the defense rule against container escapes.
     *
     * @param request - ModifyContainerPluginRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyContainerPluginRuleResponse
     *
     * @param ModifyContainerPluginRuleRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return ModifyContainerPluginRuleResponse
     */
    public function modifyContainerPluginRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->mode) {
            @$query['Mode'] = $request->mode;
        }

        if (null !== $request->ruleId) {
            @$query['RuleId'] = $request->ruleId;
        }

        if (null !== $request->ruleName) {
            @$query['RuleName'] = $request->ruleName;
        }

        if (null !== $request->ruleType) {
            @$query['RuleType'] = $request->ruleType;
        }

        if (null !== $request->selectedPolicy) {
            @$query['SelectedPolicy'] = $request->selectedPolicy;
        }

        if (null !== $request->whiteImages) {
            @$query['WhiteImages'] = $request->whiteImages;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyContainerPluginRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyContainerPluginRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the defense rule against container escapes.
     *
     * @param request - ModifyContainerPluginRuleRequest
     *
     * @returns ModifyContainerPluginRuleResponse
     *
     * @param ModifyContainerPluginRuleRequest $request
     *
     * @return ModifyContainerPluginRuleResponse
     */
    public function modifyContainerPluginRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyContainerPluginRuleWithOptions($request, $runtime);
    }

    /**
     * Modifies the configurations of vulnerability scan for a running container.
     *
     * @param request - ModifyContainerScanConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyContainerScanConfigResponse
     *
     * @param ModifyContainerScanConfigRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return ModifyContainerScanConfigResponse
     */
    public function modifyContainerScanConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appNames) {
            @$query['AppNames'] = $request->appNames;
        }

        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyContainerScanConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyContainerScanConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configurations of vulnerability scan for a running container.
     *
     * @param request - ModifyContainerScanConfigRequest
     *
     * @returns ModifyContainerScanConfigResponse
     *
     * @param ModifyContainerScanConfigRequest $request
     *
     * @return ModifyContainerScanConfigResponse
     */
    public function modifyContainerScanConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyContainerScanConfigWithOptions($request, $runtime);
    }

    /**
     * Adds vulnerabilities to the whitelist. After you add the vulnerabilities to the whitelist, Security Center no longer generates alerts for the vulnerabilities.
     *
     * @param request - ModifyCreateVulWhitelistRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyCreateVulWhitelistResponse
     *
     * @param ModifyCreateVulWhitelistRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return ModifyCreateVulWhitelistResponse
     */
    public function modifyCreateVulWhitelistWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->reason) {
            @$query['Reason'] = $request->reason;
        }

        if (null !== $request->targetInfo) {
            @$query['TargetInfo'] = $request->targetInfo;
        }

        if (null !== $request->whitelist) {
            @$query['Whitelist'] = $request->whitelist;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyCreateVulWhitelist',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyCreateVulWhitelistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds vulnerabilities to the whitelist. After you add the vulnerabilities to the whitelist, Security Center no longer generates alerts for the vulnerabilities.
     *
     * @param request - ModifyCreateVulWhitelistRequest
     *
     * @returns ModifyCreateVulWhitelistResponse
     *
     * @param ModifyCreateVulWhitelistRequest $request
     *
     * @return ModifyCreateVulWhitelistResponse
     */
    public function modifyCreateVulWhitelist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyCreateVulWhitelistWithOptions($request, $runtime);
    }

    /**
     * Modifies a custom IP address blocking policy.
     *
     * @param request - ModifyCustomBlockRecordRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyCustomBlockRecordResponse
     *
     * @param ModifyCustomBlockRecordRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ModifyCustomBlockRecordResponse
     */
    public function modifyCustomBlockRecordWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->blockIp) {
            @$query['BlockIp'] = $request->blockIp;
        }

        if (null !== $request->bound) {
            @$query['Bound'] = $request->bound;
        }

        if (null !== $request->expireTime) {
            @$query['ExpireTime'] = $request->expireTime;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyCustomBlockRecord',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyCustomBlockRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies a custom IP address blocking policy.
     *
     * @param request - ModifyCustomBlockRecordRequest
     *
     * @returns ModifyCustomBlockRecordResponse
     *
     * @param ModifyCustomBlockRecordRequest $request
     *
     * @return ModifyCustomBlockRecordResponse
     */
    public function modifyCustomBlockRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyCustomBlockRecordWithOptions($request, $runtime);
    }

    /**
     * Modifies the execution cycle of periodic tasks, including image scan, urgent vulnerability scan, and virus detection tasks.
     *
     * @param request - ModifyCycleTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyCycleTaskResponse
     *
     * @param ModifyCycleTaskRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return ModifyCycleTaskResponse
     */
    public function modifyCycleTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->configId) {
            @$query['ConfigId'] = $request->configId;
        }

        if (null !== $request->enable) {
            @$query['Enable'] = $request->enable;
        }

        if (null !== $request->firstDateStr) {
            @$query['FirstDateStr'] = $request->firstDateStr;
        }

        if (null !== $request->intervalPeriod) {
            @$query['IntervalPeriod'] = $request->intervalPeriod;
        }

        if (null !== $request->param) {
            @$query['Param'] = $request->param;
        }

        if (null !== $request->periodUnit) {
            @$query['PeriodUnit'] = $request->periodUnit;
        }

        if (null !== $request->targetEndTime) {
            @$query['TargetEndTime'] = $request->targetEndTime;
        }

        if (null !== $request->targetStartTime) {
            @$query['TargetStartTime'] = $request->targetStartTime;
        }

        if (null !== $request->taskName) {
            @$query['TaskName'] = $request->taskName;
        }

        if (null !== $request->taskType) {
            @$query['TaskType'] = $request->taskType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyCycleTask',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyCycleTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the execution cycle of periodic tasks, including image scan, urgent vulnerability scan, and virus detection tasks.
     *
     * @param request - ModifyCycleTaskRequest
     *
     * @returns ModifyCycleTaskResponse
     *
     * @param ModifyCycleTaskRequest $request
     *
     * @return ModifyCycleTaskResponse
     */
    public function modifyCycleTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyCycleTaskWithOptions($request, $runtime);
    }

    /**
     * Changes the notification status of a DingTalk chatbot.
     *
     * @remarks
     * You can call this operation only if you use Security Center Enterprise.
     *
     * @param request - ModifyDingTalkStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyDingTalkStatusResponse
     *
     * @param ModifyDingTalkStatusRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return ModifyDingTalkStatusResponse
     */
    public function modifyDingTalkStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ids) {
            @$query['Ids'] = $request->ids;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyDingTalkStatus',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyDingTalkStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the notification status of a DingTalk chatbot.
     *
     * @remarks
     * You can call this operation only if you use Security Center Enterprise.
     *
     * @param request - ModifyDingTalkStatusRequest
     *
     * @returns ModifyDingTalkStatusResponse
     *
     * @param ModifyDingTalkStatusRequest $request
     *
     * @return ModifyDingTalkStatusResponse
     */
    public function modifyDingTalkStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDingTalkStatusWithOptions($request, $runtime);
    }

    /**
     * Runs a scan task for urgent vulnerabilities.
     *
     * @param request - ModifyEmgVulSubmitRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyEmgVulSubmitResponse
     *
     * @param ModifyEmgVulSubmitRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return ModifyEmgVulSubmitResponse
     */
    public function modifyEmgVulSubmitWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->userAgreement) {
            @$query['UserAgreement'] = $request->userAgreement;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyEmgVulSubmit',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyEmgVulSubmitResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Runs a scan task for urgent vulnerabilities.
     *
     * @param request - ModifyEmgVulSubmitRequest
     *
     * @returns ModifyEmgVulSubmitResponse
     *
     * @param ModifyEmgVulSubmitRequest $request
     *
     * @return ModifyEmgVulSubmitResponse
     */
    public function modifyEmgVulSubmit($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyEmgVulSubmitWithOptions($request, $runtime);
    }

    /**
     * Changes the name of a server group.
     *
     * @param request - ModifyGroupPropertyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyGroupPropertyResponse
     *
     * @param ModifyGroupPropertyRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ModifyGroupPropertyResponse
     */
    public function modifyGroupPropertyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->data) {
            @$query['Data'] = $request->data;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyGroupProperty',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyGroupPropertyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the name of a server group.
     *
     * @param request - ModifyGroupPropertyRequest
     *
     * @returns ModifyGroupPropertyResponse
     *
     * @param ModifyGroupPropertyRequest $request
     *
     * @return ModifyGroupPropertyResponse
     */
    public function modifyGroupProperty($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyGroupPropertyWithOptions($request, $runtime);
    }

    /**
     * Modify proxy cluster.
     *
     * @param request - ModifyHybridProxyClusterRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyHybridProxyClusterResponse
     *
     * @param ModifyHybridProxyClusterRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return ModifyHybridProxyClusterResponse
     */
    public function modifyHybridProxyClusterWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterName) {
            @$query['ClusterName'] = $request->clusterName;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyHybridProxyCluster',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyHybridProxyClusterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modify proxy cluster.
     *
     * @param request - ModifyHybridProxyClusterRequest
     *
     * @returns ModifyHybridProxyClusterResponse
     *
     * @param ModifyHybridProxyClusterRequest $request
     *
     * @return ModifyHybridProxyClusterResponse
     */
    public function modifyHybridProxyCluster($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyHybridProxyClusterWithOptions($request, $runtime);
    }

    /**
     * Modify proxy policy.
     *
     * @param request - ModifyHybridProxyPolicyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyHybridProxyPolicyResponse
     *
     * @param ModifyHybridProxyPolicyRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ModifyHybridProxyPolicyResponse
     */
    public function modifyHybridProxyPolicyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterName) {
            @$query['ClusterName'] = $request->clusterName;
        }

        if (null !== $request->policyInfo) {
            @$query['PolicyInfo'] = $request->policyInfo;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyHybridProxyPolicy',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyHybridProxyPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modify proxy policy.
     *
     * @param request - ModifyHybridProxyPolicyRequest
     *
     * @returns ModifyHybridProxyPolicyResponse
     *
     * @param ModifyHybridProxyPolicyRequest $request
     *
     * @return ModifyHybridProxyPolicyResponse
     */
    public function modifyHybridProxyPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyHybridProxyPolicyWithOptions($request, $runtime);
    }

    /**
     * Modifies the configurations of an IDC probe.
     *
     * @param request - ModifyIdcProbeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyIdcProbeResponse
     *
     * @param ModifyIdcProbeRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return ModifyIdcProbeResponse
     */
    public function modifyIdcProbeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->idcName) {
            @$query['IdcName'] = $request->idcName;
        }

        if (null !== $request->idcRegion) {
            @$query['IdcRegion'] = $request->idcRegion;
        }

        if (null !== $request->intervalPeriod) {
            @$query['IntervalPeriod'] = $request->intervalPeriod;
        }

        if (null !== $request->ipSegments) {
            @$query['IpSegments'] = $request->ipSegments;
        }

        if (null !== $request->linuxPort) {
            @$query['LinuxPort'] = $request->linuxPort;
        }

        if (null !== $request->periodUnit) {
            @$query['PeriodUnit'] = $request->periodUnit;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        if (null !== $request->winPort) {
            @$query['WinPort'] = $request->winPort;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyIdcProbe',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyIdcProbeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configurations of an IDC probe.
     *
     * @param request - ModifyIdcProbeRequest
     *
     * @returns ModifyIdcProbeResponse
     *
     * @param ModifyIdcProbeRequest $request
     *
     * @return ModifyIdcProbeResponse
     */
    public function modifyIdcProbe($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyIdcProbeWithOptions($request, $runtime);
    }

    /**
     * Modifies the configurations of a scheduled image fix.
     *
     * @param request - ModifyImageFixCycleConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyImageFixCycleConfigResponse
     *
     * @param ModifyImageFixCycleConfigRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return ModifyImageFixCycleConfigResponse
     */
    public function modifyImageFixCycleConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->imageFixCycle) {
            @$body['ImageFixCycle'] = $request->imageFixCycle;
        }

        if (null !== $request->imageFixSwitch) {
            @$body['ImageFixSwitch'] = $request->imageFixSwitch;
        }

        if (null !== $request->imageFixTarget) {
            @$body['ImageFixTarget'] = $request->imageFixTarget;
        }

        if (null !== $request->imageTimeRange) {
            @$body['ImageTimeRange'] = $request->imageTimeRange;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ModifyImageFixCycleConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyImageFixCycleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configurations of a scheduled image fix.
     *
     * @param request - ModifyImageFixCycleConfigRequest
     *
     * @returns ModifyImageFixCycleConfigResponse
     *
     * @param ModifyImageFixCycleConfigRequest $request
     *
     * @return ModifyImageFixCycleConfigResponse
     */
    public function modifyImageFixCycleConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyImageFixCycleConfigWithOptions($request, $runtime);
    }

    /**
     * Modifies the transfer time of an image repository.
     *
     * @param request - ModifyImageRegistryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyImageRegistryResponse
     *
     * @param ModifyImageRegistryRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ModifyImageRegistryResponse
     */
    public function modifyImageRegistryWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->id) {
            @$body['Id'] = $request->id;
        }

        if (null !== $request->password) {
            @$body['Password'] = $request->password;
        }

        if (null !== $request->transPerHour) {
            @$body['TransPerHour'] = $request->transPerHour;
        }

        if (null !== $request->userName) {
            @$body['UserName'] = $request->userName;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ModifyImageRegistry',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyImageRegistryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the transfer time of an image repository.
     *
     * @param request - ModifyImageRegistryRequest
     *
     * @returns ModifyImageRegistryResponse
     *
     * @param ModifyImageRegistryRequest $request
     *
     * @return ModifyImageRegistryResponse
     */
    public function modifyImageRegistry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyImageRegistryWithOptions($request, $runtime);
    }

    /**
     * Modifies the defense rule against brute-force attacks that is applied to a specified server.
     *
     * @param request - ModifyInstanceAntiBruteForceRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyInstanceAntiBruteForceRuleResponse
     *
     * @param ModifyInstanceAntiBruteForceRuleRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return ModifyInstanceAntiBruteForceRuleResponse
     */
    public function modifyInstanceAntiBruteForceRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->newRuleId) {
            @$query['NewRuleId'] = $request->newRuleId;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyInstanceAntiBruteForceRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyInstanceAntiBruteForceRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the defense rule against brute-force attacks that is applied to a specified server.
     *
     * @param request - ModifyInstanceAntiBruteForceRuleRequest
     *
     * @returns ModifyInstanceAntiBruteForceRuleResponse
     *
     * @param ModifyInstanceAntiBruteForceRuleRequest $request
     *
     * @return ModifyInstanceAntiBruteForceRuleResponse
     */
    public function modifyInstanceAntiBruteForceRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyInstanceAntiBruteForceRuleWithOptions($request, $runtime);
    }

    /**
     * Modifies a proactive defense rule for containers.
     *
     * @param tmpReq - ModifyInterceptionRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyInterceptionRuleResponse
     *
     * @param ModifyInterceptionRuleRequest $tmpReq
     * @param RuntimeOptions                $runtime
     *
     * @return ModifyInterceptionRuleResponse
     */
    public function modifyInterceptionRuleWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new ModifyInterceptionRuleShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->dstTarget) {
            $request->dstTargetShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->dstTarget, 'DstTarget', 'json');
        }

        if (null !== $tmpReq->srcTarget) {
            $request->srcTargetShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->srcTarget, 'SrcTarget', 'json');
        }

        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->dstTargetShrink) {
            @$query['DstTarget'] = $request->dstTargetShrink;
        }

        if (null !== $request->interceptType) {
            @$query['InterceptType'] = $request->interceptType;
        }

        if (null !== $request->orderIndex) {
            @$query['OrderIndex'] = $request->orderIndex;
        }

        if (null !== $request->ruleId) {
            @$query['RuleId'] = $request->ruleId;
        }

        if (null !== $request->ruleName) {
            @$query['RuleName'] = $request->ruleName;
        }

        if (null !== $request->ruleSwitch) {
            @$query['RuleSwitch'] = $request->ruleSwitch;
        }

        if (null !== $request->srcTargetShrink) {
            @$query['SrcTarget'] = $request->srcTargetShrink;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyInterceptionRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyInterceptionRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies a proactive defense rule for containers.
     *
     * @param request - ModifyInterceptionRuleRequest
     *
     * @returns ModifyInterceptionRuleResponse
     *
     * @param ModifyInterceptionRuleRequest $request
     *
     * @return ModifyInterceptionRuleResponse
     */
    public function modifyInterceptionRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyInterceptionRuleWithOptions($request, $runtime);
    }

    /**
     * Enables or disables a proactive defense rule for containers.
     *
     * @param request - ModifyInterceptionRuleSwitchRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyInterceptionRuleSwitchResponse
     *
     * @param ModifyInterceptionRuleSwitchRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return ModifyInterceptionRuleSwitchResponse
     */
    public function modifyInterceptionRuleSwitchWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->ruleIds) {
            @$query['RuleIds'] = $request->ruleIds;
        }

        if (null !== $request->ruleSwitch) {
            @$query['RuleSwitch'] = $request->ruleSwitch;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyInterceptionRuleSwitch',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyInterceptionRuleSwitchResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables or disables a proactive defense rule for containers.
     *
     * @param request - ModifyInterceptionRuleSwitchRequest
     *
     * @returns ModifyInterceptionRuleSwitchResponse
     *
     * @param ModifyInterceptionRuleSwitchRequest $request
     *
     * @return ModifyInterceptionRuleSwitchResponse
     */
    public function modifyInterceptionRuleSwitch($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyInterceptionRuleSwitchWithOptions($request, $runtime);
    }

    /**
     * Modifies the information about a network object of the container firewall feature.
     *
     * @param request - ModifyInterceptionTargetRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyInterceptionTargetResponse
     *
     * @param ModifyInterceptionTargetRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return ModifyInterceptionTargetResponse
     */
    public function modifyInterceptionTargetWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appName) {
            @$query['AppName'] = $request->appName;
        }

        if (null !== $request->imageList) {
            @$query['ImageList'] = $request->imageList;
        }

        if (null !== $request->namespace) {
            @$query['Namespace'] = $request->namespace;
        }

        if (null !== $request->tagList) {
            @$query['TagList'] = $request->tagList;
        }

        if (null !== $request->targetId) {
            @$query['TargetId'] = $request->targetId;
        }

        if (null !== $request->targetName) {
            @$query['TargetName'] = $request->targetName;
        }

        if (null !== $request->targetType) {
            @$query['TargetType'] = $request->targetType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyInterceptionTarget',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyInterceptionTargetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the information about a network object of the container firewall feature.
     *
     * @param request - ModifyInterceptionTargetRequest
     *
     * @returns ModifyInterceptionTargetResponse
     *
     * @param ModifyInterceptionTargetRequest $request
     *
     * @return ModifyInterceptionTargetResponse
     */
    public function modifyInterceptionTarget($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyInterceptionTargetWithOptions($request, $runtime);
    }

    /**
     * Enables or disables the log analysis feature.
     *
     * @param request - ModifyLogMetaStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyLogMetaStatusResponse
     *
     * @param ModifyLogMetaStatusRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ModifyLogMetaStatusResponse
     */
    public function modifyLogMetaStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        if (null !== $request->logStore) {
            @$query['LogStore'] = $request->logStore;
        }

        if (null !== $request->project) {
            @$query['Project'] = $request->project;
        }

        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyLogMetaStatus',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyLogMetaStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables or disables the log analysis feature.
     *
     * @param request - ModifyLogMetaStatusRequest
     *
     * @returns ModifyLogMetaStatusResponse
     *
     * @param ModifyLogMetaStatusRequest $request
     *
     * @return ModifyLogMetaStatusResponse
     */
    public function modifyLogMetaStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyLogMetaStatusWithOptions($request, $runtime);
    }

    /**
     * Modifies the logon configuration for a specified asset.
     *
     * @param request - ModifyLoginBaseConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyLoginBaseConfigResponse
     *
     * @param ModifyLoginBaseConfigRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return ModifyLoginBaseConfigResponse
     */
    public function modifyLoginBaseConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->config) {
            @$query['Config'] = $request->config;
        }

        if (null !== $request->target) {
            @$query['Target'] = $request->target;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyLoginBaseConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyLoginBaseConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the logon configuration for a specified asset.
     *
     * @param request - ModifyLoginBaseConfigRequest
     *
     * @returns ModifyLoginBaseConfigResponse
     *
     * @param ModifyLoginBaseConfigRequest $request
     *
     * @return ModifyLoginBaseConfigResponse
     */
    public function modifyLoginBaseConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyLoginBaseConfigWithOptions($request, $runtime);
    }

    /**
     * Enables or disables the logon security settings for an asset.
     *
     * @param request - ModifyLoginSwitchConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyLoginSwitchConfigResponse
     *
     * @param ModifyLoginSwitchConfigRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ModifyLoginSwitchConfigResponse
     */
    public function modifyLoginSwitchConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->item) {
            @$query['Item'] = $request->item;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyLoginSwitchConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyLoginSwitchConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables or disables the logon security settings for an asset.
     *
     * @param request - ModifyLoginSwitchConfigRequest
     *
     * @returns ModifyLoginSwitchConfigResponse
     *
     * @param ModifyLoginSwitchConfigRequest $request
     *
     * @return ModifyLoginSwitchConfigResponse
     */
    public function modifyLoginSwitchConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyLoginSwitchConfigWithOptions($request, $runtime);
    }

    /**
     * Modifies notification settings.
     *
     * @param request - ModifyNoticeConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyNoticeConfigResponse
     *
     * @param ModifyNoticeConfigRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return ModifyNoticeConfigResponse
     */
    public function modifyNoticeConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->project) {
            @$query['Project'] = $request->project;
        }

        if (null !== $request->route) {
            @$query['Route'] = $request->route;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->timeLimit) {
            @$query['TimeLimit'] = $request->timeLimit;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyNoticeConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyNoticeConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies notification settings.
     *
     * @param request - ModifyNoticeConfigRequest
     *
     * @returns ModifyNoticeConfigResponse
     *
     * @param ModifyNoticeConfigRequest $request
     *
     * @return ModifyNoticeConfigResponse
     */
    public function modifyNoticeConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyNoticeConfigWithOptions($request, $runtime);
    }

    /**
     * Activates Simple Log Service.
     *
     * @remarks
     * *Prerequisites** [Simple Log Service](https://www.alibabacloud.com/help/en/log-service/latest/billable-items) is activated. A service-linked role for Security Center is created, and Security Center is authorized to access cloud resources. You can call the [CreateServiceLinkedRole](~~CreateServiceLinkedRole~~) operation to create a service-linked role for Security Center and authorize Security Center to access cloud resources. **Scenarios** Before you use the log analysis feature of Security Center, you must call the [ModifyOpenLogShipper](~~ModifyOpenLogShipper~~) operation to activate Simple Log Service.
     *
     * @param request - ModifyOpenLogShipperRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyOpenLogShipperResponse
     *
     * @param ModifyOpenLogShipperRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return ModifyOpenLogShipperResponse
     */
    public function modifyOpenLogShipperWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        if (null !== $request->resourceDirectoryAccountId) {
            @$query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyOpenLogShipper',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyOpenLogShipperResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Activates Simple Log Service.
     *
     * @remarks
     * *Prerequisites** [Simple Log Service](https://www.alibabacloud.com/help/en/log-service/latest/billable-items) is activated. A service-linked role for Security Center is created, and Security Center is authorized to access cloud resources. You can call the [CreateServiceLinkedRole](~~CreateServiceLinkedRole~~) operation to create a service-linked role for Security Center and authorize Security Center to access cloud resources. **Scenarios** Before you use the log analysis feature of Security Center, you must call the [ModifyOpenLogShipper](~~ModifyOpenLogShipper~~) operation to activate Simple Log Service.
     *
     * @param request - ModifyOpenLogShipperRequest
     *
     * @returns ModifyOpenLogShipperResponse
     *
     * @param ModifyOpenLogShipperRequest $request
     *
     * @return ModifyOpenLogShipperResponse
     */
    public function modifyOpenLogShipper($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyOpenLogShipperWithOptions($request, $runtime);
    }

    /**
     * Handles detected vulnerabilities. You can fix, check, or ignore the vulnerabilities.
     *
     * @param request - ModifyOperateVulRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyOperateVulResponse
     *
     * @param ModifyOperateVulRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return ModifyOperateVulResponse
     */
    public function modifyOperateVulWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        if (null !== $request->info) {
            @$query['Info'] = $request->info;
        }

        if (null !== $request->operateType) {
            @$query['OperateType'] = $request->operateType;
        }

        if (null !== $request->reason) {
            @$query['Reason'] = $request->reason;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyOperateVul',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyOperateVulResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Handles detected vulnerabilities. You can fix, check, or ignore the vulnerabilities.
     *
     * @param request - ModifyOperateVulRequest
     *
     * @returns ModifyOperateVulResponse
     *
     * @param ModifyOperateVulRequest $request
     *
     * @return ModifyOperateVulResponse
     */
    public function modifyOperateVul($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyOperateVulWithOptions($request, $runtime);
    }

    /**
     * Modifies the switch settings of pay-as-you-go modules.
     *
     * @param request - ModifyPostPayModuleSwitchRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyPostPayModuleSwitchResponse
     *
     * @param ModifyPostPayModuleSwitchRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return ModifyPostPayModuleSwitchResponse
     */
    public function modifyPostPayModuleSwitchWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->postPayInstanceId) {
            @$query['PostPayInstanceId'] = $request->postPayInstanceId;
        }

        if (null !== $request->postPayModuleSwitch) {
            @$query['PostPayModuleSwitch'] = $request->postPayModuleSwitch;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyPostPayModuleSwitch',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyPostPayModuleSwitchResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the switch settings of pay-as-you-go modules.
     *
     * @param request - ModifyPostPayModuleSwitchRequest
     *
     * @returns ModifyPostPayModuleSwitchResponse
     *
     * @param ModifyPostPayModuleSwitchRequest $request
     *
     * @return ModifyPostPayModuleSwitchResponse
     */
    public function modifyPostPayModuleSwitch($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyPostPayModuleSwitchWithOptions($request, $runtime);
    }

    /**
     * Adds a process to or removes a process from the whitelist by using the application whitelist feature.
     *
     * @remarks
     * The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
     *
     * @param request - ModifyProcessWhiteListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyProcessWhiteListResponse
     *
     * @param ModifyProcessWhiteListRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return ModifyProcessWhiteListResponse
     */
    public function modifyProcessWhiteListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->md5s) {
            @$query['Md5s'] = $request->md5s;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->strategyId) {
            @$query['StrategyId'] = $request->strategyId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyProcessWhiteList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyProcessWhiteListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds a process to or removes a process from the whitelist by using the application whitelist feature.
     *
     * @remarks
     * The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
     *
     * @param request - ModifyProcessWhiteListRequest
     *
     * @returns ModifyProcessWhiteListResponse
     *
     * @param ModifyProcessWhiteListRequest $request
     *
     * @return ModifyProcessWhiteListResponse
     */
    public function modifyProcessWhiteList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyProcessWhiteListWithOptions($request, $runtime);
    }

    /**
     * Modifies the collection frequency of asset fingerprints for an automatic periodic collection task.
     *
     * @param request - ModifyPropertyScheduleConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyPropertyScheduleConfigResponse
     *
     * @param ModifyPropertyScheduleConfigRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return ModifyPropertyScheduleConfigResponse
     */
    public function modifyPropertyScheduleConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->scheduleTime) {
            @$query['ScheduleTime'] = $request->scheduleTime;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyPropertyScheduleConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyPropertyScheduleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the collection frequency of asset fingerprints for an automatic periodic collection task.
     *
     * @param request - ModifyPropertyScheduleConfigRequest
     *
     * @returns ModifyPropertyScheduleConfigResponse
     *
     * @param ModifyPropertyScheduleConfigRequest $request
     *
     * @return ModifyPropertyScheduleConfigResponse
     */
    public function modifyPropertyScheduleConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyPropertyScheduleConfigWithOptions($request, $runtime);
    }

    /**
     * Performs security check tasks on servers with a few clicks.
     *
     * @param request - ModifyPushAllTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyPushAllTaskResponse
     *
     * @param ModifyPushAllTaskRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return ModifyPushAllTaskResponse
     */
    public function modifyPushAllTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->tasks) {
            @$query['Tasks'] = $request->tasks;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyPushAllTask',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyPushAllTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Performs security check tasks on servers with a few clicks.
     *
     * @param request - ModifyPushAllTaskRequest
     *
     * @returns ModifyPushAllTaskResponse
     *
     * @param ModifyPushAllTaskRequest $request
     *
     * @return ModifyPushAllTaskResponse
     */
    public function modifyPushAllTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyPushAllTaskWithOptions($request, $runtime);
    }

    /**
     * Refreshes the list of processes that are associated with a Linux software vulnerability.
     *
     * @param request - ModifyRefreshProcessInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyRefreshProcessInfoResponse
     *
     * @param ModifyRefreshProcessInfoRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return ModifyRefreshProcessInfoResponse
     */
    public function modifyRefreshProcessInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyRefreshProcessInfo',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyRefreshProcessInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Refreshes the list of processes that are associated with a Linux software vulnerability.
     *
     * @param request - ModifyRefreshProcessInfoRequest
     *
     * @returns ModifyRefreshProcessInfoResponse
     *
     * @param ModifyRefreshProcessInfoRequest $request
     *
     * @return ModifyRefreshProcessInfoResponse
     */
    public function modifyRefreshProcessInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyRefreshProcessInfoWithOptions($request, $runtime);
    }

    /**
     * Modifies a rule for container tamper-proofing.
     *
     * @param request - ModifySasContainerWebDefenseRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifySasContainerWebDefenseRuleResponse
     *
     * @param ModifySasContainerWebDefenseRuleRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return ModifySasContainerWebDefenseRuleResponse
     */
    public function modifySasContainerWebDefenseRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->pathConfDTOList) {
            @$query['PathConfDTOList'] = $request->pathConfDTOList;
        }

        if (null !== $request->ruleId) {
            @$query['RuleId'] = $request->ruleId;
        }

        if (null !== $request->ruleName) {
            @$query['RuleName'] = $request->ruleName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifySasContainerWebDefenseRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifySasContainerWebDefenseRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies a rule for container tamper-proofing.
     *
     * @param request - ModifySasContainerWebDefenseRuleRequest
     *
     * @returns ModifySasContainerWebDefenseRuleResponse
     *
     * @param ModifySasContainerWebDefenseRuleRequest $request
     *
     * @return ModifySasContainerWebDefenseRuleResponse
     */
    public function modifySasContainerWebDefenseRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifySasContainerWebDefenseRuleWithOptions($request, $runtime);
    }

    /**
     * Modifies common filter conditions to search for assets.
     *
     * @param request - ModifySearchConditionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifySearchConditionResponse
     *
     * @param ModifySearchConditionRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return ModifySearchConditionResponse
     */
    public function modifySearchConditionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->filterConditions) {
            @$query['FilterConditions'] = $request->filterConditions;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifySearchCondition',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifySearchConditionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies common filter conditions to search for assets.
     *
     * @param request - ModifySearchConditionRequest
     *
     * @returns ModifySearchConditionResponse
     *
     * @param ModifySearchConditionRequest $request
     *
     * @return ModifySearchConditionResponse
     */
    public function modifySearchCondition($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifySearchConditionWithOptions($request, $runtime);
    }

    /**
     * Specifies the time when an automatic configuration check is performed on cloud services.
     *
     * @remarks
     * This operation is phased out. You can use the ChangeCheckConfig operation.
     *
     * @deprecated openAPI ModifySecurityCheckScheduleConfig is deprecated, please use Sas::2018-12-03::ChangeCheckConfig instead
     *
     * @param request - ModifySecurityCheckScheduleConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifySecurityCheckScheduleConfigResponse
     *
     * @param ModifySecurityCheckScheduleConfigRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return ModifySecurityCheckScheduleConfigResponse
     */
    public function modifySecurityCheckScheduleConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->daysOfWeek) {
            @$query['DaysOfWeek'] = $request->daysOfWeek;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifySecurityCheckScheduleConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifySecurityCheckScheduleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Specifies the time when an automatic configuration check is performed on cloud services.
     *
     * @remarks
     * This operation is phased out. You can use the ChangeCheckConfig operation.
     *
     * @deprecated openAPI ModifySecurityCheckScheduleConfig is deprecated, please use Sas::2018-12-03::ChangeCheckConfig instead
     *
     * @param request - ModifySecurityCheckScheduleConfigRequest
     *
     * @returns ModifySecurityCheckScheduleConfigResponse
     *
     * @param ModifySecurityCheckScheduleConfigRequest $request
     *
     * @return ModifySecurityCheckScheduleConfigResponse
     */
    public function modifySecurityCheckScheduleConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifySecurityCheckScheduleConfigWithOptions($request, $runtime);
    }

    /**
     * Modifies the alert handling rule for alerts that are added to the whitelist by asset.
     *
     * @param request - ModifySecurityEventMarkMissIndividuallyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifySecurityEventMarkMissIndividuallyResponse
     *
     * @param ModifySecurityEventMarkMissIndividuallyRequest $request
     * @param RuntimeOptions                                 $runtime
     *
     * @return ModifySecurityEventMarkMissIndividuallyResponse
     */
    public function modifySecurityEventMarkMissIndividuallyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $body = [];
        if (null !== $request->deleteMarkMissParam) {
            @$body['DeleteMarkMissParam'] = $request->deleteMarkMissParam;
        }

        if (null !== $request->from) {
            @$body['From'] = $request->from;
        }

        if (null !== $request->insertMarkMissParam) {
            @$body['InsertMarkMissParam'] = $request->insertMarkMissParam;
        }

        if (null !== $request->lang) {
            @$body['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ModifySecurityEventMarkMissIndividually',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifySecurityEventMarkMissIndividuallyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the alert handling rule for alerts that are added to the whitelist by asset.
     *
     * @param request - ModifySecurityEventMarkMissIndividuallyRequest
     *
     * @returns ModifySecurityEventMarkMissIndividuallyResponse
     *
     * @param ModifySecurityEventMarkMissIndividuallyRequest $request
     *
     * @return ModifySecurityEventMarkMissIndividuallyResponse
     */
    public function modifySecurityEventMarkMissIndividually($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifySecurityEventMarkMissIndividuallyWithOptions($request, $runtime);
    }

    /**
     * Manage Serverless Asset Authorization.
     *
     * @param request - ModifyServerlessAuthToMachineRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyServerlessAuthToMachineResponse
     *
     * @param ModifyServerlessAuthToMachineRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return ModifyServerlessAuthToMachineResponse
     */
    public function modifyServerlessAuthToMachineWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appCriteria) {
            @$query['AppCriteria'] = $request->appCriteria;
        }

        if (null !== $request->authItem) {
            @$query['AuthItem'] = $request->authItem;
        }

        if (null !== $request->autoBind) {
            @$query['AutoBind'] = $request->autoBind;
        }

        if (null !== $request->bindAll) {
            @$query['BindAll'] = $request->bindAll;
        }

        if (null !== $request->bindAppList) {
            @$query['BindAppList'] = $request->bindAppList;
        }

        if (null !== $request->bindAssetType) {
            @$query['BindAssetType'] = $request->bindAssetType;
        }

        if (null !== $request->bindUuidList) {
            @$query['BindUuidList'] = $request->bindUuidList;
        }

        if (null !== $request->criteria) {
            @$query['Criteria'] = $request->criteria;
        }

        if (null !== $request->logicalExp) {
            @$query['LogicalExp'] = $request->logicalExp;
        }

        if (null !== $request->ntmVersion) {
            @$query['NtmVersion'] = $request->ntmVersion;
        }

        if (null !== $request->preBind) {
            @$query['PreBind'] = $request->preBind;
        }

        if (null !== $request->preBindOrderId) {
            @$query['PreBindOrderId'] = $request->preBindOrderId;
        }

        if (null !== $request->resourceDirectoryUid) {
            @$query['ResourceDirectoryUid'] = $request->resourceDirectoryUid;
        }

        if (null !== $request->unBindAppList) {
            @$query['UnBindAppList'] = $request->unBindAppList;
        }

        if (null !== $request->unBindUuidList) {
            @$query['UnBindUuidList'] = $request->unBindUuidList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyServerlessAuthToMachine',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyServerlessAuthToMachineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Manage Serverless Asset Authorization.
     *
     * @param request - ModifyServerlessAuthToMachineRequest
     *
     * @returns ModifyServerlessAuthToMachineResponse
     *
     * @param ModifyServerlessAuthToMachineRequest $request
     *
     * @return ModifyServerlessAuthToMachineResponse
     */
    public function modifyServerlessAuthToMachine($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyServerlessAuthToMachineWithOptions($request, $runtime);
    }

    /**
     * Creates or deletes a policy template on the My Policies tab of the Playbook page.
     *
     * @remarks
     * Only the Enterprise and Ultimate editions of Security Center support this API operation.
     *
     * @param request - ModifySoarStrategySubscribeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifySoarStrategySubscribeResponse
     *
     * @param ModifySoarStrategySubscribeRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return ModifySoarStrategySubscribeResponse
     */
    public function modifySoarStrategySubscribeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->strategyId) {
            @$query['StrategyId'] = $request->strategyId;
        }

        if (null !== $request->subscribeStatus) {
            @$query['SubscribeStatus'] = $request->subscribeStatus;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifySoarStrategySubscribe',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifySoarStrategySubscribeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates or deletes a policy template on the My Policies tab of the Playbook page.
     *
     * @remarks
     * Only the Enterprise and Ultimate editions of Security Center support this API operation.
     *
     * @param request - ModifySoarStrategySubscribeRequest
     *
     * @returns ModifySoarStrategySubscribeResponse
     *
     * @param ModifySoarStrategySubscribeRequest $request
     *
     * @return ModifySoarStrategySubscribeResponse
     */
    public function modifySoarStrategySubscribe($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifySoarStrategySubscribeWithOptions($request, $runtime);
    }

    /**
     * Enables the quick scan feature. You can also enable the feature on the Vulnerabilities page of the Security Center console.
     *
     * @param request - ModifyStartVulScanRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyStartVulScanResponse
     *
     * @param ModifyStartVulScanRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return ModifyStartVulScanResponse
     */
    public function modifyStartVulScanWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->types) {
            @$query['Types'] = $request->types;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyStartVulScan',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyStartVulScanResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables the quick scan feature. You can also enable the feature on the Vulnerabilities page of the Security Center console.
     *
     * @param request - ModifyStartVulScanRequest
     *
     * @returns ModifyStartVulScanResponse
     *
     * @param ModifyStartVulScanRequest $request
     *
     * @return ModifyStartVulScanResponse
     */
    public function modifyStartVulScan($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyStartVulScanWithOptions($request, $runtime);
    }

    /**
     * Modifies a baseline check policy.
     *
     * @param request - ModifyStrategyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyStrategyResponse
     *
     * @param ModifyStrategyRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return ModifyStrategyResponse
     */
    public function modifyStrategyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->customType) {
            @$query['CustomType'] = $request->customType;
        }

        if (null !== $request->cycleDays) {
            @$query['CycleDays'] = $request->cycleDays;
        }

        if (null !== $request->cycleStartTime) {
            @$query['CycleStartTime'] = $request->cycleStartTime;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->riskCustomParams) {
            @$query['RiskCustomParams'] = $request->riskCustomParams;
        }

        if (null !== $request->riskSubTypeName) {
            @$query['RiskSubTypeName'] = $request->riskSubTypeName;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->targetType) {
            @$query['TargetType'] = $request->targetType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyStrategy',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyStrategyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies a baseline check policy.
     *
     * @param request - ModifyStrategyRequest
     *
     * @returns ModifyStrategyResponse
     *
     * @param ModifyStrategyRequest $request
     *
     * @return ModifyStrategyResponse
     */
    public function modifyStrategy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyStrategyWithOptions($request, $runtime);
    }

    /**
     * Modifies the servers to which a baseline check policy is applied.
     *
     * @param request - ModifyStrategyTargetRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyStrategyTargetResponse
     *
     * @param ModifyStrategyTargetRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return ModifyStrategyTargetResponse
     */
    public function modifyStrategyTargetWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->config) {
            @$query['Config'] = $request->config;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->target) {
            @$query['Target'] = $request->target;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyStrategyTarget',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyStrategyTargetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the servers to which a baseline check policy is applied.
     *
     * @param request - ModifyStrategyTargetRequest
     *
     * @returns ModifyStrategyTargetResponse
     *
     * @param ModifyStrategyTargetRequest $request
     *
     * @return ModifyStrategyTargetResponse
     */
    public function modifyStrategyTarget($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyStrategyTargetWithOptions($request, $runtime);
    }

    /**
     * Modifies the names of the tags that are added to assets, or modifies the tags for assets.
     *
     * @param request - ModifyTagWithUuidRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyTagWithUuidResponse
     *
     * @param ModifyTagWithUuidRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return ModifyTagWithUuidResponse
     */
    public function modifyTagWithUuidWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->machineTypes) {
            @$query['MachineTypes'] = $request->machineTypes;
        }

        if (null !== $request->tagId) {
            @$query['TagId'] = $request->tagId;
        }

        if (null !== $request->tagList) {
            @$query['TagList'] = $request->tagList;
        }

        if (null !== $request->target) {
            @$query['Target'] = $request->target;
        }

        if (null !== $request->uuidList) {
            @$query['UuidList'] = $request->uuidList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyTagWithUuid',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyTagWithUuidResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the names of the tags that are added to assets, or modifies the tags for assets.
     *
     * @param request - ModifyTagWithUuidRequest
     *
     * @returns ModifyTagWithUuidResponse
     *
     * @param ModifyTagWithUuidRequest $request
     *
     * @return ModifyTagWithUuidResponse
     */
    public function modifyTagWithUuid($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyTagWithUuidWithOptions($request, $runtime);
    }

    /**
     * Modifies an anti-ransomware policy for databases.
     *
     * @param tmpReq - ModifyUniBackupPolicyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyUniBackupPolicyResponse
     *
     * @param ModifyUniBackupPolicyRequest $tmpReq
     * @param RuntimeOptions               $runtime
     *
     * @return ModifyUniBackupPolicyResponse
     */
    public function modifyUniBackupPolicyWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new ModifyUniBackupPolicyShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->fullPlan) {
            $request->fullPlanShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->fullPlan, 'FullPlan', 'json');
        }

        if (null !== $tmpReq->incPlan) {
            $request->incPlanShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->incPlan, 'IncPlan', 'json');
        }

        $query = [];
        if (null !== $request->accountName) {
            @$query['AccountName'] = $request->accountName;
        }

        if (null !== $request->accountPassword) {
            @$query['AccountPassword'] = $request->accountPassword;
        }

        if (null !== $request->fullPlanShrink) {
            @$query['FullPlan'] = $request->fullPlanShrink;
        }

        if (null !== $request->incPlanShrink) {
            @$query['IncPlan'] = $request->incPlanShrink;
        }

        if (null !== $request->policyId) {
            @$query['PolicyId'] = $request->policyId;
        }

        if (null !== $request->policyName) {
            @$query['PolicyName'] = $request->policyName;
        }

        if (null !== $request->policyStatus) {
            @$query['PolicyStatus'] = $request->policyStatus;
        }

        if (null !== $request->retention) {
            @$query['Retention'] = $request->retention;
        }

        if (null !== $request->speedLimiter) {
            @$query['SpeedLimiter'] = $request->speedLimiter;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyUniBackupPolicy',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyUniBackupPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies an anti-ransomware policy for databases.
     *
     * @param request - ModifyUniBackupPolicyRequest
     *
     * @returns ModifyUniBackupPolicyResponse
     *
     * @param ModifyUniBackupPolicyRequest $request
     *
     * @return ModifyUniBackupPolicyResponse
     */
    public function modifyUniBackupPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyUniBackupPolicyWithOptions($request, $runtime);
    }

    /**
     * Enables or disables a honeypot.
     *
     * @deprecated OpenAPI ModifyVpcHoneyPot is deprecated
     *
     * @param request - ModifyVpcHoneyPotRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyVpcHoneyPotResponse
     *
     * @param ModifyVpcHoneyPotRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return ModifyVpcHoneyPotResponse
     */
    public function modifyVpcHoneyPotWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->honeyPotAction) {
            @$query['HoneyPotAction'] = $request->honeyPotAction;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyVpcHoneyPot',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyVpcHoneyPotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Enables or disables a honeypot.
     *
     * @deprecated OpenAPI ModifyVpcHoneyPot is deprecated
     *
     * @param request - ModifyVpcHoneyPotRequest
     *
     * @returns ModifyVpcHoneyPotResponse
     *
     * @param ModifyVpcHoneyPotRequest $request
     *
     * @return ModifyVpcHoneyPotResponse
     */
    public function modifyVpcHoneyPot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVpcHoneyPotWithOptions($request, $runtime);
    }

    /**
     * Modifies the configurations of the vulnerability scan feature.
     *
     * @param request - ModifyVulConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyVulConfigResponse
     *
     * @param ModifyVulConfigRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return ModifyVulConfigResponse
     */
    public function modifyVulConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->config) {
            @$query['Config'] = $request->config;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyVulConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyVulConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configurations of the vulnerability scan feature.
     *
     * @param request - ModifyVulConfigRequest
     *
     * @returns ModifyVulConfigResponse
     *
     * @param ModifyVulConfigRequest $request
     *
     * @return ModifyVulConfigResponse
     */
    public function modifyVulConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVulConfigWithOptions($request, $runtime);
    }

    /**
     * Modifies the configurations of the vulnerability scan feature for a server.
     *
     * @param request - ModifyVulTargetRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyVulTargetResponse
     *
     * @param ModifyVulTargetRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return ModifyVulTargetResponse
     */
    public function modifyVulTargetWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->config) {
            @$query['Config'] = $request->config;
        }

        if (null !== $request->target) {
            @$query['Target'] = $request->target;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyVulTarget',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyVulTargetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configurations of the vulnerability scan feature for a server.
     *
     * @param request - ModifyVulTargetRequest
     *
     * @returns ModifyVulTargetResponse
     *
     * @param ModifyVulTargetRequest $request
     *
     * @return ModifyVulTargetResponse
     */
    public function modifyVulTarget($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVulTargetWithOptions($request, $runtime);
    }

    /**
     * Configures vulnerability scan for a server.
     *
     * @param request - ModifyVulTargetConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyVulTargetConfigResponse
     *
     * @param ModifyVulTargetConfigRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return ModifyVulTargetConfigResponse
     */
    public function modifyVulTargetConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->config) {
            @$query['Config'] = $request->config;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyVulTargetConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyVulTargetConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures vulnerability scan for a server.
     *
     * @param request - ModifyVulTargetConfigRequest
     *
     * @returns ModifyVulTargetConfigResponse
     *
     * @param ModifyVulTargetConfigRequest $request
     *
     * @return ModifyVulTargetConfigResponse
     */
    public function modifyVulTargetConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVulTargetConfigWithOptions($request, $runtime);
    }

    /**
     * Modifies the servers that are added to a vulnerability whitelist.
     *
     * @param request - ModifyVulWhitelistTargetRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyVulWhitelistTargetResponse
     *
     * @param ModifyVulWhitelistTargetRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return ModifyVulWhitelistTargetResponse
     */
    public function modifyVulWhitelistTargetWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        if (null !== $request->reason) {
            @$query['Reason'] = $request->reason;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->targetInfo) {
            @$query['TargetInfo'] = $request->targetInfo;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyVulWhitelistTarget',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyVulWhitelistTargetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the servers that are added to a vulnerability whitelist.
     *
     * @param request - ModifyVulWhitelistTargetRequest
     *
     * @returns ModifyVulWhitelistTargetResponse
     *
     * @param ModifyVulWhitelistTargetRequest $request
     *
     * @return ModifyVulWhitelistTargetResponse
     */
    public function modifyVulWhitelistTarget($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVulWhitelistTargetWithOptions($request, $runtime);
    }

    /**
     * Adds a directory to protect for a specified server.
     *
     * @param request - ModifyWebLockCreateConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyWebLockCreateConfigResponse
     *
     * @param ModifyWebLockCreateConfigRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return ModifyWebLockCreateConfigResponse
     */
    public function modifyWebLockCreateConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->defenceMode) {
            @$query['DefenceMode'] = $request->defenceMode;
        }

        if (null !== $request->dir) {
            @$query['Dir'] = $request->dir;
        }

        if (null !== $request->exclusiveDir) {
            @$query['ExclusiveDir'] = $request->exclusiveDir;
        }

        if (null !== $request->exclusiveFile) {
            @$query['ExclusiveFile'] = $request->exclusiveFile;
        }

        if (null !== $request->exclusiveFileType) {
            @$query['ExclusiveFileType'] = $request->exclusiveFileType;
        }

        if (null !== $request->inclusiveFile) {
            @$query['InclusiveFile'] = $request->inclusiveFile;
        }

        if (null !== $request->inclusiveFileType) {
            @$query['InclusiveFileType'] = $request->inclusiveFileType;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->localBackupDir) {
            @$query['LocalBackupDir'] = $request->localBackupDir;
        }

        if (null !== $request->mode) {
            @$query['Mode'] = $request->mode;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyWebLockCreateConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyWebLockCreateConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds a directory to protect for a specified server.
     *
     * @param request - ModifyWebLockCreateConfigRequest
     *
     * @returns ModifyWebLockCreateConfigResponse
     *
     * @param ModifyWebLockCreateConfigRequest $request
     *
     * @return ModifyWebLockCreateConfigResponse
     */
    public function modifyWebLockCreateConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyWebLockCreateConfigWithOptions($request, $runtime);
    }

    /**
     * Deletes a directory on a specified server from the protected directories of web tamper proofing.
     *
     * @remarks
     * After you delete a directory that has web tamper proofing enabled on a server, files in the directory are no longer protected by web tamper proofing. The information about the websites that are hosted on the server may be maliciously modified by attackers. Proceed with caution.
     *
     * @param request - ModifyWebLockDeleteConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyWebLockDeleteConfigResponse
     *
     * @param ModifyWebLockDeleteConfigRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return ModifyWebLockDeleteConfigResponse
     */
    public function modifyWebLockDeleteConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyWebLockDeleteConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyWebLockDeleteConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a directory on a specified server from the protected directories of web tamper proofing.
     *
     * @remarks
     * After you delete a directory that has web tamper proofing enabled on a server, files in the directory are no longer protected by web tamper proofing. The information about the websites that are hosted on the server may be maliciously modified by attackers. Proceed with caution.
     *
     * @param request - ModifyWebLockDeleteConfigRequest
     *
     * @returns ModifyWebLockDeleteConfigResponse
     *
     * @param ModifyWebLockDeleteConfigRequest $request
     *
     * @return ModifyWebLockDeleteConfigResponse
     */
    public function modifyWebLockDeleteConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyWebLockDeleteConfigWithOptions($request, $runtime);
    }

    /**
     * Changes the status of processes for web tamper proofing.
     *
     * @param request - ModifyWebLockProcessStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyWebLockProcessStatusResponse
     *
     * @param ModifyWebLockProcessStatusRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return ModifyWebLockProcessStatusResponse
     */
    public function modifyWebLockProcessStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dealAll) {
            @$query['DealAll'] = $request->dealAll;
        }

        if (null !== $request->operateInfo) {
            @$query['OperateInfo'] = $request->operateInfo;
        }

        if (null !== $request->processPath) {
            @$query['ProcessPath'] = $request->processPath;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyWebLockProcessStatus',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyWebLockProcessStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the status of processes for web tamper proofing.
     *
     * @param request - ModifyWebLockProcessStatusRequest
     *
     * @returns ModifyWebLockProcessStatusResponse
     *
     * @param ModifyWebLockProcessStatusRequest $request
     *
     * @return ModifyWebLockProcessStatusResponse
     */
    public function modifyWebLockProcessStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyWebLockProcessStatusWithOptions($request, $runtime);
    }

    /**
     * Refreshes the status of the web tamper proofing feature for a server.
     *
     * @remarks
     * If an exception occurs when you enable or disable the web tamper proofing feature for a server, you can call this operation to refresh the status of the web tamper proofing feature.
     *
     * @param request - ModifyWebLockRefreshRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyWebLockRefreshResponse
     *
     * @param ModifyWebLockRefreshRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return ModifyWebLockRefreshResponse
     */
    public function modifyWebLockRefreshWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyWebLockRefresh',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyWebLockRefreshResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Refreshes the status of the web tamper proofing feature for a server.
     *
     * @remarks
     * If an exception occurs when you enable or disable the web tamper proofing feature for a server, you can call this operation to refresh the status of the web tamper proofing feature.
     *
     * @param request - ModifyWebLockRefreshRequest
     *
     * @returns ModifyWebLockRefreshResponse
     *
     * @param ModifyWebLockRefreshRequest $request
     *
     * @return ModifyWebLockRefreshResponse
     */
    public function modifyWebLockRefresh($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyWebLockRefreshWithOptions($request, $runtime);
    }

    /**
     * Enables web tamper proofing for a specified server.
     *
     * @param request - ModifyWebLockStartRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyWebLockStartResponse
     *
     * @param ModifyWebLockStartRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return ModifyWebLockStartResponse
     */
    public function modifyWebLockStartWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->defenceMode) {
            @$query['DefenceMode'] = $request->defenceMode;
        }

        if (null !== $request->dir) {
            @$query['Dir'] = $request->dir;
        }

        if (null !== $request->exclusiveDir) {
            @$query['ExclusiveDir'] = $request->exclusiveDir;
        }

        if (null !== $request->exclusiveFile) {
            @$query['ExclusiveFile'] = $request->exclusiveFile;
        }

        if (null !== $request->exclusiveFileType) {
            @$query['ExclusiveFileType'] = $request->exclusiveFileType;
        }

        if (null !== $request->inclusiveFileType) {
            @$query['InclusiveFileType'] = $request->inclusiveFileType;
        }

        if (null !== $request->localBackupDir) {
            @$query['LocalBackupDir'] = $request->localBackupDir;
        }

        if (null !== $request->mode) {
            @$query['Mode'] = $request->mode;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyWebLockStart',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyWebLockStartResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables web tamper proofing for a specified server.
     *
     * @param request - ModifyWebLockStartRequest
     *
     * @returns ModifyWebLockStartResponse
     *
     * @param ModifyWebLockStartRequest $request
     *
     * @return ModifyWebLockStartResponse
     */
    public function modifyWebLockStart($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyWebLockStartWithOptions($request, $runtime);
    }

    /**
     * Enables or disables web tamper proofing for a server.
     *
     * @param request - ModifyWebLockStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyWebLockStatusResponse
     *
     * @param ModifyWebLockStatusRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ModifyWebLockStatusResponse
     */
    public function modifyWebLockStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyWebLockStatus',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyWebLockStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables or disables web tamper proofing for a server.
     *
     * @param request - ModifyWebLockStatusRequest
     *
     * @returns ModifyWebLockStatusResponse
     *
     * @param ModifyWebLockStatusRequest $request
     *
     * @return ModifyWebLockStatusResponse
     */
    public function modifyWebLockStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyWebLockStatusWithOptions($request, $runtime);
    }

    /**
     * Disables web tamper proofing for a specified server.
     *
     * @param request - ModifyWebLockUnbindRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyWebLockUnbindResponse
     *
     * @param ModifyWebLockUnbindRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ModifyWebLockUnbindResponse
     */
    public function modifyWebLockUnbindWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyWebLockUnbind',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyWebLockUnbindResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Disables web tamper proofing for a specified server.
     *
     * @param request - ModifyWebLockUnbindRequest
     *
     * @returns ModifyWebLockUnbindResponse
     *
     * @param ModifyWebLockUnbindRequest $request
     *
     * @return ModifyWebLockUnbindResponse
     */
    public function modifyWebLockUnbind($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyWebLockUnbindWithOptions($request, $runtime);
    }

    /**
     * Modifies the protection policy for a specified server.
     *
     * @param request - ModifyWebLockUpdateConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyWebLockUpdateConfigResponse
     *
     * @param ModifyWebLockUpdateConfigRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return ModifyWebLockUpdateConfigResponse
     */
    public function modifyWebLockUpdateConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->defenceMode) {
            @$query['DefenceMode'] = $request->defenceMode;
        }

        if (null !== $request->dir) {
            @$query['Dir'] = $request->dir;
        }

        if (null !== $request->exclusiveDir) {
            @$query['ExclusiveDir'] = $request->exclusiveDir;
        }

        if (null !== $request->exclusiveFile) {
            @$query['ExclusiveFile'] = $request->exclusiveFile;
        }

        if (null !== $request->exclusiveFileType) {
            @$query['ExclusiveFileType'] = $request->exclusiveFileType;
        }

        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        if (null !== $request->inclusiveFile) {
            @$query['InclusiveFile'] = $request->inclusiveFile;
        }

        if (null !== $request->inclusiveFileType) {
            @$query['InclusiveFileType'] = $request->inclusiveFileType;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->localBackupDir) {
            @$query['LocalBackupDir'] = $request->localBackupDir;
        }

        if (null !== $request->mode) {
            @$query['Mode'] = $request->mode;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyWebLockUpdateConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyWebLockUpdateConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the protection policy for a specified server.
     *
     * @param request - ModifyWebLockUpdateConfigRequest
     *
     * @returns ModifyWebLockUpdateConfigResponse
     *
     * @param ModifyWebLockUpdateConfigRequest $request
     *
     * @return ModifyWebLockUpdateConfigResponse
     */
    public function modifyWebLockUpdateConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyWebLockUpdateConfigWithOptions($request, $runtime);
    }

    /**
     * Modifies a custom web directory.
     *
     * @param request - ModifyWebPathRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyWebPathResponse
     *
     * @param ModifyWebPathRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return ModifyWebPathResponse
     */
    public function modifyWebPathWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->config) {
            @$query['Config'] = $request->config;
        }

        if (null !== $request->target) {
            @$query['Target'] = $request->target;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyWebPath',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyWebPathResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies a custom web directory.
     *
     * @param request - ModifyWebPathRequest
     *
     * @returns ModifyWebPathResponse
     *
     * @param ModifyWebPathRequest $request
     *
     * @return ModifyWebPathResponse
     */
    public function modifyWebPath($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyWebPathWithOptions($request, $runtime);
    }

    /**
     * Enables the automatic configuration of anti-ransomware policies for servers in the managed anti-ransomware feature. You can call this operation only after you purchase the managed anti-ransomware feature.
     *
     * @param request - OpenBackupAutoConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns OpenBackupAutoConfigResponse
     *
     * @param OpenBackupAutoConfigRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return OpenBackupAutoConfigResponse
     */
    public function openBackupAutoConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->maxBatchSize) {
            @$query['MaxBatchSize'] = $request->maxBatchSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'OpenBackupAutoConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return OpenBackupAutoConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables the automatic configuration of anti-ransomware policies for servers in the managed anti-ransomware feature. You can call this operation only after you purchase the managed anti-ransomware feature.
     *
     * @param request - OpenBackupAutoConfigRequest
     *
     * @returns OpenBackupAutoConfigResponse
     *
     * @param OpenBackupAutoConfigRequest $request
     *
     * @return OpenBackupAutoConfigResponse
     */
    public function openBackupAutoConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->openBackupAutoConfigWithOptions($request, $runtime);
    }

    /**
     * .
     *
     * @param request - OpenPartialBuyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns OpenPartialBuyResponse
     *
     * @param OpenPartialBuyRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return OpenPartialBuyResponse
     */
    public function openPartialBuyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'OpenPartialBuy',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return OpenPartialBuyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * .
     *
     * @param request - OpenPartialBuyRequest
     *
     * @returns OpenPartialBuyResponse
     *
     * @param OpenPartialBuyRequest $request
     *
     * @return OpenPartialBuyResponse
     */
    public function openPartialBuy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->openPartialBuyWithOptions($request, $runtime);
    }

    /**
     * Enables or disables sensitive file scan.
     *
     * @param request - OpenSensitiveFileScanRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns OpenSensitiveFileScanResponse
     *
     * @param OpenSensitiveFileScanRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return OpenSensitiveFileScanResponse
     */
    public function openSensitiveFileScanWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->switchOn) {
            @$query['SwitchOn'] = $request->switchOn;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'OpenSensitiveFileScan',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return OpenSensitiveFileScanResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables or disables sensitive file scan.
     *
     * @param request - OpenSensitiveFileScanRequest
     *
     * @returns OpenSensitiveFileScanResponse
     *
     * @param OpenSensitiveFileScanRequest $request
     *
     * @return OpenSensitiveFileScanResponse
     */
    public function openSensitiveFileScan($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->openSensitiveFileScanWithOptions($request, $runtime);
    }

    /**
     * Installs the Security Center agent on servers.
     *
     * @param request - OperateAgentClientInstallRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns OperateAgentClientInstallResponse
     *
     * @param OperateAgentClientInstallRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return OperateAgentClientInstallResponse
     */
    public function operateAgentClientInstallWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceIds) {
            @$query['InstanceIds'] = $request->instanceIds;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->os) {
            @$query['Os'] = $request->os;
        }

        if (null !== $request->region) {
            @$query['Region'] = $request->region;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'OperateAgentClientInstall',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return OperateAgentClientInstallResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Installs the Security Center agent on servers.
     *
     * @param request - OperateAgentClientInstallRequest
     *
     * @returns OperateAgentClientInstallResponse
     *
     * @param OperateAgentClientInstallRequest $request
     *
     * @return OperateAgentClientInstallResponse
     */
    public function operateAgentClientInstall($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateAgentClientInstallWithOptions($request, $runtime);
    }

    /**
     * Adds or deletes container applications for tamper proofing.
     *
     * @param request - OperateApplicationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns OperateApplicationResponse
     *
     * @param OperateApplicationRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return OperateApplicationResponse
     */
    public function operateApplicationWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->containerWebDefenseApplicationDTOS) {
            @$query['ContainerWebDefenseApplicationDTOS'] = $request->containerWebDefenseApplicationDTOS;
        }

        if (null !== $request->ruleId) {
            @$query['RuleId'] = $request->ruleId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'OperateApplication',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return OperateApplicationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds or deletes container applications for tamper proofing.
     *
     * @param request - OperateApplicationRequest
     *
     * @returns OperateApplicationResponse
     *
     * @param OperateApplicationRequest $request
     *
     * @return OperateApplicationResponse
     */
    public function operateApplication($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateApplicationWithOptions($request, $runtime);
    }

    /**
     * Manages an Object Storage Service (OSS) bucket check task.
     *
     * @param request - OperateBucketScanTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns OperateBucketScanTaskResponse
     *
     * @param OperateBucketScanTaskRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return OperateBucketScanTaskResponse
     */
    public function operateBucketScanTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bucketName) {
            @$query['BucketName'] = $request->bucketName;
        }

        if (null !== $request->operateCode) {
            @$query['OperateCode'] = $request->operateCode;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'OperateBucketScanTask',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return OperateBucketScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Manages an Object Storage Service (OSS) bucket check task.
     *
     * @param request - OperateBucketScanTaskRequest
     *
     * @returns OperateBucketScanTaskResponse
     *
     * @param OperateBucketScanTaskRequest $request
     *
     * @return OperateBucketScanTaskResponse
     */
    public function operateBucketScanTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateBucketScanTaskWithOptions($request, $runtime);
    }

    /**
     * Enables or disables a feature by type.
     *
     * @param request - OperateCommonOverallConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns OperateCommonOverallConfigResponse
     *
     * @param OperateCommonOverallConfigRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return OperateCommonOverallConfigResponse
     */
    public function operateCommonOverallConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->config) {
            @$query['Config'] = $request->config;
        }

        if (null !== $request->noTargetAsOn) {
            @$query['NoTargetAsOn'] = $request->noTargetAsOn;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'OperateCommonOverallConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return OperateCommonOverallConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables or disables a feature by type.
     *
     * @param request - OperateCommonOverallConfigRequest
     *
     * @returns OperateCommonOverallConfigResponse
     *
     * @param OperateCommonOverallConfigRequest $request
     *
     * @return OperateCommonOverallConfigResponse
     */
    public function operateCommonOverallConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateCommonOverallConfigWithOptions($request, $runtime);
    }

    /**
     * Configures features by type. The features include container image scan, local file detection, container network visualization, and container escape prevention.
     *
     * @param request - OperateCommonTargetConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns OperateCommonTargetConfigResponse
     *
     * @param OperateCommonTargetConfigRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return OperateCommonTargetConfigResponse
     */
    public function operateCommonTargetConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->fieldName) {
            @$query['FieldName'] = $request->fieldName;
        }

        if (null !== $request->fieldValue) {
            @$query['FieldValue'] = $request->fieldValue;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->targetOperations) {
            @$query['TargetOperations'] = $request->targetOperations;
        }

        if (null !== $request->targetType) {
            @$query['TargetType'] = $request->targetType;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'OperateCommonTargetConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return OperateCommonTargetConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures features by type. The features include container image scan, local file detection, container network visualization, and container escape prevention.
     *
     * @param request - OperateCommonTargetConfigRequest
     *
     * @returns OperateCommonTargetConfigResponse
     *
     * @param OperateCommonTargetConfigRequest $request
     *
     * @return OperateCommonTargetConfigResponse
     */
    public function operateCommonTargetConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateCommonTargetConfigWithOptions($request, $runtime);
    }

    /**
     * Adds a check item of an image baseline to the whitelist, or removes a check item of an image baseline from the whitelist.
     *
     * @param request - OperateImageBaselineWhitelistRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns OperateImageBaselineWhitelistResponse
     *
     * @param OperateImageBaselineWhitelistRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return OperateImageBaselineWhitelistResponse
     */
    public function operateImageBaselineWhitelistWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->baselineItemKeyList) {
            @$query['BaselineItemKeyList'] = $request->baselineItemKeyList;
        }

        if (null !== $request->imageUuid) {
            @$query['ImageUuid'] = $request->imageUuid;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->operation) {
            @$query['Operation'] = $request->operation;
        }

        if (null !== $request->scanRange) {
            @$query['ScanRange'] = $request->scanRange;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'OperateImageBaselineWhitelist',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return OperateImageBaselineWhitelistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds a check item of an image baseline to the whitelist, or removes a check item of an image baseline from the whitelist.
     *
     * @param request - OperateImageBaselineWhitelistRequest
     *
     * @returns OperateImageBaselineWhitelistResponse
     *
     * @param OperateImageBaselineWhitelistRequest $request
     *
     * @return OperateImageBaselineWhitelistResponse
     */
    public function operateImageBaselineWhitelist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateImageBaselineWhitelistWithOptions($request, $runtime);
    }

    /**
     * Handles an image vulnerability, such as fixing the image vulnerability, verifying the fix of the image vulnerability, ignoring the image vulnerability, or canceling ignoring the image vulnerability.
     *
     * @param request - OperateImageVulRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns OperateImageVulResponse
     *
     * @param OperateImageVulRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return OperateImageVulResponse
     */
    public function operateImageVulWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->info) {
            @$query['Info'] = $request->info;
        }

        if (null !== $request->operateType) {
            @$query['OperateType'] = $request->operateType;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'OperateImageVul',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return OperateImageVulResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Handles an image vulnerability, such as fixing the image vulnerability, verifying the fix of the image vulnerability, ignoring the image vulnerability, or canceling ignoring the image vulnerability.
     *
     * @param request - OperateImageVulRequest
     *
     * @returns OperateImageVulResponse
     *
     * @param OperateImageVulRequest $request
     *
     * @return OperateImageVulResponse
     */
    public function operateImageVul($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateImageVulWithOptions($request, $runtime);
    }

    /**
     * Enables or disables a feature that detects exceptions.
     *
     * @param request - OperateSuspiciousOverallConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns OperateSuspiciousOverallConfigResponse
     *
     * @param OperateSuspiciousOverallConfigRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return OperateSuspiciousOverallConfigResponse
     */
    public function operateSuspiciousOverallConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->config) {
            @$query['Config'] = $request->config;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->noTargetAsOn) {
            @$query['NoTargetAsOn'] = $request->noTargetAsOn;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'OperateSuspiciousOverallConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return OperateSuspiciousOverallConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables or disables a feature that detects exceptions.
     *
     * @param request - OperateSuspiciousOverallConfigRequest
     *
     * @returns OperateSuspiciousOverallConfigResponse
     *
     * @param OperateSuspiciousOverallConfigRequest $request
     *
     * @return OperateSuspiciousOverallConfigResponse
     */
    public function operateSuspiciousOverallConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateSuspiciousOverallConfigWithOptions($request, $runtime);
    }

    /**
     * Configures the scope on which proactive defense takes effect.
     *
     * @param request - OperateSuspiciousTargetConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns OperateSuspiciousTargetConfigResponse
     *
     * @param OperateSuspiciousTargetConfigRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return OperateSuspiciousTargetConfigResponse
     */
    public function operateSuspiciousTargetConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->targetOperations) {
            @$query['TargetOperations'] = $request->targetOperations;
        }

        if (null !== $request->targetType) {
            @$query['TargetType'] = $request->targetType;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'OperateSuspiciousTargetConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return OperateSuspiciousTargetConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures the scope on which proactive defense takes effect.
     *
     * @param request - OperateSuspiciousTargetConfigRequest
     *
     * @returns OperateSuspiciousTargetConfigResponse
     *
     * @param OperateSuspiciousTargetConfigRequest $request
     *
     * @return OperateSuspiciousTargetConfigResponse
     */
    public function operateSuspiciousTargetConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateSuspiciousTargetConfigWithOptions($request, $runtime);
    }

    /**
     * Changes the status of a rule for container tamper-proofing.
     *
     * @param request - OperateSwitchStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns OperateSwitchStatusResponse
     *
     * @param OperateSwitchStatusRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return OperateSwitchStatusResponse
     */
    public function operateSwitchStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ruleId) {
            @$query['RuleId'] = $request->ruleId;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'OperateSwitchStatus',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return OperateSwitchStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the status of a rule for container tamper-proofing.
     *
     * @param request - OperateSwitchStatusRequest
     *
     * @returns OperateSwitchStatusResponse
     *
     * @param OperateSwitchStatusRequest $request
     *
     * @return OperateSwitchStatusResponse
     */
    public function operateSwitchStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateSwitchStatusWithOptions($request, $runtime);
    }

    /**
     * Handles alert events that are generated by the antivirus feature. You can perform in-depth detection and removal, add alert events to the whitelist, ignore alert events, or manually handle alert events.
     *
     * @param request - OperateVirusEventsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns OperateVirusEventsResponse
     *
     * @param OperateVirusEventsRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return OperateVirusEventsResponse
     */
    public function operateVirusEventsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->operationAll) {
            @$query['OperationAll'] = $request->operationAll;
        }

        if (null !== $request->operationCode) {
            @$query['OperationCode'] = $request->operationCode;
        }

        if (null !== $request->operationRange) {
            @$query['OperationRange'] = $request->operationRange;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'OperateVirusEvents',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return OperateVirusEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Handles alert events that are generated by the antivirus feature. You can perform in-depth detection and removal, add alert events to the whitelist, ignore alert events, or manually handle alert events.
     *
     * @param request - OperateVirusEventsRequest
     *
     * @returns OperateVirusEventsResponse
     *
     * @param OperateVirusEventsRequest $request
     *
     * @return OperateVirusEventsResponse
     */
    public function operateVirusEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateVirusEventsWithOptions($request, $runtime);
    }

    /**
     * Fixes Linux software vulnerabilities.
     *
     * @param request - OperateVulsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns OperateVulsResponse
     *
     * @param OperateVulsRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return OperateVulsResponse
     */
    public function operateVulsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->operateType) {
            @$query['OperateType'] = $request->operateType;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        if (null !== $request->vulNames) {
            @$query['VulNames'] = $request->vulNames;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'OperateVuls',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return OperateVulsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Fixes Linux software vulnerabilities.
     *
     * @param request - OperateVulsRequest
     *
     * @returns OperateVulsResponse
     *
     * @param OperateVulsRequest $request
     *
     * @return OperateVulsResponse
     */
    public function operateVuls($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateVulsWithOptions($request, $runtime);
    }

    /**
     * Handles alert events that are generated for web tamper proofing.
     *
     * @param request - OperateWebLockFileEventsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns OperateWebLockFileEventsResponse
     *
     * @param OperateWebLockFileEventsRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return OperateWebLockFileEventsResponse
     */
    public function operateWebLockFileEventsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dealAll) {
            @$query['DealAll'] = $request->dealAll;
        }

        if (null !== $request->eventIds) {
            @$query['EventIds'] = $request->eventIds;
        }

        if (null !== $request->operationCode) {
            @$query['OperationCode'] = $request->operationCode;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'OperateWebLockFileEvents',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return OperateWebLockFileEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Handles alert events that are generated for web tamper proofing.
     *
     * @param request - OperateWebLockFileEventsRequest
     *
     * @returns OperateWebLockFileEventsResponse
     *
     * @param OperateWebLockFileEventsRequest $request
     *
     * @return OperateWebLockFileEventsResponse
     */
    public function operateWebLockFileEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateWebLockFileEventsWithOptions($request, $runtime);
    }

    /**
     * Cancels ignoring alert events.
     *
     * @param request - OperationCancelIgnoreSuspEventRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns OperationCancelIgnoreSuspEventResponse
     *
     * @param OperationCancelIgnoreSuspEventRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return OperationCancelIgnoreSuspEventResponse
     */
    public function operationCancelIgnoreSuspEventWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->securityEventIds) {
            @$query['SecurityEventIds'] = $request->securityEventIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'OperationCancelIgnoreSuspEvent',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return OperationCancelIgnoreSuspEventResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Cancels ignoring alert events.
     *
     * @param request - OperationCancelIgnoreSuspEventRequest
     *
     * @returns OperationCancelIgnoreSuspEventResponse
     *
     * @param OperationCancelIgnoreSuspEventRequest $request
     *
     * @return OperationCancelIgnoreSuspEventResponse
     */
    public function operationCancelIgnoreSuspEvent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operationCancelIgnoreSuspEventWithOptions($request, $runtime);
    }

    /**
     * Modifies the chart of a security report.
     *
     * @param request - OperationCustomizeReportChartRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns OperationCustomizeReportChartResponse
     *
     * @param OperationCustomizeReportChartRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return OperationCustomizeReportChartResponse
     */
    public function operationCustomizeReportChartWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->chartIds) {
            @$query['ChartIds'] = $request->chartIds;
        }

        if (null !== $request->reportId) {
            @$query['ReportId'] = $request->reportId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'OperationCustomizeReportChart',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return OperationCustomizeReportChartResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the chart of a security report.
     *
     * @param request - OperationCustomizeReportChartRequest
     *
     * @returns OperationCustomizeReportChartResponse
     *
     * @param OperationCustomizeReportChartRequest $request
     *
     * @return OperationCustomizeReportChartResponse
     */
    public function operationCustomizeReportChart($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operationCustomizeReportChartWithOptions($request, $runtime);
    }

    /**
     * Handles multiple exceptions at a time.
     *
     * @param request - OperationSuspEventsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns OperationSuspEventsResponse
     *
     * @param OperationSuspEventsRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return OperationSuspEventsResponse
     */
    public function operationSuspEventsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        if (null !== $request->operation) {
            @$query['Operation'] = $request->operation;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->subOperation) {
            @$query['SubOperation'] = $request->subOperation;
        }

        if (null !== $request->suspiciousEventIds) {
            @$query['SuspiciousEventIds'] = $request->suspiciousEventIds;
        }

        if (null !== $request->warnType) {
            @$query['WarnType'] = $request->warnType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'OperationSuspEvents',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return OperationSuspEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Handles multiple exceptions at a time.
     *
     * @param request - OperationSuspEventsRequest
     *
     * @returns OperationSuspEventsResponse
     *
     * @param OperationSuspEventsRequest $request
     *
     * @return OperationSuspEventsResponse
     */
    public function operationSuspEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operationSuspEventsWithOptions($request, $runtime);
    }

    /**
     * Queries image repositories by page.
     *
     * @param request - PageImageRegistryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns PageImageRegistryResponse
     *
     * @param PageImageRegistryRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return PageImageRegistryResponse
     */
    public function pageImageRegistryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $body = [];
        if (null !== $request->currentPage) {
            @$body['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->registryNameLike) {
            @$body['RegistryNameLike'] = $request->registryNameLike;
        }

        if (null !== $request->registryTypeInList) {
            @$body['RegistryTypeInList'] = $request->registryTypeInList;
        }

        if (null !== $request->registryTypeNotInList) {
            @$body['RegistryTypeNotInList'] = $request->registryTypeNotInList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'PageImageRegistry',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return PageImageRegistryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries image repositories by page.
     *
     * @param request - PageImageRegistryRequest
     *
     * @returns PageImageRegistryResponse
     *
     * @param PageImageRegistryRequest $request
     *
     * @return PageImageRegistryResponse
     */
    public function pageImageRegistry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->pageImageRegistryWithOptions($request, $runtime);
    }

    /**
     * Enables or disables the Security Center agent.
     *
     * @param request - PauseClientRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns PauseClientResponse
     *
     * @param PauseClientRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return PauseClientResponse
     */
    public function pauseClientWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        if (null !== $request->value) {
            @$query['Value'] = $request->value;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'PauseClient',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return PauseClientResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables or disables the Security Center agent.
     *
     * @param request - PauseClientRequest
     *
     * @returns PauseClientResponse
     *
     * @param PauseClientRequest $request
     *
     * @return PauseClientResponse
     */
    public function pauseClient($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->pauseClientWithOptions($request, $runtime);
    }

    /**
     * Modify the status of strategy tasks.
     *
     * @remarks
     * This API call is only supported by the Enterprise and Flagship editions of Cloud Security Center, other versions do not support it.
     *
     * @param request - ProcessSoarStrategyTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ProcessSoarStrategyTaskResponse
     *
     * @param ProcessSoarStrategyTaskRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ProcessSoarStrategyTaskResponse
     */
    public function processSoarStrategyTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->strategyTaskId) {
            @$query['StrategyTaskId'] = $request->strategyTaskId;
        }

        if (null !== $request->taskAction) {
            @$query['TaskAction'] = $request->taskAction;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ProcessSoarStrategyTask',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ProcessSoarStrategyTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modify the status of strategy tasks.
     *
     * @remarks
     * This API call is only supported by the Enterprise and Flagship editions of Cloud Security Center, other versions do not support it.
     *
     * @param request - ProcessSoarStrategyTaskRequest
     *
     * @returns ProcessSoarStrategyTaskResponse
     *
     * @param ProcessSoarStrategyTaskRequest $request
     *
     * @return ProcessSoarStrategyTaskResponse
     */
    public function processSoarStrategyTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->processSoarStrategyTaskWithOptions($request, $runtime);
    }

    /**
     * Creates an image scan task.
     *
     * @remarks
     * Before you call the PublicCreateImageScanTask operation, we recommend that you call the [PublicPreCheckImageScanTask](~~PublicPreCheckImageScanTask~~) operation to query the number of images to scan and the quota for container image scan to be consumed by the image scan task. Make sure that the remaining quota for container image scan is sufficient. This prevents the task from being stopped due to an insufficient quota.
     *
     * @param request - PublicCreateImageScanTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns PublicCreateImageScanTaskResponse
     *
     * @param PublicCreateImageScanTaskRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return PublicCreateImageScanTaskResponse
     */
    public function publicCreateImageScanTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->digests) {
            @$query['Digests'] = $request->digests;
        }

        if (null !== $request->instanceIds) {
            @$query['InstanceIds'] = $request->instanceIds;
        }

        if (null !== $request->regionIds) {
            @$query['RegionIds'] = $request->regionIds;
        }

        if (null !== $request->registryTypes) {
            @$query['RegistryTypes'] = $request->registryTypes;
        }

        if (null !== $request->repoIds) {
            @$query['RepoIds'] = $request->repoIds;
        }

        if (null !== $request->repoNames) {
            @$query['RepoNames'] = $request->repoNames;
        }

        if (null !== $request->repoNamespaces) {
            @$query['RepoNamespaces'] = $request->repoNamespaces;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'PublicCreateImageScanTask',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return PublicCreateImageScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an image scan task.
     *
     * @remarks
     * Before you call the PublicCreateImageScanTask operation, we recommend that you call the [PublicPreCheckImageScanTask](~~PublicPreCheckImageScanTask~~) operation to query the number of images to scan and the quota for container image scan to be consumed by the image scan task. Make sure that the remaining quota for container image scan is sufficient. This prevents the task from being stopped due to an insufficient quota.
     *
     * @param request - PublicCreateImageScanTaskRequest
     *
     * @returns PublicCreateImageScanTaskResponse
     *
     * @param PublicCreateImageScanTaskRequest $request
     *
     * @return PublicCreateImageScanTaskResponse
     */
    public function publicCreateImageScanTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->publicCreateImageScanTaskWithOptions($request, $runtime);
    }

    /**
     * Queries the number of images to scan in an image scan task and the quota for container image scan to be consumed by the task.
     *
     * @remarks
     * You can call the PublicPreCheckImageScanTask operation to estimate the quota for container image scan to be consumed by the task. This ensures that you know the quota to be consumed before you perform the task. If the remaining quota for container image scan is less than the quota to be consumed by the task, you must purchase a sufficient quota. This prevents the task from being stopped due to an insufficient quota.
     * If you do not specify the optional parameters when you call this operation, the total number of protected images and the quota for container image scan to be consumed by scanning all the protected images are queried. If you specify the optional parameters, the number of images that meet the specified conditions and the quota for container image scan to be consumed by scanning the images are queried.
     *
     * @param request - PublicPreCheckImageScanTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns PublicPreCheckImageScanTaskResponse
     *
     * @param PublicPreCheckImageScanTaskRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return PublicPreCheckImageScanTaskResponse
     */
    public function publicPreCheckImageScanTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->digests) {
            @$query['Digests'] = $request->digests;
        }

        if (null !== $request->instanceIds) {
            @$query['InstanceIds'] = $request->instanceIds;
        }

        if (null !== $request->regionIds) {
            @$query['RegionIds'] = $request->regionIds;
        }

        if (null !== $request->registryTypes) {
            @$query['RegistryTypes'] = $request->registryTypes;
        }

        if (null !== $request->repoIds) {
            @$query['RepoIds'] = $request->repoIds;
        }

        if (null !== $request->repoNames) {
            @$query['RepoNames'] = $request->repoNames;
        }

        if (null !== $request->repoNamespaces) {
            @$query['RepoNamespaces'] = $request->repoNamespaces;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'PublicPreCheckImageScanTask',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return PublicPreCheckImageScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the number of images to scan in an image scan task and the quota for container image scan to be consumed by the task.
     *
     * @remarks
     * You can call the PublicPreCheckImageScanTask operation to estimate the quota for container image scan to be consumed by the task. This ensures that you know the quota to be consumed before you perform the task. If the remaining quota for container image scan is less than the quota to be consumed by the task, you must purchase a sufficient quota. This prevents the task from being stopped due to an insufficient quota.
     * If you do not specify the optional parameters when you call this operation, the total number of protected images and the quota for container image scan to be consumed by scanning all the protected images are queried. If you specify the optional parameters, the number of images that meet the specified conditions and the quota for container image scan to be consumed by scanning the images are queried.
     *
     * @param request - PublicPreCheckImageScanTaskRequest
     *
     * @returns PublicPreCheckImageScanTaskResponse
     *
     * @param PublicPreCheckImageScanTaskRequest $request
     *
     * @return PublicPreCheckImageScanTaskResponse
     */
    public function publicPreCheckImageScanTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->publicPreCheckImageScanTaskWithOptions($request, $runtime);
    }

    /**
     * Adds images to Security Center and creates an image scan task to scan the images.
     *
     * @param request - PublicSyncAndCreateImageScanTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns PublicSyncAndCreateImageScanTaskResponse
     *
     * @param PublicSyncAndCreateImageScanTaskRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return PublicSyncAndCreateImageScanTaskResponse
     */
    public function publicSyncAndCreateImageScanTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->images) {
            @$query['Images'] = $request->images;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'PublicSyncAndCreateImageScanTask',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return PublicSyncAndCreateImageScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds images to Security Center and creates an image scan task to scan the images.
     *
     * @param request - PublicSyncAndCreateImageScanTaskRequest
     *
     * @returns PublicSyncAndCreateImageScanTaskResponse
     *
     * @param PublicSyncAndCreateImageScanTaskRequest $request
     *
     * @return PublicSyncAndCreateImageScanTaskResponse
     */
    public function publicSyncAndCreateImageScanTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->publicSyncAndCreateImageScanTaskWithOptions($request, $runtime);
    }

    /**
     * Queries the number of alert events in each attack phase.
     *
     * @param request - QueryAttackCountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns QueryAttackCountResponse
     *
     * @param QueryAttackCountRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return QueryAttackCountResponse
     */
    public function queryAttackCountWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        $body = [];
        if (null !== $request->from) {
            @$body['From'] = $request->from;
        }

        if (null !== $request->lang) {
            @$body['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'QueryAttackCount',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return QueryAttackCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the number of alert events in each attack phase.
     *
     * @param request - QueryAttackCountRequest
     *
     * @returns QueryAttackCountResponse
     *
     * @param QueryAttackCountRequest $request
     *
     * @return QueryAttackCountResponse
     */
    public function queryAttackCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryAttackCountWithOptions($request, $runtime);
    }

    /**
     * Queries the progress of a database scan task.
     *
     * @param request - QueryDiscoverDatabaseRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns QueryDiscoverDatabaseResponse
     *
     * @param QueryDiscoverDatabaseRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return QueryDiscoverDatabaseResponse
     */
    public function queryDiscoverDatabaseWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->createMark) {
            @$query['CreateMark'] = $request->createMark;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'QueryDiscoverDatabase',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return QueryDiscoverDatabaseResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the progress of a database scan task.
     *
     * @param request - QueryDiscoverDatabaseRequest
     *
     * @returns QueryDiscoverDatabaseResponse
     *
     * @param QueryDiscoverDatabaseRequest $request
     *
     * @return QueryDiscoverDatabaseResponse
     */
    public function queryDiscoverDatabase($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryDiscoverDatabaseWithOptions($request, $runtime);
    }

    /**
     * Queries the ID of an asset group by using the name of the asset group.
     *
     * @remarks
     * You can call the QueryGroupIdByGroupName operation to query the ID of an asset group to which your assets belong by using the name of the asset group. When you call operations such as [GetSuspiciousStatistics](~~GetSuspiciousStatistics~~) and [DeleteGroup](~~DeleteGroup~~), you must specify the ID of the asset group. To query the ID of an asset group, call the QueryGroupIdByGroupName operation.
     * ### Limits
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - QueryGroupIdByGroupNameRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns QueryGroupIdByGroupNameResponse
     *
     * @param QueryGroupIdByGroupNameRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return QueryGroupIdByGroupNameResponse
     */
    public function queryGroupIdByGroupNameWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->groupName) {
            @$query['GroupName'] = $request->groupName;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'QueryGroupIdByGroupName',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return QueryGroupIdByGroupNameResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the ID of an asset group by using the name of the asset group.
     *
     * @remarks
     * You can call the QueryGroupIdByGroupName operation to query the ID of an asset group to which your assets belong by using the name of the asset group. When you call operations such as [GetSuspiciousStatistics](~~GetSuspiciousStatistics~~) and [DeleteGroup](~~DeleteGroup~~), you must specify the ID of the asset group. To query the ID of an asset group, call the QueryGroupIdByGroupName operation.
     * ### Limits
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - QueryGroupIdByGroupNameRequest
     *
     * @returns QueryGroupIdByGroupNameResponse
     *
     * @param QueryGroupIdByGroupNameRequest $request
     *
     * @return QueryGroupIdByGroupNameResponse
     */
    public function queryGroupIdByGroupName($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryGroupIdByGroupNameWithOptions($request, $runtime);
    }

    /**
     * Queries whitelist rules.
     *
     * @param request - QueryGroupedSecurityEventMarkMissListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns QueryGroupedSecurityEventMarkMissListResponse
     *
     * @param QueryGroupedSecurityEventMarkMissListRequest $request
     * @param RuntimeOptions                               $runtime
     *
     * @return QueryGroupedSecurityEventMarkMissListResponse
     */
    public function queryGroupedSecurityEventMarkMissListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->disposalWay) {
            @$query['DisposalWay'] = $request->disposalWay;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $body = [];
        if (null !== $request->currentPage) {
            @$body['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->eventName) {
            @$body['EventName'] = $request->eventName;
        }

        if (null !== $request->from) {
            @$body['From'] = $request->from;
        }

        if (null !== $request->lang) {
            @$body['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->remark) {
            @$body['Remark'] = $request->remark;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'QueryGroupedSecurityEventMarkMissList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return QueryGroupedSecurityEventMarkMissListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries whitelist rules.
     *
     * @param request - QueryGroupedSecurityEventMarkMissListRequest
     *
     * @returns QueryGroupedSecurityEventMarkMissListResponse
     *
     * @param QueryGroupedSecurityEventMarkMissListRequest $request
     *
     * @return QueryGroupedSecurityEventMarkMissListResponse
     */
    public function queryGroupedSecurityEventMarkMissList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryGroupedSecurityEventMarkMissListWithOptions($request, $runtime);
    }

    /**
     * Queries the list of beginner tasks. Security Center provides rewards for users who complete tasks. The rewards include the quota for a value-added feature and log storage capacity.
     *
     * @param request - QueryGuidTaskListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns QueryGuidTaskListResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return QueryGuidTaskListResponse
     */
    public function queryGuidTaskListWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'QueryGuidTaskList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return QueryGuidTaskListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the list of beginner tasks. Security Center provides rewards for users who complete tasks. The rewards include the quota for a value-added feature and log storage capacity.
     *
     * @returns QueryGuidTaskListResponse
     *
     * @return QueryGuidTaskListResponse
     */
    public function queryGuidTaskList()
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryGuidTaskListWithOptions($runtime);
    }

    /**
     * Queries the retention period of images that are stored in a Jenkins image repository.
     *
     * @param request - QueryJenkinsImageRegistryPersistenceDayRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns QueryJenkinsImageRegistryPersistenceDayResponse
     *
     * @param QueryJenkinsImageRegistryPersistenceDayRequest $request
     * @param RuntimeOptions                                 $runtime
     *
     * @return QueryJenkinsImageRegistryPersistenceDayResponse
     */
    public function queryJenkinsImageRegistryPersistenceDayWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'QueryJenkinsImageRegistryPersistenceDay',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return QueryJenkinsImageRegistryPersistenceDayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the retention period of images that are stored in a Jenkins image repository.
     *
     * @param request - QueryJenkinsImageRegistryPersistenceDayRequest
     *
     * @returns QueryJenkinsImageRegistryPersistenceDayResponse
     *
     * @param QueryJenkinsImageRegistryPersistenceDayRequest $request
     *
     * @return QueryJenkinsImageRegistryPersistenceDayResponse
     */
    public function queryJenkinsImageRegistryPersistenceDay($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryJenkinsImageRegistryPersistenceDayWithOptions($request, $runtime);
    }

    /**
     * Queries the result of a database precheck task.
     *
     * @param request - QueryPreCheckDatabaseRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns QueryPreCheckDatabaseResponse
     *
     * @param QueryPreCheckDatabaseRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return QueryPreCheckDatabaseResponse
     */
    public function queryPreCheckDatabaseWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceUuid) {
            @$query['InstanceUuid'] = $request->instanceUuid;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        if (null !== $request->uniRegionId) {
            @$query['UniRegionId'] = $request->uniRegionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'QueryPreCheckDatabase',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return QueryPreCheckDatabaseResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the result of a database precheck task.
     *
     * @param request - QueryPreCheckDatabaseRequest
     *
     * @returns QueryPreCheckDatabaseResponse
     *
     * @param QueryPreCheckDatabaseRequest $request
     *
     * @return QueryPreCheckDatabaseResponse
     */
    public function queryPreCheckDatabase($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryPreCheckDatabaseWithOptions($request, $runtime);
    }

    /**
     * Restarts a server. Only Windows servers are supported.
     *
     * @param request - RebootMachineRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RebootMachineResponse
     *
     * @param RebootMachineRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return RebootMachineResponse
     */
    public function rebootMachineWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RebootMachine',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RebootMachineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Restarts a server. Only Windows servers are supported.
     *
     * @param request - RebootMachineRequest
     *
     * @returns RebootMachineResponse
     *
     * @param RebootMachineRequest $request
     *
     * @return RebootMachineResponse
     */
    public function rebootMachine($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->rebootMachineWithOptions($request, $runtime);
    }

    /**
     * Receives a reward that allows you to enable a free trial of the cloud honeypot feature or the feature of SDK for malicious file detection. You can receive a reward after you complete the required task.
     *
     * @param request - ReceiveFunctionTrialRewardByAliUidRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ReceiveFunctionTrialRewardByAliUidResponse
     *
     * @param ReceiveFunctionTrialRewardByAliUidRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return ReceiveFunctionTrialRewardByAliUidResponse
     */
    public function receiveFunctionTrialRewardByAliUidWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->functionName) {
            @$query['FunctionName'] = $request->functionName;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ReceiveFunctionTrialRewardByAliUid',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ReceiveFunctionTrialRewardByAliUidResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Receives a reward that allows you to enable a free trial of the cloud honeypot feature or the feature of SDK for malicious file detection. You can receive a reward after you complete the required task.
     *
     * @param request - ReceiveFunctionTrialRewardByAliUidRequest
     *
     * @returns ReceiveFunctionTrialRewardByAliUidResponse
     *
     * @param ReceiveFunctionTrialRewardByAliUidRequest $request
     *
     * @return ReceiveFunctionTrialRewardByAliUidResponse
     */
    public function receiveFunctionTrialRewardByAliUid($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->receiveFunctionTrialRewardByAliUidWithOptions($request, $runtime);
    }

    /**
     * Synchronizes assets.
     *
     * @param request - RefreshAssetsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RefreshAssetsResponse
     *
     * @param RefreshAssetsRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return RefreshAssetsResponse
     */
    public function refreshAssetsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->assetType) {
            @$query['AssetType'] = $request->assetType;
        }

        if (null !== $request->cloudAssetSubType) {
            @$query['CloudAssetSubType'] = $request->cloudAssetSubType;
        }

        if (null !== $request->cloudAssetType) {
            @$query['CloudAssetType'] = $request->cloudAssetType;
        }

        if (null !== $request->vendor) {
            @$query['Vendor'] = $request->vendor;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RefreshAssets',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RefreshAssetsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Synchronizes assets.
     *
     * @param request - RefreshAssetsRequest
     *
     * @returns RefreshAssetsResponse
     *
     * @param RefreshAssetsRequest $request
     *
     * @return RefreshAssetsResponse
     */
    public function refreshAssets($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->refreshAssetsWithOptions($request, $runtime);
    }

    /**
     * Refreshes the statistics of container assets in the Assets module.
     *
     * @param request - RefreshContainerAssetsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RefreshContainerAssetsResponse
     *
     * @param RefreshContainerAssetsRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return RefreshContainerAssetsResponse
     */
    public function refreshContainerAssetsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->assetType) {
            @$query['AssetType'] = $request->assetType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RefreshContainerAssets',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RefreshContainerAssetsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Refreshes the statistics of container assets in the Assets module.
     *
     * @param request - RefreshContainerAssetsRequest
     *
     * @returns RefreshContainerAssetsResponse
     *
     * @param RefreshContainerAssetsRequest $request
     *
     * @return RefreshContainerAssetsResponse
     */
    public function refreshContainerAssets($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->refreshContainerAssetsWithOptions($request, $runtime);
    }

    /**
     * Refreshes the list of Object Storage Service (OSS) buckets.
     *
     * @param request - RefreshOssBucketScanInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RefreshOssBucketScanInfoResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return RefreshOssBucketScanInfoResponse
     */
    public function refreshOssBucketScanInfoWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'RefreshOssBucketScanInfo',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RefreshOssBucketScanInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Refreshes the list of Object Storage Service (OSS) buckets.
     *
     * @returns RefreshOssBucketScanInfoResponse
     *
     * @return RefreshOssBucketScanInfoResponse
     */
    public function refreshOssBucketScanInfo()
    {
        $runtime = new RuntimeOptions([]);

        return $this->refreshOssBucketScanInfoWithOptions($runtime);
    }

    /**
     * Updates an image token.
     *
     * @param request - RefreshRegistryTokenRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RefreshRegistryTokenResponse
     *
     * @param RefreshRegistryTokenRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return RefreshRegistryTokenResponse
     */
    public function refreshRegistryTokenWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->registryId) {
            @$query['RegistryId'] = $request->registryId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RefreshRegistryToken',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RefreshRegistryTokenResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates an image token.
     *
     * @param request - RefreshRegistryTokenRequest
     *
     * @returns RefreshRegistryTokenResponse
     *
     * @param RefreshRegistryTokenRequest $request
     *
     * @return RefreshRegistryTokenResponse
     */
    public function refreshRegistryToken($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->refreshRegistryTokenWithOptions($request, $runtime);
    }

    /**
     * .
     *
     * @param request - ReleaseSasInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ReleaseSasInstanceResponse
     *
     * @param ReleaseSasInstanceRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return ReleaseSasInstanceResponse
     */
    public function releaseSasInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->chargeType) {
            @$body['ChargeType'] = $request->chargeType;
        }

        if (null !== $request->instanceId) {
            @$body['InstanceId'] = $request->instanceId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ReleaseSasInstance',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ReleaseSasInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * .
     *
     * @param request - ReleaseSasInstanceRequest
     *
     * @returns ReleaseSasInstanceResponse
     *
     * @param ReleaseSasInstanceRequest $request
     *
     * @return ReleaseSasInstanceResponse
     */
    public function releaseSasInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->releaseSasInstanceWithOptions($request, $runtime);
    }

    /**
     * Removes an instance from the whitelist.
     *
     * @param request - RemoveCheckInstanceResultWhiteListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RemoveCheckInstanceResultWhiteListResponse
     *
     * @param RemoveCheckInstanceResultWhiteListRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return RemoveCheckInstanceResultWhiteListResponse
     */
    public function removeCheckInstanceResultWhiteListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->checkId) {
            @$query['CheckId'] = $request->checkId;
        }

        if (null !== $request->instanceIds) {
            @$query['InstanceIds'] = $request->instanceIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RemoveCheckInstanceResultWhiteList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RemoveCheckInstanceResultWhiteListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Removes an instance from the whitelist.
     *
     * @param request - RemoveCheckInstanceResultWhiteListRequest
     *
     * @returns RemoveCheckInstanceResultWhiteListResponse
     *
     * @param RemoveCheckInstanceResultWhiteListRequest $request
     *
     * @return RemoveCheckInstanceResultWhiteListResponse
     */
    public function removeCheckInstanceResultWhiteList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->removeCheckInstanceResultWhiteListWithOptions($request, $runtime);
    }

    /**
     * Removes the check items of the configuration assessment feature from the whitelist.
     *
     * @param request - RemoveCheckResultWhiteListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RemoveCheckResultWhiteListResponse
     *
     * @param RemoveCheckResultWhiteListRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return RemoveCheckResultWhiteListResponse
     */
    public function removeCheckResultWhiteListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->checkGroupId) {
            @$query['CheckGroupId'] = $request->checkGroupId;
        }

        if (null !== $request->checkIds) {
            @$query['CheckIds'] = $request->checkIds;
        }

        if (null !== $request->instanceIds) {
            @$query['InstanceIds'] = $request->instanceIds;
        }

        if (null !== $request->ruleId) {
            @$query['RuleId'] = $request->ruleId;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RemoveCheckResultWhiteList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RemoveCheckResultWhiteListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Removes the check items of the configuration assessment feature from the whitelist.
     *
     * @param request - RemoveCheckResultWhiteListRequest
     *
     * @returns RemoveCheckResultWhiteListResponse
     *
     * @param RemoveCheckResultWhiteListRequest $request
     *
     * @return RemoveCheckResultWhiteListResponse
     */
    public function removeCheckResultWhiteList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->removeCheckResultWhiteListWithOptions($request, $runtime);
    }

    /**
     * Resets a honeypot.
     *
     * @param request - ResetHoneypotRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ResetHoneypotResponse
     *
     * @param ResetHoneypotRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return ResetHoneypotResponse
     */
    public function resetHoneypotWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->honeypotId) {
            @$query['HoneypotId'] = $request->honeypotId;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ResetHoneypot',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ResetHoneypotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Resets a honeypot.
     *
     * @param request - ResetHoneypotRequest
     *
     * @returns ResetHoneypotResponse
     *
     * @param ResetHoneypotRequest $request
     *
     * @return ResetHoneypotResponse
     */
    public function resetHoneypot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->resetHoneypotWithOptions($request, $runtime);
    }

    /**
     * Resets and upgrades the log analysis feature. You can call this operation only when the log analysis feature uses the pay-as-you-go billing method.
     *
     * @param request - ResetLogShipperRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ResetLogShipperResponse
     *
     * @param ResetLogShipperRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return ResetLogShipperResponse
     */
    public function resetLogShipperWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hotTtl) {
            @$query['HotTtl'] = $request->hotTtl;
        }

        if (null !== $request->logMetaList) {
            @$query['LogMetaList'] = $request->logMetaList;
        }

        if (null !== $request->ttl) {
            @$query['Ttl'] = $request->ttl;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ResetLogShipper',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ResetLogShipperResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Resets and upgrades the log analysis feature. You can call this operation only when the log analysis feature uses the pay-as-you-go billing method.
     *
     * @param request - ResetLogShipperRequest
     *
     * @returns ResetLogShipperResponse
     *
     * @param ResetLogShipperRequest $request
     *
     * @return ResetLogShipperResponse
     */
    public function resetLogShipper($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->resetLogShipperWithOptions($request, $runtime);
    }

    /**
     * Retries agentless detection tasks.
     *
     * @param request - RetryAgentlessTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RetryAgentlessTaskResponse
     *
     * @param RetryAgentlessTaskRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return RetryAgentlessTaskResponse
     */
    public function retryAgentlessTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RetryAgentlessTask',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RetryAgentlessTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Retries agentless detection tasks.
     *
     * @param request - RetryAgentlessTaskRequest
     *
     * @returns RetryAgentlessTaskResponse
     *
     * @param RetryAgentlessTaskRequest $request
     *
     * @return RetryAgentlessTaskResponse
     */
    public function retryAgentlessTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->retryAgentlessTaskWithOptions($request, $runtime);
    }

    /**
     * Retry installing the honeypot probe.
     *
     * @param request - RetryInstallProbeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RetryInstallProbeResponse
     *
     * @param RetryInstallProbeRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return RetryInstallProbeResponse
     */
    public function retryInstallProbeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->probeId) {
            @$query['ProbeId'] = $request->probeId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RetryInstallProbe',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RetryInstallProbeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Retry installing the honeypot probe.
     *
     * @param request - RetryInstallProbeRequest
     *
     * @returns RetryInstallProbeResponse
     *
     * @param RetryInstallProbeRequest $request
     *
     * @return RetryInstallProbeResponse
     */
    public function retryInstallProbe($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->retryInstallProbeWithOptions($request, $runtime);
    }

    /**
     * Restores a quarantined file.
     *
     * @param request - RollbackSuspEventQuaraFileRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RollbackSuspEventQuaraFileResponse
     *
     * @param RollbackSuspEventQuaraFileRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return RollbackSuspEventQuaraFileResponse
     */
    public function rollbackSuspEventQuaraFileWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        if (null !== $request->quaraFileId) {
            @$query['QuaraFileId'] = $request->quaraFileId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RollbackSuspEventQuaraFile',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RollbackSuspEventQuaraFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Restores a quarantined file.
     *
     * @param request - RollbackSuspEventQuaraFileRequest
     *
     * @returns RollbackSuspEventQuaraFileResponse
     *
     * @param RollbackSuspEventQuaraFileRequest $request
     *
     * @return RollbackSuspEventQuaraFileResponse
     */
    public function rollbackSuspEventQuaraFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->rollbackSuspEventQuaraFileWithOptions($request, $runtime);
    }

    /**
     * Queries the installation verification code that is used to run the installation command of the Security Center agent.
     *
     * @param request - SasInstallCodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SasInstallCodeResponse
     *
     * @param SasInstallCodeRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return SasInstallCodeResponse
     */
    public function sasInstallCodeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SasInstallCode',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SasInstallCodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the installation verification code that is used to run the installation command of the Security Center agent.
     *
     * @param request - SasInstallCodeRequest
     *
     * @returns SasInstallCodeResponse
     *
     * @param SasInstallCodeRequest $request
     *
     * @return SasInstallCodeResponse
     */
    public function sasInstallCode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->sasInstallCodeWithOptions($request, $runtime);
    }

    /**
     * Saves the configurations of a custom security report.
     *
     * @param request - SaveCustomizeReportConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SaveCustomizeReportConfigResponse
     *
     * @param SaveCustomizeReportConfigRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return SaveCustomizeReportConfigResponse
     */
    public function saveCustomizeReportConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->groupType) {
            @$query['GroupType'] = $request->groupType;
        }

        if (null !== $request->memberAccountSyncFlag) {
            @$query['MemberAccountSyncFlag'] = $request->memberAccountSyncFlag;
        }

        if (null !== $request->pinnedTime) {
            @$query['PinnedTime'] = $request->pinnedTime;
        }

        if (null !== $request->recipients) {
            @$query['Recipients'] = $request->recipients;
        }

        if (null !== $request->reportDays) {
            @$query['ReportDays'] = $request->reportDays;
        }

        if (null !== $request->reportEndDate) {
            @$query['ReportEndDate'] = $request->reportEndDate;
        }

        if (null !== $request->reportId) {
            @$query['ReportId'] = $request->reportId;
        }

        if (null !== $request->reportLang) {
            @$query['ReportLang'] = $request->reportLang;
        }

        if (null !== $request->reportSendType) {
            @$query['ReportSendType'] = $request->reportSendType;
        }

        if (null !== $request->reportStartDate) {
            @$query['ReportStartDate'] = $request->reportStartDate;
        }

        if (null !== $request->reportStatus) {
            @$query['ReportStatus'] = $request->reportStatus;
        }

        if (null !== $request->reportType) {
            @$query['ReportType'] = $request->reportType;
        }

        if (null !== $request->reportVersion) {
            @$query['ReportVersion'] = $request->reportVersion;
        }

        if (null !== $request->sendEndTime) {
            @$query['SendEndTime'] = $request->sendEndTime;
        }

        if (null !== $request->sendPeriodDays) {
            @$query['SendPeriodDays'] = $request->sendPeriodDays;
        }

        if (null !== $request->sendPeriodType) {
            @$query['SendPeriodType'] = $request->sendPeriodType;
        }

        if (null !== $request->sendStartTime) {
            @$query['SendStartTime'] = $request->sendStartTime;
        }

        if (null !== $request->targetGroups) {
            @$query['TargetGroups'] = $request->targetGroups;
        }

        if (null !== $request->targetUids) {
            @$query['TargetUids'] = $request->targetUids;
        }

        if (null !== $request->title) {
            @$query['Title'] = $request->title;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SaveCustomizeReportConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SaveCustomizeReportConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Saves the configurations of a custom security report.
     *
     * @param request - SaveCustomizeReportConfigRequest
     *
     * @returns SaveCustomizeReportConfigResponse
     *
     * @param SaveCustomizeReportConfigRequest $request
     *
     * @return SaveCustomizeReportConfigResponse
     */
    public function saveCustomizeReportConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->saveCustomizeReportConfigWithOptions($request, $runtime);
    }

    /**
     * Saves a baseline check policy for images.
     *
     * @param request - SaveImageBaselineStrategyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SaveImageBaselineStrategyResponse
     *
     * @param SaveImageBaselineStrategyRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return SaveImageBaselineStrategyResponse
     */
    public function saveImageBaselineStrategyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->baselineItemList) {
            @$query['BaselineItemList'] = $request->baselineItemList;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        if (null !== $request->strategyId) {
            @$query['StrategyId'] = $request->strategyId;
        }

        if (null !== $request->strategyName) {
            @$query['StrategyName'] = $request->strategyName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SaveImageBaselineStrategy',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SaveImageBaselineStrategyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Saves a baseline check policy for images.
     *
     * @param request - SaveImageBaselineStrategyRequest
     *
     * @returns SaveImageBaselineStrategyResponse
     *
     * @param SaveImageBaselineStrategyRequest $request
     *
     * @return SaveImageBaselineStrategyResponse
     */
    public function saveImageBaselineStrategy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->saveImageBaselineStrategyWithOptions($request, $runtime);
    }

    /**
     * Saves alert settings.
     *
     * @param request - SaveSuspEventUserSettingRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SaveSuspEventUserSettingResponse
     *
     * @param SaveSuspEventUserSettingRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return SaveSuspEventUserSettingResponse
     */
    public function saveSuspEventUserSettingWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->from) {
            @$query['From'] = $request->from;
        }

        if (null !== $request->levelsOn) {
            @$query['LevelsOn'] = $request->levelsOn;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SaveSuspEventUserSetting',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SaveSuspEventUserSettingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Saves alert settings.
     *
     * @param request - SaveSuspEventUserSettingRequest
     *
     * @returns SaveSuspEventUserSettingResponse
     *
     * @param SaveSuspEventUserSettingRequest $request
     *
     * @return SaveSuspEventUserSettingResponse
     */
    public function saveSuspEventUserSetting($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->saveSuspEventUserSettingWithOptions($request, $runtime);
    }

    /**
     * Creates an application whitelist policy.
     *
     * @remarks
     * The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or enabled the feature, you can call this operation.
     *
     * @param request - SaveWhiteListStrategyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SaveWhiteListStrategyResponse
     *
     * @param SaveWhiteListStrategyRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return SaveWhiteListStrategyResponse
     */
    public function saveWhiteListStrategyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->strategyId) {
            @$query['StrategyId'] = $request->strategyId;
        }

        if (null !== $request->strategyName) {
            @$query['StrategyName'] = $request->strategyName;
        }

        if (null !== $request->studyTime) {
            @$query['StudyTime'] = $request->studyTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SaveWhiteListStrategy',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SaveWhiteListStrategyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an application whitelist policy.
     *
     * @remarks
     * The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or enabled the feature, you can call this operation.
     *
     * @param request - SaveWhiteListStrategyRequest
     *
     * @returns SaveWhiteListStrategyResponse
     *
     * @param SaveWhiteListStrategyRequest $request
     *
     * @return SaveWhiteListStrategyResponse
     */
    public function saveWhiteListStrategy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->saveWhiteListStrategyWithOptions($request, $runtime);
    }

    /**
     * Manages the servers to which an application whitelist policy is applied.
     *
     * @param request - SaveWhiteListStrategyAssetsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SaveWhiteListStrategyAssetsResponse
     *
     * @param SaveWhiteListStrategyAssetsRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return SaveWhiteListStrategyAssetsResponse
     */
    public function saveWhiteListStrategyAssetsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->operations) {
            @$query['Operations'] = $request->operations;
        }

        if (null !== $request->relationType) {
            @$query['RelationType'] = $request->relationType;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->strategyId) {
            @$query['StrategyId'] = $request->strategyId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SaveWhiteListStrategyAssets',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SaveWhiteListStrategyAssetsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Manages the servers to which an application whitelist policy is applied.
     *
     * @param request - SaveWhiteListStrategyAssetsRequest
     *
     * @returns SaveWhiteListStrategyAssetsResponse
     *
     * @param SaveWhiteListStrategyAssetsRequest $request
     *
     * @return SaveWhiteListStrategyAssetsResponse
     */
    public function saveWhiteListStrategyAssets($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->saveWhiteListStrategyAssetsWithOptions($request, $runtime);
    }

    /**
     * Sends a security report to an email address that you specify. You can send only a security report whose statistics are collected in a custom time range.
     *
     * @param request - SendCustomizeReportRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SendCustomizeReportResponse
     *
     * @param SendCustomizeReportRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return SendCustomizeReportResponse
     */
    public function sendCustomizeReportWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->reportId) {
            @$query['ReportId'] = $request->reportId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SendCustomizeReport',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SendCustomizeReportResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Sends a security report to an email address that you specify. You can send only a security report whose statistics are collected in a custom time range.
     *
     * @param request - SendCustomizeReportRequest
     *
     * @returns SendCustomizeReportResponse
     *
     * @param SendCustomizeReportRequest $request
     *
     * @return SendCustomizeReportResponse
     */
    public function sendCustomizeReport($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->sendCustomizeReportWithOptions($request, $runtime);
    }

    /**
     * Modifies configurations for scanning image build command risks.
     *
     * @param request - SetBuildRiskDefineRuleConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetBuildRiskDefineRuleConfigResponse
     *
     * @param SetBuildRiskDefineRuleConfigRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return SetBuildRiskDefineRuleConfigResponse
     */
    public function setBuildRiskDefineRuleConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->config) {
            @$query['Config'] = $request->config;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SetBuildRiskDefineRuleConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetBuildRiskDefineRuleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies configurations for scanning image build command risks.
     *
     * @param request - SetBuildRiskDefineRuleConfigRequest
     *
     * @returns SetBuildRiskDefineRuleConfigResponse
     *
     * @param SetBuildRiskDefineRuleConfigRequest $request
     *
     * @return SetBuildRiskDefineRuleConfigResponse
     */
    public function setBuildRiskDefineRuleConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setBuildRiskDefineRuleConfigWithOptions($request, $runtime);
    }

    /**
     * Configures the status of the container firewall feature.
     *
     * @param request - SetClusterInterceptionConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetClusterInterceptionConfigResponse
     *
     * @param SetClusterInterceptionConfigRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return SetClusterInterceptionConfigResponse
     */
    public function setClusterInterceptionConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterIds) {
            @$query['ClusterIds'] = $request->clusterIds;
        }

        if (null !== $request->switchOn) {
            @$query['SwitchOn'] = $request->switchOn;
        }

        if (null !== $request->switchType) {
            @$query['SwitchType'] = $request->switchType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SetClusterInterceptionConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetClusterInterceptionConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures the status of the container firewall feature.
     *
     * @param request - SetClusterInterceptionConfigRequest
     *
     * @returns SetClusterInterceptionConfigResponse
     *
     * @param SetClusterInterceptionConfigRequest $request
     *
     * @return SetClusterInterceptionConfigResponse
     */
    public function setClusterInterceptionConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setClusterInterceptionConfigWithOptions($request, $runtime);
    }

    /**
     * Specifies the status of an image build command risk.
     *
     * @param request - SetImageBuildRiskStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetImageBuildRiskStatusResponse
     *
     * @param SetImageBuildRiskStatusRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return SetImageBuildRiskStatusResponse
     */
    public function setImageBuildRiskStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->imageUuids) {
            @$query['ImageUuids'] = $request->imageUuids;
        }

        if (null !== $request->riskKey) {
            @$query['RiskKey'] = $request->riskKey;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SetImageBuildRiskStatus',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetImageBuildRiskStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Specifies the status of an image build command risk.
     *
     * @param request - SetImageBuildRiskStatusRequest
     *
     * @returns SetImageBuildRiskStatusResponse
     *
     * @param SetImageBuildRiskStatusRequest $request
     *
     * @return SetImageBuildRiskStatusResponse
     */
    public function setImageBuildRiskStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setImageBuildRiskStatusWithOptions($request, $runtime);
    }

    /**
     * Modifies the status of sensitive files in an image.
     *
     * @param tmpReq - SetImageSensitiveFileStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetImageSensitiveFileStatusResponse
     *
     * @param SetImageSensitiveFileStatusRequest $tmpReq
     * @param RuntimeOptions                     $runtime
     *
     * @return SetImageSensitiveFileStatusResponse
     */
    public function setImageSensitiveFileStatusWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new SetImageSensitiveFileStatusShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->scanRange) {
            $request->scanRangeShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->scanRange, 'ScanRange', 'json');
        }

        $query = [];
        if (null !== $request->idList) {
            @$query['IdList'] = $request->idList;
        }

        if (null !== $request->imageUuids) {
            @$query['ImageUuids'] = $request->imageUuids;
        }

        if (null !== $request->scanRangeShrink) {
            @$query['ScanRange'] = $request->scanRangeShrink;
        }

        if (null !== $request->sensitiveFileKey) {
            @$query['SensitiveFileKey'] = $request->sensitiveFileKey;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SetImageSensitiveFileStatus',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetImageSensitiveFileStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the status of sensitive files in an image.
     *
     * @param request - SetImageSensitiveFileStatusRequest
     *
     * @returns SetImageSensitiveFileStatusResponse
     *
     * @param SetImageSensitiveFileStatusRequest $request
     *
     * @return SetImageSensitiveFileStatusResponse
     */
    public function setImageSensitiveFileStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setImageSensitiveFileStatusWithOptions($request, $runtime);
    }

    /**
     * Specifies a cycle to scan images for image repositories. Unit: days.
     *
     * @param request - SetRegistryScanDayNumRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetRegistryScanDayNumResponse
     *
     * @param SetRegistryScanDayNumRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return SetRegistryScanDayNumResponse
     */
    public function setRegistryScanDayNumWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->scanDayNum) {
            @$query['ScanDayNum'] = $request->scanDayNum;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SetRegistryScanDayNum',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetRegistryScanDayNumResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Specifies a cycle to scan images for image repositories. Unit: days.
     *
     * @param request - SetRegistryScanDayNumRequest
     *
     * @returns SetRegistryScanDayNumResponse
     *
     * @param SetRegistryScanDayNumRequest $request
     *
     * @return SetRegistryScanDayNumResponse
     */
    public function setRegistryScanDayNum($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setRegistryScanDayNumWithOptions($request, $runtime);
    }

    /**
     * Configure the check rules of sensitive files.
     *
     * @param request - SetSensitiveDefineRuleConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetSensitiveDefineRuleConfigResponse
     *
     * @param SetSensitiveDefineRuleConfigRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return SetSensitiveDefineRuleConfigResponse
     */
    public function setSensitiveDefineRuleConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->config) {
            @$query['Config'] = $request->config;
        }

        if (null !== $request->enableNewRule) {
            @$query['EnableNewRule'] = $request->enableNewRule;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SetSensitiveDefineRuleConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetSensitiveDefineRuleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configure the check rules of sensitive files.
     *
     * @param request - SetSensitiveDefineRuleConfigRequest
     *
     * @returns SetSensitiveDefineRuleConfigResponse
     *
     * @param SetSensitiveDefineRuleConfigRequest $request
     *
     * @return SetSensitiveDefineRuleConfigResponse
     */
    public function setSensitiveDefineRuleConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setSensitiveDefineRuleConfigWithOptions($request, $runtime);
    }

    /**
     * Configures the regions from which you want to synchronize assets.
     *
     * @param request - SetSyncRefreshRegionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetSyncRefreshRegionResponse
     *
     * @param SetSyncRefreshRegionRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return SetSyncRefreshRegionResponse
     */
    public function setSyncRefreshRegionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->defaultRegion) {
            @$query['DefaultRegion'] = $request->defaultRegion;
        }

        if (null !== $request->regionIds) {
            @$query['RegionIds'] = $request->regionIds;
        }

        if (null !== $request->vendor) {
            @$query['Vendor'] = $request->vendor;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SetSyncRefreshRegion',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetSyncRefreshRegionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures the regions from which you want to synchronize assets.
     *
     * @param request - SetSyncRefreshRegionRequest
     *
     * @returns SetSyncRefreshRegionResponse
     *
     * @param SetSyncRefreshRegionRequest $request
     *
     * @return SetSyncRefreshRegionResponse
     */
    public function setSyncRefreshRegion($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setSyncRefreshRegionWithOptions($request, $runtime);
    }

    /**
     * Checks cloud service configurations. You can check all items or a single item and verify whether an item is checked.
     *
     * @deprecated openAPI StartBaselineSecurityCheck is deprecated, please use Sas::2018-12-03::SubmitCheck instead
     *
     * @param request - StartBaselineSecurityCheckRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StartBaselineSecurityCheckResponse
     *
     * @param StartBaselineSecurityCheckRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return StartBaselineSecurityCheckResponse
     */
    public function startBaselineSecurityCheckWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->itemIds) {
            @$query['ItemIds'] = $request->itemIds;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StartBaselineSecurityCheck',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StartBaselineSecurityCheckResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Checks cloud service configurations. You can check all items or a single item and verify whether an item is checked.
     *
     * @deprecated openAPI StartBaselineSecurityCheck is deprecated, please use Sas::2018-12-03::SubmitCheck instead
     *
     * @param request - StartBaselineSecurityCheckRequest
     *
     * @returns StartBaselineSecurityCheckResponse
     *
     * @param StartBaselineSecurityCheckRequest $request
     *
     * @return StartBaselineSecurityCheckResponse
     */
    public function startBaselineSecurityCheck($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startBaselineSecurityCheckWithOptions($request, $runtime);
    }

    /**
     * Starts a database scan task.
     *
     * @param request - StartDiscoverDatabaseTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StartDiscoverDatabaseTaskResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return StartDiscoverDatabaseTaskResponse
     */
    public function startDiscoverDatabaseTaskWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'StartDiscoverDatabaseTask',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StartDiscoverDatabaseTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Starts a database scan task.
     *
     * @returns StartDiscoverDatabaseTaskResponse
     *
     * @return StartDiscoverDatabaseTaskResponse
     */
    public function startDiscoverDatabaseTask()
    {
        $runtime = new RuntimeOptions([]);

        return $this->startDiscoverDatabaseTaskWithOptions($runtime);
    }

    /**
     * Starts a honeypot.
     *
     * @param request - StartHoneypotRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StartHoneypotResponse
     *
     * @param StartHoneypotRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return StartHoneypotResponse
     */
    public function startHoneypotWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->honeypotId) {
            @$query['HoneypotId'] = $request->honeypotId;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StartHoneypot',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StartHoneypotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Starts a honeypot.
     *
     * @param request - StartHoneypotRequest
     *
     * @returns StartHoneypotResponse
     *
     * @param StartHoneypotRequest $request
     *
     * @return StartHoneypotResponse
     */
    public function startHoneypot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startHoneypotWithOptions($request, $runtime);
    }

    /**
     * Starts an IDC scan task.
     *
     * @param request - StartIdcProbeScanRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StartIdcProbeScanResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return StartIdcProbeScanResponse
     */
    public function startIdcProbeScanWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'StartIdcProbeScan',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StartIdcProbeScanResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Starts an IDC scan task.
     *
     * @returns StartIdcProbeScanResponse
     *
     * @return StartIdcProbeScanResponse
     */
    public function startIdcProbeScan()
    {
        $runtime = new RuntimeOptions([]);

        return $this->startIdcProbeScanWithOptions($runtime);
    }

    /**
     * Starts a database precheck task.
     *
     * @param request - StartPreCheckDatabaseRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StartPreCheckDatabaseResponse
     *
     * @param StartPreCheckDatabaseRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return StartPreCheckDatabaseResponse
     */
    public function startPreCheckDatabaseWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->databaseType) {
            @$query['DatabaseType'] = $request->databaseType;
        }

        if (null !== $request->instanceUuid) {
            @$query['InstanceUuid'] = $request->instanceUuid;
        }

        if (null !== $request->uniRegionId) {
            @$query['UniRegionId'] = $request->uniRegionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StartPreCheckDatabase',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StartPreCheckDatabaseResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Starts a database precheck task.
     *
     * @param request - StartPreCheckDatabaseRequest
     *
     * @returns StartPreCheckDatabaseResponse
     *
     * @param StartPreCheckDatabaseRequest $request
     *
     * @return StartPreCheckDatabaseResponse
     */
    public function startPreCheckDatabase($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startPreCheckDatabaseWithOptions($request, $runtime);
    }

    /**
     * Performs a virus scan task on a server or multiple servers.
     *
     * @param request - StartVirusScanTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StartVirusScanTaskResponse
     *
     * @param StartVirusScanTaskRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return StartVirusScanTaskResponse
     */
    public function startVirusScanTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->targetInfo) {
            @$query['TargetInfo'] = $request->targetInfo;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StartVirusScanTask',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StartVirusScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Performs a virus scan task on a server or multiple servers.
     *
     * @param request - StartVirusScanTaskRequest
     *
     * @returns StartVirusScanTaskResponse
     *
     * @param StartVirusScanTaskRequest $request
     *
     * @return StartVirusScanTaskResponse
     */
    public function startVirusScanTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startVirusScanTaskWithOptions($request, $runtime);
    }

    /**
     * Stops a honeypot.
     *
     * @param request - StopHoneypotRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StopHoneypotResponse
     *
     * @param StopHoneypotRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return StopHoneypotResponse
     */
    public function stopHoneypotWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->honeypotId) {
            @$query['HoneypotId'] = $request->honeypotId;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StopHoneypot',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StopHoneypotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Stops a honeypot.
     *
     * @param request - StopHoneypotRequest
     *
     * @returns StopHoneypotResponse
     *
     * @param StopHoneypotRequest $request
     *
     * @return StopHoneypotResponse
     */
    public function stopHoneypot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopHoneypotWithOptions($request, $runtime);
    }

    /**
     * Submits a configuration assessment task.
     *
     * @param request - SubmitCheckRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SubmitCheckResponse
     *
     * @param SubmitCheckRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return SubmitCheckResponse
     */
    public function submitCheckWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->scanRange) {
            @$query['ScanRange'] = $request->scanRange;
        }

        if (null !== $request->taskSource) {
            @$query['TaskSource'] = $request->taskSource;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SubmitCheck',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SubmitCheckResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Submits a configuration assessment task.
     *
     * @param request - SubmitCheckRequest
     *
     * @returns SubmitCheckResponse
     *
     * @param SubmitCheckRequest $request
     *
     * @return SubmitCheckResponse
     */
    public function submitCheck($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->submitCheckWithOptions($request, $runtime);
    }

    /**
     * Submits a repair task of risk items detected in configuration assessment or rolls back a repair task that is executed.
     *
     * @param request - SubmitOperationTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SubmitOperationTaskResponse
     *
     * @param SubmitOperationTaskRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return SubmitOperationTaskResponse
     */
    public function submitOperationTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->checkId) {
            @$query['CheckId'] = $request->checkId;
        }

        if (null !== $request->dimensionType) {
            @$query['DimensionType'] = $request->dimensionType;
        }

        if (null !== $request->operationTaskInstances) {
            @$query['OperationTaskInstances'] = $request->operationTaskInstances;
        }

        if (null !== $request->relationKey) {
            @$query['RelationKey'] = $request->relationKey;
        }

        if (null !== $request->repairTempParam) {
            @$query['RepairTempParam'] = $request->repairTempParam;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SubmitOperationTask',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SubmitOperationTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Submits a repair task of risk items detected in configuration assessment or rolls back a repair task that is executed.
     *
     * @param request - SubmitOperationTaskRequest
     *
     * @returns SubmitOperationTaskResponse
     *
     * @param SubmitOperationTaskRequest $request
     *
     * @return SubmitOperationTaskResponse
     */
    public function submitOperationTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->submitOperationTaskWithOptions($request, $runtime);
    }

    /**
     * Submits a free quick scan task, which includes vulnerability detection in the free category and free check items of Cloud Security Posture Management (CSPM).
     *
     * @param request - SubmitTenantCheckRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SubmitTenantCheckResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return SubmitTenantCheckResponse
     */
    public function submitTenantCheckWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'SubmitTenantCheck',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SubmitTenantCheckResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Submits a free quick scan task, which includes vulnerability detection in the free category and free check items of Cloud Security Posture Management (CSPM).
     *
     * @returns SubmitTenantCheckResponse
     *
     * @return SubmitTenantCheckResponse
     */
    public function submitTenantCheck()
    {
        $runtime = new RuntimeOptions([]);

        return $this->submitTenantCheckWithOptions($runtime);
    }

    /**
     * Triggers ISO 27001 compliance checks of Security Center.
     *
     * @param request - TriggerCheckRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns TriggerCheckResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return TriggerCheckResponse
     */
    public function triggerCheckWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'TriggerCheck',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return TriggerCheckResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Triggers ISO 27001 compliance checks of Security Center.
     *
     * @returns TriggerCheckResponse
     *
     * @return TriggerCheckResponse
     */
    public function triggerCheck()
    {
        $runtime = new RuntimeOptions([]);

        return $this->triggerCheckWithOptions($runtime);
    }

    /**
     * Removes servers from a proxy cluster.
     *
     * @param request - UnBindHybridProxyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UnBindHybridProxyResponse
     *
     * @param UnBindHybridProxyRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return UnBindHybridProxyResponse
     */
    public function unBindHybridProxyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterName) {
            @$query['ClusterName'] = $request->clusterName;
        }

        if (null !== $request->yundunUuids) {
            @$query['YundunUuids'] = $request->yundunUuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UnBindHybridProxy',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UnBindHybridProxyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Removes servers from a proxy cluster.
     *
     * @param request - UnBindHybridProxyRequest
     *
     * @returns UnBindHybridProxyResponse
     *
     * @param UnBindHybridProxyRequest $request
     *
     * @return UnBindHybridProxyResponse
     */
    public function unBindHybridProxy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->unBindHybridProxyWithOptions($request, $runtime);
    }

    /**
     * Cancel marking for members. You can call this operation to remove followed members from the list. In the Security Center console, the drop-down list above the left-side navigation pane no longer displays the members.
     *
     * @param request - UnMarkMonitorAccountsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UnMarkMonitorAccountsResponse
     *
     * @param UnMarkMonitorAccountsRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return UnMarkMonitorAccountsResponse
     */
    public function unMarkMonitorAccountsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accountIds) {
            @$query['AccountIds'] = $request->accountIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UnMarkMonitorAccounts',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UnMarkMonitorAccountsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Cancel marking for members. You can call this operation to remove followed members from the list. In the Security Center console, the drop-down list above the left-side navigation pane no longer displays the members.
     *
     * @param request - UnMarkMonitorAccountsRequest
     *
     * @returns UnMarkMonitorAccountsResponse
     *
     * @param UnMarkMonitorAccountsRequest $request
     *
     * @return UnMarkMonitorAccountsResponse
     */
    public function unMarkMonitorAccounts($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->unMarkMonitorAccountsWithOptions($request, $runtime);
    }

    /**
     * Unbinds servers that are not deployed on Alibaba Cloud from Security Center.
     *
     * @remarks
     * If you no longer require protection for servers that are not deployed on Alibaba Cloud, you can call this operation to unbind the servers from Security Center. After you unbind a server that is not deployed on Alibaba Cloud from Security Center, the server no longer consumes the quota of protected servers or protected server vCPUs. This way, you can install the Security Center agent on other servers to meet your business requirements.
     * > You can unbind only the servers that are not deployed on Alibaba Cloud from Security Center. If you use an Alibaba Cloud Elastic Compute Service (ECS) instance, you do not need to unbind the ECS instance. If you uninstall the Security Center agent from an ECS instance, the ECS instance still exists as a disconnected server in the asset list of the Security Center console. The ECS instance is not removed from the asset list.
     * **Prerequisites**
     * *   The server that you want to unbind from Security Center is not deployed on Alibaba Cloud and the Security Center agent is disabled for the server. In this case, the agent is in the Close state and Security Center does not protect the server. You can call the [PauseClient](~~PauseClient~~) operation to disable the agent.
     * *   The client protection feature is disabled for the server that you want to unbind from Security Center. For more information about how to disable the client protection feature, see [Use the client protection feature](https://www.alibabacloud.com/help/en/security-center/latest/local-file-detection-engine).
     *
     * @param request - UnbindAegisRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UnbindAegisResponse
     *
     * @param UnbindAegisRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return UnbindAegisResponse
     */
    public function unbindAegisWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UnbindAegis',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UnbindAegisResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Unbinds servers that are not deployed on Alibaba Cloud from Security Center.
     *
     * @remarks
     * If you no longer require protection for servers that are not deployed on Alibaba Cloud, you can call this operation to unbind the servers from Security Center. After you unbind a server that is not deployed on Alibaba Cloud from Security Center, the server no longer consumes the quota of protected servers or protected server vCPUs. This way, you can install the Security Center agent on other servers to meet your business requirements.
     * > You can unbind only the servers that are not deployed on Alibaba Cloud from Security Center. If you use an Alibaba Cloud Elastic Compute Service (ECS) instance, you do not need to unbind the ECS instance. If you uninstall the Security Center agent from an ECS instance, the ECS instance still exists as a disconnected server in the asset list of the Security Center console. The ECS instance is not removed from the asset list.
     * **Prerequisites**
     * *   The server that you want to unbind from Security Center is not deployed on Alibaba Cloud and the Security Center agent is disabled for the server. In this case, the agent is in the Close state and Security Center does not protect the server. You can call the [PauseClient](~~PauseClient~~) operation to disable the agent.
     * *   The client protection feature is disabled for the server that you want to unbind from Security Center. For more information about how to disable the client protection feature, see [Use the client protection feature](https://www.alibabacloud.com/help/en/security-center/latest/local-file-detection-engine).
     *
     * @param request - UnbindAegisRequest
     *
     * @returns UnbindAegisResponse
     *
     * @param UnbindAegisRequest $request
     *
     * @return UnbindAegisResponse
     */
    public function unbindAegis($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->unbindAegisWithOptions($request, $runtime);
    }

    /**
     * Uninstalls the anti-ransomware agent.
     *
     * @param request - UninstallBackupClientRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UninstallBackupClientResponse
     *
     * @param UninstallBackupClientRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return UninstallBackupClientResponse
     */
    public function uninstallBackupClientWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->policyVersion) {
            @$query['PolicyVersion'] = $request->policyVersion;
        }

        if (null !== $request->uuid) {
            @$query['Uuid'] = $request->uuid;
        }

        if (null !== $request->uuidList) {
            @$query['UuidList'] = $request->uuidList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UninstallBackupClient',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UninstallBackupClientResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Uninstalls the anti-ransomware agent.
     *
     * @param request - UninstallBackupClientRequest
     *
     * @returns UninstallBackupClientResponse
     *
     * @param UninstallBackupClientRequest $request
     *
     * @return UninstallBackupClientResponse
     */
    public function uninstallBackupClient($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->uninstallBackupClientWithOptions($request, $runtime);
    }

    /**
     * Uninstalls the database backup agent.
     *
     * @param request - UninstallUniBackupAgentRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UninstallUniBackupAgentResponse
     *
     * @param UninstallUniBackupAgentRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return UninstallUniBackupAgentResponse
     */
    public function uninstallUniBackupAgentWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->policyId) {
            @$query['PolicyId'] = $request->policyId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UninstallUniBackupAgent',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UninstallUniBackupAgentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Uninstalls the database backup agent.
     *
     * @param request - UninstallUniBackupAgentRequest
     *
     * @returns UninstallUniBackupAgentResponse
     *
     * @param UninstallUniBackupAgentRequest $request
     *
     * @return UninstallUniBackupAgentResponse
     */
    public function uninstallUniBackupAgent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->uninstallUniBackupAgentWithOptions($request, $runtime);
    }

    /**
     * Updates the status of the honeypot installation time.
     *
     * @param request - UpdateAlarmEventRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateAlarmEventResponse
     *
     * @param UpdateAlarmEventRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return UpdateAlarmEventResponse
     */
    public function updateAlarmEventWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->alarmEventIdList) {
            @$body['AlarmEventIdList'] = $request->alarmEventIdList;
        }

        if (null !== $request->lang) {
            @$body['Lang'] = $request->lang;
        }

        if (null !== $request->operationCode) {
            @$body['OperationCode'] = $request->operationCode;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'UpdateAlarmEvent',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateAlarmEventResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates the status of the honeypot installation time.
     *
     * @param request - UpdateAlarmEventRequest
     *
     * @returns UpdateAlarmEventResponse
     *
     * @param UpdateAlarmEventRequest $request
     *
     * @return UpdateAlarmEventResponse
     */
    public function updateAlarmEvent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateAlarmEventWithOptions($request, $runtime);
    }

    /**
     * Update the configuration of sensitive assets in the attack path.
     *
     * @param request - UpdateAttackPathSensitiveAssetConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateAttackPathSensitiveAssetConfigResponse
     *
     * @param UpdateAttackPathSensitiveAssetConfigRequest $request
     * @param RuntimeOptions                              $runtime
     *
     * @return UpdateAttackPathSensitiveAssetConfigResponse
     */
    public function updateAttackPathSensitiveAssetConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->attackPathAssetList) {
            @$query['AttackPathAssetList'] = $request->attackPathAssetList;
        }

        if (null !== $request->attackPathSensitiveAssetConfigId) {
            @$query['AttackPathSensitiveAssetConfigId'] = $request->attackPathSensitiveAssetConfigId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateAttackPathSensitiveAssetConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateAttackPathSensitiveAssetConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Update the configuration of sensitive assets in the attack path.
     *
     * @param request - UpdateAttackPathSensitiveAssetConfigRequest
     *
     * @returns UpdateAttackPathSensitiveAssetConfigResponse
     *
     * @param UpdateAttackPathSensitiveAssetConfigRequest $request
     *
     * @return UpdateAttackPathSensitiveAssetConfigResponse
     */
    public function updateAttackPathSensitiveAssetConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateAttackPathSensitiveAssetConfigWithOptions($request, $runtime);
    }

    /**
     * Update Attack Path Whitelist.
     *
     * @param request - UpdateAttackPathWhitelistRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateAttackPathWhitelistResponse
     *
     * @param UpdateAttackPathWhitelistRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return UpdateAttackPathWhitelistResponse
     */
    public function updateAttackPathWhitelistWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->attackPathAssetList) {
            @$query['AttackPathAssetList'] = $request->attackPathAssetList;
        }

        if (null !== $request->attackPathWhitelistId) {
            @$query['AttackPathWhitelistId'] = $request->attackPathWhitelistId;
        }

        if (null !== $request->pathName) {
            @$query['PathName'] = $request->pathName;
        }

        if (null !== $request->pathType) {
            @$query['PathType'] = $request->pathType;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->whitelistName) {
            @$query['WhitelistName'] = $request->whitelistName;
        }

        if (null !== $request->whitelistType) {
            @$query['WhitelistType'] = $request->whitelistType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateAttackPathWhitelist',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateAttackPathWhitelistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Update Attack Path Whitelist.
     *
     * @param request - UpdateAttackPathWhitelistRequest
     *
     * @returns UpdateAttackPathWhitelistResponse
     *
     * @param UpdateAttackPathWhitelistRequest $request
     *
     * @return UpdateAttackPathWhitelistResponse
     */
    public function updateAttackPathWhitelist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateAttackPathWhitelistWithOptions($request, $runtime);
    }

    /**
     * Updates the whitelist rule for a baseline check item.
     *
     * @param request - UpdateBaselineCheckWhiteRecordRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateBaselineCheckWhiteRecordResponse
     *
     * @param UpdateBaselineCheckWhiteRecordRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return UpdateBaselineCheckWhiteRecordResponse
     */
    public function updateBaselineCheckWhiteRecordWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->checkId) {
            @$query['CheckId'] = $request->checkId;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->reason) {
            @$query['Reason'] = $request->reason;
        }

        if (null !== $request->recordId) {
            @$query['RecordId'] = $request->recordId;
        }

        if (null !== $request->removeContainerUuids) {
            @$query['RemoveContainerUuids'] = $request->removeContainerUuids;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        if (null !== $request->targetType) {
            @$query['TargetType'] = $request->targetType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateBaselineCheckWhiteRecord',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateBaselineCheckWhiteRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates the whitelist rule for a baseline check item.
     *
     * @param request - UpdateBaselineCheckWhiteRecordRequest
     *
     * @returns UpdateBaselineCheckWhiteRecordResponse
     *
     * @param UpdateBaselineCheckWhiteRecordRequest $request
     *
     * @return UpdateBaselineCheckWhiteRecordResponse
     */
    public function updateBaselineCheckWhiteRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateBaselineCheckWhiteRecordWithOptions($request, $runtime);
    }

    /**
     * User creates a custom check item.
     *
     * @param tmpReq - UpdateCheckItemRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateCheckItemResponse
     *
     * @param UpdateCheckItemRequest $tmpReq
     * @param RuntimeOptions         $runtime
     *
     * @return UpdateCheckItemResponse
     */
    public function updateCheckItemWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new UpdateCheckItemShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->assistInfo) {
            $request->assistInfoShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->assistInfo, 'AssistInfo', 'json');
        }

        if (null !== $tmpReq->description) {
            $request->descriptionShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->description, 'Description', 'json');
        }

        if (null !== $tmpReq->solution) {
            $request->solutionShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->solution, 'Solution', 'json');
        }

        $query = [];
        if (null !== $request->assistInfoShrink) {
            @$query['AssistInfo'] = $request->assistInfoShrink;
        }

        if (null !== $request->checkId) {
            @$query['CheckId'] = $request->checkId;
        }

        if (null !== $request->checkRule) {
            @$query['CheckRule'] = $request->checkRule;
        }

        if (null !== $request->checkShowName) {
            @$query['CheckShowName'] = $request->checkShowName;
        }

        if (null !== $request->descriptionShrink) {
            @$query['Description'] = $request->descriptionShrink;
        }

        if (null !== $request->instanceSubType) {
            @$query['InstanceSubType'] = $request->instanceSubType;
        }

        if (null !== $request->instanceType) {
            @$query['InstanceType'] = $request->instanceType;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->riskLevel) {
            @$query['RiskLevel'] = $request->riskLevel;
        }

        if (null !== $request->sectionIds) {
            @$query['SectionIds'] = $request->sectionIds;
        }

        if (null !== $request->solutionShrink) {
            @$query['Solution'] = $request->solutionShrink;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->vendor) {
            @$query['Vendor'] = $request->vendor;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateCheckItem',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateCheckItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * User creates a custom check item.
     *
     * @param request - UpdateCheckItemRequest
     *
     * @returns UpdateCheckItemResponse
     *
     * @param UpdateCheckItemRequest $request
     *
     * @return UpdateCheckItemResponse
     */
    public function updateCheckItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateCheckItemWithOptions($request, $runtime);
    }

    /**
     * Update Custom Policy.
     *
     * @param request - UpdateCheckPolicyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateCheckPolicyResponse
     *
     * @param UpdateCheckPolicyRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return UpdateCheckPolicyResponse
     */
    public function updateCheckPolicyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dependentPolicyId) {
            @$query['DependentPolicyId'] = $request->dependentPolicyId;
        }

        if (null !== $request->policyId) {
            @$query['PolicyId'] = $request->policyId;
        }

        if (null !== $request->policyShowName) {
            @$query['PolicyShowName'] = $request->policyShowName;
        }

        if (null !== $request->policyType) {
            @$query['PolicyType'] = $request->policyType;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateCheckPolicy',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateCheckPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Update Custom Policy.
     *
     * @param request - UpdateCheckPolicyRequest
     *
     * @returns UpdateCheckPolicyResponse
     *
     * @param UpdateCheckPolicyRequest $request
     *
     * @return UpdateCheckPolicyResponse
     */
    public function updateCheckPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateCheckPolicyWithOptions($request, $runtime);
    }

    /**
     * Modifies alerting settings for servers.
     *
     * @param request - UpdateClientAlertModeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateClientAlertModeResponse
     *
     * @param UpdateClientAlertModeRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return UpdateClientAlertModeResponse
     */
    public function updateClientAlertModeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->mode) {
            @$query['Mode'] = $request->mode;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateClientAlertMode',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateClientAlertModeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies alerting settings for servers.
     *
     * @param request - UpdateClientAlertModeRequest
     *
     * @returns UpdateClientAlertModeResponse
     *
     * @param UpdateClientAlertModeRequest $request
     *
     * @return UpdateClientAlertModeResponse
     */
    public function updateClientAlertMode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateClientAlertModeWithOptions($request, $runtime);
    }

    /**
     * Modifies the settings of common switches.
     *
     * @param request - UpdateCommonSwitchConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateCommonSwitchConfigResponse
     *
     * @param UpdateCommonSwitchConfigRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return UpdateCommonSwitchConfigResponse
     */
    public function updateCommonSwitchConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->targetDefault) {
            @$query['TargetDefault'] = $request->targetDefault;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateCommonSwitchConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateCommonSwitchConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the settings of common switches.
     *
     * @param request - UpdateCommonSwitchConfigRequest
     *
     * @returns UpdateCommonSwitchConfigResponse
     *
     * @param UpdateCommonSwitchConfigRequest $request
     *
     * @return UpdateCommonSwitchConfigResponse
     */
    public function updateCommonSwitchConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateCommonSwitchConfigWithOptions($request, $runtime);
    }

    /**
     * Changes the status of a security report.
     *
     * @param request - UpdateCustomizeReportStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateCustomizeReportStatusResponse
     *
     * @param UpdateCustomizeReportStatusRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return UpdateCustomizeReportStatusResponse
     */
    public function updateCustomizeReportStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->pinnedTime) {
            @$query['PinnedTime'] = $request->pinnedTime;
        }

        if (null !== $request->reportId) {
            @$query['ReportId'] = $request->reportId;
        }

        if (null !== $request->reportStatus) {
            @$query['ReportStatus'] = $request->reportStatus;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateCustomizeReportStatus',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateCustomizeReportStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the status of a security report.
     *
     * @param request - UpdateCustomizeReportStatusRequest
     *
     * @returns UpdateCustomizeReportStatusResponse
     *
     * @param UpdateCustomizeReportStatusRequest $request
     *
     * @return UpdateCustomizeReportStatusResponse
     */
    public function updateCustomizeReportStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateCustomizeReportStatusWithOptions($request, $runtime);
    }

    /**
     * Modifies the status of core file monitoring events reported by the Security Center agent.
     *
     * @param request - UpdateFileProtectEventStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateFileProtectEventStatusResponse
     *
     * @param UpdateFileProtectEventStatusRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return UpdateFileProtectEventStatusResponse
     */
    public function updateFileProtectEventStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateFileProtectEventStatus',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateFileProtectEventStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the status of core file monitoring events reported by the Security Center agent.
     *
     * @param request - UpdateFileProtectEventStatusRequest
     *
     * @returns UpdateFileProtectEventStatusResponse
     *
     * @param UpdateFileProtectEventStatusRequest $request
     *
     * @return UpdateFileProtectEventStatusResponse
     */
    public function updateFileProtectEventStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateFileProtectEventStatusWithOptions($request, $runtime);
    }

    /**
     * Adds remarks to core file monitoring events reported by the Security Center agent.
     *
     * @param request - UpdateFileProtectRemarkRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateFileProtectRemarkResponse
     *
     * @param UpdateFileProtectRemarkRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return UpdateFileProtectRemarkResponse
     */
    public function updateFileProtectRemarkWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateFileProtectRemark',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateFileProtectRemarkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds remarks to core file monitoring events reported by the Security Center agent.
     *
     * @param request - UpdateFileProtectRemarkRequest
     *
     * @returns UpdateFileProtectRemarkResponse
     *
     * @param UpdateFileProtectRemarkRequest $request
     *
     * @return UpdateFileProtectRemarkResponse
     */
    public function updateFileProtectRemark($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateFileProtectRemarkWithOptions($request, $runtime);
    }

    /**
     * Modifies the content of a core file monitoring rule based on the ID of the rule.
     *
     * @param request - UpdateFileProtectRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateFileProtectRuleResponse
     *
     * @param UpdateFileProtectRuleRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return UpdateFileProtectRuleResponse
     */
    public function updateFileProtectRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->alertLevel) {
            @$query['AlertLevel'] = $request->alertLevel;
        }

        if (null !== $request->fileOps) {
            @$query['FileOps'] = $request->fileOps;
        }

        if (null !== $request->filePaths) {
            @$query['FilePaths'] = $request->filePaths;
        }

        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        if (null !== $request->procPaths) {
            @$query['ProcPaths'] = $request->procPaths;
        }

        if (null !== $request->ruleAction) {
            @$query['RuleAction'] = $request->ruleAction;
        }

        if (null !== $request->ruleName) {
            @$query['RuleName'] = $request->ruleName;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateFileProtectRule',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateFileProtectRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the content of a core file monitoring rule based on the ID of the rule.
     *
     * @param request - UpdateFileProtectRuleRequest
     *
     * @returns UpdateFileProtectRuleResponse
     *
     * @param UpdateFileProtectRuleRequest $request
     *
     * @return UpdateFileProtectRuleResponse
     */
    public function updateFileProtectRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateFileProtectRuleWithOptions($request, $runtime);
    }

    /**
     * Modifies the queries per second (QPS) limit on the files uploaded from the client.
     *
     * @param request - UpdateFileUploadLimitRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateFileUploadLimitResponse
     *
     * @param UpdateFileUploadLimitRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return UpdateFileUploadLimitResponse
     */
    public function updateFileUploadLimitWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->limit) {
            @$query['Limit'] = $request->limit;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateFileUploadLimit',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateFileUploadLimitResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the queries per second (QPS) limit on the files uploaded from the client.
     *
     * @param request - UpdateFileUploadLimitRequest
     *
     * @returns UpdateFileUploadLimitResponse
     *
     * @param UpdateFileUploadLimitRequest $request
     *
     * @return UpdateFileUploadLimitResponse
     */
    public function updateFileUploadLimit($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateFileUploadLimitWithOptions($request, $runtime);
    }

    /**
     * Modifies the configuration of a specified honeypot.
     *
     * @param request - UpdateHoneypotRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateHoneypotResponse
     *
     * @param UpdateHoneypotRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return UpdateHoneypotResponse
     */
    public function updateHoneypotWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->honeypotId) {
            @$query['HoneypotId'] = $request->honeypotId;
        }

        if (null !== $request->honeypotName) {
            @$query['HoneypotName'] = $request->honeypotName;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->meta) {
            @$query['Meta'] = $request->meta;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateHoneypot',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateHoneypotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configuration of a specified honeypot.
     *
     * @param request - UpdateHoneypotRequest
     *
     * @returns UpdateHoneypotResponse
     *
     * @param UpdateHoneypotRequest $request
     *
     * @return UpdateHoneypotResponse
     */
    public function updateHoneypot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateHoneypotWithOptions($request, $runtime);
    }

    /**
     * Modifies the configuration of a specified management node.
     *
     * @param request - UpdateHoneypotNodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateHoneypotNodeResponse
     *
     * @param UpdateHoneypotNodeRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return UpdateHoneypotNodeResponse
     */
    public function updateHoneypotNodeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->availableProbeNum) {
            @$query['AvailableProbeNum'] = $request->availableProbeNum;
        }

        if (null !== $request->nodeId) {
            @$query['NodeId'] = $request->nodeId;
        }

        if (null !== $request->nodeName) {
            @$query['NodeName'] = $request->nodeName;
        }

        if (null !== $request->securityGroupProbeIpList) {
            @$query['SecurityGroupProbeIpList'] = $request->securityGroupProbeIpList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateHoneypotNode',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateHoneypotNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configuration of a specified management node.
     *
     * @param request - UpdateHoneypotNodeRequest
     *
     * @returns UpdateHoneypotNodeResponse
     *
     * @param UpdateHoneypotNodeRequest $request
     *
     * @return UpdateHoneypotNodeResponse
     */
    public function updateHoneypotNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateHoneypotNodeWithOptions($request, $runtime);
    }

    /**
     * Modifies the configurations of the specified honeypot template.
     *
     * @param request - UpdateHoneypotPresetRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateHoneypotPresetResponse
     *
     * @param UpdateHoneypotPresetRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return UpdateHoneypotPresetResponse
     */
    public function updateHoneypotPresetWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->honeypotImageName) {
            @$query['HoneypotImageName'] = $request->honeypotImageName;
        }

        if (null !== $request->honeypotPresetId) {
            @$query['HoneypotPresetId'] = $request->honeypotPresetId;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->meta) {
            @$query['Meta'] = $request->meta;
        }

        if (null !== $request->presetName) {
            @$query['PresetName'] = $request->presetName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateHoneypotPreset',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateHoneypotPresetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configurations of the specified honeypot template.
     *
     * @param request - UpdateHoneypotPresetRequest
     *
     * @returns UpdateHoneypotPresetResponse
     *
     * @param UpdateHoneypotPresetRequest $request
     *
     * @return UpdateHoneypotPresetResponse
     */
    public function updateHoneypotPreset($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateHoneypotPresetWithOptions($request, $runtime);
    }

    /**
     * Modifies the attributes of a specified probe.
     *
     * @param request - UpdateHoneypotProbeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateHoneypotProbeResponse
     *
     * @param UpdateHoneypotProbeRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return UpdateHoneypotProbeResponse
     */
    public function updateHoneypotProbeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->arp) {
            @$query['Arp'] = $request->arp;
        }

        if (null !== $request->displayName) {
            @$query['DisplayName'] = $request->displayName;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->ping) {
            @$query['Ping'] = $request->ping;
        }

        if (null !== $request->probeId) {
            @$query['ProbeId'] = $request->probeId;
        }

        if (null !== $request->serviceIpList) {
            @$query['ServiceIpList'] = $request->serviceIpList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateHoneypotProbe',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateHoneypotProbeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the attributes of a specified probe.
     *
     * @param request - UpdateHoneypotProbeRequest
     *
     * @returns UpdateHoneypotProbeResponse
     *
     * @param UpdateHoneypotProbeRequest $request
     *
     * @return UpdateHoneypotProbeResponse
     */
    public function updateHoneypotProbe($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateHoneypotProbeWithOptions($request, $runtime);
    }

    /**
     * Modifies a probe service.
     *
     * @param request - UpdateHoneypotProbeBindRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateHoneypotProbeBindResponse
     *
     * @param UpdateHoneypotProbeBindRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return UpdateHoneypotProbeBindResponse
     */
    public function updateHoneypotProbeBindWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bindId) {
            @$query['BindId'] = $request->bindId;
        }

        if (null !== $request->bindPortList) {
            @$query['BindPortList'] = $request->bindPortList;
        }

        if (null !== $request->bindType) {
            @$query['BindType'] = $request->bindType;
        }

        if (null !== $request->currentPage) {
            @$query['CurrentPage'] = $request->currentPage;
        }

        if (null !== $request->honeypotId) {
            @$query['HoneypotId'] = $request->honeypotId;
        }

        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->ports) {
            @$query['Ports'] = $request->ports;
        }

        if (null !== $request->probeId) {
            @$query['ProbeId'] = $request->probeId;
        }

        if (null !== $request->serviceIpList) {
            @$query['ServiceIpList'] = $request->serviceIpList;
        }

        if (null !== $request->setStatus) {
            @$query['SetStatus'] = $request->setStatus;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateHoneypotProbeBind',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateHoneypotProbeBindResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies a probe service.
     *
     * @param request - UpdateHoneypotProbeBindRequest
     *
     * @returns UpdateHoneypotProbeBindResponse
     *
     * @param UpdateHoneypotProbeBindRequest $request
     *
     * @return UpdateHoneypotProbeBindResponse
     */
    public function updateHoneypotProbeBind($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateHoneypotProbeBindWithOptions($request, $runtime);
    }

    /**
     * Updates the Security Center agent that is installed on a proxy server in a hybrid cloud.
     *
     * @param request - UpdateHybridProxyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateHybridProxyResponse
     *
     * @param UpdateHybridProxyRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return UpdateHybridProxyResponse
     */
    public function updateHybridProxyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->proxyUuid) {
            @$query['ProxyUuid'] = $request->proxyUuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateHybridProxy',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateHybridProxyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates the Security Center agent that is installed on a proxy server in a hybrid cloud.
     *
     * @param request - UpdateHybridProxyRequest
     *
     * @returns UpdateHybridProxyResponse
     *
     * @param UpdateHybridProxyRequest $request
     *
     * @return UpdateHybridProxyResponse
     */
    public function updateHybridProxy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateHybridProxyWithOptions($request, $runtime);
    }

    /**
     * Updates an alert handling rule.
     *
     * @param request - UpdateImageEventOperationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateImageEventOperationResponse
     *
     * @param UpdateImageEventOperationRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return UpdateImageEventOperationResponse
     */
    public function updateImageEventOperationWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->conditions) {
            @$query['Conditions'] = $request->conditions;
        }

        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        if (null !== $request->note) {
            @$query['Note'] = $request->note;
        }

        if (null !== $request->scenarios) {
            @$query['Scenarios'] = $request->scenarios;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateImageEventOperation',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateImageEventOperationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates an alert handling rule.
     *
     * @param request - UpdateImageEventOperationRequest
     *
     * @returns UpdateImageEventOperationResponse
     *
     * @param UpdateImageEventOperationRequest $request
     *
     * @return UpdateImageEventOperationResponse
     */
    public function updateImageEventOperation($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateImageEventOperationWithOptions($request, $runtime);
    }

    /**
     * Updates the vulnerability whitelist of an image.
     *
     * @param request - UpdateImageVulWhitelistTargetRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateImageVulWhitelistTargetResponse
     *
     * @param UpdateImageVulWhitelistTargetRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return UpdateImageVulWhitelistTargetResponse
     */
    public function updateImageVulWhitelistTargetWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->reason) {
            @$query['Reason'] = $request->reason;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        if (null !== $request->target) {
            @$query['Target'] = $request->target;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateImageVulWhitelistTarget',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateImageVulWhitelistTargetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates the vulnerability whitelist of an image.
     *
     * @param request - UpdateImageVulWhitelistTargetRequest
     *
     * @returns UpdateImageVulWhitelistTargetResponse
     *
     * @param UpdateImageVulWhitelistTargetRequest $request
     *
     * @return UpdateImageVulWhitelistTargetResponse
     */
    public function updateImageVulWhitelistTarget($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateImageVulWhitelistTargetWithOptions($request, $runtime);
    }

    /**
     * Modifies the name of a Jenkins image repository.
     *
     * @param request - UpdateJenkinsImageRegistryNameRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateJenkinsImageRegistryNameResponse
     *
     * @param UpdateJenkinsImageRegistryNameRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return UpdateJenkinsImageRegistryNameResponse
     */
    public function updateJenkinsImageRegistryNameWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $body = [];
        if (null !== $request->registryId) {
            @$body['RegistryId'] = $request->registryId;
        }

        if (null !== $request->registryName) {
            @$body['RegistryName'] = $request->registryName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'UpdateJenkinsImageRegistryName',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateJenkinsImageRegistryNameResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the name of a Jenkins image repository.
     *
     * @param request - UpdateJenkinsImageRegistryNameRequest
     *
     * @returns UpdateJenkinsImageRegistryNameResponse
     *
     * @param UpdateJenkinsImageRegistryNameRequest $request
     *
     * @return UpdateJenkinsImageRegistryNameResponse
     */
    public function updateJenkinsImageRegistryName($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateJenkinsImageRegistryNameWithOptions($request, $runtime);
    }

    /**
     * Modifies the retention period of images that are stored in a Jenkins image repository.
     *
     * @param request - UpdateJenkinsImageRegistryPersistenceDayRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateJenkinsImageRegistryPersistenceDayResponse
     *
     * @param UpdateJenkinsImageRegistryPersistenceDayRequest $request
     * @param RuntimeOptions                                  $runtime
     *
     * @return UpdateJenkinsImageRegistryPersistenceDayResponse
     */
    public function updateJenkinsImageRegistryPersistenceDayWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        $body = [];
        if (null !== $request->persistenceDay) {
            @$body['PersistenceDay'] = $request->persistenceDay;
        }

        if (null !== $request->registryId) {
            @$body['RegistryId'] = $request->registryId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'UpdateJenkinsImageRegistryPersistenceDay',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateJenkinsImageRegistryPersistenceDayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the retention period of images that are stored in a Jenkins image repository.
     *
     * @param request - UpdateJenkinsImageRegistryPersistenceDayRequest
     *
     * @returns UpdateJenkinsImageRegistryPersistenceDayResponse
     *
     * @param UpdateJenkinsImageRegistryPersistenceDayRequest $request
     *
     * @return UpdateJenkinsImageRegistryPersistenceDayResponse
     */
    public function updateJenkinsImageRegistryPersistenceDay($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateJenkinsImageRegistryPersistenceDayWithOptions($request, $runtime);
    }

    /**
     * Modifies an alert whitelist rule of sensitive files that are detected by using the agentless detection feature.
     *
     * @param request - UpdateMaliciousFileWhitelistConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateMaliciousFileWhitelistConfigResponse
     *
     * @param UpdateMaliciousFileWhitelistConfigRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return UpdateMaliciousFileWhitelistConfigResponse
     */
    public function updateMaliciousFileWhitelistConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->configId) {
            @$query['ConfigId'] = $request->configId;
        }

        if (null !== $request->eventName) {
            @$query['EventName'] = $request->eventName;
        }

        if (null !== $request->field) {
            @$query['Field'] = $request->field;
        }

        if (null !== $request->fieldValue) {
            @$query['FieldValue'] = $request->fieldValue;
        }

        if (null !== $request->operator) {
            @$query['Operator'] = $request->operator;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        if (null !== $request->source) {
            @$query['Source'] = $request->source;
        }

        if (null !== $request->targetType) {
            @$query['TargetType'] = $request->targetType;
        }

        if (null !== $request->targetValue) {
            @$query['TargetValue'] = $request->targetValue;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateMaliciousFileWhitelistConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateMaliciousFileWhitelistConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies an alert whitelist rule of sensitive files that are detected by using the agentless detection feature.
     *
     * @param request - UpdateMaliciousFileWhitelistConfigRequest
     *
     * @returns UpdateMaliciousFileWhitelistConfigResponse
     *
     * @param UpdateMaliciousFileWhitelistConfigRequest $request
     *
     * @return UpdateMaliciousFileWhitelistConfigResponse
     */
    public function updateMaliciousFileWhitelistConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateMaliciousFileWhitelistConfigWithOptions($request, $runtime);
    }

    /**
     * Modify Multi-Account Instance Configuration.
     *
     * @param request - UpdateMultiUserInstancesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateMultiUserInstancesResponse
     *
     * @param UpdateMultiUserInstancesRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return UpdateMultiUserInstancesResponse
     */
    public function updateMultiUserInstancesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->memberInstances) {
            @$query['MemberInstances'] = $request->memberInstances;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateMultiUserInstances',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateMultiUserInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modify Multi-Account Instance Configuration.
     *
     * @param request - UpdateMultiUserInstancesRequest
     *
     * @returns UpdateMultiUserInstancesResponse
     *
     * @param UpdateMultiUserInstancesRequest $request
     *
     * @return UpdateMultiUserInstancesResponse
     */
    public function updateMultiUserInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateMultiUserInstancesWithOptions($request, $runtime);
    }

    /**
     * Updates the blocking rule for at-risk images.
     *
     * @param tmpReq - UpdateOpaStrategyNewRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateOpaStrategyNewResponse
     *
     * @param UpdateOpaStrategyNewRequest $tmpReq
     * @param RuntimeOptions              $runtime
     *
     * @return UpdateOpaStrategyNewResponse
     */
    public function updateOpaStrategyNewWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new UpdateOpaStrategyNewShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->alarmDetail) {
            $request->alarmDetailShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->alarmDetail, 'AlarmDetail', 'json');
        }

        $query = [];
        if (null !== $request->alarmDetailShrink) {
            @$query['AlarmDetail'] = $request->alarmDetailShrink;
        }

        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->clusterName) {
            @$query['ClusterName'] = $request->clusterName;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->imageName) {
            @$query['ImageName'] = $request->imageName;
        }

        if (null !== $request->label) {
            @$query['Label'] = $request->label;
        }

        if (null !== $request->maliciousImage) {
            @$query['MaliciousImage'] = $request->maliciousImage;
        }

        if (null !== $request->ruleAction) {
            @$query['RuleAction'] = $request->ruleAction;
        }

        if (null !== $request->scopes) {
            @$query['Scopes'] = $request->scopes;
        }

        if (null !== $request->strategyId) {
            @$query['StrategyId'] = $request->strategyId;
        }

        if (null !== $request->strategyName) {
            @$query['StrategyName'] = $request->strategyName;
        }

        if (null !== $request->strategyTemplateId) {
            @$query['StrategyTemplateId'] = $request->strategyTemplateId;
        }

        if (null !== $request->unScanedImage) {
            @$query['UnScanedImage'] = $request->unScanedImage;
        }

        if (null !== $request->whiteList) {
            @$query['WhiteList'] = $request->whiteList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateOpaStrategyNew',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateOpaStrategyNewResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates the blocking rule for at-risk images.
     *
     * @param request - UpdateOpaStrategyNewRequest
     *
     * @returns UpdateOpaStrategyNewResponse
     *
     * @param UpdateOpaStrategyNewRequest $request
     *
     * @return UpdateOpaStrategyNewResponse
     */
    public function updateOpaStrategyNew($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateOpaStrategyNewWithOptions($request, $runtime);
    }

    /**
     * Modifies a policy of detecting Object Storage Service (OSS) objects by using the SDK for malicious file detection feature.
     *
     * @param request - UpdateOssScanConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateOssScanConfigResponse
     *
     * @param UpdateOssScanConfigRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return UpdateOssScanConfigResponse
     */
    public function updateOssScanConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->allKeyPrefix) {
            @$query['AllKeyPrefix'] = $request->allKeyPrefix;
        }

        if (null !== $request->bucketNameList) {
            @$query['BucketNameList'] = $request->bucketNameList;
        }

        if (null !== $request->decompressMaxFileCount) {
            @$query['DecompressMaxFileCount'] = $request->decompressMaxFileCount;
        }

        if (null !== $request->decompressMaxLayer) {
            @$query['DecompressMaxLayer'] = $request->decompressMaxLayer;
        }

        if (null !== $request->decryptionList) {
            @$query['DecryptionList'] = $request->decryptionList;
        }

        if (null !== $request->enable) {
            @$query['Enable'] = $request->enable;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        if (null !== $request->keyPrefixList) {
            @$query['KeyPrefixList'] = $request->keyPrefixList;
        }

        if (null !== $request->keySuffixList) {
            @$query['KeySuffixList'] = $request->keySuffixList;
        }

        if (null !== $request->lastModifiedStartTime) {
            @$query['LastModifiedStartTime'] = $request->lastModifiedStartTime;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->realTimeIncr) {
            @$query['RealTimeIncr'] = $request->realTimeIncr;
        }

        if (null !== $request->scanDayList) {
            @$query['ScanDayList'] = $request->scanDayList;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateOssScanConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateOssScanConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies a policy of detecting Object Storage Service (OSS) objects by using the SDK for malicious file detection feature.
     *
     * @param request - UpdateOssScanConfigRequest
     *
     * @returns UpdateOssScanConfigResponse
     *
     * @param UpdateOssScanConfigRequest $request
     *
     * @return UpdateOssScanConfigResponse
     */
    public function updateOssScanConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateOssScanConfigWithOptions($request, $runtime);
    }

    /**
     * Change Postpaid Asset Authorization Version.
     *
     * @param request - UpdatePostPaidBindRelRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdatePostPaidBindRelResponse
     *
     * @param UpdatePostPaidBindRelRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return UpdatePostPaidBindRelResponse
     */
    public function updatePostPaidBindRelWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->autoBind) {
            @$query['AutoBind'] = $request->autoBind;
        }

        if (null !== $request->autoBindVersion) {
            @$query['AutoBindVersion'] = $request->autoBindVersion;
        }

        if (null !== $request->bindAction) {
            @$query['BindAction'] = $request->bindAction;
        }

        if (null !== $request->updateIfNecessary) {
            @$query['UpdateIfNecessary'] = $request->updateIfNecessary;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdatePostPaidBindRel',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdatePostPaidBindRelResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Change Postpaid Asset Authorization Version.
     *
     * @param request - UpdatePostPaidBindRelRequest
     *
     * @returns UpdatePostPaidBindRelResponse
     *
     * @param UpdatePostPaidBindRelRequest $request
     *
     * @return UpdatePostPaidBindRelResponse
     */
    public function updatePostPaidBindRel($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updatePostPaidBindRelWithOptions($request, $runtime);
    }

    /**
     * Enables or disables automatic upgrade.
     *
     * @param request - UpdatePublishAutoUpgradeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdatePublishAutoUpgradeResponse
     *
     * @param UpdatePublishAutoUpgradeRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return UpdatePublishAutoUpgradeResponse
     */
    public function updatePublishAutoUpgradeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->autoUpgrade) {
            @$query['AutoUpgrade'] = $request->autoUpgrade;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdatePublishAutoUpgrade',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdatePublishAutoUpgradeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables or disables automatic upgrade.
     *
     * @param request - UpdatePublishAutoUpgradeRequest
     *
     * @returns UpdatePublishAutoUpgradeResponse
     *
     * @param UpdatePublishAutoUpgradeRequest $request
     *
     * @return UpdatePublishAutoUpgradeResponse
     */
    public function updatePublishAutoUpgrade($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updatePublishAutoUpgradeWithOptions($request, $runtime);
    }

    /**
     * Updates a release batch.
     *
     * @param request - UpdatePublishBatchRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdatePublishBatchResponse
     *
     * @param UpdatePublishBatchRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return UpdatePublishBatchResponse
     */
    public function updatePublishBatchWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->batchId) {
            @$query['BatchId'] = $request->batchId;
        }

        if (null !== $request->batchName) {
            @$query['BatchName'] = $request->batchName;
        }

        if (null !== $request->interval) {
            @$query['Interval'] = $request->interval;
        }

        if (null !== $request->operationBase) {
            @$query['OperationBase'] = $request->operationBase;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdatePublishBatch',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdatePublishBatchResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates a release batch.
     *
     * @param request - UpdatePublishBatchRequest
     *
     * @returns UpdatePublishBatchResponse
     *
     * @param UpdatePublishBatchRequest $request
     *
     * @return UpdatePublishBatchResponse
     */
    public function updatePublishBatch($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updatePublishBatchWithOptions($request, $runtime);
    }

    /**
     * Modifies the configuration of the client upgrade time. If you want to call this operation, contact technical support.
     *
     * @param request - UpdatePublishCronRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdatePublishCronResponse
     *
     * @param UpdatePublishCronRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return UpdatePublishCronResponse
     */
    public function updatePublishCronWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->cron) {
            @$query['Cron'] = $request->cron;
        }

        if (null !== $request->cronDay) {
            @$query['CronDay'] = $request->cronDay;
        }

        if (null !== $request->cronTime) {
            @$query['CronTime'] = $request->cronTime;
        }

        if (null !== $request->cronType) {
            @$query['CronType'] = $request->cronType;
        }

        if (null !== $request->duration) {
            @$query['Duration'] = $request->duration;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdatePublishCron',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdatePublishCronResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configuration of the client upgrade time. If you want to call this operation, contact technical support.
     *
     * @param request - UpdatePublishCronRequest
     *
     * @returns UpdatePublishCronResponse
     *
     * @param UpdatePublishCronRequest $request
     *
     * @return UpdatePublishCronResponse
     */
    public function updatePublishCron($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updatePublishCronWithOptions($request, $runtime);
    }

    /**
     * Modifies the settings of the canary release feature for agent upgrade. If you want to use the feature, contact technical support.
     *
     * @param request - UpdatePublishGraySwitchRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdatePublishGraySwitchResponse
     *
     * @param UpdatePublishGraySwitchRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return UpdatePublishGraySwitchResponse
     */
    public function updatePublishGraySwitchWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->graySwitchStatus) {
            @$query['GraySwitchStatus'] = $request->graySwitchStatus;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdatePublishGraySwitch',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdatePublishGraySwitchResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the settings of the canary release feature for agent upgrade. If you want to use the feature, contact technical support.
     *
     * @param request - UpdatePublishGraySwitchRequest
     *
     * @returns UpdatePublishGraySwitchResponse
     *
     * @param UpdatePublishGraySwitchRequest $request
     *
     * @return UpdatePublishGraySwitchResponse
     */
    public function updatePublishGraySwitch($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updatePublishGraySwitchWithOptions($request, $runtime);
    }

    /**
     * Updates the unique identifier of an asset selection.
     *
     * @param request - UpdateSelectionKeyByTypeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateSelectionKeyByTypeResponse
     *
     * @param UpdateSelectionKeyByTypeRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return UpdateSelectionKeyByTypeResponse
     */
    public function updateSelectionKeyByTypeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->businessType) {
            @$query['BusinessType'] = $request->businessType;
        }

        if (null !== $request->selectionKey) {
            @$query['SelectionKey'] = $request->selectionKey;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateSelectionKeyByType',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateSelectionKeyByTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates the unique identifier of an asset selection.
     *
     * @param request - UpdateSelectionKeyByTypeRequest
     *
     * @returns UpdateSelectionKeyByTypeResponse
     *
     * @param UpdateSelectionKeyByTypeRequest $request
     *
     * @return UpdateSelectionKeyByTypeResponse
     */
    public function updateSelectionKeyByType($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateSelectionKeyByTypeWithOptions($request, $runtime);
    }

    /**
     * Update the selected strict events in strict mode.
     *
     * @param request - UpdateStrictEventNameRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateStrictEventNameResponse
     *
     * @param UpdateStrictEventNameRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return UpdateStrictEventNameResponse
     */
    public function updateStrictEventNameWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->eventNameList) {
            @$query['EventNameList'] = $request->eventNameList;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->operator) {
            @$query['Operator'] = $request->operator;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateStrictEventName',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateStrictEventNameResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Update the selected strict events in strict mode.
     *
     * @param request - UpdateStrictEventNameRequest
     *
     * @returns UpdateStrictEventNameResponse
     *
     * @param UpdateStrictEventNameRequest $request
     *
     * @return UpdateStrictEventNameResponse
     */
    public function updateStrictEventName($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateStrictEventNameWithOptions($request, $runtime);
    }

    /**
     * Updates machines in a release batch.
     *
     * @param request - UpdateTargetListByBatchRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateTargetListByBatchResponse
     *
     * @param UpdateTargetListByBatchRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return UpdateTargetListByBatchResponse
     */
    public function updateTargetListByBatchWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->batchId) {
            @$query['BatchId'] = $request->batchId;
        }

        if (null !== $request->operationList) {
            @$query['OperationList'] = $request->operationList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateTargetListByBatch',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateTargetListByBatchResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates machines in a release batch.
     *
     * @param request - UpdateTargetListByBatchRequest
     *
     * @returns UpdateTargetListByBatchResponse
     *
     * @param UpdateTargetListByBatchRequest $request
     *
     * @return UpdateTargetListByBatchResponse
     */
    public function updateTargetListByBatch($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateTargetListByBatchWithOptions($request, $runtime);
    }

    /**
     * Updates the IP address whitelist of an image repository.
     *
     * @param request - UpdateWhiteListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateWhiteListResponse
     *
     * @param UpdateWhiteListRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return UpdateWhiteListResponse
     */
    public function updateWhiteListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->registryId) {
            @$query['RegistryId'] = $request->registryId;
        }

        if (null !== $request->whiteList) {
            @$query['WhiteList'] = $request->whiteList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateWhiteList',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateWhiteListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates the IP address whitelist of an image repository.
     *
     * @param request - UpdateWhiteListRequest
     *
     * @returns UpdateWhiteListResponse
     *
     * @param UpdateWhiteListRequest $request
     *
     * @return UpdateWhiteListResponse
     */
    public function updateWhiteList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateWhiteListWithOptions($request, $runtime);
    }

    /**
     * Updates the status of an application whitelist policy.
     *
     * @remarks
     * The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
     *
     * @param request - UpdateWhiteListStrategyStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateWhiteListStrategyStatusResponse
     *
     * @param UpdateWhiteListStrategyStatusRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return UpdateWhiteListStrategyStatusResponse
     */
    public function updateWhiteListStrategyStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->sourceIp) {
            @$query['SourceIp'] = $request->sourceIp;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->strategyIds) {
            @$query['StrategyIds'] = $request->strategyIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateWhiteListStrategyStatus',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateWhiteListStrategyStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates the status of an application whitelist policy.
     *
     * @remarks
     * The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
     *
     * @param request - UpdateWhiteListStrategyStatusRequest
     *
     * @returns UpdateWhiteListStrategyStatusResponse
     *
     * @param UpdateWhiteListStrategyStatusRequest $request
     *
     * @return UpdateWhiteListStrategyStatusResponse
     */
    public function updateWhiteListStrategyStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateWhiteListStrategyStatusWithOptions($request, $runtime);
    }

    /**
     * Upgrades the version of an anti-ransomware policy.
     *
     * @param request - UpgradeBackupPolicyVersionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpgradeBackupPolicyVersionResponse
     *
     * @param UpgradeBackupPolicyVersionRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return UpgradeBackupPolicyVersionResponse
     */
    public function upgradeBackupPolicyVersionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->id) {
            @$query['Id'] = $request->id;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpgradeBackupPolicyVersion',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpgradeBackupPolicyVersionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Upgrades the version of an anti-ransomware policy.
     *
     * @param request - UpgradeBackupPolicyVersionRequest
     *
     * @returns UpgradeBackupPolicyVersionResponse
     *
     * @param UpgradeBackupPolicyVersionRequest $request
     *
     * @return UpgradeBackupPolicyVersionResponse
     */
    public function upgradeBackupPolicyVersion($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->upgradeBackupPolicyVersionWithOptions($request, $runtime);
    }

    /**
     * Upgrades the version of the management node to which a honeypot belongs.
     *
     * @param request - UpgradeHoneypotNodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpgradeHoneypotNodeResponse
     *
     * @param UpgradeHoneypotNodeRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return UpgradeHoneypotNodeResponse
     */
    public function upgradeHoneypotNodeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->allowHoneypotAccessInternet) {
            @$query['AllowHoneypotAccessInternet'] = $request->allowHoneypotAccessInternet;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->nodeId) {
            @$query['NodeId'] = $request->nodeId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpgradeHoneypotNode',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpgradeHoneypotNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Upgrades the version of the management node to which a honeypot belongs.
     *
     * @param request - UpgradeHoneypotNodeRequest
     *
     * @returns UpgradeHoneypotNodeResponse
     *
     * @param UpgradeHoneypotNodeRequest $request
     *
     * @return UpgradeHoneypotNodeResponse
     */
    public function upgradeHoneypotNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->upgradeHoneypotNodeWithOptions($request, $runtime);
    }

    /**
     * Manually upgrades the client version on assets.
     *
     * @param request - UpgradeVersionByUuidsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpgradeVersionByUuidsResponse
     *
     * @param UpgradeVersionByUuidsRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return UpgradeVersionByUuidsResponse
     */
    public function upgradeVersionByUuidsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->upgradeVersion) {
            @$query['UpgradeVersion'] = $request->upgradeVersion;
        }

        if (null !== $request->uuidList) {
            @$query['UuidList'] = $request->uuidList;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpgradeVersionByUuids',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpgradeVersionByUuidsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Manually upgrades the client version on assets.
     *
     * @param request - UpgradeVersionByUuidsRequest
     *
     * @returns UpgradeVersionByUuidsResponse
     *
     * @param UpgradeVersionByUuidsRequest $request
     *
     * @return UpgradeVersionByUuidsResponse
     */
    public function upgradeVersionByUuids($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->upgradeVersionByUuidsWithOptions($request, $runtime);
    }

    /**
     * Uploads a honeypot file.
     *
     * @param request - UploadedHoneyPotFileRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UploadedHoneyPotFileResponse
     *
     * @param UploadedHoneyPotFileRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return UploadedHoneyPotFileResponse
     */
    public function uploadedHoneyPotFileWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->fileKey) {
            @$query['FileKey'] = $request->fileKey;
        }

        if (null !== $request->fileName) {
            @$query['FileName'] = $request->fileName;
        }

        if (null !== $request->fileType) {
            @$query['FileType'] = $request->fileType;
        }

        if (null !== $request->honeypotImageName) {
            @$query['HoneypotImageName'] = $request->honeypotImageName;
        }

        if (null !== $request->lang) {
            @$query['Lang'] = $request->lang;
        }

        if (null !== $request->nodeId) {
            @$query['NodeId'] = $request->nodeId;
        }

        if (null !== $request->templateExtra) {
            @$query['TemplateExtra'] = $request->templateExtra;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UploadedHoneyPotFile',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UploadedHoneyPotFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Uploads a honeypot file.
     *
     * @param request - UploadedHoneyPotFileRequest
     *
     * @returns UploadedHoneyPotFileResponse
     *
     * @param UploadedHoneyPotFileRequest $request
     *
     * @return UploadedHoneyPotFileResponse
     */
    public function uploadedHoneyPotFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->uploadedHoneyPotFileWithOptions($request, $runtime);
    }

    /**
     * Verifies whether risk items are fixed. If a risk item is fixed, the status of the related check item is updated to Passed.
     *
     * @param request - ValidateHcWarningsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ValidateHcWarningsResponse
     *
     * @param ValidateHcWarningsRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return ValidateHcWarningsResponse
     */
    public function validateHcWarningsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->checkIds) {
            @$query['CheckIds'] = $request->checkIds;
        }

        if (null !== $request->riskIds) {
            @$query['RiskIds'] = $request->riskIds;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->uuids) {
            @$query['Uuids'] = $request->uuids;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ValidateHcWarnings',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ValidateHcWarningsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Verifies whether risk items are fixed. If a risk item is fixed, the status of the related check item is updated to Passed.
     *
     * @param request - ValidateHcWarningsRequest
     *
     * @returns ValidateHcWarningsResponse
     *
     * @param ValidateHcWarningsRequest $request
     *
     * @return ValidateHcWarningsResponse
     */
    public function validateHcWarnings($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->validateHcWarningsWithOptions($request, $runtime);
    }

    /**
     * Customization and validation of check items and repair parameters.
     *
     * @param tmpReq - VerifyCheckCustomConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns VerifyCheckCustomConfigResponse
     *
     * @param VerifyCheckCustomConfigRequest $tmpReq
     * @param RuntimeOptions                 $runtime
     *
     * @return VerifyCheckCustomConfigResponse
     */
    public function verifyCheckCustomConfigWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new VerifyCheckCustomConfigShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->customCheckConfig) {
            $request->customCheckConfigShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->customCheckConfig, 'CustomCheckConfig', 'json');
        }

        $query = [];
        if (null !== $request->checkId) {
            @$query['CheckId'] = $request->checkId;
        }

        if (null !== $request->customCheckConfigShrink) {
            @$query['CustomCheckConfig'] = $request->customCheckConfigShrink;
        }

        if (null !== $request->customConfigs) {
            @$query['CustomConfigs'] = $request->customConfigs;
        }

        if (null !== $request->repairConfigs) {
            @$query['RepairConfigs'] = $request->repairConfigs;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'VerifyCheckCustomConfig',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return VerifyCheckCustomConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Customization and validation of check items and repair parameters.
     *
     * @param request - VerifyCheckCustomConfigRequest
     *
     * @returns VerifyCheckCustomConfigResponse
     *
     * @param VerifyCheckCustomConfigRequest $request
     *
     * @return VerifyCheckCustomConfigResponse
     */
    public function verifyCheckCustomConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->verifyCheckCustomConfigWithOptions($request, $runtime);
    }

    /**
     * Verifies the instances on which risks are detected based on a check item.
     *
     * @param request - VerifyCheckInstanceResultRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns VerifyCheckInstanceResultResponse
     *
     * @param VerifyCheckInstanceResultRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return VerifyCheckInstanceResultResponse
     */
    public function verifyCheckInstanceResultWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->checkId) {
            @$query['CheckId'] = $request->checkId;
        }

        if (null !== $request->checkIds) {
            @$query['CheckIds'] = $request->checkIds;
        }

        if (null !== $request->instanceIds) {
            @$query['InstanceIds'] = $request->instanceIds;
        }

        if (null !== $request->taskSource) {
            @$query['TaskSource'] = $request->taskSource;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'VerifyCheckInstanceResult',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return VerifyCheckInstanceResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Verifies the instances on which risks are detected based on a check item.
     *
     * @param request - VerifyCheckInstanceResultRequest
     *
     * @returns VerifyCheckInstanceResultResponse
     *
     * @param VerifyCheckInstanceResultRequest $request
     *
     * @return VerifyCheckInstanceResultResponse
     */
    public function verifyCheckInstanceResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->verifyCheckInstanceResultWithOptions($request, $runtime);
    }

    /**
     * Verifies risk items that are detected based on check items.
     *
     * @param request - VerifyCheckResultRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns VerifyCheckResultResponse
     *
     * @param VerifyCheckResultRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return VerifyCheckResultResponse
     */
    public function verifyCheckResultWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->checkIds) {
            @$query['CheckIds'] = $request->checkIds;
        }

        if (null !== $request->instanceIds) {
            @$query['InstanceIds'] = $request->instanceIds;
        }

        if (null !== $request->taskSource) {
            @$query['TaskSource'] = $request->taskSource;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'VerifyCheckResult',
            'version' => '2018-12-03',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return VerifyCheckResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Verifies risk items that are detected based on check items.
     *
     * @param request - VerifyCheckResultRequest
     *
     * @returns VerifyCheckResultResponse
     *
     * @param VerifyCheckResultRequest $request
     *
     * @return VerifyCheckResultResponse
     */
    public function verifyCheckResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->verifyCheckResultWithOptions($request, $runtime);
    }
}
